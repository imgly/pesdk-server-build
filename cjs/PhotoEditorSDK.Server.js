var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// engine/sdk/core/constants.ts
var constants_exports = {};
__export(constants_exports, {
  FragmentPrecision: () => FragmentPrecision,
  ImageFormat: () => ImageFormat,
  OptionType: () => OptionType,
  RenderType: () => RenderType,
  RendererType: () => RendererType,
  UniformType: () => UniformType
});
var RenderType, ImageFormat, OptionType, UniformType, RendererType, FragmentPrecision;
var init_constants = __esm({
  "engine/sdk/core/constants.ts"() {
    RenderType = {
      IMAGE: "image",
      DATAURL: "data-url",
      BUFFER: "buffer",
      BLOB: "blob",
      MSBLOB: "ms-blob"
    };
    ImageFormat = {
      PNG: "image/png",
      JPEG: "image/jpeg",
      RAW: "raw"
    };
    OptionType = /* @__PURE__ */ ((OptionType9) => {
      OptionType9["NUMBER"] = "number";
      OptionType9["VECTOR2"] = "vector2";
      OptionType9["COLOR_MATRIX"] = "color-matrix";
      OptionType9["COLOR"] = "color";
      OptionType9["ARRAY"] = "array";
      OptionType9["OBJECT"] = "object";
      OptionType9["STRING"] = "string";
      OptionType9["BOOLEAN"] = "boolean";
      OptionType9["CONFIGURABLE"] = "configurable";
      OptionType9["IMAGE"] = "image";
      OptionType9["FUNCTION"] = "function";
      OptionType9["TEXTURE"] = "texture";
      OptionType9["ALL"] = "*";
      return OptionType9;
    })(OptionType || {});
    UniformType = /* @__PURE__ */ ((UniformType8) => {
      UniformType8["SAMPLER2D"] = "sampler2d";
      UniformType8["INT"] = "i";
      UniformType8["INT1"] = "1i";
      UniformType8["INT2"] = "2i";
      UniformType8["INT3"] = "3i";
      UniformType8["INT4"] = "4i";
      UniformType8["FLOAT"] = "f";
      UniformType8["FLOAT1"] = "1f";
      UniformType8["FLOAT2"] = "2f";
      UniformType8["FLOAT_VECTOR2"] = "2fv";
      UniformType8["FLOAT3"] = "3f";
      UniformType8["FLOAT4"] = "4f";
      UniformType8["MAT3"] = "mat3";
      UniformType8["MAT3FV"] = "mat3fv";
      UniformType8["MAT4"] = "mat4";
      return UniformType8;
    })(UniformType || {});
    RendererType = /* @__PURE__ */ ((RendererType4) => {
      RendererType4["WEBGL"] = "webgl";
      RendererType4["CANVAS"] = "canvas";
      return RendererType4;
    })(RendererType || {});
    FragmentPrecision = /* @__PURE__ */ ((FragmentPrecision2) => {
      FragmentPrecision2["High"] = "highp";
      FragmentPrecision2["Medium"] = "mediump";
      FragmentPrecision2["Low"] = "lowp";
      return FragmentPrecision2;
    })(FragmentPrecision || {});
  }
});

// engine/sdk/core/engine/utils/pixel-array-image.ts
var PixelArrayImage;
var init_pixel_array_image = __esm({
  "engine/sdk/core/engine/utils/pixel-array-image.ts"() {
    PixelArrayImage = class {
      constructor(width, height, data) {
        this.width = width;
        this.height = height;
        this.data = data;
      }
    };
  }
});

// engine/sdk/core/engine/utils/render/serverUtils.ts
var serverUtils_exports = {};
__export(serverUtils_exports, {
  serverUtils: () => serverUtils
});
var import_canvas, import_gl, nodeCanvasToPixelArray, glTexImage, serverUtils;
var init_serverUtils = __esm({
  "engine/sdk/core/engine/utils/render/serverUtils.ts"() {
    import_canvas = require("canvas");
    import_gl = __toESM(require("gl"));
    init_pixel_array_image();
    nodeCanvasToPixelArray = (image) => {
      const canvas = new import_canvas.Canvas(image.width, image.height);
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      return new PixelArrayImage(image.width, image.height, imageData.data);
    };
    glTexImage = (gl, source) => {
      const image = source instanceof PixelArrayImage ? source : nodeCanvasToPixelArray(source);
      const canvas = new import_canvas.Canvas(image.width, image.height);
      const ctx = canvas.getContext("2d");
      ctx.drawImage(source, 0, 0);
      const imageData = ctx.getImageData(0, 0, image.width, image.height);
      const pixels = new PixelArrayImage(image.width, image.height, imageData.data);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data);
    };
    serverUtils = {
      isSupported: () => true,
      isCanvas: (node) => node instanceof import_canvas.Canvas,
      isImage: (node) => false,
      Image: import_canvas.Image,
      createCanvas: () => {
        return new import_canvas.Canvas(300, 150);
      },
      glMaxTexture: (gl) => gl.getParameter(gl.MAX_TEXTURE_SIZE),
      glGet: (canvas) => (0, import_gl.default)(canvas.width, canvas.height, {
        preserveDrawingBuffer: true
      }),
      glResize(gl, vector) {
        const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
        if (ext) {
          ext.resize(vector.x, vector.y);
        }
        return gl;
      },
      glTexImage
    };
  }
});

// engine/sdk/core/engine/utils/render/index.ts
var utils, renderUtils, isWebGLRenderer, isWebCanvas, isWebImage;
var init_render = __esm({
  "engine/sdk/core/engine/utils/render/index.ts"() {
    init_constants();
    if (false) {
      utils = null.webUtils;
    }
    if (true) {
      utils = (init_serverUtils(), __toCommonJS(serverUtils_exports)).serverUtils;
    }
    renderUtils = utils;
    isWebGLRenderer = (renderer) => renderer._type === "webgl" /* WEBGL */;
    isWebCanvas = (node) => Boolean(node && "tagName" in node && node.tagName && node.tagName.toUpperCase() === "CANVAS");
    isWebImage = (image) => Boolean("tagName" in image && image.tagName.toUpperCase() === "IMG");
  }
});

// engine/sdk/core/lib/array-utils.js
var ArrayUtils, array_utils_default;
var init_array_utils = __esm({
  "engine/sdk/core/lib/array-utils.js"() {
    ArrayUtils = class {
      static head(arr) {
        return arr[0];
      }
      static tail(arr) {
        return arr.slice(1);
      }
      static last(arr) {
        return arr[arr.length - 1];
      }
      static init(arr) {
        return arr.slice(0, arr.length - 1);
      }
      static remove(arr, func) {
        return arr.filter((v, i, arr2) => !func(v, i, arr2));
      }
      static findIndex(array, func) {
        for (let i = 0; i < array.length; i++) {
          if (func(array[i])) {
            return i;
          }
        }
        return -1;
      }
      static find(array, func) {
        for (let i = 0; i < array.length; i++) {
          if (func(array[i])) {
            return array[i];
          }
        }
        return void 0;
      }
      static flatten(array) {
        return array.reduce(function(flat, toFlatten) {
          return flat.concat(Array.isArray(toFlatten) ? ArrayUtils.flatten(toFlatten) : toFlatten);
        }, []);
      }
      static range(start, end) {
        const arr = [];
        if (end > start) {
          for (let i = start; i < end; i++) {
            arr.push(i);
          }
        }
        return arr;
      }
      static repeat(val, n) {
        const arr = [];
        for (let i = 0; i < n; i++) {
          arr[i] = val;
        }
        return arr;
      }
      static zip(a, b) {
        const len = Math.min(a.length, b.length);
        const arr = [];
        for (let i = 0; i < len; i++) {
          arr[i] = [a[i], b[i]];
        }
        return arr;
      }
    };
    array_utils_default = ArrayUtils;
  }
});

// engine/sdk/core/lib/base64.js
var KEY_STR, Base64, base64_default;
var init_base64 = __esm({
  "engine/sdk/core/lib/base64.js"() {
    KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    Base64 = {
      encode(input) {
        let output = "";
        let chr1;
        let chr2;
        let chr3;
        let enc1;
        let enc2;
        let enc3;
        let enc4;
        let i = 0;
        do {
          chr1 = input[i++];
          chr2 = input[i++];
          chr3 = input[i++];
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = (chr2 & 15) << 2 | chr3 >> 6;
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
          chr1 = chr2 = chr3 = "";
          enc1 = enc2 = enc3 = enc4 = "";
        } while (i < input.length);
        return output;
      },
      decode(input) {
        let chr1;
        let chr2;
        let chr3;
        let enc1;
        let enc2;
        let enc3;
        let enc4;
        let i = 0;
        const buf = [];
        const base64test = /[^A-Za-z0-9+/=]/g;
        if (base64test.exec(input)) {
          throw new Error("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
        }
        input = input.replace(/[^A-Za-z0-9+/=]/g, "");
        do {
          enc1 = KEY_STR.indexOf(input.charAt(i++));
          enc2 = KEY_STR.indexOf(input.charAt(i++));
          enc3 = KEY_STR.indexOf(input.charAt(i++));
          enc4 = KEY_STR.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          buf.push(chr1);
          if (enc3 !== 64) {
            buf.push(chr2);
          }
          if (enc4 !== 64) {
            buf.push(chr3);
          }
          chr1 = chr2 = chr3 = "";
          enc1 = enc2 = enc3 = enc4 = "";
        } while (i < input.length);
        return buf;
      }
    };
    base64_default = Base64;
  }
});

// engine/sdk/core/lib/utils.js
var _Utils, Utils, utils_default;
var init_utils = __esm({
  "engine/sdk/core/lib/utils.js"() {
    init_render();
    init_array_utils();
    init_base64();
    _Utils = class {
      static mapRange(value, fromRange, toRange) {
        return (value - fromRange.getMin()) * toRange.getLength() / fromRange.getLength() + toRange.getMin();
      }
      static isPlainObject(object) {
        if (typeof object !== "object" || !object) {
          return false;
        }
        if (typeof Object.getPrototypeOf === "function") {
          const proto = Object.getPrototypeOf(object);
          return proto === Object.prototype || proto === null;
        }
        return Object.prototype.toString.call(object) === "[object Object]";
      }
      static isMobile() {
        if (typeof navigator === "undefined")
          return false;
        const a = navigator.userAgent || navigator.vendor || window.opera;
        return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
      }
      static isBrowser() {
        return typeof window !== "undefined";
      }
      static values(object) {
        const values = [];
        for (const key in object) {
          values.push(object[key]);
        }
        return values;
      }
      static generateUUID() {
        let d = new Date().getTime();
        if (false) {
          if (typeof window.performance !== "undefined" && typeof window.performance.now === "function") {
            d += window.performance.now();
          }
        }
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          const r = (d + Math.random() * 16) % 16 | 0;
          d = Math.floor(d / 16);
          return (c === "x" ? r : r & 3 | 8).toString(16);
        });
      }
      static resizeVectorToFit(vector, max) {
        const scale = Math.min(max.x / vector.x, max.y / vector.y);
        const newSize = vector.clone().multiply(scale);
        return newSize;
      }
      static resizeVectorToFill(vector, container) {
        const vectorRatio = vector.x / vector.y;
        const containerRatio = container.x / container.y;
        if (vectorRatio > containerRatio) {
          return container.clone().set(container.y * vectorRatio, container.y);
        }
        return container.clone().set(container.x, container.x / vectorRatio);
      }
      static isExtendable(val) {
        return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
      }
      static defaults(object, ...sources) {
        const newObject = {};
        for (const key in object) {
          newObject[key] = object[key];
        }
        for (let i = 0; i < sources.length; i++) {
          const source = sources[i];
          for (const key in source) {
            if (typeof newObject[key] === "undefined") {
              newObject[key] = source[key];
            }
          }
        }
        return newObject;
      }
      static deepMerge(dest, ...sources) {
        const _deepMerge = (dest2, source) => {
          if (source === void 0) {
            return _deepMerge(null, dest2);
          }
          if (Array.isArray(source)) {
            return [...source];
          }
          if (!_Utils.isPlainObject(source)) {
            return source;
          }
          if (!_Utils.isPlainObject(dest2)) {
            return __spreadValues({}, source);
          }
          const result = __spreadValues({}, dest2);
          Object.keys(source).forEach((key) => {
            const value = source[key];
            if (value === void 0) {
              return;
            }
            result[key] = _deepMerge(dest2[key], value);
          });
          return result;
        };
        return sources.reduce(_deepMerge, dest);
      }
      static deepDefaults(object, ...sources) {
        const reversedSources = [...sources].reverse();
        return _Utils.deepMerge(...reversedSources, object);
      }
      static deepClone(object) {
        const newObject = {};
        for (const key in object) {
          if (_Utils.isExtendable(object[key])) {
            newObject[key] = _Utils.deepClone(object[key]);
          } else {
            newObject[key] = object[key];
          }
        }
        return newObject;
      }
      static extend(object, ...sources) {
        const newObject = {};
        for (const key in object) {
          newObject[key] = object[key];
        }
        for (let i = 0; i < sources.length; i++) {
          const source = sources[i];
          for (const key in source) {
            newObject[key] = source[key];
          }
        }
        return newObject;
      }
      static clone(object) {
        return this.extend({}, object);
      }
      static getUUID() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0;
          const v = c === "x" ? r : r & 3 | 8;
          return v.toString(16);
        });
      }
      static createCanvas() {
        return renderUtils.createCanvas();
      }
      static isPowerOfTwo(dimensions) {
        return (dimensions.x & dimensions.x - 1) === 0 && (dimensions.y & dimensions.y - 1) === 0;
      }
      static nextLowestPOT(x) {
        for (let i = 1; i < 32; i <<= 1) {
          x |= x >> i;
        }
        return x - (x >> 1);
      }
      static nextHighestPOT(x) {
        x--;
        for (let i = 1; i < 32; i <<= 1) {
          x |= x >> i;
        }
        return x + 1;
      }
      static moveArrayItem(arr, oldIndex, newIndex) {
        if (newIndex >= arr.length) {
          let k = newIndex - arr.length;
          while (k-- + 1) {
            arr.push(void 0);
          }
        }
        arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
      }
      static ensureCanvasDimensions(canvas, dimensions) {
        if (canvas.width !== dimensions.x || canvas.height !== dimensions.y) {
          canvas.width = dimensions.x;
          canvas.height = dimensions.y;
          return true;
        }
        return false;
      }
      static byteArrayToString(byteArray) {
        return byteArray.map((byte) => String.fromCharCode(byte)).join("");
      }
      static clamp(number, min, max) {
        return Math.max(min, Math.min(number, max));
      }
      static wildCardMatch(str, rule) {
        return new RegExp(`^${rule.split("*").join(".*")}$`).test(str);
      }
      static flipObject(obj) {
        const newObj = {};
        for (const key in obj) {
          newObj[obj[key]] = key;
        }
        return newObj;
      }
      static ISODateString(date) {
        function pad(n) {
          return n < 10 ? `0${n}` : n;
        }
        return `${date.getUTCFullYear()}-${pad(date.getUTCMonth() + 1)}-${pad(date.getUTCDate())}T${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}Z`;
      }
      static getCrossOriginValue(crossOrigin) {
        if (!crossOrigin) {
          return "anonymous";
        }
        if (crossOrigin === "none") {
          return void 0;
        }
        return crossOrigin;
      }
      static invariant(condition, message) {
        if (!condition) {
          const error = new Error(message);
          throw error;
        }
      }
      static executePromises(promises) {
        const count = promises.length;
        let counter = 0;
        const values = [];
        const errors = [];
        return new Promise((resolve, reject) => {
          const onFinnish = () => {
            counter++;
            if (counter >= count) {
              if (errors.length <= 0) {
                resolve(values);
              } else {
                reject(errors);
              }
            }
          };
          const onSuccess = (value) => {
            values.push(value);
            onFinnish();
          };
          const onError = (value) => {
            errors.push(value);
            onFinnish();
          };
          promises.forEach((promise) => {
            promise.then(onSuccess).catch(onError);
          });
        });
      }
    };
    Utils = _Utils;
    __publicField(Utils, "Array", array_utils_default);
    utils_default = Utils;
  }
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// node_modules/color-convert/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-convert/node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn(args);
        if (typeof result === "object") {
          for (var len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var colorConvert = require_color_convert();
    var wrapAnsi16 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => function() {
      const code = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => function() {
      const rgb = fn.apply(colorConvert, arguments);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;
      for (const groupName of Object.keys(styles)) {
        const group = styles[groupName];
        for (const styleName of Object.keys(group)) {
          const style = group[styleName];
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
      }
      const ansi2ansi = (n) => n;
      const rgb2rgb = (r, g, b) => [r, g, b];
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };
      for (let key of Object.keys(colorConvert)) {
        if (typeof colorConvert[key] !== "object") {
          continue;
        }
        const suite = colorConvert[key];
        if (key === "ansi16") {
          key = "ansi";
        }
        if ("ansi16" in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }
        if ("ansi256" in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }
        if ("rgb" in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/chalk/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/chalk/node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/chalk/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/templates.js"(exports, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, args) {
      const results = [];
      const chunks = args.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const styleName of Object.keys(enabled)) {
        if (Array.isArray(enabled[styleName])) {
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          if (enabled[styleName].length > 0) {
            current = current[styleName].apply(current, enabled[styleName]);
          } else {
            current = current[styleName];
          }
        }
      }
      return current;
    }
    module2.exports = (chalk, tmp) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
        if (escapeChar) {
          chunk.push(unescape(escapeChar));
        } else if (style) {
          const str = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(chr);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMsg);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/index.js
var require_chalk = __commonJS({
  "node_modules/chalk/index.js"(exports, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var ansiStyles = require_ansi_styles();
    var stdoutColor = require_supports_color().stdout;
    var template = require_templates();
    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
    var skipModels = /* @__PURE__ */ new Set(["gray"]);
    var styles = /* @__PURE__ */ Object.create(null);
    function applyOptions(obj, options) {
      options = options || {};
      const scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === void 0 ? scLevel : options.level;
      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
    }
    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        const chalk = {};
        applyOptions(chalk, options);
        chalk.template = function() {
          const args = [].slice.call(arguments);
          return chalkTag.apply(null, [chalk.template].concat(args));
        };
        Object.setPrototypeOf(chalk, Chalk.prototype);
        Object.setPrototypeOf(chalk.template, chalk);
        chalk.template.constructor = Chalk;
        return chalk.template;
      }
      applyOptions(this, options);
    }
    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }
    for (const key of Object.keys(ansiStyles)) {
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
      styles[key] = {
        get() {
          const codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    }
    styles.visible = {
      get() {
        return build.call(this, this._styles || [], true, "visible");
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
    for (const model of Object.keys(ansiStyles.color.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      styles[model] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
      if (skipModels.has(model)) {
        continue;
      }
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const level = this.level;
          return function() {
            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            const codes = {
              open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, styles);
    function build(_styles, _empty, key) {
      const builder = function() {
        return applyStyle.apply(builder, arguments);
      };
      builder._styles = _styles;
      builder._empty = _empty;
      const self = this;
      Object.defineProperty(builder, "level", {
        enumerable: true,
        get() {
          return self.level;
        },
        set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, "enabled", {
        enumerable: true,
        get() {
          return self.enabled;
        },
        set(enabled) {
          self.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
      builder.__proto__ = proto;
      return builder;
    }
    function applyStyle() {
      const args = arguments;
      const argsLen = args.length;
      let str = String(arguments[0]);
      if (argsLen === 0) {
        return "";
      }
      if (argsLen > 1) {
        for (let a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? "" : str;
      }
      const originalDim = ansiStyles.dim.open;
      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = "";
      }
      for (const code of this._styles.slice().reverse()) {
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
      }
      ansiStyles.dim.open = originalDim;
      return str;
    }
    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(" ");
      }
      const args = [].slice.call(arguments, 2);
      const parts = [strings.raw[0]];
      for (let i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
        parts.push(String(strings.raw[i]));
      }
      return template(chalk, parts.join(""));
    }
    Object.defineProperties(Chalk.prototype, styles);
    module2.exports = Chalk();
    module2.exports.supportsColor = stdoutColor;
    module2.exports.default = module2.exports;
  }
});

// engine/shared/log.js
var defaultLevels, hasConsoleGroups, getLogStyles, Logger, Log2, log_default;
var init_log = __esm({
  "engine/shared/log.js"() {
    init_utils();
    defaultLevels = [
      { name: "trace", type: "trace", background: "#EEEEEE", color: "#AAAAAA" },
      { name: "info", type: "log", background: "#BDE5F8", color: "#00529B" },
      { name: "warn", type: "warn", background: "#FEEFB3", color: "#9F6000" },
      { name: "error", type: "error", background: "#FFBABA", color: "#D8000C" },
      { name: "log", type: "log", background: "#EEEEEE", color: "#1f4f6b" }
    ];
    hasConsoleGroups = () => console && console.group && console.groupCollapsed && console.groupEnd;
    getLogStyles = (background, color) => {
      if (false) {
        return [
          "background: #2D7BFF; line-height: 20px; padding: 4px 0",
          "background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0",
          "background: #2D7BFF; line-height: 20px; padding: 4px 0",
          `background: ${background}; color: ${color}; line-height: 20px; padding: 4px 0; font-weight: bold`,
          "background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0",
          "background: #2D7BFF; line-height: 20px; padding: 4px 0"
        ];
      }
      if (true) {
        const chalk = require_chalk();
        return [
          chalk.bgHex("#2D7BFF"),
          chalk.bgHex("#2B2B2B").white,
          chalk.bgHex("#2D7BFF"),
          chalk.bgHex(background).hex(color).bold,
          chalk.bgHex("#2B2B2B").white,
          chalk.bgHex("#2D7BFF")
        ];
      }
    };
    Logger = class {
      constructor(maxLevel = "warn", levels = defaultLevels) {
        this._levels = [...levels];
        this._maxLevel = this.getLevelIndexByName(maxLevel);
        this._consoleFuncs = {
          trace: (...args) => {
            if (hasConsoleGroups()) {
              console.groupCollapsed(...args);
              console.trace();
              console.groupEnd();
            } else {
              console.trace(...args);
            }
          }
        };
        this._levels.forEach(({ name }) => {
          this[name] = (tag, ...args) => {
            this._log(name, tag, ...args);
          };
        });
      }
      getLevelIndexByName(levelName) {
        return utils_default.Array.findIndex(this._levels, (l) => l.name === levelName);
      }
      getLevelObjectByName(levelName) {
        return utils_default.Array.find(this._levels, (l) => l.name === levelName);
      }
      canLog(levelName) {
        const level = this.getLevelIndexByName(levelName);
        if (level < 0) {
          return false;
        }
        return level >= this._maxLevel;
      }
      setLevel(levelName) {
        const level = this.getLevelIndexByName(levelName);
        if (level < 0) {
          return;
        }
        this._maxLevel = level;
      }
      _log(levelName, tag, ...args) {
        const level = this.getLevelObjectByName(levelName);
        if (!level || !this.canLog(levelName)) {
          return;
        }
        const { name, type, background, color } = level;
        const outputs = args.filter((arg) => arg !== void 0).map((arg) => {
          if (arg.toObject) {
            return JSON.parse(JSON.stringify(arg.toObject()));
          }
          return arg;
        });
        const consoleFunc = this._consoleFuncs[type] || console[type] ? (...args2) => console[type](...args2) : (...args2) => console.log(...args2);
        const outputsLen = outputs.length;
        const styles = getLogStyles(background, color);
        if (false) {
          if (!hasColorOutput()) {
            const outputsLen2 = outputs.length;
            if (outputsLen2 <= 0) {
              consoleFunc(`PhotoEditorSDK | ${tag} `);
              return;
            }
            if (outputsLen2 === 1 && typeof outputs[0] === "string") {
              consoleFunc(`PhotoEditorSDK | ${tag} | ${outputs[0]}`);
              return;
            }
            consoleFunc(`PhotoEditorSDK | ${tag} | `, ...outputs);
            return;
          }
          if (outputsLen <= 0) {
            consoleFunc(`%c  %c PhotoEditorSDK %c  %c ${tag} %c %c  `, ...styles);
            return;
          }
          if (outputsLen === 1 && typeof outputs[0] === "string") {
            consoleFunc(`%c  %c PhotoEditorSDK %c  %c ${tag} %c  ${outputs[0]}  %c  `, ...styles);
            return;
          }
          if (hasConsoleGroups()) {
            console.groupCollapsed(`%c  %c PhotoEditorSDK %c  %c ${tag} %c`, ...utils_default.Array.init(styles));
            consoleFunc(...outputs);
            console.groupEnd();
          } else {
            consoleFunc(`%c  %c PhotoEditorSDK %c  %c ${tag} %c`, ...utils_default.Array.init(styles), ...outputs);
          }
        }
        if (true) {
          const prefix = `${styles[0](" ")} ${styles[1]("PhotoEditorSDK")} ${styles[2](" ")} ${styles[3](tag)}`;
          const suffix = `${styles[5](" ")} `;
          if (outputsLen <= 0) {
            consoleFunc(`${prefix} ${suffix}`);
            return;
          }
          if (outputsLen === 1 && typeof outputs[0] === "string") {
            consoleFunc(`${prefix} ${styles[4](outputs[0])} ${suffix}`);
            return;
          }
          if (hasConsoleGroups()) {
            console.groupCollapsed(`${prefix} ${suffix}`);
            consoleFunc(...outputs);
            console.groupEnd();
          } else {
            consoleFunc(`${prefix} ${suffix}`, ...outputs);
          }
        }
      }
      image(tag = "", source) {
        if (false) {
          let image = new window.Image();
          const onload = () => {
            const { width } = image;
            const { height } = image;
            if (tag) {
              console.log(tag);
            }
            console.log(`%c+`, `
        font-size: 1px;
        padding: 0px ${Math.floor(width / 2)}px;
        line-height: ${height}px;
        background: url(${image.src});
        color: transparent;
        background-repeat: no-repeat;
        background-size: ${width}px ${height}px;`);
          };
          image.onload = onload;
          if (source instanceof window.HTMLCanvasElement) {
            image.src = source.toDataURL();
          } else if (source instanceof window.Image) {
            image = source;
            onload();
          } else if (typeof source === "string") {
            image.src = source;
          } else {
            this.log(tag, source);
          }
          return image;
        }
      }
      texture(tag = "", texture) {
        if (false) {
          if (!texture) {
            this.log(tag, "texture: null or undefined");
            return;
          }
          const baseTexture = texture.getBaseTexture();
          const renderers = baseTexture.getRenderers();
          const glRenderer = utils_default.Array.find(renderers, (r) => r && r.constructor.type === "webgl");
          const { width, height } = baseTexture.getFrame();
          if (glRenderer) {
            const gl = glRenderer.getContext();
            const glTexture = baseTexture.getGLTextureForRenderer(glRenderer);
            this.logGlTexture(gl, glTexture, width, height, tag);
          } else {
            Log2.image(tag, baseTexture.getSource());
          }
        }
      }
      logGlTexture(gl, texture, width = 150, height = 150, tag) {
        if (false) {
          gl.bindTexture(gl.TEXTURE_2D, texture);
          const framebuffer = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          const data = new Uint8Array(width * height * 4);
          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
          gl.deleteFramebuffer(framebuffer);
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const context = canvas.getContext("2d");
          const imageData = context.createImageData(width, height);
          imageData.data.set(data);
          context.putImageData(imageData, 0, 0);
          return Log2.image(tag, canvas);
        }
      }
    };
    Log2 = new Logger("warn");
    log_default = Log2;
  }
});

// engine/shared/loaders/image-loader.js
var readFileAsync, loadRemoteFile, image_loader_default;
var init_image_loader = __esm({
  "engine/shared/loaders/image-loader.js"() {
    readFileAsync = (filePath) => {
      if (true) {
        const fs = require("fs");
        return new Promise((resolve, reject) => {
          try {
            fs.readFile(filePath, (err, buffer) => {
              if (err) {
                reject(err);
              } else {
                resolve([filePath, buffer]);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
    };
    loadRemoteFile = (url) => {
      if (true) {
        const request = require("request");
        return new Promise((resolve, reject) => {
          request.get(url, { encoding: null }, (err, response, body) => {
            if (err)
              return reject(err);
            if (response.statusCode !== 200) {
              return reject(new Error(`Server responded with status code ${response.statusCode}`));
            }
            resolve([url, response.body]);
          });
        });
      }
    };
    image_loader_default = {
      load(url, crossOrigin = { cors: true, value: "anonymous" }) {
        const loadPromise = () => {
          if (false) {
            return Promise.resolve([url, url]);
          }
          if (true) {
            if (url.substr(0, 5) === "data:") {
              return Promise.resolve([url, url]);
            }
            if (!url.match(/^(https?|ftp|file):\/\//)) {
              return readFileAsync(url);
            }
            return loadRemoteFile(url);
          }
        };
        return loadPromise().then(([originalSrc, src]) => {
          return this._createAndLoadImage(originalSrc, src, crossOrigin);
        });
      },
      loadImage(src, crossOrigin = { cors: true, value: "anonymous" }) {
        if (false) {
          return this._loadWithoutExif(src, crossOrigin);
        }
        return this.load(src, crossOrigin);
      },
      _loadWithoutExif(src, crossOrigin = { cors: true, value: "anonymous" }) {
        return new Promise((resolve, reject) => {
          const image = new window.Image();
          image.addEventListener("load", () => {
            resolve(image);
          });
          image.addEventListener("error", () => {
            reject(new Error(`Failed to load image at ${src}`));
          });
          if (crossOrigin.cors) {
            image.crossOrigin = crossOrigin.value;
          }
          image.src = src;
        });
      },
      _createAndLoadImage(originalSrc, src, crossOrigin = { cors: true, value: "anonymous" }) {
        return new Promise((resolve, reject) => {
          if (false) {
            const loadWithoutExif = this._loadWithoutExif(src, crossOrigin).then((img) => resolve(img));
            const loadWithExif = new Promise((resolve2, reject2) => {
              this._loadAsDataURL(src, crossOrigin).then((dataURL) => {
                const image = new window.Image();
                image.addEventListener("load", () => {
                  resolve2(image);
                });
                image.src = dataURL;
                image.rawSource = dataURL;
              }).catch((_) => {
                loadWithoutExif.then((img) => resolve2(img));
              });
            });
            if (this._stringEndsWith(src, ".svg")) {
              return loadWithoutExif.then((img) => resolve(img));
            }
            return loadWithExif.then((img) => resolve(img));
          }
          if (true) {
            const Canvas2 = require("canvas");
            const image = new Canvas2.Image();
            image.src = src;
            image.rawSource = src;
            image.filePath = originalSrc;
            resolve(image);
          }
        });
      },
      _stringEndsWith(srcString, search, length = srcString.length) {
        if (length === void 0 || length > srcString.length) {
          length = srcString.length;
        }
        return srcString.substring(length - search.length, length) === search;
      },
      _loadAsDataURL(url, crossOrigin = { cors: true, value: "anonymous" }) {
        if (false) {
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.onload = function() {
              const reader = new FileReader();
              reader.onloadend = function() {
                if (reader.error) {
                  reject(reader.error);
                }
                resolve(reader.result);
              };
              reader.readAsDataURL(xhr.response);
            };
            xhr.open("GET", url);
            xhr.responseType = "blob";
            xhr.withCredentials = crossOrigin.cors && crossOrigin.value === "use-credentials";
            xhr.send();
          });
        }
        return Promise.reject(new Error(`Loading images as data urls is only supported in browser environments.`));
      },
      loadXHR(url, mime) {
        return new Promise((resolve, reject) => {
          let xhr;
          if (window.XDomainRequest) {
            xhr = new window.XDomainRequest();
            if (mime)
              xhr.overrideMimeType(mime);
            xhr.onload = function() {
              resolve(xhr);
            };
            xhr.onerror = function(e) {
              reject(e);
            };
          } else if (window.XMLHttpRequest) {
            xhr = new window.XMLHttpRequest();
            if (mime)
              xhr.overrideMimeType(mime);
            xhr.onreadystatechange = function(oEvent) {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  resolve(xhr);
                } else {
                  reject(new Error(`HTTP Status ${xhr.status}`));
                }
              }
            };
          }
          xhr.open("GET", url, true);
          xhr.send();
        });
      }
    };
  }
});

// node_modules/native-url/dist/index.js
var require_dist = __commonJS({
  "node_modules/native-url/dist/index.js"(exports) {
    var t;
    var e = (t = require("querystring")) && typeof t == "object" && "default" in t ? t.default : t;
    var o = /https?|ftp|gopher|file/;
    function r(t2) {
      typeof t2 == "string" && (t2 = d(t2));
      var r2 = function(t3, e2, o2) {
        var r3 = t3.auth, a2 = t3.hostname, s2 = t3.protocol || "", p2 = t3.pathname || "", n2 = t3.hash || "", c2 = t3.query || "", h2 = false;
        r3 = r3 ? encodeURIComponent(r3).replace(/%3A/i, ":") + "@" : "", t3.host ? h2 = r3 + t3.host : a2 && (h2 = r3 + (~a2.indexOf(":") ? "[" + a2 + "]" : a2), t3.port && (h2 += ":" + t3.port)), c2 && typeof c2 == "object" && (c2 = e2.encode(c2));
        var l2 = t3.search || c2 && "?" + c2 || "";
        return s2 && s2.substr(-1) !== ":" && (s2 += ":"), t3.slashes || (!s2 || o2.test(s2)) && h2 !== false ? (h2 = "//" + (h2 || ""), p2 && p2[0] !== "/" && (p2 = "/" + p2)) : h2 || (h2 = ""), n2 && n2[0] !== "#" && (n2 = "#" + n2), l2 && l2[0] !== "?" && (l2 = "?" + l2), { protocol: s2, host: h2, pathname: p2 = p2.replace(/[?#]/g, encodeURIComponent), search: l2 = l2.replace("#", "%23"), hash: n2 };
      }(t2, e, o);
      return "" + r2.protocol + r2.host + r2.pathname + r2.search + r2.hash;
    }
    var a = "http://";
    var s = "w.w";
    var p = a + s;
    var n = /^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i;
    var c = /https?|ftp|gopher|file/;
    function h(t2, e2) {
      var o2 = typeof t2 == "string" ? d(t2) : t2;
      t2 = typeof t2 == "object" ? r(t2) : t2;
      var s2 = d(e2), h2 = "";
      o2.protocol && !o2.slashes && (h2 = o2.protocol, t2 = t2.replace(o2.protocol, ""), h2 += e2[0] === "/" || t2[0] === "/" ? "/" : ""), h2 && s2.protocol && (h2 = "", s2.slashes || (h2 = s2.protocol, e2 = e2.replace(s2.protocol, "")));
      var l2 = t2.match(n);
      l2 && !s2.protocol && (t2 = t2.substr((h2 = l2[1] + (l2[2] || "")).length), /^\/\/[^/]/.test(e2) && (h2 = h2.slice(0, -1)));
      var i2 = new URL(t2, p + "/"), u2 = new URL(e2, i2).toString().replace(p, ""), f2 = s2.protocol || o2.protocol;
      return f2 += o2.slashes || s2.slashes ? "//" : "", !h2 && f2 ? u2 = u2.replace(a, f2) : h2 && (u2 = u2.replace(a, "")), c.test(u2) || ~e2.indexOf(".") || t2.slice(-1) === "/" || e2.slice(-1) === "/" || u2.slice(-1) !== "/" || (u2 = u2.slice(0, -1)), h2 && (u2 = h2 + (u2[0] === "/" ? u2.substr(1) : u2)), u2;
    }
    function l() {
    }
    l.prototype.parse = d, l.prototype.format = r, l.prototype.resolve = h, l.prototype.resolveObject = h;
    var i = /^https?|ftp|gopher|file/;
    var u = /^(.*?)([#?].*)/;
    var f = /^([a-z0-9.+-]*:)(\/{0,3})(.*)/i;
    var m = /^([a-z0-9.+-]*:)?\/\/\/*/i;
    var v = /^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;
    function d(t2, o2, a2) {
      if (o2 === void 0 && (o2 = false), a2 === void 0 && (a2 = false), t2 && typeof t2 == "object" && t2 instanceof l)
        return t2;
      var n2 = (t2 = t2.trim()).match(u);
      t2 = n2 ? n2[1].replace(/\\/g, "/") + n2[2] : t2.replace(/\\/g, "/"), v.test(t2) && t2.slice(-1) !== "/" && (t2 += "/");
      var c2 = !/(^javascript)/.test(t2) && t2.match(f), h2 = m.test(t2), d2 = "";
      c2 && (i.test(c2[1]) || (d2 = c2[1].toLowerCase(), t2 = "" + c2[2] + c2[3]), c2[2] || (h2 = false, i.test(c2[1]) ? (d2 = c2[1], t2 = "" + c2[3]) : t2 = "//" + c2[3]), c2[2].length !== 3 && c2[2].length !== 1 || (d2 = c2[1], t2 = "/" + c2[3]));
      var g, y = (n2 ? n2[1] : t2).match(/^https?:\/\/[^/]+(:[0-9]+)(?=\/|$)/), b = y && y[1], C = new l(), U = "", j = "";
      try {
        g = new URL(t2);
      } catch (e2) {
        U = e2, d2 || a2 || !/^\/\//.test(t2) || /^\/\/.+[@.]/.test(t2) || (j = "/", t2 = t2.substr(1));
        try {
          g = new URL(t2, p);
        } catch (t3) {
          return C.protocol = d2, C.href = d2, C;
        }
      }
      C.slashes = h2 && !j, C.host = g.host === s ? "" : g.host, C.hostname = g.hostname === s ? "" : g.hostname.replace(/(\[|\])/g, ""), C.protocol = U ? d2 || null : g.protocol, C.search = g.search.replace(/\\/g, "%5C"), C.hash = g.hash.replace(/\\/g, "%5C");
      var w = t2.split("#");
      !C.search && ~w[0].indexOf("?") && (C.search = "?"), C.hash || w[1] !== "" || (C.hash = "#"), C.query = o2 ? e.decode(g.search.substr(1)) : C.search.substr(1), C.pathname = j + (c2 ? function(t3) {
        return t3.replace(/['^|`]/g, function(t4) {
          return "%" + t4.charCodeAt().toString(16).toUpperCase();
        }).replace(/((?:%[0-9A-F]{2})+)/g, function(t4, e2) {
          try {
            return decodeURIComponent(e2).split("").map(function(t5) {
              var e3 = t5.charCodeAt();
              return e3 > 256 || /^[a-z0-9]$/i.test(t5) ? t5 : "%" + e3.toString(16).toUpperCase();
            }).join("");
          } catch (t5) {
            return e2;
          }
        });
      }(g.pathname) : g.pathname), C.protocol === "about:" && C.pathname === "blank" && (C.protocol = "", C.pathname = ""), U && t2[0] !== "/" && (C.pathname = C.pathname.substr(1)), d2 && !i.test(d2) && t2.slice(-1) !== "/" && C.pathname === "/" && (C.pathname = ""), C.path = C.pathname + C.search, C.auth = [g.username, g.password].map(decodeURIComponent).filter(Boolean).join(":"), C.port = g.port, b && !C.host.endsWith(b) && (C.host += b, C.port = b.slice(1)), C.href = j ? "" + C.pathname + C.search + C.hash : r(C);
      var x = /^(file)/.test(C.href) ? ["host", "hostname"] : [];
      return Object.keys(C).forEach(function(t3) {
        ~x.indexOf(t3) || (C[t3] = C[t3] || null);
      }), C;
    }
    exports.parse = d, exports.format = r, exports.resolve = h, exports.resolveObject = function(t2, e2) {
      return d(h(t2, e2));
    }, exports.Url = l;
  }
});

// engine/shared/loaders/json-loader.js
var import_native_url, TIMEOUT, root, JSONLoader;
var init_json_loader = __esm({
  "engine/shared/loaders/json-loader.js"() {
    import_native_url = __toESM(require_dist());
    TIMEOUT = 5e3;
    root = typeof window !== "undefined" ? window : global;
    JSONLoader = class {
      constructor(url) {
        this._url = url;
        this._parsedUrl = (0, import_native_url.parse)(this._url, true);
      }
      _isJSONPRequest() {
        const { query } = this._parsedUrl;
        for (const key in query) {
          const value = query[key];
          if (value === "?") {
            return true;
          }
        }
        return false;
      }
      load() {
        if (this._isJSONPRequest()) {
          return this._loadJSONP();
        }
        return this._loadJSON();
      }
      _loadJSON() {
        return new Promise((resolve, reject) => {
          let xhr;
          if (root.XDomainRequest) {
            xhr = new root.XDomainRequest();
            xhr.onload = function() {
              const json = JSON.parse(xhr.responseText);
              resolve(json);
            };
            xhr.onerror = function(e) {
              reject(e);
            };
            xhr.open("GET", this._url, true);
            xhr.send();
          } else if (root.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(oEvent) {
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  const json = JSON.parse(xhr.responseText);
                  resolve(json);
                } else {
                  reject(new Error(`HTTP Status ${xhr.status}`));
                }
              }
            };
            xhr.open("GET", this._url, true);
            xhr.send();
          }
        });
      }
      _loadJSONP() {
        let failed = false;
        let succeeded = false;
        const fnName = `pesdk${Math.round(Math.random() * 99999999999999)}`;
        return new Promise((resolve, reject) => {
          const node = this._createJSONPNode(fnName);
          root[fnName] = (result) => {
            this._removeJSONPNode(node);
            if (!failed) {
              succeeded = true;
              resolve(result);
            }
          };
          root.setTimeout(() => {
            if (!succeeded) {
              this._removeJSONPNode(node);
              failed = true;
              reject(new Error("Timeout of 5 seconds exceeded."));
            }
          }, TIMEOUT);
        });
      }
      _createJSONPNode(fnName) {
        const JSONPUrl = this._buildJSONPUrl(fnName);
        const headNode = document.querySelector("head");
        const scriptNode = document.createElement("script");
        scriptNode.src = JSONPUrl;
        headNode.appendChild(scriptNode);
        return scriptNode;
      }
      _removeJSONPNode(node) {
        node.parentNode.removeChild(node);
      }
      _buildJSONPUrl(fnName) {
        const { query } = this._parsedUrl;
        let parameter = null;
        for (const param in query) {
          if (query[param] === "?") {
            parameter = param;
            break;
          }
        }
        delete this._parsedUrl.search;
        query[parameter] = fnName;
        return (0, import_native_url.format)(this._parsedUrl);
      }
    };
  }
});

// engine/shared/loaders/index.js
var loaders_exports = {};
__export(loaders_exports, {
  ImageLoader: () => image_loader_default,
  JSONLoader: () => JSONLoader
});
var init_loaders = __esm({
  "engine/shared/loaders/index.js"() {
    init_image_loader();
    init_json_loader();
  }
});

// engine/sdk/core/lib/color.js
var Color, color_default;
var init_color = __esm({
  "engine/sdk/core/lib/color.js"() {
    Color = class {
      constructor(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
      }
      toRGBA() {
        const colors = [
          Math.round(this.r * 255),
          Math.round(this.g * 255),
          Math.round(this.b * 255),
          this.a.toFixed(2)
        ];
        return `rgba(${colors.join(",")})`;
      }
      set(r, g, b, a = this.a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this;
      }
      toRGB() {
        return [
          Math.round(this.r * 255),
          Math.round(this.g * 255),
          Math.round(this.b * 255)
        ];
      }
      toHex() {
        const components = [
          this._componentToHex(Math.round(this.r * 255)),
          this._componentToHex(Math.round(this.g * 255)),
          this._componentToHex(Math.round(this.b * 255))
        ];
        return `#${components.join("")}`;
      }
      toGLColor() {
        return [this.r, this.g, this.b, this.a];
      }
      toArray() {
        return this.toGLColor();
      }
      toRGBGLColor() {
        return [this.r, this.g, this.b];
      }
      toHSV() {
        const max = Math.max(this.r, this.g, this.b);
        const min = Math.min(this.r, this.g, this.b);
        let h;
        let s;
        const v = max;
        const d = max - min;
        s = max === 0 ? 0 : d / max;
        if (max === min) {
          h = 0;
        } else {
          switch (max) {
            case this.r:
              h = (this.g - this.b) / d;
              if (this.g < this.b) {
                h += 6;
              }
              break;
            case this.g:
              h = (this.b - this.r) / d + 2;
              break;
            case this.b:
              h = (this.r - this.g) / d + 4;
              break;
          }
          h /= 6;
        }
        return [h, s, v];
      }
      fromHSV(h, s, v) {
        this.copy(Color.fromHSV(h, s, v));
        return this;
      }
      static fromHSV(h, s, v, a = 1) {
        let [r, g, b] = [];
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0:
            r = v;
            g = t;
            b = p;
            break;
          case 1:
            r = q;
            g = v;
            b = p;
            break;
          case 2:
            r = p;
            g = v;
            b = t;
            break;
          case 3:
            r = p;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p;
            b = v;
            break;
          case 5:
            r = v;
            g = p;
            b = q;
            break;
        }
        return new Color(r, g, b, a);
      }
      static fromArray(arr) {
        return new Color(arr[0], arr[1], arr[2], arr[3]);
      }
      static fromHex(hex) {
        const [r, g, b] = hex.match(/[0-9A-fa-f]{1,2}/g);
        return new Color(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1);
      }
      clone() {
        return new Color(this.r, this.g, this.b, this.a);
      }
      cloneRGB() {
        return new Color(this.r, this.g, this.b, 1);
      }
      add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        this.a += color.a;
        return this;
      }
      minus(color) {
        this.r -= color.r;
        this.g -= color.g;
        this.b -= color.b;
        this.a -= color.a;
        return this;
      }
      multiplyScalar(val) {
        this.r *= val;
        this.g *= val;
        this.b *= val;
        this.a *= val;
        return this;
      }
      divideScalar(val) {
        this.r /= val;
        this.g /= val;
        this.b /= val;
        this.a /= val;
        return this;
      }
      clamp(minVal, maxVal) {
        this.r = Math.min(Math.max(this.r, minVal), maxVal);
        this.g = Math.min(Math.max(this.g, minVal), maxVal);
        this.b = Math.min(Math.max(this.b, minVal), maxVal);
        this.a = Math.min(Math.max(this.a, minVal), maxVal);
        return this;
      }
      mix(c, a) {
        this.r = (1 - a) * this.r + a * c.r;
        this.g = (1 - a) * this.g + a * c.g;
        this.b = (1 - a) * this.b + a * c.b;
        this.a = (1 - a) * this.a + a * c.a;
        return this;
      }
      copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        this.a = color.a;
        return this;
      }
      equals(color) {
        return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
      }
      _componentToHex(component) {
        const hex = component.toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
      }
      toString() {
        return `Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
      }
      static get TRANSPARENT() {
        return new Color(0, 0, 0, 0);
      }
      static get WHITE() {
        return new Color(1, 1, 1, 1);
      }
      static get BLACK() {
        return new Color(0, 0, 0, 1);
      }
      static get RED() {
        return new Color(1, 0, 0, 1);
      }
      static get BLUE() {
        return new Color(0, 0, 1, 1);
      }
      static get GREEN() {
        return new Color(0, 1, 0, 1);
      }
    };
    color_default = Color;
  }
});

// engine/sdk/core/lib/event-emitter.js
var DEFAULT_MAX_LISTENERS, EventEmitter, event_emitter_default;
var init_event_emitter = __esm({
  "engine/sdk/core/lib/event-emitter.js"() {
    init_log();
    DEFAULT_MAX_LISTENERS = 12;
    EventEmitter = class {
      constructor() {
        this._maxListeners = DEFAULT_MAX_LISTENERS;
        this._events = {};
        this._pipeDestinations = [];
      }
      pipeEvents(destination) {
        this._pipeDestinations.push(destination);
      }
      unpipeEvents(destination) {
        const i = this._pipeDestinations.indexOf(destination);
        if (i === -1) {
          return;
        }
        this._pipeDestinations.splice(i, 1);
      }
      on(type, listener) {
        if (typeof type === "undefined") {
          throw new Error(`Invalid event type: \`${type}\``);
        }
        if (typeof listener !== "function") {
          throw new TypeError();
        }
        const listeners = this._events[type] || (this._events[type] = []);
        if (listeners.indexOf(listener) !== -1) {
          return this;
        }
        listeners.push(listener);
        if (this._maxListeners && listeners.length > this._maxListeners) {
          log_default.warn("EventEmitter", `Possible memory leak detected, added ${listeners.length} \`${type}\` listeners (current limit is ${this._maxListeners})`);
          if (typeof console !== "undefined") {
            console.trace();
          }
        }
        return this;
      }
      once(type, listener) {
        if (typeof type === "undefined") {
          throw new Error(`Invalid event type: \`${type}\``);
        }
        const eventsInstance = this;
        function onceCallback() {
          eventsInstance.off(type, onceCallback);
          listener.apply(null, arguments);
        }
        return this.on(type, onceCallback);
      }
      off(type, ...args) {
        if (typeof type === "undefined") {
          throw new Error(`Invalid event type: \`${type}\``);
        }
        if (args.length === 0) {
          this._events[type] = null;
          return this;
        }
        const listener = args[0];
        if (typeof listener !== "function") {
          throw new TypeError();
        }
        const listeners = this._events[type];
        if (!listeners || !listeners.length) {
          return this;
        }
        const indexOfListener = listeners.indexOf(listener);
        if (indexOfListener === -1) {
          return this;
        }
        listeners.splice(indexOfListener, 1);
        return this;
      }
      emit(type, ...args) {
        if (typeof type === "undefined") {
          throw new Error(`Invalid event type: \`${type}\``);
        }
        this._pipeDestinations.forEach((dest) => {
          dest.emit(type, ...args);
        });
        const listeners = this._events[type];
        if (!listeners || !listeners.length) {
          return false;
        }
        listeners.slice(0).forEach((fn) => fn.apply(null, args));
        return true;
      }
      setMaxListeners(newMaxListeners) {
        if (parseInt(newMaxListeners, 10) !== newMaxListeners) {
          throw new TypeError();
        }
        this._maxListeners = newMaxListeners;
      }
    };
    event_emitter_default = EventEmitter;
  }
});

// packages/shared/helpers/cleanUpCanvasMemory.ts
var cleanUpCanvasMemory;
var init_cleanUpCanvasMemory = __esm({
  "packages/shared/helpers/cleanUpCanvasMemory.ts"() {
    cleanUpCanvasMemory = (canvas) => {
      if (canvas) {
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        if (ctx) {
          ctx.clearRect(0, 0, 1, 1);
        }
      }
    };
  }
});

// engine/sdk/core/lib/gl-utils.js
var gl_utils_default;
var init_gl_utils = __esm({
  "engine/sdk/core/lib/gl-utils.js"() {
    init_log();
    init_cleanUpCanvasMemory();
    gl_utils_default = {
      checkFramebufferStatus(tag, gl) {
        const fboStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        const possibleStatuses = {
          [gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT]: "Incomplete attachment",
          [gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT]: "Missing attachment",
          [gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS]: "Incomplete dimensions",
          [gl.FRAMEBUFFER_UNSUPPORTED]: "Framebuffer unsupported"
        };
        if (fboStatus !== gl.FRAMEBUFFER_COMPLETE) {
          log_default.warn(tag, `Framebuffer incomplete: ${possibleStatuses[fboStatus]}`);
        }
      },
      determineGPUName(gl) {
        let gpuName = null;
        let canvas = null;
        if (!gl) {
          canvas = document.createElement("canvas");
          gl = canvas.getContext("experimental-webgl") || canvas.getContext("webgl");
        }
        const ext = gl && gl.getExtension("WEBGL_debug_renderer_info");
        if (ext) {
          gpuName = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
          canvas && canvas.remove();
        }
        cleanUpCanvasMemory(canvas);
        return gpuName;
      },
      isGPUBlacklisted(gpuname, userAgent = null) {
        return false;
      }
    };
  }
});

// engine/v6/utils/types.ts
var isNumber;
var init_types = __esm({
  "engine/v6/utils/types.ts"() {
    isNumber = (value) => typeof value === "number";
  }
});

// engine/sdk/core/lib/math/vector2.ts
var isVector, getVectorObj, mathWrapper, Vector2;
var init_vector2 = __esm({
  "engine/sdk/core/lib/math/vector2.ts"() {
    init_types();
    isVector = (value) => value instanceof Vector2;
    getVectorObj = (valueX, valueY) => {
      if (isVector(valueX)) {
        return {
          x: valueX.x,
          y: valueX.y
        };
      }
      return {
        x: valueX,
        y: isNumber(valueY) ? valueY : valueX
      };
    };
    mathWrapper = (vector, operation) => (valueX, valueY) => {
      const { x, y } = getVectorObj(valueX, valueY);
      vector.x = operation(vector.x, x);
      vector.y = operation(vector.y, y);
      return vector;
    };
    Vector2 = class {
      constructor(x = 0, y = 0) {
        this.add = mathWrapper(this, (a, b) => a + b);
        this.subtract = mathWrapper(this, (a, b) => a - b);
        this.divide = mathWrapper(this, (a, b) => a / b);
        this.multiply = mathWrapper(this, (a, b) => a * b);
        this.x = x;
        this.y = y;
      }
      set(valueX, valueY) {
        const { x, y } = getVectorObj(valueX, valueY);
        this.x = x;
        this.y = y;
        return this;
      }
      clone() {
        return new Vector2(this.x, this.y);
      }
      copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
      }
      clamp(minimum, maximum) {
        if (isNumber(minimum)) {
          minimum = new Vector2(minimum, minimum);
        }
        if (isNumber(maximum)) {
          maximum = new Vector2(maximum, maximum);
        }
        if (minimum) {
          this.x = Math.max(minimum.x, this.x);
          this.y = Math.max(minimum.y, this.y);
        }
        if (maximum) {
          this.x = Math.min(maximum.x, this.x);
          this.y = Math.min(maximum.y, this.y);
        }
        return this;
      }
      dot(valueX, valueY) {
        const { x, y } = getVectorObj(valueX, valueY);
        return this.x * x + this.y * y;
      }
      equals(valueX, valueY) {
        const { x, y } = getVectorObj(valueX, valueY);
        return x === this.x && y === this.y;
      }
      flip() {
        const tempX = this.x;
        this.x = this.y;
        this.y = tempX;
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
      floor() {
        this.x |= 0;
        this.y |= 0;
        return this;
      }
      abs() {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        return this;
      }
      len() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      min() {
        return Math.min(this.x, this.y);
      }
      max() {
        return Math.max(this.x, this.y);
      }
      toObject() {
        return { x: this.x, y: this.y };
      }
      toString() {
        return `Vector2({ x: ${this.x}, y: ${this.y} })`;
      }
      roundDecimal(decimals) {
        this.x = parseFloat(this.x.toFixed(decimals));
        this.y = parseFloat(this.y.toFixed(decimals));
        return this;
      }
      asArray(reverse = false) {
        if (reverse) {
          return [this.y, this.x];
        }
        return [this.x, this.y];
      }
      static fromObject(object) {
        return new Vector2(object.x, object.y);
      }
      static get NULL() {
        return new Vector2(0, 0);
      }
    };
  }
});

// engine/sdk/core/lib/math/matrix.ts
var Matrix;
var init_matrix = __esm({
  "engine/sdk/core/lib/math/matrix.ts"() {
    init_vector2();
    Matrix = class {
      constructor() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        this.reset();
      }
      multiply(matrix2) {
        let a;
        let b;
        let c;
        let d;
        let tx;
        let ty;
        a = this.a * matrix2.a + this.b * matrix2.c;
        b = this.a * matrix2.b + this.b * matrix2.d;
        c = this.c * matrix2.a + this.d * matrix2.c;
        d = this.c * matrix2.b + this.d * matrix2.d;
        tx = this.tx * matrix2.a + this.ty * matrix2.c + matrix2.tx;
        ty = this.tx * matrix2.b + this.ty * matrix2.d + matrix2.ty;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      applyToVector(position) {
        const { x, y } = position;
        position = position.clone();
        position.x = this.a * x + this.c * y + this.tx;
        position.y = this.b * x + this.d * y + this.tx;
        return position;
      }
      applyInverseToVector(position) {
        const determinant = 1 / (this.a * this.d + this.c * -this.b);
        const { x, y } = position;
        position = position.clone();
        position.x = this.d * determinant * x + -this.c * determinant * y + (this.ty * this.c - this.tx * this.d) * determinant;
        position.y = this.a * determinant * y + -this.b * determinant * x + (-this.ty * this.a + this.tx * this.b) * determinant;
        return position;
      }
      rectangleToCoordinates(rectangle, anchor = new Vector2(0, 0)) {
        const w0 = rectangle.width * (1 - anchor.x);
        const w1 = rectangle.width * -anchor.x;
        const h0 = rectangle.height * (1 - anchor.y);
        const h1 = rectangle.height * -anchor.y;
        const positions = [];
        positions.push(new Vector2(this.a * w1 + this.c * h1 + this.tx, this.d * h1 + this.b * w1 + this.ty));
        positions.push(new Vector2(this.a * w0 + this.c * h1 + this.tx, this.d * h1 + this.b * w0 + this.ty));
        positions.push(new Vector2(this.a * w0 + this.c * h0 + this.tx, this.d * h0 + this.b * w0 + this.ty));
        positions.push(new Vector2(this.a * w1 + this.c * h0 + this.tx, this.d * h0 + this.b * w1 + this.ty));
        return positions;
      }
      reset() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
      }
      toArray() {
        const arr = [this.a, this.b, 0, this.c, this.d, 0, this.tx, this.ty, 1];
        if (typeof Float32Array === "undefined") {
          return arr;
        }
        return new Float32Array(arr);
      }
      toString() {
        return `Matrix({ a: ${this.a}, b: ${this.b}, c: ${this.c}, d: ${this.d}, tx: ${this.tx}, ty: ${this.ty} })`;
      }
      static get IDENTITY() {
        return new Matrix();
      }
    };
  }
});

// engine/sdk/core/lib/math/rectangle.ts
var Rectangle;
var init_rectangle = __esm({
  "engine/sdk/core/lib/math/rectangle.ts"() {
    init_vector2();
    Rectangle = class {
      constructor(x = 0, y = 0, width = 0, height = 0) {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      set(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        return this;
      }
      clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
      }
      copy(other) {
        this.x = other.x;
        this.y = other.y;
        this.width = other.width;
        this.height = other.height;
        return this;
      }
      equals(rect, y, width, height) {
        if (rect instanceof Rectangle) {
          return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
        }
        return rect === this.x && y === this.y && width === this.width && height === this.height;
      }
      translate(sx, sy) {
        const { x, y } = getVectorObj(sx, sy);
        this.x += x;
        this.y += y;
        return this;
      }
      scale(sx, sy) {
        const { x, y } = getVectorObj(sx, sy);
        this.width *= x;
        this.height *= y;
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.width = Math.round(this.width);
        this.height = Math.round(this.height);
        return this;
      }
      getPosition() {
        return new Vector2(this.x, this.y);
      }
      getSize() {
        return new Vector2(this.width, this.height);
      }
      insetBy(dx, dy) {
        this.x += dx;
        this.y += dy;
        this.width -= 2 * dx;
        this.height -= 2 * dy;
        return this;
      }
      intersects(rect) {
        const p1 = new Vector2(this.x, this.y);
        const p2 = new Vector2(this.x + this.width, this.y + this.height);
        const q1 = new Vector2(rect.x, rect.y);
        const q2 = new Vector2(rect.x + rect.width, rect.y + rect.height);
        if (q1.x > p2.x || p1.x > q2.x || q2.y < p1.y || p2.y < q1.y) {
          return false;
        }
        return true;
      }
      toString() {
        return `Rectangle({ x: ${this.x}, y: ${this.y}, width: ${this.width}, height: ${this.height} })`;
      }
      static FromDiagonalPoints(p1, p2) {
        let inverted = false;
        if (p2.x - p1.x < 0) {
          inverted = true;
        }
        const topLeft = inverted ? p2 : p1;
        const bottomRight = inverted ? p1 : p2;
        const width = bottomRight.x - topLeft.x;
        const height = bottomRight.y - topLeft.y;
        return new Rectangle(topLeft.x, topLeft.y, width, height);
      }
    };
  }
});

// engine/sdk/core/engine/globals.js
var BATCH_SIZE, VERTEX_SIZE, VERTEX_BYTE_SIZE;
var init_globals = __esm({
  "engine/sdk/core/engine/globals.js"() {
    init_log();
    init_constants();
    init_color();
    init_event_emitter();
    init_gl_utils();
    init_matrix();
    init_rectangle();
    init_vector2();
    init_utils();
    BATCH_SIZE = 2e3;
    VERTEX_SIZE = 5;
    VERTEX_BYTE_SIZE = VERTEX_SIZE * 4;
  }
});

// engine/sdk/core/engine/display/display-object.ts
var DisplayObject;
var init_display_object = __esm({
  "engine/sdk/core/engine/display/display-object.ts"() {
    init_globals();
    DisplayObject = class {
      constructor() {
        this._position = new Vector2(0, 0);
        this._scale = new Vector2(1, 1);
        this._pivot = new Vector2(0, 0);
        this._rotation = 0;
        this._lastRotation = null;
        this._alpha = 1;
        this._visible = true;
        this._worldTransform = new Matrix();
        this._parent = null;
        this._shaders = [];
        this._boundsNeedUpdate = true;
        this._bounds = new Rectangle(0, 0, 1, 1);
        this._localBoundsNeedUpdate = true;
        this._localBounds = new Rectangle(0, 0, 1, 1);
        this._filterRectangle = new Rectangle(0, 0, 0, 0);
      }
      renderWebGL(renderer) {
        log_default.warn(this.constructor.name, "`renderWebGL` is abstract and not implemented in inherited class");
      }
      renderCanvas(renderer) {
        log_default.warn(this.constructor.name, "`renderCanvas` is abstract and not implemented in inherited class");
      }
      updateTransform() {
        const parentTransform = this._parent ? this._parent.getWorldTransform() : Matrix.IDENTITY;
        const worldTransform = this._worldTransform;
        const sinRotation = Math.sin(this._rotation);
        const cosRotation = Math.cos(this._rotation);
        worldTransform.a = cosRotation * this._scale.x;
        worldTransform.b = sinRotation * this._scale.x;
        worldTransform.c = -sinRotation * this._scale.y;
        worldTransform.d = cosRotation * this._scale.y;
        worldTransform.tx = this._position.x;
        worldTransform.ty = this._position.y;
        if (this._pivot.x || this._pivot.y) {
          worldTransform.tx -= this._pivot.x * worldTransform.a + this._pivot.y * worldTransform.c;
          worldTransform.ty -= this._pivot.x * worldTransform.b + this._pivot.y * worldTransform.d;
        }
        worldTransform.multiply(parentTransform);
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      addShader(shader) {
        this._shaders.push(shader);
      }
      removeShader(shader) {
        const index = this._shaders.indexOf(shader);
        if (index !== -1) {
          this._shaders.splice(index, 1);
          return true;
        }
        return false;
      }
      removeShaderAt(index) {
        if (!this._shaders[index]) {
          return false;
        }
        this._shaders.splice(index, 1);
        return true;
      }
      getBounds() {
        return this._bounds.clone();
      }
      getPosition() {
        return this._position;
      }
      setPosition(valueX, valueY) {
        this._position.set(valueX, valueY);
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      getScale() {
        return this._scale;
      }
      setScale(valueX, valueY) {
        this._scale.set(valueX, valueY);
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      getPivot() {
        return this._pivot;
      }
      setPivot(valueX, valueY) {
        this._pivot.set(valueX, valueY);
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      getRotation() {
        return this._rotation;
      }
      setRotation(rotation) {
        this._rotation = rotation;
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      getAlpha() {
        return this._alpha;
      }
      setAlpha(alpha) {
        this._alpha = alpha;
      }
      getWorldAlpha() {
        if (this._parent) {
          return this._parent.getAlpha() * this._alpha;
        }
        return this._alpha;
      }
      getWorldTransform() {
        return this._worldTransform;
      }
      getParent() {
        return this._parent;
      }
      setParent(parent) {
        this._parent = parent;
      }
      getFilterRectangle() {
        return this._filterRectangle;
      }
      setFilterRectangle(rectangle) {
        this._filterRectangle.copy(rectangle);
      }
      isVisible() {
        return this._visible;
      }
      setVisible(visible) {
        this._visible = visible;
      }
    };
  }
});

// engine/sdk/core/engine/display/container.ts
var Container;
var init_container = __esm({
  "engine/sdk/core/engine/display/container.ts"() {
    init_globals();
    init_display_object();
    Container = class extends DisplayObject {
      constructor() {
        super();
        this._children = [];
        this._filters = [];
      }
      addFilter(filter) {
        this._filters.push(filter);
      }
      removeFilter(filter) {
        const index = this._filters.indexOf(filter);
        if (index !== -1) {
          this._filters.splice(index, 1);
          return true;
        }
        return false;
      }
      setFilters(filters) {
        this._filters = filters;
      }
      addChild(child) {
        const originalParent = child.getParent();
        if (originalParent instanceof Container) {
          originalParent.removeChild(child);
        }
        child.setParent(this);
        this._children.push(child);
      }
      prependChild(child) {
        const originalParent = child.getParent();
        if (originalParent instanceof Container) {
          originalParent.removeChild(child);
        }
        child.setParent(this);
        this._children.unshift(child);
      }
      hasChild(child) {
        const index = this._children.indexOf(child);
        return index !== -1;
      }
      removeChild(child) {
        const index = this._children.indexOf(child);
        if (index !== -1) {
          this._children.splice(index, 1);
          child.setParent(null);
        } else {
          log_default.info(this.constructor.name, "Tried to remove a child that does not exist");
        }
      }
      clearChildren() {
        this._children = [];
      }
      renderWebGL(renderer) {
        if (!this._visible) {
          return;
        }
        const filterManager = renderer.getFilterManager();
        if (this._filters && this._filters.length) {
          filterManager.pushFilters(this, this._filters);
        }
        renderer.getCurrentObjectRenderer().start();
        this._renderWebGL(renderer);
        this._children.forEach((child) => {
          child.renderWebGL(renderer);
        });
        renderer.getCurrentObjectRenderer().flush();
        if (this._filters && this._filters.length) {
          filterManager.popFilters();
        }
        renderer.getCurrentObjectRenderer().start();
      }
      _renderWebGL(renderer) {
      }
      renderCanvas(renderer) {
        if (!this._visible) {
          return;
        }
        const filterManager = renderer.getFilterManager();
        if (this._filters && this._filters.length) {
          filterManager.pushFilters(this, this._filters);
        }
        this._renderCanvas(renderer);
        this._children.forEach((child) => {
          child.renderCanvas(renderer);
        });
        if (this._filters && this._filters.length) {
          filterManager.popFilters();
        }
      }
      _renderCanvas(renderer) {
      }
      updateTransform() {
        super.updateTransform();
        this._children.forEach((child) => {
          child.updateTransform();
        });
      }
      getLocalBounds() {
        if (this._localBoundsNeedUpdate) {
          this._localBoundsNeedUpdate = false;
        }
        return this._localBounds.clone();
      }
      getBounds() {
        if (this._boundsNeedUpdate) {
          this._boundsNeedUpdate = false;
        }
        return this._bounds.clone();
      }
      getChildren() {
        return this._children;
      }
      getFilters() {
        return this._filters;
      }
      dispose() {
      }
    };
  }
});

// engine/sdk/operations/shared/vendor/stack-blur.js
function stackBlurCanvasRGBA(imageData, top_x, top_y, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var pixels = imageData.data;
  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
  var div = radius + radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stackEnd;
  var stack = stackStart;
  for (i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1)
      stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;
  yw = yi = 0;
  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];
  for (y = 0; y < height; y++) {
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack = stackStart;
    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    for (i = 1; i < radiusPlus1; i++) {
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++) {
      pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa !== 0) {
        pa = 255 / pa;
        pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
      r_in_sum += stackIn.r = pixels[p];
      g_in_sum += stackIn.g = pixels[p + 1];
      b_in_sum += stackIn.b = pixels[p + 2];
      a_in_sum += stackIn.a = pixels[p + 3];
      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (x = 0; x < width; x++) {
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack = stackStart;
    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    yp = width;
    for (i = 1; i <= radius; i++) {
      yi = yp + x << 2;
      r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack = stack.next;
      if (i < heightMinus1) {
        yp += width;
      }
    }
    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++) {
      p = yi << 2;
      pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa > 0) {
        pa = 255 / pa;
        pixels[p] = r_sum * mul_sum >> shg_sum;
        pixels[p + 1] = g_sum * mul_sum >> shg_sum;
        pixels[p + 2] = b_sum * mul_sum >> shg_sum;
      } else {
        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
      r_sum += r_in_sum += stackIn.r = pixels[p];
      g_sum += g_in_sum += stackIn.g = pixels[p + 1];
      b_sum += b_in_sum += stackIn.b = pixels[p + 2];
      a_sum += a_in_sum += stackIn.a = pixels[p + 3];
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
}
function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
}
var mul_table, shg_table;
var init_stack_blur = __esm({
  "engine/sdk/operations/shared/vendor/stack-blur.js"() {
    "use strict";
    mul_table = [
      512,
      512,
      456,
      512,
      328,
      456,
      335,
      512,
      405,
      328,
      271,
      456,
      388,
      335,
      292,
      512,
      454,
      405,
      364,
      328,
      298,
      271,
      496,
      456,
      420,
      388,
      360,
      335,
      312,
      292,
      273,
      512,
      482,
      454,
      428,
      405,
      383,
      364,
      345,
      328,
      312,
      298,
      284,
      271,
      259,
      496,
      475,
      456,
      437,
      420,
      404,
      388,
      374,
      360,
      347,
      335,
      323,
      312,
      302,
      292,
      282,
      273,
      265,
      512,
      497,
      482,
      468,
      454,
      441,
      428,
      417,
      405,
      394,
      383,
      373,
      364,
      354,
      345,
      337,
      328,
      320,
      312,
      305,
      298,
      291,
      284,
      278,
      271,
      265,
      259,
      507,
      496,
      485,
      475,
      465,
      456,
      446,
      437,
      428,
      420,
      412,
      404,
      396,
      388,
      381,
      374,
      367,
      360,
      354,
      347,
      341,
      335,
      329,
      323,
      318,
      312,
      307,
      302,
      297,
      292,
      287,
      282,
      278,
      273,
      269,
      265,
      261,
      512,
      505,
      497,
      489,
      482,
      475,
      468,
      461,
      454,
      447,
      441,
      435,
      428,
      422,
      417,
      411,
      405,
      399,
      394,
      389,
      383,
      378,
      373,
      368,
      364,
      359,
      354,
      350,
      345,
      341,
      337,
      332,
      328,
      324,
      320,
      316,
      312,
      309,
      305,
      301,
      298,
      294,
      291,
      287,
      284,
      281,
      278,
      274,
      271,
      268,
      265,
      262,
      259,
      257,
      507,
      501,
      496,
      491,
      485,
      480,
      475,
      470,
      465,
      460,
      456,
      451,
      446,
      442,
      437,
      433,
      428,
      424,
      420,
      416,
      412,
      408,
      404,
      400,
      396,
      392,
      388,
      385,
      381,
      377,
      374,
      370,
      367,
      363,
      360,
      357,
      354,
      350,
      347,
      344,
      341,
      338,
      335,
      332,
      329,
      326,
      323,
      320,
      318,
      315,
      312,
      310,
      307,
      304,
      302,
      299,
      297,
      294,
      292,
      289,
      287,
      285,
      282,
      280,
      278,
      275,
      273,
      271,
      269,
      267,
      265,
      263,
      261,
      259
    ];
    shg_table = [
      9,
      11,
      12,
      13,
      13,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24
    ];
  }
});

// engine/sdk/core/lib/math/color-matrix.js
var ColorMatrix, color_matrix_default;
var init_color_matrix = __esm({
  "engine/sdk/core/lib/math/color-matrix.js"() {
    init_color();
    ColorMatrix = class {
      constructor(a = 1, b = 0, c = 0, d = 0, e = 0, f = 0, g = 1, h = 0, i = 0, j = 0, k = 0, l = 0, m = 1, n = 0, o = 0, p = 0, q = 0, r = 0, s = 1, t = 0) {
        this.set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t);
      }
      set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
        this.f = f;
        this.g = g;
        this.h = h;
        this.i = i;
        this.j = j;
        this.k = k;
        this.l = l;
        this.m = m;
        this.n = n;
        this.o = o;
        this.p = p;
        this.q = q;
        this.r = r;
        this.s = s;
        this.t = t;
      }
      reset() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 0;
        this.e = 0;
        this.f = 0;
        this.g = 1;
        this.h = 0;
        this.i = 0;
        this.j = 0;
        this.k = 0;
        this.l = 0;
        this.m = 1;
        this.n = 0;
        this.o = 0;
        this.p = 0;
        this.q = 0;
        this.r = 0;
        this.s = 1;
        this.t = 0;
      }
      apply(color) {
        const r = this.a * color.r + this.b * color.g + this.c * color.b + this.d * color.a + this.e;
        const g = this.f * color.r + this.g * color.g + this.h * color.b + this.i * color.a + this.j;
        const b = this.k * color.r + this.l * color.g + this.m * color.b + this.n * color.a + this.o;
        const a = this.p * color.r + this.q * color.g + this.r * color.b + this.s * color.a + this.t;
        return new color_default(r, g, b, a);
      }
      multiply(matrix2) {
        let a;
        let b;
        let c;
        let d;
        let e;
        let f;
        let g;
        let h;
        let i;
        let j;
        let k;
        let l;
        let m;
        let n;
        let o;
        let p;
        let q;
        let r;
        let s;
        let t;
        const A = matrix2;
        const B = this;
        a = A.a * B.a + A.b * B.f + A.c * B.k + A.d * B.p;
        b = A.a * B.b + A.b * B.g + A.c * B.l + A.d * B.q;
        c = A.a * B.c + A.b * B.h + A.c * B.m + A.d * B.r;
        d = A.a * B.d + A.b * B.i + A.c * B.n + A.d * B.s;
        f = A.f * B.a + A.g * B.f + A.h * B.k + A.i * B.p;
        g = A.f * B.b + A.g * B.g + A.h * B.l + A.i * B.q;
        h = A.f * B.c + A.g * B.h + A.h * B.m + A.i * B.r;
        i = A.f * B.d + A.g * B.i + A.h * B.n + A.i * B.s;
        k = A.k * B.a + A.l * B.f + A.m * B.k + A.n * B.p;
        l = A.k * B.b + A.l * B.g + A.m * B.l + A.n * B.q;
        m = A.k * B.c + A.l * B.h + A.m * B.m + A.n * B.r;
        n = A.k * B.d + A.l * B.i + A.m * B.n + A.n * B.s;
        p = A.p * B.a + A.q * B.f + A.r * B.k + A.s * B.p;
        q = A.p * B.b + A.q * B.g + A.r * B.l + A.s * B.q;
        r = A.p * B.c + A.q * B.h + A.r * B.m + A.s * B.r;
        s = A.p * B.d + A.q * B.i + A.r * B.n + A.s * B.s;
        e = A.a * B.e + A.b * B.j + A.c * B.o + A.d * B.t + A.e;
        j = A.f * B.e + A.g * B.j + A.h * B.o + A.i * B.t + A.j;
        o = A.k * B.e + A.l * B.j + A.m * B.o + A.n * B.t + A.o;
        t = A.p * B.e + A.q * B.j + A.r * B.o + A.s * B.t + A.t;
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
        this.f = f;
        this.g = g;
        this.h = h;
        this.i = i;
        this.j = j;
        this.k = k;
        this.l = l;
        this.m = m;
        this.n = n;
        this.o = o;
        this.p = p;
        this.q = q;
        this.r = r;
        this.s = s;
        this.t = t;
        return this;
      }
      clone() {
        const matrix2 = new ColorMatrix();
        matrix2.set(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m, this.n, this.o, this.p, this.q, this.r, this.s, this.t);
        return matrix2;
      }
      equals(matrix2) {
        return this.a === matrix2.a && this.b === matrix2.b && this.c === matrix2.c && this.d === matrix2.d && this.e === matrix2.e && this.f === matrix2.f && this.g === matrix2.g && this.h === matrix2.h && this.i === matrix2.i && this.j === matrix2.j && this.k === matrix2.k && this.l === matrix2.l && this.m === matrix2.m && this.n === matrix2.n && this.o === matrix2.o && this.p === matrix2.p && this.q === matrix2.q && this.r === matrix2.r && this.s === matrix2.s && this.t === matrix2.t;
      }
      getOffsets() {
        return [this.e, this.j, this.o, this.t];
      }
      toString() {
        return `ColorMatrix( ${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e},
      ${this.f}, ${this.g}, ${this.h}, ${this.i}, ${this.j},
      ${this.k}, ${this.l}, ${this.m}, ${this.n}, ${this.o},
      ${this.p}, ${this.q}, ${this.r}, ${this.s}, ${this.t} )`;
      }
      toArray() {
        return "abcdefghijklmnopqrst".split("").map((v) => this[v]);
      }
      static get IDENTITY() {
        return new ColorMatrix();
      }
      static createBrightnessMatrix(brightness) {
        const matrix2 = new ColorMatrix();
        matrix2.e = brightness;
        matrix2.j = brightness;
        matrix2.o = brightness;
        return matrix2;
      }
      static createContrastMatrix(contrast) {
        const matrix2 = new ColorMatrix();
        const t = (1 - contrast) / 2;
        matrix2.a = matrix2.g = matrix2.m = contrast;
        matrix2.e = matrix2.j = matrix2.o = t;
        return matrix2;
      }
      static createSaturationMatrix(saturation = 1) {
        const matrix2 = new ColorMatrix();
        const invSat = 1 - saturation;
        const r = 0.213 * invSat;
        const g = 0.715 * invSat;
        const b = 0.072 * invSat;
        matrix2.a = r + saturation;
        matrix2.b = g;
        matrix2.c = b;
        matrix2.f = r;
        matrix2.g = g + saturation;
        matrix2.h = b;
        matrix2.k = r;
        matrix2.l = g;
        matrix2.m = b + saturation;
        return matrix2;
      }
      static createExposureMatrix(exposure = 0) {
        const scale = Math.pow(2, exposure);
        return new ColorMatrix(scale, 0, 0, 0, 0, 0, scale, 0, 0, 0, 0, 0, scale, 0, 0, 0, 0, 0, 1, 0);
      }
      static createLinearMatrix(slope = 1, intercept = 0) {
        const matrix2 = new ColorMatrix();
        matrix2.a = matrix2.g = matrix2.m = slope;
        matrix2.e = matrix2.j = matrix2.o = intercept;
        return matrix2;
      }
    };
    color_matrix_default = ColorMatrix;
  }
});

// engine/sdk/core/lib/configurable.ts
var Configurable, configurable_default;
var init_configurable = __esm({
  "engine/sdk/core/lib/configurable.ts"() {
    init_constants();
    init_render();
    init_color();
    init_event_emitter();
    init_color_matrix();
    init_vector2();
    init_utils();
    Configurable = class extends event_emitter_default {
      constructor(options = {}, additionalAvailableOptions = {}) {
        super();
        this.availableOptions = __spreadValues(__spreadValues({}, Object.getPrototypeOf(this).availableOptions), additionalAvailableOptions);
        this._onConfigurableUpdate = this._onConfigurableUpdate.bind(this);
        this._initOptions(options);
      }
      _buildConfigError(message) {
        let errorMessage = "";
        if (this.constructor.name) {
          errorMessage = `${this.constructor.name}: `;
        }
        errorMessage += message;
        return new Error(errorMessage);
      }
      _onOptionsChange() {
      }
      validateSettings() {
        return new Promise((resolve, reject) => {
          for (const optionName in this.availableOptions) {
            const optionConfig = this.availableOptions[optionName];
            if (optionConfig.required && typeof this._options[optionName] === "undefined") {
              return reject(this._buildConfigError(`Option \`${optionName}\` is required.`));
            }
          }
          resolve();
        });
      }
      _initOptions(userOptions = {}) {
        this._options = {};
        let optionName;
        let option;
        let capitalized;
        const self = this;
        for (optionName in this.availableOptions) {
          capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
          option = this.availableOptions[optionName];
          if ([
            "string" /* STRING */,
            "number" /* NUMBER */,
            "boolean" /* BOOLEAN */,
            "object" /* OBJECT */,
            "vector2" /* VECTOR2 */,
            "color" /* COLOR */,
            "configurable" /* CONFIGURABLE */,
            "color-matrix" /* COLOR_MATRIX */,
            "array" /* ARRAY */,
            "image" /* IMAGE */,
            "function" /* FUNCTION */,
            "*" /* ALL */
          ].indexOf(option.type) === -1) {
            throw this._buildConfigError(`Unknown option type: \`${option.type}\``);
          }
          const fn = function Ca(optionName2) {
            self[`set${capitalized}`] = function(value, update, initial) {
              self.setOption(optionName2, value, update, initial);
            };
            self[`get${capitalized}`] = function() {
              return self.getOption(optionName2);
            };
          };
          fn(optionName);
          if (option.type === "configurable" /* CONFIGURABLE */) {
            this._options[optionName] = new Configurable(void 0, option.structure || {});
            this._options[optionName].on("update", this._onConfigurableUpdate);
          }
          if (!(optionName in userOptions) || typeof userOptions[optionName] === "undefined") {
            if (typeof option.default !== "undefined") {
              let defaultValue = option.default;
              if (typeof option.default === "function") {
                defaultValue = option.default();
              }
              this[`set${capitalized}`](defaultValue, false, true);
            } else if (option.type !== "configurable" /* CONFIGURABLE */) {
              this._options[optionName] = void 0;
            }
          }
        }
        for (optionName in userOptions) {
          if (typeof this.availableOptions[optionName] === "undefined") {
            throw new Error(`Invalid option: ${optionName}`);
          }
          if (typeof userOptions[optionName] !== "undefined") {
            capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
            this[`set${capitalized}`](userOptions[optionName], false, true);
          }
        }
      }
      set(options, emitUpdate = true) {
        Object.keys(options).forEach((key) => {
          this.setOption(key, options[key], false);
        });
        this._onOptionsChange();
        if (emitUpdate) {
          this.emit("update", this, options);
        }
      }
      getOption(optionName) {
        return this._options[optionName];
      }
      hasOption(optionName) {
        return !!this.availableOptions[optionName];
      }
      getOptionDefault(optionName) {
        const option = this.availableOptions[optionName];
        if (!option) {
          throw new Error(`Invalid option: ${optionName}`);
        }
        return option.default;
      }
      resetOptions() {
        this.set(this.getDefaultOptions());
      }
      getDefaultOptions() {
        const options = {};
        for (const optionName in this.availableOptions) {
          const defaultValue = this.availableOptions[optionName].default;
          if (typeof defaultValue === "undefined")
            continue;
          options[optionName] = defaultValue;
        }
        return options;
      }
      getOptions() {
        return __spreadValues({}, this._options);
      }
      equals(other) {
        const otherOptions = other.getOptions();
        return this.optionsEqual(otherOptions);
      }
      optionsEqual(options) {
        for (const optionName in options) {
          const value = options[optionName];
          if (!this._optionEquals(optionName, value)) {
            return false;
          }
        }
        return true;
      }
      _optionEquals(optionName, value) {
        const option = this.availableOptions[optionName];
        if (typeof option === "undefined") {
          throw new Error(`Invalid option: ${optionName}`);
        }
        const optionType = this.availableOptions[optionName].type;
        const currentValue = this._options[optionName];
        if (currentValue === value)
          return true;
        if (typeof value === "undefined" || typeof currentValue === "undefined")
          return false;
        switch (optionType) {
          case "object" /* OBJECT */:
            if (typeof currentValue.optionsEqual === "function") {
              return currentValue.optionsEqual(value._options);
            }
            return currentValue === value;
          case "string" /* STRING */:
          case "number" /* NUMBER */:
          case "boolean" /* BOOLEAN */:
          case "function" /* FUNCTION */:
          case "*":
            return currentValue === value;
          case "vector2" /* VECTOR2 */:
            return currentValue.equals(value);
          case "color" /* COLOR */:
          case "color-matrix" /* COLOR_MATRIX */:
            return value.equals(currentValue);
          case "configurable" /* CONFIGURABLE */:
            return currentValue.optionsEqual(value);
          case "array" /* ARRAY */:
            return this._arrayOptionEquals(optionName, value);
          case "image" /* IMAGE */:
            return currentValue.src === value.src;
        }
      }
      _arrayOptionEquals(optionName, arr) {
        const thisArr = this._options[optionName];
        if (arr.length !== thisArr.length) {
          return false;
        }
        let equal = true;
        for (let i = 0; i < thisArr.length; i++) {
          const thisValue = thisArr[i];
          const value = arr[i];
          if (thisValue instanceof Configurable) {
            if (typeof value === "undefined" || !thisValue.optionsEqual(value)) {
              equal = false;
              break;
            }
          } else if (value !== thisValue) {
            equal = false;
            break;
          }
        }
        return equal;
      }
      serializeOptions(keys = Object.keys(this._options), toObject = false) {
        const options = {};
        keys.forEach((key) => {
          if (typeof this.availableOptions[key] === "undefined") {
            return Log.warn(`Trying to serialize a key that does not exist: ${key}`);
          }
          if (this.availableOptions[key].serializable === false)
            return;
          options[key] = this.serializeOption(key, toObject);
        });
        return options;
      }
      serializeOption(optionName, toObject = false) {
        const option = this.availableOptions[optionName];
        const optionType = option.type;
        const value = this._options[optionName];
        if (!value)
          return value;
        if (option.serializable === false) {
          throw new Error(`Option \`${optionName}\` is not serializable.`);
        }
        switch (optionType) {
          case "string" /* STRING */:
          case "number" /* NUMBER */:
          case "boolean" /* BOOLEAN */:
          case "object" /* OBJECT */:
          case "function" /* FUNCTION */:
          case "*" /* ALL */:
            return value;
          case "vector2" /* VECTOR2 */:
            return toObject ? value.toObject() : value.clone();
          case "color" /* COLOR */:
          case "color-matrix" /* COLOR_MATRIX */:
            return toObject ? value.toArray() : value.clone();
          case "configurable" /* CONFIGURABLE */:
            return value.serializeOptions(void 0, toObject);
          case "array" /* ARRAY */:
            return value.slice(0);
          case "image" /* IMAGE */:
            return toObject ? value.src : value;
        }
      }
      setOption(optionName, value, update = true, initial = false) {
        const optionConfig = this.availableOptions[optionName];
        if (!optionConfig) {
          throw new Error(`Invalid option: ${optionName}`);
        }
        if (typeof optionConfig.setter !== "undefined") {
          value = optionConfig.setter.call(this, value, initial);
        }
        if (typeof optionConfig.validation !== "undefined") {
          optionConfig.validation(value);
        }
        if (value === null || typeof value === "undefined") {
          if (optionConfig.required) {
            throw this._buildConfigError(`Option \`${optionName}\` is required.`);
          }
          this._options[optionName] = value;
        } else {
          switch (optionConfig.type) {
            case "string" /* STRING */: {
              if (typeof value !== "string" /* STRING */) {
                throw this._buildConfigError(`Option \`${optionName}\` has to be a string.`);
              }
              const { available } = optionConfig;
              if (typeof available !== "undefined" && available.indexOf(value) === -1) {
                throw this._buildConfigError(`Invalid value for \`${optionName}\` (valid values are: ${optionConfig.available.join(", ")})`);
              }
              this._options[optionName] = value;
              break;
            }
            case "number" /* NUMBER */:
              if (typeof value !== "number" /* NUMBER */) {
                throw this._buildConfigError(`Option \`${optionName}\` has to be a number.`);
              }
              this._options[optionName] = value;
              break;
            case "boolean" /* BOOLEAN */:
              if (typeof value !== "boolean" /* BOOLEAN */) {
                throw this._buildConfigError(`Option \`${optionName}\` has to be a boolean.`);
              }
              this._options[optionName] = value;
              break;
            case "vector2" /* VECTOR2 */:
              if (!(value instanceof Vector2) && !(typeof value === "object" && "x" in value && "y" in value)) {
                throw this._buildConfigError(`Option \`${optionName}\` has to be an instance of Vector2 or an Object holding x and y values.`);
              }
              if (value instanceof Vector2) {
                this._options[optionName] = value.clone();
              } else {
                this._options[optionName] = Vector2.fromObject(value);
              }
              break;
            case "color" /* COLOR */:
              if (!(value instanceof color_default)) {
                throw this._buildConfigError(`Option \`${optionName}\` has to be an instance of Color.`);
              }
              this._options[optionName] = value;
              break;
            case "color-matrix" /* COLOR_MATRIX */:
              if (!(value instanceof color_matrix_default)) {
                throw this._buildConfigError(`Option \`${optionName}\` has to be an instance of ColorMatrix.`);
              }
              this._options[optionName] = value.clone();
              break;
            case "function" /* FUNCTION */:
              if (typeof value !== "function") {
                throw this._buildConfigError(`Option \`${optionName}\` has to be a function.`);
              }
              this._options[optionName] = value;
              break;
            case "object" /* OBJECT */:
            case "*":
              this._options[optionName] = value;
              break;
            case "image" /* IMAGE */: {
              const { Image: Image3 } = renderUtils;
              if (typeof value === "string") {
                const image = new Image3();
                if (isWebImage(image)) {
                  image.crossOrigin = utils_default.getCrossOriginValue(optionConfig.crossOrigin);
                }
                image.src = value;
                this._options[optionName] = image;
              } else if (value instanceof Image3 || typeof HTMLCanvasElement !== "undefined" && value instanceof HTMLCanvasElement || typeof HTMLImageElement !== "undefined" && value instanceof HTMLImageElement) {
                this._options[optionName] = value;
              } else {
                throw this._buildConfigError(`Option \`${optionName}\` has to be an Image, Canvas or String.`);
              }
              break;
            }
            case "configurable" /* CONFIGURABLE */:
              if (value instanceof Configurable) {
                this._options[optionName] = value;
              } else {
                this._options[optionName].set(value);
              }
              break;
            case "array" /* ARRAY */:
              if (!(value instanceof Array)) {
                throw this._buildConfigError(`Option \`${optionName}\` has to be an Array.`);
              }
              this._options[optionName] = value.slice(0);
              break;
            default:
              throw this._buildConfigError(`Unknown option type: \`${optionConfig.type}\``);
          }
        }
        if (update) {
          this._onOptionsChange();
          this.emit("update", this, { [optionName]: value });
        }
      }
      _onConfigurableUpdate(...args) {
        this.emit("update", ...args);
      }
      hasChanges() {
        const defaultOptions = this.getDefaultOptions();
        return !this.optionsEqual(defaultOptions);
      }
    };
    configurable_default = Configurable;
  }
});

// engine/sdk/core/engine/shaders/shader.ts
var Shader;
var init_shader = __esm({
  "engine/sdk/core/engine/shaders/shader.ts"() {
    init_constants();
    init_globals();
    init_globals();
    Shader = class {
      constructor(renderer, vertexSource, fragmentSource, uniforms = {}, attributes = []) {
        this._program = null;
        this._renderer = renderer;
        this._vertexSource = vertexSource;
        this._fragmentSource = fragmentSource;
        this._uniforms = uniforms;
        this._uniformLocations = {};
        this._attributes = attributes;
        this._attributeLocations = {};
        this._onContextChange = this._onContextChange.bind(this);
        this._renderer.on("context", this._onContextChange);
        this._init();
      }
      _init() {
        this._compile();
        const gl = this._renderer.getContext();
        gl.useProgram(this._program);
        this._cacheUniformLocations();
        this._cacheAttributeLocations();
      }
      _onContextChange() {
        this._init();
      }
      setupBuffers(vertexBuffer, indexBuffer) {
        const gl = this._renderer.getContext();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.vertexAttribPointer(this._attributeLocations.a_position, 2, gl.FLOAT, false, VERTEX_BYTE_SIZE, 0);
        gl.vertexAttribPointer(this._attributeLocations.a_texCoord, 2, gl.FLOAT, false, VERTEX_BYTE_SIZE, 2 * 4);
        gl.vertexAttribPointer(this._attributeLocations.a_color, 4, gl.UNSIGNED_BYTE, true, VERTEX_BYTE_SIZE, 4 * 4);
      }
      syncUniforms() {
        Object.keys(this._uniforms).forEach((key) => {
          this.syncUniform(key);
        });
      }
      syncUniform(name) {
        const gl = this._renderer.getContext();
        const uniform = this._uniforms[name];
        const location = this._uniformLocations[name];
        switch (uniform.type) {
          case "sampler2d" /* SAMPLER2D */:
            gl.uniform1i(location, uniform.value);
            break;
          case "i" /* INT */:
          case "1i" /* INT1 */:
            gl.uniform1i(location, uniform.value);
            break;
          case "2i" /* INT2 */:
            gl.uniform2i(location, uniform.value[0], uniform.value[1]);
            break;
          case "3i" /* INT3 */:
            gl.uniform3i(location, uniform.value[0], uniform.value[1], uniform.value[2]);
            break;
          case "4i" /* INT4 */:
            gl.uniform4i(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
            break;
          case "f" /* FLOAT */:
          case "1f" /* FLOAT1 */:
            gl.uniform1f(location, uniform.value);
            break;
          case "2f" /* FLOAT2 */:
            gl.uniform2f(location, uniform.value[0], uniform.value[1]);
            break;
          case "3f" /* FLOAT3 */:
            gl.uniform3f(location, uniform.value[0], uniform.value[1], uniform.value[2]);
            break;
          case "4f" /* FLOAT4 */:
            gl.uniform4f(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
            break;
          case "2fv" /* FLOAT_VECTOR2 */:
            gl.uniform2fv(location, uniform.value);
            break;
          case "mat3" /* MAT3 */:
          case "mat3fv" /* MAT3FV */:
            gl.uniformMatrix3fv(location, false, uniform.value);
            break;
          case "mat4" /* MAT4 */:
            gl.uniformMatrix4fv(location, false, uniform.value);
            break;
          default:
            log_default.warn(this.constructor.name, `Unknown uniform type: ${uniform.type}`);
        }
      }
      _cacheAttributeLocations() {
        const gl = this._renderer.getContext();
        this._attributes.forEach((name) => {
          if (this._program) {
            this._attributeLocations[name] = gl.getAttribLocation(this._program, name);
          }
        });
      }
      _cacheUniformLocations() {
        const gl = this._renderer.getContext();
        const keys = Object.keys(this._uniforms);
        keys.forEach((key) => {
          if (this._program) {
            const location = gl.getUniformLocation(this._program, key);
            if (location) {
              this._uniformLocations[key] = location;
            }
          }
        });
      }
      _addPrecisionToSource(source) {
        const maxFloatPrecision = this._renderer.getMaxFloatPrecision();
        let precision = "mediump" /* Medium */;
        if (utils_default.isMobile() && maxFloatPrecision === "highp" /* High */) {
          precision = "highp" /* High */;
        }
        return `precision ${precision} float;
${source}`;
      }
      _compile() {
        const gl = this._renderer.getContext();
        const vertexShader = this._compileShader(gl.VERTEX_SHADER, this._vertexSource);
        this._vertexShader = vertexShader;
        const fragmentSource = this._addPrecisionToSource(this._fragmentSource);
        const fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);
        this._fragmentShader = fragmentShader;
        const program = gl.createProgram();
        if (!program) {
          return;
        }
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
          let errorMessage = gl.getProgramInfoLog(program);
          if (gl.isContextLost())
            errorMessage = "WebGL context lost";
          gl.deleteProgram(program);
          log_default.error(this.constructor.name, `WebGL program linking error: ${errorMessage}`);
        } else {
          this._program = program;
        }
      }
      _compileShader(shaderType, shaderSource) {
        const gl = this._renderer.getContext();
        const shader = gl.createShader(shaderType);
        if (!shader) {
          throw new Error(`Cannot create shared: ${JSON.stringify(shaderType)}`);
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!compiled) {
          let errorMessage = gl.getShaderInfoLog(shader);
          if (gl.isContextLost())
            errorMessage = "WebGL context lost";
          gl.deleteShader(shader);
          log_default.error(this.constructor.name, `WebGL shader compilation error: ${errorMessage}`);
        }
        return shader;
      }
      setUniform(name, value, sync = false) {
        this._uniforms[name].value = value;
        if (sync) {
          this.syncUniform(name);
        }
      }
      setUniforms(uniforms, sync = false) {
        Object.keys(uniforms).forEach((key) => {
          this._uniforms[key].value = uniforms[key];
          if (sync) {
            this.syncUniform(key);
          }
        });
      }
      getUniforms() {
        return this._uniforms;
      }
      getAttributes() {
        return this._attributes;
      }
      getAttributeLocations() {
        return this._attributeLocations;
      }
      getProgram() {
        return this._program;
      }
      dispose() {
        const gl = this._renderer.getContext();
        gl.deleteProgram(this._program);
        gl.deleteShader(this._vertexShader);
        gl.deleteShader(this._fragmentShader);
        this._renderer.off("context", this._onContextChange);
      }
    };
  }
});

// engine/sdk/core/engine/shaders/source/texture.frag
var texture_default;
var init_texture = __esm({
  "engine/sdk/core/engine/shaders/source/texture.frag"() {
    texture_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = texture2D(u_image, v_texCoord) * v_color;\n}\n";
  }
});

// engine/sdk/core/engine/shaders/source/texture.vert
var texture_default2;
var init_texture2 = __esm({
  "engine/sdk/core/engine/shaders/source/texture.vert"() {
    texture_default2 = "attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\nuniform mat3 u_projMatrix;\n\nvoid main() {\n  gl_Position = vec4((u_projMatrix * vec3(a_position, 1)).xy, 0, 1);\n  v_texCoord = a_texCoord;\n  v_color = vec4(a_color.rgb * a_color.a, a_color.a);\n}\n";
  }
});

// engine/sdk/core/engine/shaders/texture-shader.ts
var matrix, textureShaderDefaults, TextureShader;
var init_texture_shader = __esm({
  "engine/sdk/core/engine/shaders/texture-shader.ts"() {
    init_constants();
    init_globals();
    init_shader();
    init_texture();
    init_texture2();
    matrix = new Matrix();
    textureShaderDefaults = {
      vertexSource: texture_default2,
      fragmentSource: texture_default,
      uniforms: {
        u_image: {
          type: "sampler2d" /* SAMPLER2D */,
          value: 0
        },
        u_projMatrix: {
          type: "mat3" /* MAT3 */,
          value: matrix.toArray()
        }
      },
      attributes: ["a_position", "a_texCoord", "a_color"]
    };
    TextureShader = class extends Shader {
      constructor(renderer, vertexSource = textureShaderDefaults.vertexSource, fragmentSource = textureShaderDefaults.fragmentSource) {
        super(renderer, vertexSource, fragmentSource, textureShaderDefaults.uniforms, textureShaderDefaults.attributes);
      }
    };
  }
});

// engine/sdk/core/engine/shaders/index.ts
var init_shaders = __esm({
  "engine/sdk/core/engine/shaders/index.ts"() {
    init_shader();
    init_texture_shader();
  }
});

// engine/sdk/core/engine/filters/filter.ts
var Filter;
var init_filter = __esm({
  "engine/sdk/core/engine/filters/filter.ts"() {
    init_cleanUpCanvasMemory();
    init_stack_blur();
    init_constants();
    init_configurable();
    init_globals();
    init_shaders();
    init_render();
    Filter = class extends configurable_default {
      constructor(options = {}, additionalAvailableOptions = {}) {
        super(options, additionalAvailableOptions);
        this._initOptions(options);
      }
      _initOptions(userOptions = {}) {
        this._shaders = [];
        this._availableUniforms = textureShaderDefaults.uniforms;
        this._attributes = textureShaderDefaults.attributes;
        this._vertexSource = textureShaderDefaults.vertexSource;
        this._fragmentSource = textureShaderDefaults.fragmentSource;
        this._initUniforms();
        super._initOptions(userOptions);
      }
      _initUniforms() {
        this._uniforms = {};
        for (const name in this._availableUniforms) {
          const uniform = this._availableUniforms[name];
          this._uniforms[name] = {
            type: uniform.type,
            value: uniform.default || null
          };
        }
        for (const optionName in this.availableOptions) {
          const optionConfig = this.availableOptions[optionName];
          if (!optionConfig.uniformType) {
            log_default.trace(this.constructor.name, `Option \`${optionName}\` is missing a \`uniformType\`!`);
          } else {
            this._uniforms[`u_${optionName}`] = {
              type: optionConfig.uniformType,
              value: optionConfig.default || null
            };
          }
        }
      }
      setOption(optionName, value, update = true) {
        super.setOption(optionName, value, update);
        let uniformValue = value;
        const optionConfig = this.availableOptions[optionName];
        if (!optionConfig.uniformType) {
          return;
        }
        const uniformName = `u_${optionName}`;
        switch (optionConfig.type) {
          case "color" /* COLOR */:
            if (optionConfig.uniformType === "4f" /* FLOAT4 */) {
              uniformValue = value.toGLColor();
            } else if (optionConfig.uniformType === "3f" /* FLOAT3 */) {
              uniformValue = value.toRGBGLColor();
            }
            break;
          case "vector2" /* VECTOR2 */:
            uniformValue = [value.x, value.y];
            break;
          case "color-matrix" /* COLOR_MATRIX */: {
            uniformValue = [
              value.a,
              value.b,
              value.c,
              value.d,
              value.f,
              value.g,
              value.h,
              value.i,
              value.k,
              value.l,
              value.m,
              value.n,
              value.p,
              value.q,
              value.r,
              value.s
            ];
            const vectorValue = [value.e, value.j, value.o, value.t];
            this._uniforms[`${uniformName}_vec`] = {
              value: vectorValue,
              type: "4f" /* FLOAT4 */
            };
          }
        }
        this.setUniform(uniformName, uniformValue);
      }
      setUniform(name, value, sync = false) {
        this._uniforms[name].value = value;
      }
      setUniforms(uniforms, sync = false) {
        Object.entries(uniforms).forEach(([key, value]) => {
          this._uniforms[key].value = value;
          if (sync) {
            this.syncUniform(key);
          }
        });
      }
      syncUniform(name) {
        this._shaders.forEach((shader) => {
          shader.syncUniform(name);
        });
      }
      syncUniforms() {
        this._shaders.forEach((shader) => {
          shader.syncUniforms();
        });
      }
      getShaderForRenderer(renderer) {
        const { id } = renderer;
        if (!this._shaders)
          this._shaders = [];
        let shader = this._shaders[id];
        if (!shader) {
          shader = new Shader(renderer, this._vertexSource, this._fragmentSource, this._uniforms, this._attributes);
          this._shaders[id] = shader;
        }
        return shader;
      }
      apply(renderer, inputTarget, outputTarget, clear = false) {
        if (isWebGLRenderer(renderer)) {
          this._applyWebGL(renderer, inputTarget, outputTarget, clear);
        } else {
          this._applyCanvas(renderer, inputTarget, outputTarget, clear);
        }
      }
      _applyWebGL(renderer, inputTarget, outputTarget, clear = false) {
        const gl = renderer.getContext();
        const shader = this.getShaderForRenderer(renderer);
        renderer.setRenderTarget(outputTarget);
        if (clear) {
          outputTarget.clear();
        }
        renderer.setShader(shader);
        const projectionMatrix = renderer.getCurrentRenderTarget().getProjectionMatrix().toArray();
        shader.setUniform("u_projMatrix", projectionMatrix);
        shader.syncUniforms();
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, inputTarget.getTexture());
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const outputContext = outputTarget.getContext();
        log_default.warn(this.constructor.name, "`_applyCanvas` is not implemented. Just copying image data from `inputTarget` to `outputTarget`.");
        outputContext.clearRect(0, 0, canvas.width, canvas.height);
        outputContext.drawImage(canvas, 0, 0);
      }
      dispose() {
        this._shaders.forEach((shader) => shader.dispose());
        this._shaders = [];
      }
      _blurImage(inputTarget, outputTarget, blurIntensity) {
        const blurWidth = 10;
        const inputCanvas = inputTarget.getCanvas();
        const downScale = Math.min(1, blurWidth / (blurIntensity * Math.min(inputCanvas.width, inputCanvas.height)));
        const scaleCanvas = utils_default.createCanvas();
        scaleCanvas.width = Math.round(inputCanvas.width * downScale);
        scaleCanvas.height = Math.round(inputCanvas.height * downScale);
        const scaleContext = scaleCanvas.getContext("2d");
        scaleContext.drawImage(inputCanvas, 0, 0, inputCanvas.width, inputCanvas.height, 0, 0, scaleCanvas.width, scaleCanvas.height);
        const radius = blurIntensity * Math.min(scaleCanvas.width, scaleCanvas.height);
        const blurryImageData = scaleContext.getImageData(0, 0, scaleCanvas.width, scaleCanvas.height);
        stackBlurCanvasRGBA(blurryImageData, 0, 0, scaleCanvas.width, scaleCanvas.height, radius);
        scaleContext.putImageData(blurryImageData, 0, 0);
        outputTarget.getContext().drawImage(scaleCanvas, 0, 0, scaleCanvas.width, scaleCanvas.height, 0, 0, inputCanvas.width, inputCanvas.height);
        cleanUpCanvasMemory(scaleCanvas);
      }
    };
  }
});

// engine/sdk/core/engine/filters/source/unpremultiply.frag
var unpremultiply_default;
var init_unpremultiply = __esm({
  "engine/sdk/core/engine/filters/source/unpremultiply.frag"() {
    unpremultiply_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(color.a > 0. ? color.rgb / color.a : vec3(0), color.a);\n}\n";
  }
});

// engine/sdk/core/engine/filters/unpremultiply-filter.js
var UnpremultiplyFilter;
var init_unpremultiply_filter = __esm({
  "engine/sdk/core/engine/filters/unpremultiply-filter.js"() {
    init_filter();
    init_unpremultiply();
    UnpremultiplyFilter = class extends Filter {
      constructor() {
        super();
        this._fragmentSource = unpremultiply_default;
      }
    };
  }
});

// engine/sdk/core/engine/filters/source/color-overlay.frag
var color_overlay_default;
var init_color_overlay = __esm({
  "engine/sdk/core/engine/filters/source/color-overlay.frag"() {
    color_overlay_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform vec4 u_color;\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(mix(color.rgb, u_color.rgb, u_color.a), color.a) * color.a;\n}\n";
  }
});

// engine/sdk/core/engine/filters/color-overlay-filter.js
var OptionType2, UniformType3, ColorOverlayFilter, color_overlay_filter_default;
var init_color_overlay_filter = __esm({
  "engine/sdk/core/engine/filters/color-overlay-filter.js"() {
    init_globals();
    init_filter();
    init_color_overlay();
    ({ OptionType: OptionType2, UniformType: UniformType3 } = constants_exports);
    ColorOverlayFilter = class extends Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = color_overlay_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const { color } = this._options;
        const inputImageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const outputImageData = outputContext.getImageData(0, 0, canvas.width, canvas.height);
        const pixelCount = canvas.width * canvas.height;
        const inputColor = new color_default();
        const outputColor = new color_default();
        for (let i = 0; i < pixelCount * 4; i += 4) {
          inputColor.set(inputImageData.data[i] / 255, inputImageData.data[i + 1] / 255, inputImageData.data[i + 2] / 255, inputImageData.data[i + 3] / 255);
          outputColor.set(outputImageData.data[i] / 255, outputImageData.data[i + 1] / 255, outputImageData.data[i + 2] / 255, outputImageData.data[i + 3] / 255);
          const newR = outputColor.r + inputColor.a * (inputColor.r - outputColor.r);
          outputImageData.data[i] = (newR + inputColor.a * (color.r - newR)) * 255;
          const newG = outputColor.g + inputColor.a * (inputColor.g - outputColor.g);
          outputImageData.data[i + 1] = (newG + inputColor.a * (color.g - newG)) * 255;
          const newB = outputColor.b + inputColor.a * (inputColor.b - outputColor.b);
          outputImageData.data[i + 2] = (newB + inputColor.a * (color.b - newB)) * 255;
        }
        outputContext.putImageData(outputImageData, 0, 0);
      }
    };
    ColorOverlayFilter.prototype.availableOptions = {
      color: {
        type: OptionType2.COLOR,
        default: color_default.WHITE,
        uniformType: UniformType3.FLOAT4
      }
    };
    color_overlay_filter_default = ColorOverlayFilter;
  }
});

// engine/sdk/core/engine/filters/source/tint.frag
var tint_default;
var init_tint = __esm({
  "engine/sdk/core/engine/filters/source/tint.frag"() {
    tint_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform vec4 u_color;\nuniform int u_mode;\nvec3 W = vec3(0.2125, 0.7154, 0.0721);\nconst float EPSILON = 0.0000001;\nvoid main() {\n    vec4 color = texture2D(u_image, v_texCoord); // Is premultiplied.\n    color.rgb /= max(color.a, EPSILON); // Revert premultiplied alpha.\n    vec4 newColor;\n    if (u_mode == 0) {\n        newColor = vec4(color.rgb, 1.0); // We use alpha 1.0 becaue color is not premultiplied.\n        newColor *= color.a; // Premultiply the result\n    } else if (u_mode == 1) {\n        newColor = vec4(u_color.rgb, 1.0); // Use alpha 1.0 because it is not premultiplied.\n        newColor *= color.a * u_color.a; // Changed alpha and premultiplied the result.\n    } else if (u_mode == 2) {\n        float luminance = dot(color.rgb, W); // Convert to color to gray value.\n        newColor = vec4(vec3(luminance) * u_color.rgb, 1.0); // Colorize and with alpha 1.0 because it is not premultiplied.\n        newColor *= color.a * u_color.a; // Changed alpha and premultiplied the result.\n    }\n    gl_FragColor = newColor;\n}";
  }
});

// engine/sdk/core/engine/filters/tint-filter.js
var OptionType3, UniformType4, TintFilter, tint_filter_default;
var init_tint_filter = __esm({
  "engine/sdk/core/engine/filters/tint-filter.js"() {
    init_globals();
    init_filter();
    init_tint();
    ({ OptionType: OptionType3, UniformType: UniformType4 } = constants_exports);
    TintFilter = class extends Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = tint_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const { mode, color } = this._options;
        const { r, g, b, a } = color;
        const W = [0.2125, 0.7154, 0.0721];
        switch (mode) {
          case TintFilter.MODES.SOLID:
            for (let i = 0; i < canvas.width * canvas.height; i++) {
              const index = i * 4;
              imageData.data[index] += (r * 255 - imageData.data[index]) * a;
              imageData.data[index + 1] += (g * 255 - imageData.data[index + 1]) * a;
              imageData.data[index + 2] += (b * 255 - imageData.data[index + 2]) * a;
            }
            break;
          case TintFilter.MODES.COLORIZED:
            for (let i = 0; i < canvas.width * canvas.height; i++) {
              const index = i * 4;
              const luminance = imageData.data[index] / 255 * W[0] + imageData.data[index + 1] / 255 * W[1] + imageData.data[index + 2] / 255 * W[2];
              const colorized = new color_default(luminance * r, luminance * g, luminance * b);
              imageData.data[index] += (colorized.r * 255 - imageData.data[index]) * a;
              imageData.data[index + 1] += (colorized.g * 255 - imageData.data[index + 1]) * a;
              imageData.data[index + 2] += (colorized.b * 255 - imageData.data[index + 2]) * a;
            }
            break;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    TintFilter.MODES = {
      NONE: 0,
      SOLID: 1,
      COLORIZED: 2
    };
    TintFilter.prototype.availableOptions = {
      color: {
        type: OptionType3.COLOR,
        default: color_default.WHITE,
        uniformType: UniformType4.FLOAT4
      },
      mode: {
        type: OptionType3.NUMBER,
        default: TintFilter.MODES.NONE,
        uniformType: UniformType4.INT
      }
    };
    tint_filter_default = TintFilter;
  }
});

// engine/sdk/core/engine/filters/source/overlay.frag
var overlay_default;
var init_overlay = __esm({
  "engine/sdk/core/engine/filters/source/overlay.frag"() {
    overlay_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform sampler2D u_overlayImage;\nuniform int u_blendMode;\nuniform float u_alpha;\n\nconst float EPSILON = 0.000001;\n\nvec4 overlay(vec4 a, vec4 b) {\n    vec3 result = mix(\n          1.0 - 2.0 * (1.0 - a.rgb) * (1.0 - b.rgb),\n          2.0 * a.rgb * b.rgb,\n          vec3(a.r < 0.5, a.g < 0.5, a.b < 0.5)\n      );\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 hardLight(vec4 b, vec4 a) {\n    vec3 result = mix(\n          1.0 - 2.0 * (1.0 - a.rgb) * (1.0 - b.rgb),\n          2.0 * a.rgb * b.rgb,\n          vec3(a.r < 0.5, a.g < 0.5, a.b < 0.5)\n      );\n    return mix(b, vec4(result, b.a), u_alpha * a.a);\n}\n\nvec4 softLight(vec4 a, vec4 b) {\n    vec3 result = mix(\n          2.0 * a.rgb * (1.0 - b.rgb) + (2.0 * b.rgb - 1.0) * sqrt(a.rgb),\n          2.0 * a.rgb * b.rgb + a.rgb * a.rgb * (1.0 - 2.0 * b.rgb),\n          vec3(b.r < 0.5, b.g < 0.5, b.b < 0.5)\n      );\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 multiply(vec4 a, vec4 b) {\n    vec3 result = a.rgb * b.rgb;\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 darken(vec4 a, vec4 b) {\n    vec3 result = min(a.rgb, b.rgb);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 lighten(vec4 a, vec4 b) {\n    vec3 result = max(a.rgb, b.rgb);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 screen(vec4 a, vec4 b) {\n    vec3 result = 1.0 - (1.0 - a.rgb) * (1.0 - b.rgb);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 colorBurn(vec4 a, vec4 b) {\n    vec3 result = clamp(1.0 - (1.0 - a.rgb) / max(b.rgb, EPSILON), 0.0, 1.0);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 normal(vec4 a, vec4 b) {\n    return mix(a, vec4(b.rgb, a.a), u_alpha * b.a);\n}\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  vec4 overlayColor = texture2D(u_overlayImage, v_texCoord);\n\n  vec4 resultColor;\n  if (u_blendMode == 0) {\n    resultColor = normal(color, overlayColor);\n  } else if (u_blendMode == 1) {\n    resultColor = overlay(color, overlayColor);\n  } else if (u_blendMode == 2) {\n    resultColor = hardLight(color, overlayColor);\n  } else if (u_blendMode == 3) {\n    resultColor = softLight(color, overlayColor);\n  } else if (u_blendMode == 4) {\n    resultColor = multiply(color, overlayColor);\n  } else if (u_blendMode == 5) {\n    resultColor = darken(color, overlayColor);\n  } else if (u_blendMode == 6) {\n    resultColor = lighten(color, overlayColor);\n  } else if (u_blendMode == 7) {\n    resultColor = screen(color, overlayColor);\n  } else if (u_blendMode == 8) {\n    resultColor = colorBurn(color, overlayColor);\n  }\n  gl_FragColor = vec4(resultColor.rgb * resultColor.a, resultColor.a);\n}\n";
  }
});

// engine/sdk/core/engine/filters/overlay-filter.js
var OptionType4, UniformType5, EPSILON, OverlayFilter, overlay_filter_default;
var init_overlay_filter = __esm({
  "engine/sdk/core/engine/filters/overlay-filter.js"() {
    init_globals();
    init_filter();
    init_overlay();
    ({ OptionType: OptionType4, UniformType: UniformType5 } = constants_exports);
    EPSILON = 1e-6;
    OverlayFilter = class extends Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = overlay_default;
        this._lastImage = null;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const overlayContext = this._options.overlayTexture.getRenderTarget().getContext();
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const overlayImageData = overlayContext.getImageData(0, 0, canvas.width, canvas.height);
        const { blendMode, alpha } = this._options;
        const inputColor = new color_default();
        const overlayColor = new color_default();
        const outputColor = new color_default();
        for (let i = 0; i < canvas.width * canvas.height * 4; i += 4) {
          inputColor.set(imageData.data[i] / 255, imageData.data[i + 1] / 255, imageData.data[i + 2] / 255, imageData.data[i + 3] / 255);
          overlayColor.set(overlayImageData.data[i] / 255, overlayImageData.data[i + 1] / 255, overlayImageData.data[i + 2] / 255, overlayImageData.data[i + 3] / 255);
          let rA;
          let rB;
          let newR;
          let gA;
          let gB;
          let newG;
          let bA;
          let bB;
          let newB;
          switch (blendMode) {
            case OverlayFilter.BLEND_MODES.NORMAL:
              outputColor.set(inputColor.r + overlayColor.a * alpha * (overlayColor.r - inputColor.r), inputColor.g + overlayColor.a * alpha * (overlayColor.g - inputColor.g), inputColor.b + overlayColor.a * alpha * (overlayColor.b - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.OVERLAY:
              rA = 1 - 2 * (1 - inputColor.r) * (1 - overlayColor.r);
              rB = 2 * inputColor.r * overlayColor.r;
              newR = rA + (inputColor.r < 0.5 ? 1 : 0) * (rB - rA);
              gA = 1 - 2 * (1 - inputColor.g) * (1 - overlayColor.g);
              gB = 2 * inputColor.g * overlayColor.g;
              newG = gA + (inputColor.g < 0.5 ? 1 : 0) * (gB - gA);
              bA = 1 - 2 * (1 - inputColor.b) * (1 - overlayColor.b);
              bB = 2 * inputColor.b * overlayColor.b;
              newB = bA + (inputColor.b < 0.5 ? 1 : 0) * (bB - bA);
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.HARD_LIGHT:
              rA = 1 - 2 * (1 - overlayColor.r) * (1 - inputColor.r);
              rB = 2 * overlayColor.r * inputColor.r;
              newR = rA + (overlayColor.r < 0.5 ? 1 : 0) * (rB - rA);
              gA = 1 - 2 * (1 - overlayColor.g) * (1 - inputColor.g);
              gB = 2 * overlayColor.g * inputColor.g;
              newG = gA + (overlayColor.g < 0.5 ? 1 : 0) * (gB - gA);
              bA = 1 - 2 * (1 - overlayColor.b) * (1 - inputColor.b);
              bB = 2 * overlayColor.b * inputColor.b;
              newB = bA + (overlayColor.b < 0.5 ? 1 : 0) * (bB - bA);
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.SOFT_LIGHT:
              rA = 2 * inputColor.r * (1 - overlayColor.r) + (2 * overlayColor.r - 1) * Math.sqrt(inputColor.r);
              rB = 2 * inputColor.r * overlayColor.r + inputColor.r * inputColor.r * (1 - 2 * overlayColor.r);
              newR = rA + (overlayColor.r < 0.5 ? 1 : 0) * (rB - rA);
              gA = 2 * inputColor.g * (1 - overlayColor.g) + (2 * overlayColor.g - 1) * Math.sqrt(inputColor.g);
              gB = 2 * inputColor.g * overlayColor.g + inputColor.g * inputColor.g * (1 - 2 * overlayColor.g);
              newG = gA + (overlayColor.g < 0.5 ? 1 : 0) * (gB - gA);
              bA = 2 * inputColor.b * (1 - overlayColor.b) + (2 * overlayColor.b - 1) * Math.sqrt(inputColor.b);
              bB = 2 * inputColor.b * overlayColor.b + inputColor.b * inputColor.b * (1 - 2 * overlayColor.b);
              newB = bA + (overlayColor.b < 0.5 ? 1 : 0) * (bB - bA);
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.MULTIPLY:
              newR = inputColor.r * overlayColor.r;
              newG = inputColor.g * overlayColor.g;
              newB = inputColor.b * overlayColor.b;
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.DARKEN:
              newR = Math.min(inputColor.r, overlayColor.r);
              newG = Math.min(inputColor.g, overlayColor.g);
              newB = Math.min(inputColor.b, overlayColor.b);
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.LIGHTEN:
              newR = Math.max(inputColor.r, overlayColor.r);
              newG = Math.max(inputColor.g, overlayColor.g);
              newB = Math.max(inputColor.b, overlayColor.b);
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.SCREEN:
              newR = 1 - (1 - inputColor.r) * (1 - overlayColor.r);
              newG = 1 - (1 - inputColor.g) * (1 - overlayColor.g);
              newB = 1 - (1 - inputColor.b) * (1 - overlayColor.b);
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
            case OverlayFilter.BLEND_MODES.COLOR_BURN:
              newR = Math.max(0, Math.min(1, 1 - (1 - inputColor.r) / Math.max(overlayColor.r, EPSILON)));
              newG = Math.max(0, Math.min(1, 1 - (1 - inputColor.g) / Math.max(overlayColor.g, EPSILON)));
              newB = Math.max(0, Math.min(1, 1 - (1 - inputColor.b) / Math.max(overlayColor.b, EPSILON)));
              outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
              break;
          }
          imageData.data[i] = outputColor.r * 255;
          imageData.data[i + 1] = outputColor.g * 255;
          imageData.data[i + 2] = outputColor.b * 255;
          imageData.data[i + 3] = outputColor.a * 255;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    OverlayFilter.BLEND_MODES = {
      NORMAL: 0,
      OVERLAY: 1,
      HARD_LIGHT: 2,
      SOFT_LIGHT: 3,
      MULTIPLY: 4,
      DARKEN: 5,
      LIGHTEN: 6,
      SCREEN: 7,
      COLOR_BURN: 8
    };
    OverlayFilter.prototype.availableOptions = {
      blendMode: {
        type: OptionType4.NUMBER,
        default: OverlayFilter.BLEND_MODES.NORMAL,
        uniformType: UniformType5.INT
      },
      overlayImage: {
        type: OptionType4.NUMBER,
        required: true,
        uniformType: UniformType5.SAMPLER2D
      },
      overlayTexture: { type: OptionType4.OBJECT, required: true },
      alpha: {
        type: OptionType4.NUMBER,
        default: 1,
        uniformType: UniformType5.FLOAT
      }
    };
    overlay_filter_default = OverlayFilter;
  }
});

// engine/sdk/core/engine/filters/index.js
var filters_exports = {};
__export(filters_exports, {
  ColorOverlayFilter: () => color_overlay_filter_default,
  OverlayFilter: () => overlay_filter_default,
  TintFilter: () => tint_filter_default,
  UnpremultiplyFilter: () => UnpremultiplyFilter
});
var init_filters = __esm({
  "engine/sdk/core/engine/filters/index.js"() {
    init_unpremultiply_filter();
    init_color_overlay_filter();
    init_tint_filter();
    init_overlay_filter();
  }
});

// engine/sdk/core/engine/textures/base-texture.ts
var textureFilterToGL, _BaseTexture, BaseTexture;
var init_base_texture = __esm({
  "engine/sdk/core/engine/textures/base-texture.ts"() {
    init_globals();
    init_render();
    textureFilterToGL = {
      [1 /* Linear */]: "LINEAR",
      [0 /* Nearest */]: "NEAREST",
      [2 /* Bilinear */]: "LINEAR_MIPMAP_NEAREST",
      [3 /* Trilinear */]: "LINEAR_MIPMAP_LINEAR"
    };
    _BaseTexture = class extends event_emitter_default {
      constructor(source) {
        super();
        this._renderers = [];
        this._glTextures = {};
        this._dirty = true;
        this._mipMapping = false;
        this._glUnit = 0;
        this._magFilter = _BaseTexture.DefaultMagFilter;
        this._minFilter = _BaseTexture.DefaultMinFilter;
        this._repeatX = 0 /* ClampToEdge */;
        this._repeatY = 0 /* ClampToEdge */;
        this._pixelRatio = 1;
        this._loaded = false;
        this._frame = new Rectangle(0, 0, 100, 100);
        this._onSourceLoaded = this._onSourceLoaded.bind(this);
        this._source = source;
        this._loadSource();
      }
      resizeTo(dimensions) {
        if (this._frame.width === dimensions.x && this._frame.height === dimensions.y) {
          return;
        }
        this._frame.width = dimensions.x;
        this._frame.height = dimensions.y;
        this._dirty = true;
      }
      _loadSource() {
        const source = this._source;
        if (!source)
          return;
        if (renderUtils.isCanvas(source)) {
          return this._onSourceLoaded();
        }
        if (source.complete) {
          return this._onSourceLoaded();
        }
        source.addEventListener && source.addEventListener("load", this._onSourceLoaded);
      }
      _onSourceLoaded() {
        this._loaded = true;
        this.emit("loaded");
        this.update();
      }
      _updateGLFilters() {
        if (!this._source)
          return;
        const sourceDimensions = new Vector2(this._source.width, this._source.height);
        if (utils_default.isPowerOfTwo(sourceDimensions)) {
          log_default.info(this.constructor.name, "Mip-mapping enabled");
          this._minFilter = _BaseTexture.TrilinearFilter;
          this._mipMapping = true;
        } else {
          this._minFilter = _BaseTexture.LinearFilter;
          this._mipMapping = false;
        }
      }
      update() {
        if (!this._source)
          return;
        if (this._frame.width !== this._source.width || this._frame.height !== this._source.height) {
          this._frame = new Rectangle(0, 0, this._source.width, this._source.height);
          this._dirty = true;
        }
        this._updateGLFilters();
        this.emit("update");
      }
      getRenderers() {
        return [...this._renderers];
      }
      getGLFilter(gl, minOrMag) {
        switch (minOrMag) {
          case "min":
            return gl[textureFilterToGL[this._minFilter]];
          case "mag":
            return gl[textureFilterToGL[this._magFilter]];
        }
      }
      isLoaded() {
        return this._loaded;
      }
      setLoaded(loaded) {
        this._loaded = loaded;
      }
      getSource() {
        return this._source;
      }
      setSource(source) {
        this._source = source;
      }
      getGLTextureForRenderer(renderer) {
        return this._glTextures[renderer.id];
      }
      setGLTextureForRenderer(texture, renderer) {
        this._renderers[renderer.id] = renderer;
        this._glTextures[renderer.id] = texture;
      }
      getFrame() {
        return this._frame;
      }
      setFrame(frame) {
        this._frame = frame;
      }
      getDimensions() {
        return new Vector2(this._frame.width, this._frame.height);
      }
      getPixelRatio() {
        return this._pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
      }
      getGLUnit() {
        return this._glUnit;
      }
      setGLUnit(glUnit) {
        this._glUnit = glUnit;
      }
      setMinFilter(minFilter) {
        this._minFilter = minFilter;
      }
      getMinFilter() {
        return this._minFilter;
      }
      setMagFilter(magFilter) {
        this._magFilter = magFilter;
      }
      getMagFilter() {
        return this._magFilter;
      }
      setRepeatX(repeat) {
        this._repeatX = repeat;
      }
      getRepeatX() {
        return this._repeatX;
      }
      setRepeatY(repeat) {
        this._repeatY = repeat;
      }
      getRepeatY() {
        return this._repeatY;
      }
      getGLRepeat(gl, direction) {
        const value = direction === "x" ? this.getRepeatX() : this.getRepeatY();
        switch (value) {
          case 0 /* ClampToEdge */:
            return gl.CLAMP_TO_EDGE;
          case 1 /* Repeat */:
            return gl.REPEAT;
          case 2 /* MirroredRepeat */:
            return gl.MIRRORED_REPEAT;
          default:
            return 0;
        }
      }
      isDirty() {
        return this._dirty;
      }
      setDirty(dirty) {
        this._dirty = dirty;
      }
      disposeGLTextures() {
        this._renderers.forEach((renderer) => {
          if (isWebGLRenderer(renderer)) {
            this.disposeGLTexturesForRenderer(renderer);
          }
        });
      }
      disposeGLTexturesForRenderer(renderer) {
        if (!this._glTextures[renderer.id])
          return;
        const gl = renderer.getContext();
        gl.deleteTexture(this._glTextures[renderer.id]);
        delete this._glTextures[renderer.id];
        if (!this._renderers[renderer.id]) {
          delete this._renderers[renderer.id];
        }
      }
      isMipMappingEnabled() {
        return this._mipMapping;
      }
      setMipMappingEnabled(enabled) {
        this._mipMapping = enabled;
      }
      dispose() {
        this.disposeGLTextures();
        this._source = void 0;
      }
    };
    BaseTexture = _BaseTexture;
    BaseTexture.NearestFilter = 0 /* Nearest */;
    BaseTexture.LinearFilter = 1 /* Linear */;
    BaseTexture.BilinearFilter = 2 /* Bilinear */;
    BaseTexture.TrilinearFilter = 3 /* Trilinear */;
    BaseTexture.DefaultMagFilter = 1 /* Linear */;
    BaseTexture.DefaultMinFilter = 1 /* Linear */;
    BaseTexture.Repeat = 1 /* Repeat */;
    BaseTexture._id = 0;
  }
});

// engine/sdk/core/engine/utils/canvas-render-target.ts
var CanvasRenderTarget;
var init_canvas_render_target = __esm({
  "engine/sdk/core/engine/utils/canvas-render-target.ts"() {
    init_globals();
    init_base_texture();
    init_render();
    CanvasRenderTarget = class {
      constructor(width, height, pixelRatio, canvas = renderUtils.createCanvas(), context) {
        this._width = width;
        this._height = height;
        this._pixelRatio = pixelRatio;
        this._baseTexture = new BaseTexture();
        this._canvas = canvas;
        const ctx = context || this._canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Cannot get canvas context");
        }
        this._context = ctx;
        this._baseTexture.setSource(this._canvas);
        this._canvas.width = this._width * this._pixelRatio;
        this._canvas.height = this._height * this._pixelRatio;
        this._filterStack = [
          {
            renderTarget: this,
            filters: []
          }
        ];
      }
      clear() {
        const ctx = this._context;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      resizeTo(dimensions) {
        this._baseTexture.resizeTo(dimensions);
        if (this._width !== dimensions.x) {
          this._width = dimensions.x;
          this._canvas.width = this._width * this._pixelRatio;
        }
        if (this._height !== dimensions.y) {
          this._height = dimensions.y;
          this._canvas.height = this._height * this._pixelRatio;
        }
      }
      getCanvas() {
        return this._canvas;
      }
      getContext() {
        return this._context;
      }
      getFilterStack() {
        return this._filterStack;
      }
      getWidth() {
        return this._width;
      }
      getHeight() {
        return this._height;
      }
      getPixelRatio() {
        return this._pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
      }
      getDimensions() {
        return new Vector2(this._width, this._height);
      }
      getBaseTexture() {
        return this._baseTexture;
      }
      dispose() {
        delete this._canvas;
        delete this._context;
        this._baseTexture.dispose();
      }
    };
  }
});

// engine/sdk/core/engine/managers/canvas-filter-manager.ts
var CanvasFilterManager;
var init_canvas_filter_manager = __esm({
  "engine/sdk/core/engine/managers/canvas-filter-manager.ts"() {
    init_globals();
    init_canvas_render_target();
    CanvasFilterManager = class {
      constructor(renderer) {
        this._renderer = renderer;
        this._filterStack = [
          {
            renderTarget: renderer.getCurrentRenderTarget(),
            filters: []
          }
        ];
        this._textures = [];
        this._textureFrame = new Rectangle(0, 0, renderer.getWidth(), renderer.getHeight());
      }
      resizeTo(dimensions) {
        this._textureFrame.width = dimensions.x;
        this._textureFrame.height = dimensions.y;
        this._textures.forEach((texture) => texture.resizeTo(dimensions));
      }
      pushFilters(displayObject, filters) {
        this._currentFrame = displayObject.getBounds();
        const renderTarget = this._getOrCreateRenderTarget();
        this._renderer.setRenderTarget(renderTarget);
        this._filterStack.push({ renderTarget, filters });
        renderTarget.clear();
      }
      popFilters() {
        const filter = this._filterStack.pop();
        if (!filter)
          return void 0;
        const { filters, renderTarget } = filter;
        const lastFilter = this._filterStack[this._filterStack.length - 1];
        const inputRenderTarget = renderTarget;
        const outputRenderTarget = lastFilter.renderTarget;
        if (filters.length === 1) {
          const fn = filters[0];
          fn.apply(this._renderer, inputRenderTarget, outputRenderTarget);
          this._textures.push(inputRenderTarget);
        } else {
          this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
        }
        return filters;
      }
      _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
        let flipRenderTarget = inputRenderTarget;
        let flopRenderTarget = this._getOrCreateRenderTarget(true);
        const lastFilter = filters[filters.length - 1];
        filters.forEach((filter) => {
          const isLastFilter = filter === lastFilter;
          if (!isLastFilter) {
            filter.apply(this._renderer, flipRenderTarget, flopRenderTarget);
            const temp = flipRenderTarget;
            flipRenderTarget = flopRenderTarget;
            flopRenderTarget = temp;
          } else {
            filter.apply(this._renderer, flipRenderTarget, outputRenderTarget);
          }
        });
        this._textures.push(flipRenderTarget);
        this._textures.push(flopRenderTarget);
      }
      _getOrCreateRenderTarget(clear = false) {
        let renderTarget = this._textures.pop();
        if (!renderTarget) {
          renderTarget = new CanvasRenderTarget(this._textureFrame.width, this._textureFrame.height, 1);
        }
        if (clear) {
          renderTarget.clear();
        }
        return renderTarget;
      }
      setFilterStack(filterStack) {
        this._filterStack = filterStack;
      }
      dispose() {
      }
    };
  }
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "node_modules/performance-now/lib/performance-now.js"(exports, module2) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }).call(exports);
  }
});

// engine/sdk/core/engine/utils/context-performance-hook.js
var now, ContextPerformanceHook, context_performance_hook_default;
var init_context_performance_hook = __esm({
  "engine/sdk/core/engine/utils/context-performance-hook.js"() {
    init_globals();
    now = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();
    ContextPerformanceHook = class {
      constructor(context) {
        this._context = context;
        this._tracking = false;
        const self = this;
        for (const key in context) {
          const value = context[key];
          if (typeof value === "function") {
            this[key] = function(...args) {
              const fn = context[key];
              if (!self._tracking) {
                return fn.apply(context, args);
              }
              const start = now();
              const result = fn.apply(context, args);
              const time = now() - start;
              const call = {
                functionName: key,
                arguments: args,
                duration: time
              };
              self._trackedCalls.push(call);
              return result;
            };
          } else {
            this._makePropertyWrapper(key);
          }
        }
      }
      _makePropertyWrapper(property) {
        const insecureProperties = ["_context", "_trackedCalls", "_tracking"];
        if (insecureProperties.indexOf(property) !== -1)
          return;
        const context = this._context;
        this.__defineGetter__(property, () => {
          return context[property];
        });
        this.__defineSetter__(property, (value) => {
          context[property] = value;
        });
      }
      startFrame() {
        this._tracking = true;
        this._trackedCalls = [];
      }
      endFrame() {
        const tag = "Rendering";
        log_default.log(tag, "Frame rendering results:");
        log_default.log(tag, `Context calls: ${this._trackedCalls.length}`);
        const groupedCalls = {};
        this._trackedCalls.forEach(({ functionName, duration }) => {
          groupedCalls[functionName] = groupedCalls[functionName] || {
            totalDuration: 0,
            calls: 0
          };
          groupedCalls[functionName].totalDuration += duration;
          groupedCalls[functionName].calls++;
        });
        let callsArray = [];
        for (const key in groupedCalls) {
          const data = groupedCalls[key];
          data.averageDuration = data.totalDuration / data.calls;
          callsArray.push({ functionName: key, data });
        }
        callsArray.sort((a, b) => b.data.totalDuration - a.data.totalDuration);
        callsArray = callsArray.slice(0, 3);
        callsArray.forEach((item) => {
          log_default.log(tag, `${item.functionName}: ${item.data.calls} calls, ${item.data.totalDuration.toFixed(2)}ms`);
        });
      }
    };
    context_performance_hook_default = ContextPerformanceHook;
  }
});

// engine/sdk/core/engine/renderers/base-renderer.ts
var BaseRenderer;
var init_base_renderer = __esm({
  "engine/sdk/core/engine/renderers/base-renderer.ts"() {
    init_globals();
    BaseRenderer = class extends event_emitter_default {
      constructor(width = 800, height = 600, options) {
        super();
        this._maxTextureSize = null;
        this._options = __spreadProps(__spreadValues({
          debug: false,
          transparent: false,
          clearColor: color_default.TRANSPARENT
        }, options), {
          pixelRatio: 1
        });
        this.setMaxListeners(0);
        this._width = width;
        this._height = height;
        this._dimensions = new Vector2(this._width, this._height);
        this._maxTextureSize = null;
        this._pixelRatio = this._options.pixelRatio;
        this._canvas = this._options.canvas;
        this._clearColor = this._options.transparent ? color_default.TRANSPARENT : this._options.clearColor || color_default.BLACK;
      }
      setCanvas(canvas) {
        const previousCanvas = this._canvas;
        this._canvas = canvas;
        if (previousCanvas !== canvas) {
          this._createContext();
          this._onBeforeContext();
          this._setupContext();
        }
        this.resizeTo(new Vector2(this._width, this._height));
      }
      getCanvas() {
        return this._canvas;
      }
      _onBeforeContext() {
      }
      resizeTo(dimensions, resizeCanvas = true) {
        this._width = dimensions.x * this._pixelRatio;
        this._height = dimensions.y * this._pixelRatio;
        if (resizeCanvas && this._canvas) {
          this._canvas.width = this._width;
          this._canvas.height = this._height;
          if ("style" in this._canvas) {
            this._canvas.style.width = `${this._width / this._pixelRatio}px`;
            this._canvas.style.height = `${this._height / this._pixelRatio}px`;
          }
        }
        this._dimensions = dimensions.clone();
      }
      _createContext() {
        log_default.warn(this.constructor.name, "`_createContext` is abstract and not implemented in inherited class");
      }
      _setupContext() {
        log_default.warn(this.constructor.name, "`_setupContext` is abstract and not implemented in inherited class");
      }
      render(displayObject) {
        log_default.warn(this.constructor.name, "`render` is abstract and not implemented in inherited class");
      }
      getMaxDimensions() {
        return null;
      }
      getContext() {
        return this._context;
      }
      getWidth() {
        return this._dimensions.x;
      }
      getHeight() {
        return this._dimensions.y;
      }
      getDimensions() {
        return this._dimensions;
      }
      getPixelRatio() {
        return this._pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        if (this._defaultRenderTarget) {
          this._defaultRenderTarget.setPixelRatio(pixelRatio);
        }
      }
      getMaxTextureSize() {
        return this._maxTextureSize;
      }
      getFilterManager() {
        return this._filterManager;
      }
      setFilterManager(filterManager) {
        this._filterManager = filterManager;
      }
      setClearColor(color) {
        this._clearColor = color;
      }
      getClearColor() {
        return this._clearColor;
      }
      isOfType(type) {
        return this._type === type;
      }
      dispose() {
        log_default.warn(this.constructor.name, "`dispose` is abstract and not implemented in inherited class");
      }
    };
  }
});

// engine/sdk/core/engine/renderers/canvas/canvas-renderer.ts
var RendererType2, _CanvasRenderer, CanvasRenderer;
var init_canvas_renderer = __esm({
  "engine/sdk/core/engine/renderers/canvas/canvas-renderer.ts"() {
    init_cleanUpCanvasMemory();
    init_display_object();
    init_globals();
    init_canvas_filter_manager();
    init_canvas_render_target();
    init_context_performance_hook();
    init_render();
    init_base_renderer();
    ({ RendererType: RendererType2 } = constants_exports);
    _CanvasRenderer = class extends BaseRenderer {
      constructor(width = 800, height = 600, options) {
        super(width, height, __spreadValues({}, options));
        this.id = 0;
        this.setCanvas((options == null ? void 0 : options.canvas) || renderUtils.createCanvas());
        this._type = RendererType2.CANVAS;
      }
      _createContext() {
        const canvas = this._canvas;
        let ctx = canvas.getContext("2d");
        if (!ctx)
          return;
        if (this._options.debug) {
          ctx = new context_performance_hook_default(ctx);
        }
        this.id = _CanvasRenderer.contextId++;
        this._context = ctx;
        this.emit("context", ctx);
        return ctx;
      }
      _setupContext() {
        const ctx = this._context;
        if (!("imageSmoothingEnabled" in ctx)) {
          ["moz", "webkit", "ms"].forEach((prop) => {
            if (ctx[prop]) {
              ctx[prop] = true;
            }
          });
        } else {
          ctx.imageSmoothingEnabled = true;
        }
        this._defaultRenderTarget = new CanvasRenderTarget(this._width, this._height, this._pixelRatio, this._canvas, this._context);
        this.setRenderTarget(this._defaultRenderTarget);
        this._filterManager = new CanvasFilterManager(this);
      }
      render(displayObject) {
        const ctx = this._renderTarget.getContext();
        const originalParent = displayObject.getParent();
        displayObject.setParent(new DisplayObject());
        displayObject.updateTransform();
        if (originalParent) {
          displayObject.setParent(originalParent);
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;
        const { width, height } = this._canvas;
        ctx.clearRect(0, 0, width, height);
        if (this._clearColor.a !== 0) {
          ctx.save();
          ctx.fillStyle = this._clearColor.toRGBA();
          ctx.fillRect(0, 0, width, height);
          ctx.restore();
        }
        this.renderDisplayObject(displayObject, this._renderTarget);
      }
      renderDisplayObject(displayObject, renderTarget) {
        const originalRenderTarget = this._renderTarget;
        this._filterManager.setFilterStack(renderTarget.getFilterStack());
        this.setRenderTarget(renderTarget);
        displayObject.renderCanvas(this);
        this.setRenderTarget(originalRenderTarget);
      }
      getCurrentRenderTarget() {
        return this._renderTarget;
      }
      setRenderTarget(renderTarget) {
        this._renderTarget = renderTarget;
      }
      getContext() {
        return this._renderTarget.getContext();
      }
      dispose() {
        cleanUpCanvasMemory(this._canvas);
        this._filterManager.dispose();
      }
    };
    CanvasRenderer = _CanvasRenderer;
    CanvasRenderer.contextId = 0;
    CanvasRenderer.type = RendererType2.CANVAS;
  }
});

// engine/v6/utils/webgl.ts
var hookWindowGL;
var init_webgl = __esm({
  "engine/v6/utils/webgl.ts"() {
    hookWindowGL = (gl) => {
      if (typeof window !== "undefined") {
        const { WebGLDebugUtils } = window;
        if (WebGLDebugUtils) {
          const logGL = (functionName, args) => {
            console.error(`gl.${functionName}(${WebGLDebugUtils.glFunctionArgsToString(functionName, args)})`);
          };
          gl = WebGLDebugUtils.makeDebugContext(gl, null, logGL);
        }
      }
      return gl;
    };
  }
});

// engine/sdk/core/engine/utils/quad.ts
var Quad;
var init_quad = __esm({
  "engine/sdk/core/engine/utils/quad.ts"() {
    Quad = class {
      constructor(gl) {
        this.vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);
        this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        this.indices = new Uint16Array([0, 1, 2, 0, 3, 2]);
        this.colors = new Float32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
        this.vertexBuffer = null;
        this.indexBuffer = null;
        this.gl = gl;
        this.initBuffers();
        this.uploadBuffers();
      }
      map(rect1, rect2) {
        const { x, y } = rect2;
        this.uvs[2] = rect2.width / rect1.width;
        this.uvs[4] = this.uvs[2];
        this.uvs[5] = rect2.height / rect1.height;
        this.uvs[7] = this.uvs[5];
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + rect2.width;
        this.vertices[3] = y;
        this.vertices[4] = this.vertices[2];
        this.vertices[5] = y + rect2.height;
        this.vertices[6] = x;
        this.vertices[7] = this.vertices[5];
        this.uploadBuffers();
      }
      getVertexBuffer() {
        return this.vertexBuffer;
      }
      getIndexBuffer() {
        return this.indexBuffer;
      }
      dispose() {
        this.cleanBuffer();
      }
      initBuffers() {
        const { gl } = this;
        this.cleanBuffer();
        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);
        this.indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);
      }
      uploadBuffers() {
        const { gl } = this;
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);
        gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this.uvs);
        gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this.colors);
      }
      cleanBuffer() {
        const { gl } = this;
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.indexBuffer);
      }
    };
  }
});

// engine/sdk/core/engine/utils/webgl-render-target.ts
var WebglRenderTarget;
var init_webgl_render_target = __esm({
  "engine/sdk/core/engine/utils/webgl-render-target.ts"() {
    init_globals();
    init_base_texture();
    WebglRenderTarget = class {
      constructor(renderer, width, height, pixelRatio, isRoot = false) {
        this._renderer = renderer;
        this._gl = renderer.getContext();
        this._width = width;
        this._height = height;
        this._frame = null;
        this._pixelRatio = pixelRatio;
        this._projectionMatrix = new Matrix();
        this._mipMapping = false;
        this._baseTexture = new BaseTexture();
        const frame = this._baseTexture.getFrame();
        frame.width = width;
        frame.height = height;
        this._baseTexture.setPixelRatio(pixelRatio);
        this._baseTexture.setLoaded(true);
        this._framebuffer = null;
        this._isRoot = isRoot;
        this._filterStack = [
          {
            renderTarget: this,
            filters: []
          }
        ];
        if (!isRoot) {
          this._initFrameBuffer();
        }
      }
      resizeTo(dimensions) {
        this._width = dimensions.x | 0;
        this._height = dimensions.y | 0;
        this._baseTexture.resizeTo(dimensions);
        if (!this._isRoot) {
          this._resizeTexture();
        }
        this._baseTexture.setMinFilter(this._getMinFilter());
        this._baseTexture.setMagFilter(this._getMagFilter());
        this._calculateProjectionMatrix();
      }
      _getMinFilter() {
        let minFilter = BaseTexture.DefaultMinFilter;
        if (this._mipMapping) {
          minFilter = BaseTexture.TrilinearFilter;
        }
        return minFilter;
      }
      _getMagFilter() {
        return BaseTexture.DefaultMagFilter;
      }
      _resizeTexture() {
        const gl = this._gl;
        const realWidth = this._width * this._pixelRatio;
        const realHeight = this._height * this._pixelRatio;
        if (this._texture) {
          gl.deleteTexture(this._texture);
          this._texture = null;
        }
        this._texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, realWidth, realHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);
        if (this._texture) {
          this._baseTexture.setGLTextureForRenderer(this._texture, this._renderer);
        }
        if (this._renderer._options.debug) {
          gl_utils_default.checkFramebufferStatus("WebGLRenderTarget#_initFramebuffer", gl);
        }
        const dimensions = new Vector2(this._width, this._height);
        if (utils_default.isPowerOfTwo(dimensions)) {
          log_default.info("WebGLRenderTarget", "Mip-mapping enabled");
          this._mipMapping = true;
        } else {
          this._mipMapping = false;
        }
        this._baseTexture.setMipMappingEnabled(this._mipMapping);
      }
      activate() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
        this._calculateProjectionMatrix();
        gl.viewport(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
        gl.disable(gl.STENCIL_TEST);
      }
      clear(color = color_default.TRANSPARENT) {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
        if (this._renderer._options.debug) {
          gl_utils_default.checkFramebufferStatus("WebGLRenderTarget#clear", gl);
        }
        gl.clearColor.apply(gl, color.toGLColor());
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      _calculateProjectionMatrix() {
        const projectionMatrix = this._projectionMatrix;
        projectionMatrix.reset();
        const frame = this._frame || new Rectangle(0, 0, this._width, this._height);
        const { x, y } = frame;
        if (!this._isRoot) {
          projectionMatrix.a = 1 / this._width * 2;
          projectionMatrix.d = 1 / this._height * 2;
          projectionMatrix.tx = -1 - x * projectionMatrix.a;
          projectionMatrix.ty = -1 - y * projectionMatrix.d;
        } else {
          projectionMatrix.a = 1 / this._width * 2;
          projectionMatrix.d = -1 / this._height * 2;
          projectionMatrix.tx = -1 - x * projectionMatrix.a;
          projectionMatrix.ty = 1 - y * projectionMatrix.d;
        }
      }
      _initFrameBuffer() {
        const gl = this._gl;
        if (this._framebuffer) {
          gl.deleteFramebuffer(this._framebuffer);
          this._framebuffer = null;
        }
        if (this._texture) {
          gl.deleteTexture(this._texture);
          this._texture = null;
        }
        this._framebuffer = gl.createFramebuffer();
        this._texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this._texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);
        if (this._texture) {
          this._baseTexture.setGLTextureForRenderer(this._texture, this._renderer);
        }
        this.resizeTo(new Vector2(this._width, this._height));
        if (this._renderer._options.debug) {
          gl_utils_default.checkFramebufferStatus("WebGLRenderTarget#_initFramebuffer", gl);
        }
      }
      getProjectionMatrix() {
        return this._projectionMatrix;
      }
      getTexture() {
        return this._texture;
      }
      getFrame() {
        return this._frame;
      }
      setFrame(frame) {
        this._frame = frame;
      }
      getFilterStack() {
        return this._filterStack;
      }
      getPixelRatio() {
        return this._pixelRatio;
      }
      setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        if (!this._isRoot) {
          this._resizeTexture();
        }
      }
      getBaseTexture() {
        return this._baseTexture;
      }
      dispose() {
        const gl = this._gl;
        this._baseTexture.dispose();
        if (this._framebuffer) {
          gl.deleteFramebuffer(this._framebuffer);
          this._framebuffer = null;
        }
        if (this._texture) {
          gl.deleteTexture(this._texture);
          this._texture = null;
        }
      }
    };
  }
});

// engine/sdk/core/engine/managers/webgl-filter-manager.ts
var WebGLFilterManager;
var init_webgl_filter_manager = __esm({
  "engine/sdk/core/engine/managers/webgl-filter-manager.ts"() {
    init_filters();
    init_globals();
    init_quad();
    init_render();
    init_webgl_render_target();
    WebGLFilterManager = class {
      constructor(renderer) {
        this._renderer = renderer;
        this._filterStack = [];
        this._currentFrame = null;
        this._renderTargets = [];
        this._textureFrame = new Rectangle(0, 0, renderer.getWidth(), renderer.getHeight());
        this._onContextChange = this._onContextChange.bind(this);
        this._renderer.on("context", this._onContextChange);
        this._onContextChange();
      }
      resizeTo(dimensions) {
        this._textureFrame.width = dimensions.x;
        this._textureFrame.height = dimensions.y;
        this._renderTargets.forEach((texture) => texture.resizeTo(dimensions));
      }
      getFilterStack() {
        return this._filterStack;
      }
      setFilterStack(filterStack) {
        this._filterStack = filterStack;
      }
      _getOrCreateRenderTarget(clear = false) {
        let renderTarget = this._renderTargets.pop();
        if (!renderTarget) {
          renderTarget = new WebglRenderTarget(this._renderer, this._textureFrame.width, this._textureFrame.height, 1);
        }
        if (this._currentFrame) {
          renderTarget.setFrame(this._currentFrame);
        }
        if (clear) {
          renderTarget.clear();
        }
        return renderTarget;
      }
      pushFilters(displayObject, filters) {
        const bounds = displayObject.getBounds();
        this._currentFrame = bounds;
        const filterRectangle = displayObject.getFilterRectangle();
        if (filterRectangle.width > 0 && filterRectangle.height > 0) {
          this._currentFrame = filterRectangle;
        }
        const renderTarget = this._getOrCreateRenderTarget();
        this._renderer.setRenderTarget(renderTarget);
        const filterIsImage = filters[0] instanceof UnpremultiplyFilter;
        if (filterIsImage) {
          renderTarget.clear(this._renderer.getClearColor());
        } else {
          renderTarget.clear();
        }
        this._filterStack.push({ renderTarget, filters });
      }
      popFilters() {
        const filter = this._filterStack.pop();
        if (!filter)
          return void 0;
        const { filters, renderTarget } = filter;
        const lastFilter = this._filterStack[this._filterStack.length - 1];
        const inputRenderTarget = renderTarget;
        const outputRenderTarget = lastFilter.renderTarget;
        const frame = inputRenderTarget.getFrame();
        if (frame) {
          this._quad.map(this._textureFrame, frame);
        }
        const shader = filters[0].getShaderForRenderer(this._renderer);
        const vertexBuffer = this._quad.getVertexBuffer();
        const indexBuffer = this._quad.getIndexBuffer();
        const gl = this._renderer.getContext();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        const attributeLocations = shader.getAttributeLocations();
        gl.vertexAttribPointer(attributeLocations.a_position, 2, gl.FLOAT, false, 0, 0);
        gl.vertexAttribPointer(attributeLocations.a_texCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
        gl.vertexAttribPointer(attributeLocations.a_color, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
        this._renderer.updateTexture(inputRenderTarget.getBaseTexture(), false);
        if (filters.length === 1) {
          filters[0].apply(this._renderer, inputRenderTarget, outputRenderTarget);
          this._renderTargets.push(inputRenderTarget);
        } else {
          this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
        }
        return filters;
      }
      _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
        let flipRenderTarget = inputRenderTarget;
        let flopRenderTarget = this._getOrCreateRenderTarget(true);
        this._renderer.updateTexture(flopRenderTarget.getBaseTexture(), false);
        const lastFilter = filters[filters.length - 1];
        filters.forEach((filter) => {
          const isLastFilter = filter === lastFilter;
          if (!isLastFilter) {
            filter.apply(this._renderer, flipRenderTarget, flopRenderTarget, true);
            const temp = flipRenderTarget;
            flipRenderTarget = flopRenderTarget;
            flopRenderTarget = temp;
          } else {
            filter.apply(this._renderer, flipRenderTarget, outputRenderTarget, true);
          }
        });
        this._renderTargets.push(flipRenderTarget);
        this._renderTargets.push(flopRenderTarget);
      }
      _onContextChange() {
        this._renderTargets.length = 0;
        if (isWebGLRenderer(this._renderer)) {
          if (this._quad) {
            this._quad.dispose();
          }
          this._quad = new Quad(this._renderer.getContext());
        }
      }
      dispose() {
        this._renderer.off("context", this._onContextChange);
        if (this._quad) {
          this._quad.dispose();
        }
        this._renderTargets.forEach((target) => {
          target.dispose();
        });
      }
    };
  }
});

// engine/sdk/core/engine/utils/webgl/webgl-memory-manager.js
var import_stats, WebGLMemoryManager;
var init_webgl_memory_manager = __esm({
  "engine/sdk/core/engine/utils/webgl/webgl-memory-manager.js"() {
    import_stats = __toESM(require("stats.js"));
    WebGLMemoryManager = class {
      constructor(context) {
        this._context = context;
        this._domAvailable = typeof document !== "undefined";
        this._hookIntoContext();
        this._textures = {};
        this._framebuffers = {};
        this._programs = {};
        this._shaders = {};
        this._buffers = {};
        this._boundTexture = null;
        this._id = 0;
        this._enums = {};
        this._setupStats();
        this._createEnumMap();
        this._updateMemoryStats = this._updateMemoryStats.bind(this);
        this._updateMemoryStats();
      }
      _createEnumMap() {
        for (const key in this._context) {
          const value = this._context[key];
          if (typeof value === "number") {
            this._enums[value] = key;
          }
        }
      }
      _enumValueToString(value) {
        const key = this._enums[value];
        return typeof key === "undefined" ? value : key;
      }
      _setupStats() {
        if (!this._domAvailable)
          return;
        this._stats = new import_stats.default();
        this._stats.showPanel(3);
        this._memPanel = this._stats.addPanel(new import_stats.default.Panel("MB [WebGL]", "#43ADEB", "#282828"));
        this._texPanel = this._stats.addPanel(new import_stats.default.Panel("Textures", "#43ADEB", "#282828"));
        this._bufPanel = this._stats.addPanel(new import_stats.default.Panel("Buffers", "#43ADEB", "#282828"));
        this._fboPanel = this._stats.addPanel(new import_stats.default.Panel("FBOs", "#43ADEB", "#282828"));
        this._prgPanel = this._stats.addPanel(new import_stats.default.Panel("Programs", "#43ADEB", "#282828"));
        this._shdPanel = this._stats.addPanel(new import_stats.default.Panel("Shaders", "#43ADEB", "#282828"));
      }
      _updatePanel(panel) {
        if (!this._domAvailable)
          return;
        this._stats.begin();
        switch (panel) {
          case "tex":
            this._texPanel.update(this.getTexturesCount(), 50);
            break;
          case "buf":
            this._bufPanel.update(this.getBuffersCount(), 50);
            break;
          case "fbo":
            this._fboPanel.update(this.getFBOCount(), 50);
            break;
          case "prg":
            this._prgPanel.update(this.getProgramCount(), 50);
            break;
          case "shd":
            this._shdPanel.update(this.getShaderCount(), 50);
            break;
        }
        this._stats.end();
      }
      getTexturesCount() {
        return Object.keys(this._textures).length;
      }
      getBuffersCount() {
        return Object.keys(this._buffers).length;
      }
      getFBOCount() {
        return Object.keys(this._framebuffers).length;
      }
      getProgramCount() {
        return Object.keys(this._programs).length;
      }
      getShaderCount() {
        return Object.keys(this._shaders).length;
      }
      _updateMemoryStats() {
        if (!this._domAvailable)
          return;
        const memory = this._getMemoryUsage() / 1e3 / 1e3;
        this._memPanel.update(memory, 400);
        setTimeout(this._updateMemoryStats, 1e3);
      }
      _getMemoryUsage() {
        let bytes = 0;
        for (const name in this._textures) {
          bytes += this._textures[name].memory;
        }
        for (const name in this._buffers) {
          bytes += this._buffers[name].memory;
        }
        return bytes;
      }
      _hookIntoContext() {
        for (const key in this._context) {
          const value = this._context[key];
          if (typeof value === "function") {
            this[key] = function(...args) {
              const fn = this._context[key];
              return this._trackGLCall(fn, key, args);
            };
          } else {
            this._makePropertyWrapper(key);
          }
        }
      }
      _makePropertyWrapper(property) {
        const insecureProperties = ["_context"];
        if (insecureProperties.indexOf(property) !== -1)
          return;
        const context = this._context;
        this.__defineGetter__(property, () => {
          return context[property];
        });
        this.__defineSetter__(property, (value) => {
          context[property] = value;
        });
      }
      _trackGLCall(fn, functionName, args) {
        const overrideFunctions = [
          "texImage2D",
          "bindTexture",
          "createTexture",
          "deleteTexture",
          "createBuffer",
          "bindBuffer",
          "bufferData",
          "deleteBuffer",
          "createFramebuffer",
          "deleteFramebuffer",
          "createProgram",
          "deleteProgram",
          "createShader",
          "deleteShader"
        ];
        let result;
        if (overrideFunctions.indexOf(functionName) !== -1) {
          result = this[`_${functionName}`](args);
        } else {
          result = fn.apply(this._context, args);
        }
        const err = this._context.getError();
        if (err !== 0) {
          let truncatedArgs = args.join(", ");
          if (truncatedArgs.length > 100) {
            truncatedArgs = `${truncatedArgs.substr(0, 100)}...`;
          }
          console.error(new Error(`WebGL Error ${this._enumValueToString(err)} in ${functionName}(${truncatedArgs})`));
        }
        return result;
      }
      _createProgram() {
        const program = this._context.createProgram();
        program._wmmId = this._id++;
        this._programs[program._wmmId] = program;
        this._updatePanel("prg");
        return program;
      }
      _deleteProgram([program]) {
        if (!program || !this._programs[program._wmmId])
          return;
        delete this._programs[program._wmmId];
        this._context.deleteProgram(program);
        this._updatePanel("prg");
      }
      _createShader([type]) {
        const shader = this._context.createShader(type);
        shader._wmmId = this._id++;
        this._shaders[shader._wmmId] = shader;
        this._updatePanel("shd");
        return shader;
      }
      _deleteShader([shader]) {
        if (!shader || !this._shaders[shader._wmmId])
          return;
        delete this._shaders[shader._wmmId];
        this._context.deleteShader(shader);
        this._updatePanel("shd");
      }
      _createFramebuffer() {
        const framebuffer = this._context.createFramebuffer();
        framebuffer._wmmId = this._id++;
        this._framebuffers[framebuffer._wmmId] = framebuffer;
        this._updatePanel("fbo");
        return framebuffer;
      }
      _deleteFramebuffer([framebuffer]) {
        if (!framebuffer || !this._framebuffers[framebuffer._wmmId])
          return;
        delete this._framebuffers[framebuffer._wmmId];
        this._context.deleteFramebuffer(framebuffer);
        this._updatePanel("fbo");
      }
      _createBuffer() {
        const buffer = this._context.createBuffer();
        buffer._wmmId = this._id++;
        this._buffers[buffer._wmmId] = {
          buffer,
          memory: 0
        };
        this._updatePanel("buf");
        return buffer;
      }
      _bindBuffer([target, buffer]) {
        this._context.bindBuffer(target, buffer);
        this._boundBuffer = buffer._wmmId;
      }
      _bufferData([target, sizeOrData, usage]) {
        this._context.bufferData(target, sizeOrData, usage);
        let size;
        if (typeof sizeOrData === "number") {
          size = sizeOrData;
        } else if ("byteLength" in sizeOrData) {
          size = sizeOrData.byteLength;
        } else if ("length" in sizeOrData) {
          size = sizeOrData.length;
        }
        this._buffers[this._boundBuffer].memory = size;
      }
      _deleteBuffer([buffer]) {
        if (!buffer || !this._buffers[buffer._wmmId])
          return;
        delete this._buffers[buffer._wmmId];
        this._context.deleteBuffer(buffer);
        this._updatePanel("buf");
      }
      _createTexture() {
        const texture = this._context.createTexture();
        texture._wmmId = this._id++;
        this._textures[texture._wmmId] = {
          texture,
          memory: 0
        };
        this._updatePanel("tex");
        return texture;
      }
      _deleteTexture([texture]) {
        if (!texture || !this._textures[texture._wmmId])
          return;
        delete this._textures[texture._wmmId];
        this._context.deleteTexture(texture);
        this._updatePanel("tex");
      }
      _bindTexture([target, texture]) {
        this._context.bindTexture(target, texture);
        this._boundTexture = texture._wmmId;
      }
      _texImage2D(args) {
        let [, , internalformat, width, height, border, , , pixels] = args;
        if (typeof pixels === "undefined") {
          pixels = border;
        }
        this._context.texImage2D.apply(this._context, args);
        const byteCount = this._calculateByteCountForTexture(internalformat, width, height, pixels);
        this._textures[this._boundTexture].memory = byteCount;
      }
      _calculateByteCountForTexture(format2, width, height, pixels) {
        if (pixels !== null) {
          if ("width" in pixels) {
            width = pixels.width;
            height = pixels.height;
          } else {
            return pixels.length;
          }
        }
        let bytesPerPixel = 1;
        switch (format2) {
          case this._context.ALPHA:
            bytesPerPixel = 1;
            break;
          case this._context.RGB:
            bytesPerPixel = 3;
            break;
          case this._context.RGBA:
            bytesPerPixel = 4;
            break;
        }
        return width * height * bytesPerPixel;
      }
    };
  }
});

// engine/sdk/core/engine/renderers/webgl/object-renderers/object-renderer.ts
var ObjectRenderer;
var init_object_renderer = __esm({
  "engine/sdk/core/engine/renderers/webgl/object-renderers/object-renderer.ts"() {
    ObjectRenderer = class {
      constructor(renderer) {
        this._renderer = renderer;
        this._onContextChange = this._onContextChange.bind(this);
        this._renderer.on("context", this._onContextChange);
      }
      _onContextChange() {
      }
      start() {
      }
      stop() {
        this.flush();
      }
      flush() {
      }
      dispose() {
        this._renderer.off("context", this._onContextChange);
        delete this._renderer;
      }
    };
  }
});

// engine/sdk/core/engine/renderers/webgl/object-renderers/sprite-renderer.ts
var SpriteRenderer;
var init_sprite_renderer = __esm({
  "engine/sdk/core/engine/renderers/webgl/object-renderers/sprite-renderer.ts"() {
    init_globals();
    init_object_renderer();
    SpriteRenderer = class extends ObjectRenderer {
      constructor(renderer) {
        super(renderer);
        this._vertexBuffer = null;
        this._indexBuffer = null;
        this._maxBatchSize = BATCH_SIZE;
        this._vertices = new ArrayBuffer(BATCH_SIZE * 4 * VERTEX_BYTE_SIZE);
        this._positions = new Float32Array(this._vertices);
        this._colors = new Uint32Array(this._vertices);
        this._indices = new Uint16Array(BATCH_SIZE * 6);
        for (let i = 0, j = 0; i < BATCH_SIZE * 6; i += 6, j += 4) {
          this._indices[i + 0] = j + 0;
          this._indices[i + 1] = j + 1;
          this._indices[i + 2] = j + 2;
          this._indices[i + 3] = j + 0;
          this._indices[i + 4] = j + 2;
          this._indices[i + 5] = j + 3;
        }
        this._sprites = [];
        this._currentBatchSize = 0;
        this._onContextChange();
      }
      render(sprite) {
        const texture = sprite.getTexture();
        if (!texture)
          return;
        const textureFrame = texture.getFrame();
        const baseTexture = texture.getBaseTexture();
        if (this._currentBatchSize >= this._maxBatchSize) {
          this.flush();
        }
        const uvs = texture.getUVs();
        if (!uvs) {
          return;
        }
        const index = this._currentBatchSize * VERTEX_BYTE_SIZE;
        this._addVertexCoordinates(sprite, index, textureFrame);
        this._addTextureUVs(sprite, index, uvs);
        this._addColors(sprite, index);
        this._sprites[this._currentBatchSize] = sprite;
        this._currentBatchSize++;
      }
      _addColors(sprite, index) {
        const colors = this._colors;
        const tint = 16777215;
        const color = (tint >> 16) + (tint & 65280) + ((tint & 255) << 16) + (sprite.getWorldAlpha() * 255 << 24);
        colors[index + 4] = colors[index + 9] = colors[index + 14] = colors[index + 19] = color;
      }
      _addTextureUVs(sprite, index, uvs) {
        const positions = this._positions;
        const [uv1, uv2, uv3, uv4] = uvs;
        positions[index + 2] = uv1.x;
        positions[index + 3] = uv1.y;
        positions[index + 7] = uv2.x;
        positions[index + 8] = uv2.y;
        positions[index + 12] = uv3.x;
        positions[index + 13] = uv3.y;
        positions[index + 17] = uv4.x;
        positions[index + 18] = uv4.y;
      }
      _addVertexCoordinates(sprite, index, textureFrame) {
        const positions = this._positions;
        const worldTransform = sprite.getWorldTransform();
        const anchor = sprite.getAnchor();
        const rectPositions = worldTransform.rectangleToCoordinates(textureFrame, anchor);
        const stride = 5;
        for (let i = 0; i < 4; i++) {
          positions[index + i * stride] = rectPositions[i].x;
          positions[index + i * stride + 1] = rectPositions[i].y;
        }
      }
      _onContextChange() {
        const gl = this._renderer.getContext();
        this._shader = this._renderer.shaders.default;
        if (this._vertexBuffer) {
          this._vertexBuffer = null;
        }
        if (this._indexBuffer) {
          this._indexBuffer = null;
        }
        this._vertexBuffer = gl.createBuffer();
        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
      }
      start() {
        if (this._vertexBuffer && this._indexBuffer) {
          this._shader.setupBuffers(this._vertexBuffer, this._indexBuffer);
        }
      }
      flush() {
        var _a;
        const renderer = this._renderer;
        const gl = renderer.getContext();
        if (this._currentBatchSize === 0) {
          return;
        }
        if (this._currentBatchSize > BATCH_SIZE * 0.5) {
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
        } else {
          const subArray = this._positions.subarray(0, this._currentBatchSize * VERTEX_BYTE_SIZE);
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, subArray);
        }
        let currentBatchSize = 0;
        let currentBaseTexture = null;
        let nextBaseTexture = null;
        let currentShader = null;
        let nextShader = null;
        let shaderChanged = false;
        let textureChanged = false;
        let sprite = null;
        let batchStartIndex = 0;
        for (let i = 0, j = this._currentBatchSize; i < j; i++) {
          sprite = this._sprites[i];
          nextBaseTexture = (_a = sprite.getTexture()) == null ? void 0 : _a.getBaseTexture();
          nextShader = sprite.getShader() || this._shader;
          shaderChanged = currentShader !== nextShader;
          textureChanged = currentBaseTexture !== nextBaseTexture;
          if (textureChanged || shaderChanged) {
            if (currentBaseTexture) {
              this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);
            }
            batchStartIndex = i;
            currentBatchSize = 0;
            currentBaseTexture = nextBaseTexture;
            if (shaderChanged) {
              currentShader = nextShader;
              renderer.setShader(currentShader);
              const renderTarget = renderer.getCurrentRenderTarget();
              const projectionMatrix = renderTarget.getProjectionMatrix().toArray();
              currentShader.setUniform("u_projMatrix", projectionMatrix);
              currentShader.syncUniforms();
              gl.activeTexture(gl.TEXTURE0);
            }
          }
          currentBatchSize++;
        }
        if (currentBaseTexture) {
          this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);
        }
        this._currentBatchSize = 0;
        this._sprites = [];
      }
      _renderBatch(baseTexture, batchSize, batchStartIndex) {
        if (batchSize === 0) {
          return;
        }
        const renderer = this._renderer;
        const gl = renderer.getContext();
        let glTexture = baseTexture.getGLTextureForRenderer(renderer);
        if (!glTexture) {
          glTexture = renderer.getOrCreateGLTexture(baseTexture);
        }
        if (baseTexture.isDirty()) {
          renderer.updateTexture(baseTexture);
          baseTexture.setDirty(false);
        }
        gl.activeTexture(gl.TEXTURE0 + baseTexture.getGLUnit());
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        const verticesCount = batchSize * 6;
        const vertexOffset = batchStartIndex * 6 * 2;
        gl.drawElements(gl.TRIANGLES, verticesCount, gl.UNSIGNED_SHORT, vertexOffset);
      }
      dispose() {
        const renderer = this._renderer;
        const gl = renderer.getContext();
        this._sprites.forEach((sprite) => {
          sprite.dispose();
        });
        if (this._vertexBuffer) {
          gl.deleteBuffer(this._vertexBuffer);
          this._vertexBuffer = null;
        }
        if (this._indexBuffer) {
          gl.deleteBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
        delete this._vertices;
        delete this._positions;
        delete this._colors;
        delete this._indices;
        super.dispose();
      }
    };
  }
});

// engine/sdk/core/engine/renderers/webgl/webgl-renderer.ts
var _WebGLRenderer, WebGLRenderer;
var init_webgl_renderer = __esm({
  "engine/sdk/core/engine/renderers/webgl/webgl-renderer.ts"() {
    init_webgl();
    init_cleanUpCanvasMemory();
    init_constants();
    init_display_object();
    init_globals();
    init_webgl_filter_manager();
    init_shaders();
    init_context_performance_hook();
    init_render();
    init_webgl_render_target();
    init_webgl_memory_manager();
    init_base_renderer();
    init_object_renderer();
    init_sprite_renderer();
    _WebGLRenderer = class extends BaseRenderer {
      constructor(width = 800, height = 600, options) {
        super(width, height, options);
        this.type = "webgl" /* WEBGL */;
        this.maxTextureDimensions = null;
        this._type = "webgl" /* WEBGL */;
        this._onContextLost = this._onContextLost.bind(this);
        this._onContextRestored = this._onContextRestored.bind(this);
        this.setCanvas(this._options.canvas || renderUtils.createCanvas());
        this.shaders = {
          default: new TextureShader(this, void 0, void 0)
        };
        this.renderers = {
          sprite: new SpriteRenderer(this)
        };
      }
      _onContextLost(e) {
        e.preventDefault();
        log_default.warn(this.constructor.name, "WebGL context has been lost - trying to restore.");
        this.emit("context-lost");
      }
      _onContextCreationError(e) {
        e.preventDefault();
        log_default.warn(this.constructor.name, `Failed to create WebGL context: ${e.statusMessage || "Unknown error"}`);
      }
      _onContextRestored() {
        log_default.warn(this.constructor.name, "WebGL context has been restored. Clearing all textures.");
        this._createContext();
        this._setupContext();
        this.emit("context-restored");
      }
      _onBeforeContext() {
        if (this._filterManager) {
          this._filterManager.dispose();
        }
        this._filterManager = new WebGLFilterManager(this);
        this._currentObjectRenderer = new ObjectRenderer(this);
      }
      setShader(shader) {
        this._currentShader = shader;
        this._context.useProgram(shader.getProgram());
        this._setAttributesForShader(shader);
      }
      setCanvas(canvas) {
        if (this._canvas) {
          this._removeContextEventListeners();
        }
        super.setCanvas(canvas);
        this._addContextEventListeners();
      }
      _addContextEventListeners() {
        if (isWebCanvas(this._canvas)) {
          this._canvas.addEventListener("webglcontextlost", this._onContextLost);
          this._canvas.addEventListener("webglcontextrestored", this._onContextRestored);
          this._canvas.addEventListener("webglcontextcreationerror", this._onContextCreationError);
        }
      }
      _removeContextEventListeners() {
        if (isWebCanvas(this._canvas)) {
          this._canvas.removeEventListener("webglcontextlost", this._onContextLost);
          this._canvas.removeEventListener("webglcontextrestored", this._onContextRestored);
          this._canvas.removeEventListener("webglcontextcreationerror", this._onContextCreationError);
        }
      }
      _setAttributesForShader(shader) {
        if (!this._canvas)
          return;
        const gl = this._context;
        const attributes = shader.getAttributes();
        const attributeLocations = shader.getAttributeLocations();
        attributes.forEach((attributeName) => {
          const attributeLocation = attributeLocations[attributeName];
          gl.enableVertexAttribArray(attributeLocation);
        });
      }
      _createContext() {
        if (!this._canvas)
          return;
        let gl = renderUtils.glGet(this._canvas);
        if (this._options.debug) {
          hookWindowGL(gl);
        }
        if (this._options.debug) {
          gl = new context_performance_hook_default(gl);
          gl = new WebGLMemoryManager(gl);
        }
        this.id = _WebGLRenderer.contextId++;
        this._context = gl;
        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.emit("context", gl);
        return gl;
      }
      _setupContext() {
        const gl = this._context;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        this._defaultRenderTarget = new WebglRenderTarget(this, this._width, this._height, this._pixelRatio, true);
        this.setRenderTarget(this._defaultRenderTarget);
        this._getMaxPrecision();
      }
      getContext() {
        return this._context;
      }
      _getMaxPrecision() {
        const gl = this._context;
        const highFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        this._maxFloatPrecision = (highFloat == null ? void 0 : highFloat.precision) !== 0 ? "highp" /* High */ : "mediump" /* Medium */;
        const highInt = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT);
        this._maxIntPrecision = (highInt == null ? void 0 : highInt.rangeMax) !== 0 ? "highp" /* High */ : "lowp" /* Low */;
      }
      resizeTo(dimensions, resizeCanvas = true) {
        super.resizeTo(dimensions, resizeCanvas);
        if (this._currentRenderTarget) {
          this._currentRenderTarget.resizeTo(dimensions);
        }
        this._context = renderUtils.glResize(this._context, dimensions);
      }
      setRenderTarget(renderTarget = this._defaultRenderTarget) {
        this._currentRenderTarget = renderTarget;
        this._currentRenderTarget.activate();
      }
      setObjectRenderer(objectRenderer) {
        this._currentObjectRenderer.stop();
        this._currentObjectRenderer = objectRenderer;
        this._currentObjectRenderer.start();
      }
      render(displayObject) {
        this.setRenderTarget(this._defaultRenderTarget);
        this._defaultRenderTarget.clear(this._clearColor);
        const originalParent = displayObject.getParent();
        displayObject.setParent(new DisplayObject());
        displayObject.updateTransform();
        if (originalParent) {
          displayObject.setParent(originalParent);
        }
        this.renderDisplayObject(displayObject, this._defaultRenderTarget);
      }
      renderDisplayObject(displayObject, renderTarget) {
        this.setRenderTarget(renderTarget);
        this._filterManager.setFilterStack(renderTarget.getFilterStack());
        displayObject.renderWebGL(this);
        this._currentObjectRenderer.flush();
      }
      clear() {
        const gl = this._context;
        gl.clearColor.apply(gl, this._clearColor.toGLColor);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      save() {
        return {
          renderTarget: this._currentRenderTarget,
          objectRenderer: this._currentObjectRenderer,
          filterStack: this._filterManager.getFilterStack()
        };
      }
      restore(save) {
        this.setRenderTarget(save.renderTarget);
        this._filterManager.setFilterStack(save.filterStack);
        this._currentObjectRenderer = save.objectRenderer;
      }
      getOrCreateGLTexture(texture) {
        const gl = this._context;
        let glTexture = texture.getGLTextureForRenderer(this);
        if (!glTexture) {
          glTexture = gl.createTexture();
          texture.setGLTextureForRenderer(glTexture, this);
        }
        return glTexture;
      }
      updateTexture(texture, upload = true) {
        const source = texture.getSource();
        const gl = this._context;
        const glUnit = texture.getGLUnit();
        const glTexture = this.getOrCreateGLTexture(texture);
        gl.activeTexture(gl.TEXTURE0 + glUnit);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        if (upload && source) {
          renderUtils.glTexImage(gl, source);
        }
        if (texture.isMipMappingEnabled()) {
          gl.generateMipmap(gl.TEXTURE_2D);
        } else {
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texture.getGLRepeat(gl, "x"));
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texture.getGLRepeat(gl, "y"));
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.getGLFilter(gl, "min"));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.getGLFilter(gl, "mag"));
        gl.activeTexture(gl.TEXTURE0);
      }
      getMaxDimensions() {
        if (!this.maxTextureDimensions) {
          this.maxTextureDimensions = renderUtils.glMaxTexture(this._context);
        }
        return this.maxTextureDimensions;
      }
      getCurrentRenderTarget() {
        return this._currentRenderTarget;
      }
      getCurrentObjectRenderer() {
        return this._currentObjectRenderer;
      }
      getMaxFloatPrecision() {
        return this._maxFloatPrecision;
      }
      getMaxIntPrecision() {
        return this._maxIntPrecision;
      }
      dispose() {
        if (this._canvas) {
          cleanUpCanvasMemory(this._canvas);
        }
        this._filterManager.dispose();
        this._currentObjectRenderer.dispose();
        this._defaultRenderTarget.dispose();
        for (const shader in this.shaders) {
          this.shaders[shader].dispose();
          delete this.shaders[shader];
        }
        this._removeContextEventListeners();
        const gl = this._context;
        const loseContextExtension = gl.getExtension("WEBGL_lose_context");
        if (loseContextExtension) {
          loseContextExtension.loseContext();
        }
      }
    };
    WebGLRenderer = _WebGLRenderer;
    WebGLRenderer.contextId = 0;
  }
});

// engine/v6/data/textureUVs.ts
var create, updateViaFrames, textureUVs;
var init_textureUVs = __esm({
  "engine/v6/data/textureUVs.ts"() {
    init_vector2();
    create = () => [
      new Vector2(0, 0),
      new Vector2(1, 0),
      new Vector2(1, 1),
      new Vector2(0, 1)
    ];
    updateViaFrames = (uvs, frame, baseFrame) => {
      const [uv1, uv2, uv3, uv4] = uvs;
      uv1.x = frame.x / baseFrame.width;
      uv1.y = frame.y / baseFrame.height;
      uv2.x = (frame.x + frame.width) / baseFrame.width;
      uv2.y = frame.y / baseFrame.height;
      uv3.x = (frame.x + frame.width) / baseFrame.width;
      uv3.y = (frame.y + frame.height) / baseFrame.height;
      uv4.x = frame.x / baseFrame.width;
      uv4.y = (frame.y + frame.height) / baseFrame.height;
      return uvs;
    };
    textureUVs = {
      create,
      updateViaFrames
    };
  }
});

// engine/sdk/core/engine/textures/texture.ts
var Texture;
var init_texture3 = __esm({
  "engine/sdk/core/engine/textures/texture.ts"() {
    init_textureUVs();
    init_globals();
    init_base_texture();
    Texture = class extends event_emitter_default {
      constructor(baseTexture, frame) {
        super();
        if (!(baseTexture instanceof BaseTexture)) {
          throw new Error("`baseTexture` should be an instance of BaseTexture");
        }
        this._uvs = textureUVs.create();
        this._frame = frame ? frame.clone() : new Rectangle(0, 0, 1, 1);
        this._frameLocked = Boolean(frame);
        this._onBaseTextureLoaded = this._onBaseTextureLoaded.bind(this);
        this._onBaseTextureUpdated = this._onBaseTextureUpdated.bind(this);
        this.setBaseTexture(baseTexture);
      }
      static fromImage(image) {
        const baseTexture = new BaseTexture(image);
        return new Texture(baseTexture);
      }
      static fromCanvas(canvas) {
        const baseTexture = new BaseTexture(canvas);
        return new Texture(baseTexture);
      }
      _onBaseTextureLoaded() {
        if (!this._frameLocked) {
          const frame = this._baseTexture.getFrame().clone();
          this.setFrame(frame);
        }
        this._baseTexture.on("update", this._onBaseTextureUpdated);
      }
      _onBaseTextureUpdated() {
        const { width, height } = this._baseTexture.getFrame();
        this._frame.width = width;
        this._frame.height = height;
        this.emit("update");
      }
      _updateUVs() {
        this._uvs = textureUVs.updateViaFrames(this._uvs, this._frame, this._baseTexture.getFrame());
      }
      getBaseTexture() {
        return this._baseTexture;
      }
      setBaseTexture(baseTexture) {
        this._baseTexture = baseTexture;
        if (!this._baseTexture.isLoaded()) {
          this._baseTexture.once("loaded", this._onBaseTextureLoaded);
        } else {
          const { width, height } = baseTexture.getFrame();
          if (!this._frameLocked) {
            this._frame = new Rectangle(0, 0, width, height);
          }
          this._onBaseTextureLoaded();
        }
      }
      getFrame() {
        return this._frame;
      }
      setFrame(frame) {
        this._frame = frame;
        this._updateUVs();
      }
      getWidth() {
        return this._frame.width;
      }
      getHeight() {
        return this._frame.height;
      }
      getUVs() {
        return this._uvs;
      }
      getDimensions() {
        return new Vector2(this._frame.width, this._frame.height);
      }
      dispose(baseTexture = true) {
        baseTexture && this._baseTexture.dispose();
      }
    };
  }
});

// engine/sdk/core/engine/textures/render-texture.ts
var isWebGL, RenderTexture;
var init_render_texture = __esm({
  "engine/sdk/core/engine/textures/render-texture.ts"() {
    init_constants();
    init_globals();
    init_canvas_filter_manager();
    init_webgl_filter_manager();
    init_canvas_render_target();
    init_webgl_render_target();
    init_base_texture();
    init_texture3();
    isWebGL = (renderer) => renderer._type === "webgl" /* WEBGL */;
    RenderTexture = class extends Texture {
      constructor(renderer, width = 100, height = 100, pixelRatio = 1) {
        super(new BaseTexture(), new Rectangle(0, 0, width, height));
        this._loaded = true;
        this._width = width;
        this._height = height;
        this._pixelRatio = pixelRatio;
        this._renderer = renderer;
        this._setupFilterManager();
        this._setupBuffer();
        this.setBaseTexture(this._renderTarget.getBaseTexture());
        this._updateUVs();
      }
      _setupFilterManager() {
        if (this._filterManager) {
          this._filterManager.dispose();
        }
        if (isWebGL(this._renderer)) {
          this._filterManager = new WebGLFilterManager(this._renderer);
        } else {
          this._filterManager = new CanvasFilterManager(this._renderer);
        }
        this._filterManager.resizeTo(new Vector2(this._width, this._height));
      }
      _setupBuffer() {
        if (this._renderTarget) {
          this._renderTarget.dispose();
        }
        if (isWebGL(this._renderer)) {
          this._renderTarget = new WebglRenderTarget(this._renderer, this._width, this._height, this._pixelRatio);
        } else {
          this._renderTarget = new CanvasRenderTarget(this._width, this._height, this._pixelRatio);
        }
      }
      clear(color) {
        this._renderTarget.clear(color);
      }
      resizeTo(dimensions) {
        if (this._width === dimensions.x && this._height === dimensions.y) {
          return;
        }
        this._width = dimensions.x;
        this._height = dimensions.y;
        this._frame.width = dimensions.x;
        this._frame.height = dimensions.y;
        this._renderTarget.resizeTo(dimensions);
        this._filterManager.resizeTo(dimensions);
      }
      render(displayObject) {
        if (isWebGL(this._renderer)) {
          this._renderWebGL(displayObject);
        } else {
          this._renderCanvas(displayObject);
        }
      }
      _renderWebGL(displayObject) {
        if (!isWebGL(this._renderer))
          return;
        this._renderTarget.activate();
        displayObject.getWorldTransform().reset();
        displayObject.getChildren().forEach((child) => {
          child.updateTransform();
        });
        const tempFilterManager = this._renderer.getFilterManager();
        this._renderer.setFilterManager(this._filterManager);
        this._renderer.renderDisplayObject(displayObject, this._renderTarget);
        this._renderer.setFilterManager(tempFilterManager);
      }
      _renderCanvas(displayObject) {
        if (isWebGL(this._renderer))
          return;
        displayObject.getWorldTransform().reset();
        displayObject.getChildren().forEach((child) => {
          child.updateTransform();
        });
        const tempFilterManager = this._renderer.getFilterManager();
        this._renderer.setFilterManager(this._filterManager);
        this._renderer.renderDisplayObject(displayObject, this._renderTarget);
        this._renderer.setFilterManager(tempFilterManager);
      }
      getRenderTarget() {
        return this._renderTarget;
      }
      dispose() {
        this._renderTarget.dispose();
        this._filterManager.dispose();
        super.dispose();
      }
    };
  }
});

// engine/shared/constants/index.js
var Events, constants_default;
var init_constants2 = __esm({
  "engine/shared/constants/index.js"() {
    Events = {
      EXPORT: "export",
      CLOSE: "close",
      OPERATION_CREATED: "operation:created",
      OPERATION_UPDATED: "operation:updated",
      OPERATION_REMOVED: "operation:removed",
      EDITOR_READY: "editor:ready",
      WINDOW_RESIZE: "window:resize",
      ZOOM_DONE: "editor:zoom_done",
      HISTORY_UNDO: "history:undo",
      HISTORY_UPDATED: "history:update",
      FEATURES_DISABLED: "editor:features:disabled",
      FEATURES_ENABLED: "editor:features:enabled",
      FEATURES_UPDATED: "editor:features:updated",
      TRANSFORM_REAPPLY_RATIO: "transform:reapply_ratio"
    };
    constants_default = {
      DEFAULTS: {
        FILTERS: [
          {
            identifier: "imgly_filters_duotone",
            defaultName: "DuoTone",
            assetFileName: "duotone",
            filters: [
              {
                identifier: "imgly_duotone_desert",
                defaultName: "Desert",
                lightColor: "#e1de9a",
                darkColor: "#cb2129"
              },
              {
                identifier: "imgly_duotone_peach",
                defaultName: "Peach",
                lightColor: "#e9abb8",
                darkColor: "#0040ff"
              },
              {
                identifier: "imgly_duotone_clash",
                defaultName: "Clash",
                lightColor: "#f41a0f",
                darkColor: "#23007c"
              },
              {
                identifier: "imgly_duotone_plum",
                defaultName: "Plum",
                lightColor: "#74d7ff",
                darkColor: "#23007c"
              },
              {
                identifier: "imgly_duotone_breezy",
                defaultName: "Breezy",
                lightColor: "#68fdff",
                darkColor: "#c20000"
              },
              {
                identifier: "imgly_duotone_deepblue",
                defaultName: "Deep Blue",
                lightColor: "#2de9eb",
                darkColor: "#58007c"
              },
              {
                identifier: "imgly_duotone_frog",
                defaultName: "Frog",
                lightColor: "#5bff60",
                darkColor: "#7f23a9"
              },
              {
                identifier: "imgly_duotone_sunset",
                defaultName: "Sunset",
                lightColor: "#f8ea46",
                darkColor: "#c400be"
              }
            ]
          },
          {
            identifier: "imgly_filters_bw",
            assetFileName: "b&w",
            defaultName: "Black & White",
            filters: [
              {
                identifier: "imgly_lut_ad1920",
                defaultName: "1920 A.D.",
                lutImage: "filters/imgly_lut_ad1920_5_5_128.png"
              },
              {
                identifier: "imgly_lut_bw",
                defaultName: "Greyed",
                lutImage: "filters/imgly_lut_bw_5_5_128.png"
              },
              {
                identifier: "imgly_lut_x400",
                defaultName: "Dusty",
                lutImage: "filters/imgly_lut_dusty_5_5_128.png"
              },
              {
                identifier: "imgly_lut_litho",
                defaultName: "Litho",
                lutImage: "filters/imgly_lut_litho_5_5_128.png"
              },
              {
                identifier: "imgly_lut_sepiahigh",
                defaultName: "Sepia",
                lutImage: "filters/imgly_lut_sepia_5_5_128.png"
              },
              {
                identifier: "imgly_lut_plate",
                defaultName: "Weathered",
                lutImage: "filters/imgly_lut_weathered_5_5_128.png"
              },
              {
                identifier: "imgly_lut_sin",
                defaultName: "Hard Stuff",
                lutImage: "filters/imgly_lut_hard_stuff_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              }
            ]
          },
          {
            identifier: "imgly_filters_retro",
            assetFileName: "vintage",
            defaultName: "Vintage",
            filters: [
              {
                identifier: "imgly_lut_blues",
                defaultName: "Polaroid",
                lutImage: "filters/imgly_lut_polaroid_5_5_128.png"
              },
              {
                identifier: "imgly_lut_front",
                defaultName: "Sunny 70s",
                lutImage: "filters/imgly_lut_sunny_70s_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_texas",
                defaultName: "Oldtimer",
                lutImage: "filters/imgly_lut_oldtimer_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_celsius",
                defaultName: "Inferno",
                lutImage: "filters/imgly_lut_inferno_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_cool",
                defaultName: "Snappy",
                lutImage: "filters/imgly_lut_snappy_5_5_128.png"
              }
            ]
          },
          {
            identifier: "imgly_filters_analog",
            assetFileName: "smooth",
            defaultName: "Smooth",
            filters: [
              {
                identifier: "imgly_lut_chest",
                defaultName: "Chestnut",
                lutImage: "filters/imgly_lut_chestnut_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_winter",
                defaultName: "Softly",
                lutImage: "filters/imgly_lut_softly_5_5_128.png"
              },
              {
                identifier: "imgly_lut_kdynamic",
                defaultName: "Pebble",
                lutImage: "filters/imgly_lut_pebble_5_5_128.png"
              },
              {
                identifier: "imgly_lut_fall",
                defaultName: "Moss",
                lutImage: "filters/imgly_lut_moss_5_5_128.png"
              },
              {
                identifier: "imgly_lut_lenin",
                defaultName: "Lemon",
                lutImage: "filters/imgly_lut_lemon_5_5_128.png"
              },
              {
                identifier: "imgly_lut_pola669",
                defaultName: "Green Gap",
                lutImage: "filters/imgly_lut_green_gap_5_5_128.png"
              }
            ]
          },
          {
            identifier: "imgly_filters_winter",
            assetFileName: "cold",
            defaultName: "Cold",
            filters: [
              {
                identifier: "imgly_lut_elder",
                defaultName: "Colla",
                lutImage: "filters/imgly_lut_colla_5_5_128.png"
              },
              {
                identifier: "imgly_lut_orchid",
                defaultName: "Solanus",
                lutImage: "filters/imgly_lut_solanus_5_5_128.png"
              },
              {
                identifier: "imgly_lut_bleached",
                defaultName: "Kalmen",
                lutImage: "filters/imgly_lut_kalmen_5_5_128.png"
              },
              {
                identifier: "imgly_lut_bleachedblue",
                defaultName: "Joran",
                lutImage: "filters/imgly_lut_joran_5_5_128.png"
              },
              {
                identifier: "imgly_lut_breeze",
                defaultName: "Levante",
                lutImage: "filters/imgly_lut_levante_5_5_128.png"
              },
              {
                identifier: "imgly_lut_blueshadows",
                defaultName: "Zephyr",
                lutImage: "filters/imgly_lut_zephyr_5_5_128.png"
              }
            ]
          },
          {
            identifier: "imgly_filters_summer",
            assetFileName: "warm",
            defaultName: "Warm",
            filters: [
              {
                identifier: "imgly_lut_sunset",
                defaultName: "Golden",
                lutImage: "filters/imgly_lut_golden_5_5_128.png"
              },
              {
                identifier: "imgly_lut_eighties",
                defaultName: "Low Fire",
                lutImage: "filters/imgly_lut_low_fire_5_5_128.png"
              },
              {
                identifier: "imgly_lut_evening",
                defaultName: "Sunrise",
                lutImage: "filters/imgly_lut_sunrise_5_5_128.png"
              },
              {
                identifier: "imgly_lut_k2",
                defaultName: "Flat Black",
                lutImage: "filters/imgly_lut_flat_black_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_nogreen",
                defaultName: "Pumpkin",
                lutImage: "filters/imgly_lut_pumpkin_5_5_128.png"
              }
            ]
          },
          {
            identifier: "imgly_filters_legacy",
            defaultName: "Legacy",
            assetFileName: "legacy",
            filters: [
              {
                identifier: "imgly_lut_ancient",
                defaultName: "Ancient",
                lutImage: "filters/imgly_lut_ancient_5_5_128.png"
              },
              {
                identifier: "imgly_lut_cottoncandy",
                defaultName: "Candy",
                lutImage: "filters/imgly_lut_cottoncandy_5_5_128.png"
              },
              {
                identifier: "imgly_lut_classic",
                defaultName: "Classic",
                lutImage: "filters/imgly_lut_classic_5_5_128.png"
              },
              {
                identifier: "imgly_lut_colorful",
                defaultName: "Colorful",
                lutImage: "filters/imgly_lut_colorful_5_5_128.png"
              },
              {
                identifier: "imgly_lut_creamy",
                defaultName: "Creamy",
                lutImage: "filters/imgly_lut_creamy_5_5_128.png"
              },
              {
                identifier: "imgly_lut_fixie",
                defaultName: "Fixie",
                lutImage: "filters/imgly_lut_fixie_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_food",
                defaultName: "Food",
                lutImage: "filters/imgly_lut_food_5_5_128.png"
              },
              {
                identifier: "imgly_lut_fridge",
                defaultName: "Fridge",
                lutImage: "filters/imgly_lut_fridge_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_glam",
                defaultName: "Glam",
                lutImage: "filters/imgly_lut_glam_5_5_128.png"
              },
              {
                identifier: "imgly_lut_gobblin",
                defaultName: "Gobblin",
                lutImage: "filters/imgly_lut_gobblin_5_5_128.png"
              },
              {
                identifier: "imgly_lut_highcontrast",
                defaultName: "Hicon",
                lutImage: "filters/imgly_lut_highcontrast_5_5_128.png"
              },
              {
                identifier: "imgly_lut_highcarb",
                defaultName: "High Carb",
                lutImage: "filters/imgly_lut_highcarb_5_5_128.png"
              },
              {
                identifier: "imgly_lut_k1",
                defaultName: "K1",
                lutImage: "filters/imgly_lut_k1_5_5_128.png"
              },
              {
                identifier: "imgly_lut_k6",
                defaultName: "K6",
                lutImage: "filters/imgly_lut_k6_5_5_128.png"
              },
              {
                identifier: "imgly_lut_keen",
                defaultName: "Keen",
                lutImage: "filters/imgly_lut_keen_5_5_128.png"
              },
              {
                identifier: "imgly_lut_lomo",
                defaultName: "Lomo",
                lutImage: "filters/imgly_lut_lomo_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_lomo100",
                defaultName: "Lomo 100",
                lutImage: "filters/imgly_lut_lomo100_5_5_128.png"
              },
              {
                identifier: "imgly_lut_lucid",
                defaultName: "Lucid",
                lutImage: "filters/imgly_lut_lucid_5_5_128.png"
              },
              {
                identifier: "imgly_lut_mellow",
                defaultName: "Mellow",
                lutImage: "filters/imgly_lut_mellow_8_8_512.png",
                resolution: 512,
                horizontalTileCount: 8,
                verticalTileCount: 8
              },
              {
                identifier: "imgly_lut_neat",
                defaultName: "Neat",
                lutImage: "filters/imgly_lut_neat_5_5_128.png"
              },
              {
                identifier: "imgly_lut_pale",
                defaultName: "Pale",
                lutImage: "filters/imgly_lut_pale_5_5_128.png"
              },
              {
                identifier: "imgly_lut_pitched",
                defaultName: "Pitched",
                lutImage: "filters/imgly_lut_pitched_5_5_128.png"
              },
              {
                identifier: "imgly_lut_polasx",
                defaultName: "Pola SX",
                lutImage: "filters/imgly_lut_polasx_5_5_128.png"
              },
              {
                identifier: "imgly_lut_pro400",
                defaultName: "Pro 400",
                lutImage: "filters/imgly_lut_pro400_5_5_128.png"
              },
              {
                identifier: "imgly_lut_quozi",
                defaultName: "Quozi",
                lutImage: "filters/imgly_lut_quozi_5_5_128.png"
              },
              {
                identifier: "imgly_lut_settled",
                defaultName: "Settled",
                lutImage: "filters/imgly_lut_settled_5_5_128.png"
              },
              {
                identifier: "imgly_lut_seventies",
                defaultName: "Seventies",
                lutImage: "filters/imgly_lut_seventies_5_5_128.png"
              },
              {
                identifier: "imgly_lut_soft",
                defaultName: "Soft",
                lutImage: "filters/imgly_lut_soft_5_5_128.png"
              },
              {
                identifier: "imgly_lut_steel",
                defaultName: "Steel",
                lutImage: "filters/imgly_lut_steel_5_5_128.png"
              },
              {
                identifier: "imgly_lut_summer",
                defaultName: "Summer",
                lutImage: "filters/imgly_lut_summer_5_5_128.png"
              },
              {
                identifier: "imgly_lut_tender",
                defaultName: "Tender",
                lutImage: "filters/imgly_lut_tender_5_5_128.png"
              },
              {
                identifier: "imgly_lut_twilight",
                defaultName: "Twilight",
                lutImage: "filters/imgly_lut_twilight_5_5_128.png"
              }
            ]
          }
        ],
        OVERLAYS: [
          {
            identifier: "imgly_overlay_golden",
            defaultName: "Golden",
            image: "overlays/imgly_overlay_golden.jpg",
            thumbnail: "overlays/imgly_overlay_golden_thumb.jpg",
            blendMode: "lighten"
          },
          {
            identifier: "imgly_overlay_bokeh",
            defaultName: "Bokeh",
            image: "overlays/imgly_overlay_bokeh.jpg",
            thumbnail: "overlays/imgly_overlay_bokeh_thumb.jpg",
            blendMode: "lighten"
          },
          {
            identifier: "imgly_overlay_hearts",
            defaultName: "Hearts",
            image: "overlays/imgly_overlay_hearts.jpg",
            thumbnail: "overlays/imgly_overlay_hearts_thumb.jpg",
            blendMode: "screen"
          },
          {
            identifier: "imgly_overlay_lightleak1",
            defaultName: "Light Leak",
            image: "overlays/imgly_overlay_lightleak1.jpg",
            thumbnail: "overlays/imgly_overlay_lightleak1_thumb.jpg",
            blendMode: "screen"
          },
          {
            identifier: "imgly_overlay_lightleak2",
            defaultName: "Light Leak 2",
            image: "overlays/imgly_overlay_lightleak2.jpg",
            thumbnail: "overlays/imgly_overlay_lightleak2_thumb.jpg",
            blendMode: "lighten"
          },
          {
            identifier: "imgly_overlay_rain",
            defaultName: "Rain",
            image: "overlays/imgly_overlay_rain.jpg",
            thumbnail: "overlays/imgly_overlay_rain_thumb.jpg",
            blendMode: "overlay"
          },
          {
            identifier: "imgly_overlay_wood",
            defaultName: "Wood",
            image: "overlays/imgly_overlay_wood.jpg",
            thumbnail: "overlays/imgly_overlay_wood_thumb.jpg",
            blendMode: "multiply"
          },
          {
            identifier: "imgly_overlay_mosaic",
            defaultName: "Mosaic",
            image: "overlays/imgly_overlay_mosaic.jpg",
            thumbnail: "overlays/imgly_overlay_mosaic_thumb.jpg",
            blendMode: "multiply"
          },
          {
            identifier: "imgly_overlay_chop",
            defaultName: "Chop",
            image: "overlays/imgly_overlay_chop.jpg",
            thumbnail: "overlays/imgly_overlay_chop_thumb.jpg",
            blendMode: "multiply"
          },
          {
            identifier: "imgly_overlay_vintage",
            defaultName: "Vintage",
            image: "overlays/imgly_overlay_vintage.jpg",
            thumbnail: "overlays/imgly_overlay_vintage_thumb.jpg",
            blendMode: "darken"
          },
          {
            identifier: "imgly_overlay_metal",
            defaultName: "Metal",
            image: "overlays/imgly_overlay_metal.jpg",
            thumbnail: "overlays/imgly_overlay_metal_thumb.jpg",
            blendMode: "overlay"
          },
          {
            identifier: "imgly_overlay_paper",
            defaultName: "Paper",
            image: "overlays/imgly_overlay_paper.jpg",
            thumbnail: "overlays/imgly_overlay_paper_thumb.jpg",
            blendMode: "multiply"
          },
          {
            identifier: "imgly_overlay_painting",
            defaultName: "Painting",
            image: "overlays/imgly_overlay_painting.jpg",
            thumbnail: "overlays/imgly_overlay_painting_thumb.jpg",
            blendMode: "overlay"
          },
          {
            identifier: "imgly_overlay_grain",
            defaultName: "Grain",
            image: "overlays/imgly_overlay_grain.jpg",
            thumbnail: "overlays/imgly_overlay_grain_thumb.jpg",
            blendMode: "overlay"
          },
          {
            identifier: "imgly_overlay_clouds",
            defaultName: "Clouds",
            image: "overlays/imgly_overlay_clouds.jpg",
            thumbnail: "overlays/imgly_overlay_clouds_thumb.jpg",
            blendMode: "softLight"
          },
          {
            identifier: "imgly_overlay_wall1",
            defaultName: "Wall",
            image: "overlays/imgly_overlay_wall1.jpg",
            thumbnail: "overlays/imgly_overlay_wall1_thumb.jpg",
            blendMode: "lighten"
          },
          {
            identifier: "imgly_overlay_wall2",
            defaultName: "Wall 2",
            image: "overlays/imgly_overlay_wall2.jpg",
            thumbnail: "overlays/imgly_overlay_wall2_thumb.jpg",
            blendMode: "overlay"
          }
        ],
        FRAME_CATEGORIES: [
          {
            identifier: "imgly_frame_generic",
            defaultName: "Generic",
            metaData: {
              backgroundImage: "frames/generic.png"
            },
            frames: [
              {
                identifier: "imgly_frame_dia",
                defaultName: "Dia",
                layoutMode: "horizontal-inside",
                thumbnail: "frames/imgly_frame_dia/imgly_frame_dia_thumb.png",
                imageGroups: {
                  top: {
                    mid: {
                      image: "frames/imgly_frame_dia/imgly_frame_dia_top.png",
                      mode: "repeat"
                    }
                  },
                  left: {
                    start: "frames/imgly_frame_dia/imgly_frame_dia_top_corner_left.png",
                    mid: "frames/imgly_frame_dia/imgly_frame_dia_left.png",
                    end: "frames/imgly_frame_dia/imgly_frame_dia_bottom_corner_left.png"
                  },
                  right: {
                    start: "frames/imgly_frame_dia/imgly_frame_dia_top_corner_right.png",
                    mid: "frames/imgly_frame_dia/imgly_frame_dia_right.png",
                    end: "frames/imgly_frame_dia/imgly_frame_dia_bottom_corner_right.png"
                  },
                  bottom: {
                    mid: {
                      image: "frames/imgly_frame_dia/imgly_frame_dia_bottom.png",
                      mode: "repeat"
                    }
                  }
                }
              },
              {
                identifier: "imgly_frame_art_decor",
                defaultName: "Art Decor",
                tintable: true,
                layoutMode: "horizontal-inside",
                thumbnail: "frames/imgly_frame_art_decor/imgly_frame_art_decor_thumb.png",
                imageGroups: {
                  top: {
                    start: "frames/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_top.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_right.png"
                  },
                  left: {
                    mid: {
                      image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_left.png",
                      mode: "stretch"
                    }
                  },
                  right: {
                    mid: {
                      image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_right.png",
                      mode: "stretch"
                    }
                  },
                  bottom: {
                    start: "frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_right.png"
                  }
                }
              },
              {
                identifier: "imgly_frame_black_passepartout",
                defaultName: "Black Passepartout",
                layoutMode: "horizontal-inside",
                thumbnail: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_thumb.png",
                imageGroups: {
                  top: {
                    start: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_right.png"
                  },
                  left: {
                    mid: {
                      image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_left.png",
                      mode: "stretch"
                    }
                  },
                  right: {
                    mid: {
                      image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_right.png",
                      mode: "stretch"
                    }
                  },
                  bottom: {
                    start: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_right.png"
                  }
                }
              },
              {
                identifier: "imgly_frame_lowpoly_shadow",
                defaultName: "Low Poly",
                layoutMode: "horizontal-inside",
                thumbnail: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_thumb.png",
                imageGroups: {
                  top: {
                    start: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_right.png"
                  },
                  left: {
                    mid: {
                      image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_left.png",
                      mode: "stretch"
                    }
                  },
                  right: {
                    mid: {
                      image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_right.png",
                      mode: "stretch"
                    }
                  },
                  bottom: {
                    start: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_right.png"
                  }
                }
              },
              {
                identifier: "imgly_frame_wood_passepartout",
                defaultName: "Wood Passepartout",
                layoutMode: "horizontal-inside",
                thumbnail: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_thumb.png",
                imageGroups: {
                  top: {
                    start: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_right.png"
                  },
                  left: {
                    mid: {
                      image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_left.png",
                      mode: "stretch"
                    }
                  },
                  right: {
                    mid: {
                      image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_right.png",
                      mode: "stretch"
                    }
                  },
                  bottom: {
                    start: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_left.png",
                    mid: {
                      image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom.png",
                      mode: "stretch"
                    },
                    end: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_right.png"
                  }
                }
              }
            ]
          }
        ],
        STICKER_CATEGORIES: [
          {
            identifier: "imgly_sticker_emoticons",
            defaultName: "Emoticons",
            metaData: {
              backgroundImage: "stickers/emoticons/background.png"
            },
            stickers: [
              {
                identifier: "imgly_sticker_emoticons_alien",
                defaultName: "Alien",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_alien.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_alien.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_alien.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_alien.png"
                    ],
                    width: 1e3,
                    height: 935
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_angel",
                defaultName: "Angel",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_angel.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_angel.png"
                    ],
                    width: 62,
                    height: 64
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_angel.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_angel.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_angry",
                defaultName: "Angry",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_angry.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_angry.png"
                    ],
                    width: 62,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_angry.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_angry.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_anxious",
                defaultName: "Anxious",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_anxious.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_anxious.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_anxious.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_anxious.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_asleep",
                defaultName: "Asleep",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_asleep.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_asleep.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_asleep.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_asleep.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_attention",
                defaultName: "Attention",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_attention.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_attention.png"
                    ],
                    width: 62,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_attention.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_attention.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_baby_chicken",
                defaultName: "Baby Chicken",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_baby_chicken.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_baby_chicken.png"
                    ],
                    width: 61,
                    height: 42
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_baby_chicken.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_baby_chicken.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_batman",
                defaultName: "Batman",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_batman.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_batman.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_batman.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_batman.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_beer",
                defaultName: "Beer",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_beer.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_beer.png"
                    ],
                    width: 62,
                    height: 59
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_beer.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_beer.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_blush",
                defaultName: "Blush",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_blush.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_blush.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_blush.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_blush.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_boxer",
                defaultName: "Boxer",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_boxer.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_boxer.png"
                    ],
                    width: 62,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_boxer.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_boxer.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_business",
                defaultName: "Business",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_business.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_business.png"
                    ],
                    width: 60,
                    height: 63
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_business.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_business.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_chicken",
                defaultName: "Chicken",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_chicken.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_chicken.png"
                    ],
                    width: 63,
                    height: 55
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_chicken.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_chicken.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_cool",
                defaultName: "Cool",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_cool.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_cool.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_cool.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_cool.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_cry",
                defaultName: "Cry",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_cry.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_cry.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_cry.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_cry.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_deceased",
                defaultName: "Deceased",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_deceased.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_deceased.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_deceased.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_deceased.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_devil",
                defaultName: "Devil",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_devil.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_devil.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_devil.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_devil.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_duckface",
                defaultName: "Duckface",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_duckface.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_duckface.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_duckface.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_duckface.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_furious",
                defaultName: "Furious",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_furious.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_furious.png"
                    ],
                    width: 62,
                    height: 61
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_furious.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_furious.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_grin",
                defaultName: "Grin",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_grin.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_grin.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_grin.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_grin.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_guitar",
                defaultName: "Guitar",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_guitar.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_guitar.png"
                    ],
                    width: 64,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_guitar.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_guitar.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_harry_potter",
                defaultName: "Harry Potter",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_harry_potter.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_harry_potter.png"
                    ],
                    width: 64,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_harry_potter.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_harry_potter.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_hippie",
                defaultName: "Hippie",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_hippie.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_hippie.png"
                    ],
                    width: 62,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_hippie.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_hippie.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_hitman",
                defaultName: "Hitman",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_hitman.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_hitman.png"
                    ],
                    width: 64,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_hitman.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_hitman.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_humourous",
                defaultName: "Humourous",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_humourous.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_humourous.png"
                    ],
                    width: 64,
                    height: 64
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_humourous.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_humourous.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_idea",
                defaultName: "Idea",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_idea.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_idea.png"
                    ],
                    width: 64,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_idea.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_idea.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_impatient",
                defaultName: "Impatient",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_impatient.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_impatient.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_impatient.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_impatient.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_kiss",
                defaultName: "Kiss",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_kiss.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_kiss.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_kiss.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_kiss.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_kisses",
                defaultName: "Kisses",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_kisses.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_kisses.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_kisses.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_kisses.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_laugh",
                defaultName: "Laugh",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_laugh.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_laugh.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_laugh.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_laugh.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_loud_cry",
                defaultName: "Loud Cry",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_loud_cry.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_loud_cry.png"
                    ],
                    width: 64,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_loud_cry.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_loud_cry.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_loving",
                defaultName: "Loving",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_loving.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_loving.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_loving.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_loving.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_masked",
                defaultName: "Masked",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_masked.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_masked.png"
                    ],
                    width: 62,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_masked.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_masked.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_music",
                defaultName: "Music",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_music.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_music.png"
                    ],
                    width: 62,
                    height: 54
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_music.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_music.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_nerd",
                defaultName: "Nerd",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_nerd.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_nerd.png"
                    ]
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_nerd.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_nerd.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_ninja",
                defaultName: "Ninja",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_ninja.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_ninja.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_ninja.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_ninja.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_not_speaking_to_you",
                defaultName: "Not Speaking To You",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_not_speaking_to_you.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_not_speaking_to_you.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_not_speaking_to_you.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_not_speaking_to_you.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_pig",
                defaultName: "Pig",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_pig.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_pig.png"
                    ],
                    width: 63,
                    height: 41
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_pig.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_pig.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_pumpkin",
                defaultName: "Pumpkin",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_pumpkin.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_pumpkin.png"
                    ],
                    width: 62,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_pumpkin.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_pumpkin.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_question",
                defaultName: "Question",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_question.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_question.png"
                    ],
                    width: 62,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_question.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_question.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_rabbit",
                defaultName: "Rabbit",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_rabbit.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_rabbit.png"
                    ],
                    width: 65,
                    height: 47
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_rabbit.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_rabbit.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_sad",
                defaultName: "Sad",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sad.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sad.png"
                    ]
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sad.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sad.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_sick",
                defaultName: "Sick",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sick.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sick.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sick.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sick.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_skateboard",
                defaultName: "Skateboard",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_skateboard.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_skateboard.png"
                    ],
                    width: 62,
                    height: 64
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_skateboard.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_skateboard.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_skull",
                defaultName: "Skull",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_skull.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_skull.png"
                    ],
                    width: 62,
                    height: 62
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_skull.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_skull.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_sleepy",
                defaultName: "Sleepy",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sleepy.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sleepy.png"
                    ],
                    width: 62,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sleepy.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sleepy.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_smile",
                defaultName: "Smile",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_smile.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_smile.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_smile.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_smile.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_smoking",
                defaultName: "Smoking",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_smoking.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_smoking.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_smoking.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_smoking.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_sobbing",
                defaultName: "Sobbing",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sobbing.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sobbing.png"
                    ],
                    width: 62,
                    height: 59
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sobbing.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sobbing.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_star",
                defaultName: "Star",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_star.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_star.png"
                    ],
                    width: 64,
                    height: 64
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_star.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_star.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_steaming_furious",
                defaultName: "Steaming Furious",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_steaming_furious.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_steaming_furious.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_steaming_furious.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_steaming_furious.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_sunbathing",
                defaultName: "Sunbathing",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sunbathing.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sunbathing.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_sunbathing.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sunbathing.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_tired",
                defaultName: "Tired",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_tired.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_tired.png"
                    ],
                    width: 62,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_tired.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_tired.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_tongue_out_wink",
                defaultName: "Tongue Out Wink",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_tongue_out_wink.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_tongue_out_wink.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_tongue_out_wink.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_tongue_out_wink.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_wave",
                defaultName: "Wave",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wave.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wave.png"
                    ],
                    width: 62,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wave.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wave.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_wide_grin",
                defaultName: "Wide Grin",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wide_grin.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wide_grin.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wide_grin.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wide_grin.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_wink",
                defaultName: "Wink",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wink.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wink.png"
                    ],
                    width: 62,
                    height: 58
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wink.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wink.png"
                    ]
                  }
                }
              },
              {
                identifier: "imgly_sticker_emoticons_wrestler",
                defaultName: "Wrestler",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wrestler.svg",
                      "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wrestler.png"
                    ],
                    width: 62,
                    height: 60
                  },
                  mediaBase: {
                    uris: [
                      "stickers/emoticons/stickers/imgly_sticker_emoticons_wrestler.svg",
                      "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wrestler.png"
                    ]
                  }
                }
              }
            ]
          },
          {
            identifier: "imgly_sticker_shapes",
            defaultName: "Shapes",
            metaData: {
              backgroundImage: "stickers/shapes/background.png"
            },
            stickers: [
              {
                identifier: "imgly_sticker_shapes_arrow_02",
                defaultName: "Arrow 1",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_arrow_02.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_arrow_02.png"
                    ],
                    width: 2e3,
                    height: 1236
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_arrow_02.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_arrow_02.png"
                    ],
                    width: 2e3,
                    height: 1236
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_arrow_03",
                defaultName: "Arrow 2",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_arrow_03.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_arrow_03.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_arrow_03.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_arrow_03.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_01",
                defaultName: "Badge 1",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_01.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_01.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_01.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_01.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_04",
                defaultName: "Badge 2",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_04.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_04.png"
                    ],
                    width: 2e3,
                    height: 1589
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_04.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_04.png"
                    ],
                    width: 2e3,
                    height: 1589
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_06",
                defaultName: "Badge 3",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_06.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_06.png"
                    ],
                    width: 2e3,
                    height: 1733
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_06.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_06.png"
                    ],
                    width: 2e3,
                    height: 1733
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_08",
                defaultName: "Badge 4",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_08.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_08.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_08.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_08.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_11",
                defaultName: "Badge 5",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_11.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_11.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_11.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_11.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_12",
                defaultName: "Badge 6",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_12.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_12.png"
                    ],
                    width: 2001,
                    height: 1903
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_12.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_12.png"
                    ],
                    width: 2001,
                    height: 1903
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_13",
                defaultName: "Badge 7",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_13.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_13.png"
                    ],
                    width: 2e3,
                    height: 1718
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_13.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_13.png"
                    ],
                    width: 2e3,
                    height: 1718
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_15",
                defaultName: "Badge 8",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_15.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_15.png"
                    ],
                    width: 1618,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_15.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_15.png"
                    ],
                    width: 1618,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_18",
                defaultName: "Badge 9",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_18.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_18.png"
                    ],
                    width: 1198,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_18.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_18.png"
                    ],
                    width: 1198,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_19",
                defaultName: "Badge 10",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_19.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_19.png"
                    ],
                    width: 2127,
                    height: 481
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_19.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_19.png"
                    ],
                    width: 2127,
                    height: 481
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_20",
                defaultName: "Badge 11",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_20.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_20.png"
                    ],
                    width: 2e3,
                    height: 1404
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_20.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_20.png"
                    ],
                    width: 2e3,
                    height: 1404
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_28",
                defaultName: "Badge 12",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_28.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_28.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_28.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_28.png"
                    ],
                    width: 2e3,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_32",
                defaultName: "Badge 13",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_32.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_32.png"
                    ],
                    width: 1960,
                    height: 2e3
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_32.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_32.png"
                    ],
                    width: 1960,
                    height: 2e3
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_35",
                defaultName: "Badge 14",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_35.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_35.png"
                    ],
                    width: 2e3,
                    height: 2002
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_35.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_35.png"
                    ],
                    width: 2e3,
                    height: 2002
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_badge_36",
                defaultName: "Badge 15",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_36.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_36.png"
                    ],
                    width: 2e3,
                    height: 1668
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_badge_36.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_36.png"
                    ],
                    width: 2e3,
                    height: 1668
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_spray_01",
                defaultName: "Spray 1",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_spray_01.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_01.png"
                    ],
                    width: 1912,
                    height: 2039
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_spray_01.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_spray_01.png"
                    ],
                    width: 1912,
                    height: 2039
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_spray_03",
                defaultName: "Spray 2",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_spray_03.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_03.png"
                    ],
                    width: 1681,
                    height: 1779
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_spray_03.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_spray_03.png"
                    ],
                    width: 1681,
                    height: 1779
                  }
                }
              },
              {
                identifier: "imgly_sticker_shapes_spray_04",
                defaultName: "Spray 3",
                tintMode: "solid",
                images: {
                  mediaThumb: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_spray_04.svg",
                      "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_04.png"
                    ],
                    width: 1407,
                    height: 2248
                  },
                  mediaBase: {
                    uris: [
                      "stickers/shapes/stickers/imgly_sticker_shapes_spray_04.svg",
                      "stickers/shapes/stickers/base/imgly_sticker_shapes_spray_04.png"
                    ],
                    width: 1407,
                    height: 2248
                  }
                }
              }
            ]
          }
        ]
      }
    };
  }
});

// engine/sdk/core/vendor/jsbn.js
function BigInteger(a, b, c) {
  if (a != null)
    if (typeof a == "number")
      this.fromNumber(a, b, c);
    else if (b == null && typeof a != "string")
      this.fromString(a, 256);
    else
      this.fromString(a, b);
}
function nbi() {
  return new BigInteger(null);
}
function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c;
    c = Math.floor(v / 67108864);
    w[j++] = v & 67108863;
  }
  return c;
}
function am2(i, x, w, j, c, n) {
  var xl = x & 32767, xh = x >> 15;
  while (--n >= 0) {
    var l = this[i] & 32767;
    var h = this[i++] >> 15;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
    w[j++] = l & 1073741823;
  }
  return c;
}
function am3(i, x, w, j, c, n) {
  var xl = x & 16383, xh = x >> 14;
  while (--n >= 0) {
    var l = this[i] & 16383;
    var h = this[i++] >> 14;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 16383) << 14) + w[j] + c;
    c = (l >> 28) + (m >> 14) + xh * h;
    w[j++] = l & 268435455;
  }
  return c;
}
function int2char(n) {
  return BI_RM.charAt(n);
}
function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)];
  return c == null ? -1 : c;
}
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i)
    r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}
function bnpFromInt(x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0)
    this[0] = x;
  else if (x < -1)
    this[0] = x + this.DV;
  else
    this.t = 0;
}
function nbv(i) {
  var r = nbi();
  r.fromInt(i);
  return r;
}
function bnpFromString(s, b) {
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 256)
    k = 8;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else {
    this.fromRadix(s, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while (--i >= 0) {
    var x = k == 8 ? s[i] & 255 : intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == "-")
        mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this[this.t++] = x;
    else if (sh + k > this.DB) {
      this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this[this.t++] = x >> this.DB - sh;
    } else
      this[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB)
      sh -= this.DB;
  }
  if (k == 8 && (s[0] & 128) != 0) {
    this.s = -1;
    if (sh > 0)
      this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }
  this.clamp();
  if (mi)
    BigInteger.ZERO.subTo(this, this);
}
function bnpClamp() {
  var c = this.s & this.DM;
  while (this.t > 0 && this[this.t - 1] == c)
    --this.t;
}
function bnToString(b) {
  if (this.s < 0)
    return "-" + this.negate().toString(b);
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else
    return this.toRadix(b);
  var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
  var p = this.DB - i * this.DB % k;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) > 0) {
      m = true;
      r = int2char(d);
    }
    while (i >= 0) {
      if (p < k) {
        d = (this[i] & (1 << p) - 1) << k - p;
        d |= this[--i] >> (p += this.DB - k);
      } else {
        d = this[i] >> (p -= k) & km;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if (d > 0)
        m = true;
      if (m)
        r += int2char(d);
    }
  }
  return m ? r : "0";
}
function bnNegate() {
  var r = nbi();
  BigInteger.ZERO.subTo(this, r);
  return r;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a) {
  var r = this.s - a.s;
  if (r != 0)
    return r;
  var i = this.t;
  r = i - a.t;
  if (r != 0)
    return this.s < 0 ? -r : r;
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0)
      return r;
  return 0;
}
function nbits(x) {
  var r = 1, t;
  if ((t = x >>> 16) != 0) {
    x = t;
    r += 16;
  }
  if ((t = x >> 8) != 0) {
    x = t;
    r += 8;
  }
  if ((t = x >> 4) != 0) {
    x = t;
    r += 4;
  }
  if ((t = x >> 2) != 0) {
    x = t;
    r += 2;
  }
  if ((t = x >> 1) != 0) {
    x = t;
    r += 1;
  }
  return r;
}
function bnBitLength() {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n, r) {
  var i;
  for (i = this.t - 1; i >= 0; --i)
    r[i + n] = this[i];
  for (i = n - 1; i >= 0; --i)
    r[i] = 0;
  r.t = this.t + n;
  r.s = this.s;
}
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i)
    r[i - n] = this[i];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
}
function bnpLShiftTo(n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
  for (i = this.t - 1; i >= 0; --i) {
    r[i + ds + 1] = this[i] >> cbs | c;
    c = (this[i] & bm) << bs;
  }
  for (i = ds - 1; i >= 0; --i)
    r[i] = 0;
  r[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
}
function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r[0] = this[ds] >> bs;
  for (var i = ds + 1; i < this.t; ++i) {
    r[i - ds - 1] |= (this[i] & bm) << cbs;
    r[i - ds] = this[i] >> bs;
  }
  if (bs > 0)
    r[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
}
function bnpSubTo(a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] - a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c -= a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1)
    r[i++] = this.DV + c;
  else if (c > 0)
    r[i++] = c;
  r.t = i;
  r.clamp();
}
function bnpMultiplyTo(a, r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i + y.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < y.t; ++i)
    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
  r.s = 0;
  r.clamp();
  if (this.s != a.s)
    BigInteger.ZERO.subTo(r, r);
}
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2 * x.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1);
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV;
      r[i + x.t + 1] = 1;
    }
  }
  if (r.t > 0)
    r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
}
function bnpDivRemTo(m, q, r) {
  var pm = m.abs();
  if (pm.t <= 0)
    return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q != null)
      q.fromInt(0);
    if (r != null)
      this.copyTo(r);
    return;
  }
  if (r == null)
    r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB - nbits(pm[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y);
    pt.copyTo(r);
  }
  var ys = y.t;
  var y0 = y[ys - 1];
  if (y0 == 0)
    return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
  var i = r.t, j = i - ys, t = q == null ? nbi() : q;
  y.dlShiftTo(j, t);
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t, r);
  }
  BigInteger.ONE.dlShiftTo(ys, t);
  t.subTo(y, y);
  while (y.t < ys)
    y[y.t++] = 0;
  while (--j >= 0) {
    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
      y.dlShiftTo(j, t);
      r.subTo(t, r);
      while (r[i] < --qd)
        r.subTo(t, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms)
      BigInteger.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  if (nsh > 0)
    r.rShiftTo(nsh, r);
  if (ts < 0)
    BigInteger.ZERO.subTo(r, r);
}
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
    a.subTo(r, r);
  return r;
}
function Classic(m) {
  this.m = m;
}
function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0)
    return x.mod(this.m);
  else
    return x;
}
function cRevert(x) {
  return x;
}
function cReduce(x) {
  x.divRemTo(this.m, null, x);
}
function cMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
function cSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var x = this[0];
  if ((x & 1) == 0)
    return 0;
  var y = x & 3;
  y = y * (2 - (x & 15) * y) & 15;
  y = y * (2 - (x & 255) * y) & 255;
  y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
  y = y * (2 - x * y % this.DV) % this.DV;
  return y > 0 ? this.DV - y : -y;
}
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m.DB - 15) - 1;
  this.mt2 = 2 * m.t;
}
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
    this.m.subTo(r, r);
  return r;
}
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}
function montReduce(x) {
  while (x.t <= this.mt2)
    x[x.t++] = 0;
  for (var i = 0; i < this.m.t; ++i) {
    var j = x[i] & 32767;
    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
    j = i + this.m.t;
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
    while (x[j] >= x.DV) {
      x[j] -= x.DV;
      x[++j]++;
    }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
}
function montSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function montMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
function bnpIsEven() {
  return (this.t > 0 ? this[0] & 1 : this.s) == 0;
}
function bnpExp(e, z) {
  if (e > 4294967295 || e < 1)
    return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
  g.copyTo(r);
  while (--i >= 0) {
    z.sqrTo(r, r2);
    if ((e & 1 << i) > 0)
      z.mulTo(r2, g, r);
    else {
      var t = r;
      r = r2;
      r2 = t;
    }
  }
  return z.revert(r);
}
function bnModPowInt(e, m) {
  var z;
  if (e < 256 || m.isEven())
    z = new Classic(m);
  else
    z = new Montgomery(m);
  return this.exp(e, z);
}
function bnClone() {
  var r = nbi();
  this.copyTo(r);
  return r;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    else if (this.t == 0)
      return -1;
  } else if (this.t == 1)
    return this[0];
  else if (this.t == 0)
    return 0;
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this[0] << 16 >> 16;
}
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
}
function bnSigNum() {
  if (this.s < 0)
    return -1;
  else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
    return 0;
  else
    return 1;
}
function bnpToRadix(b) {
  if (b == null)
    b = 10;
  if (this.signum() == 0 || b < 2 || b > 36)
    return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b, cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d, y, z);
  while (y.signum() > 0) {
    r = (a + z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d, y, z);
  }
  return z.intValue().toString(b) + r;
}
function bnpFromRadix(s, b) {
  this.fromInt(0);
  if (b == null)
    b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == "-" && this.signum() == 0)
        mi = true;
      continue;
    }
    w = b * w + x;
    if (++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w, 0);
      j = 0;
      w = 0;
    }
  }
  if (j > 0) {
    this.dMultiply(Math.pow(b, j));
    this.dAddOffset(w, 0);
  }
  if (mi)
    BigInteger.ZERO.subTo(this, this);
}
function bnpFromNumber(a, b, c) {
  if (typeof b == "number") {
    if (a < 2)
      this.fromInt(1);
    else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1))
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
      if (this.isEven())
        this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a)
          this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
      }
    }
  } else {
    var x = new Array(), t = a & 7;
    x.length = (a >> 3) + 1;
    b.nextBytes(x);
    if (t > 0)
      x[0] &= (1 << t) - 1;
    else
      x[0] = 0;
    this.fromString(x, 256);
  }
}
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB - i * this.DB % 8, d, k = 0;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
      r[k++] = d | this.s << this.DB - p;
    while (i >= 0) {
      if (p < 8) {
        d = (this[i] & (1 << p) - 1) << 8 - p;
        d |= this[--i] >> (p += this.DB - 8);
      } else {
        d = this[i] >> (p -= 8) & 255;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if ((d & 128) != 0)
        d |= -256;
      if (k == 0 && (this.s & 128) != (d & 128))
        ++k;
      if (k > 0 || d != this.s)
        r[k++] = d;
    }
  }
  return r;
}
function bnEquals(a) {
  return this.compareTo(a) == 0;
}
function bnMin(a) {
  return this.compareTo(a) < 0 ? this : a;
}
function bnMax(a) {
  return this.compareTo(a) > 0 ? this : a;
}
function bnpBitwiseTo(a, op, r) {
  var i, f, m = Math.min(a.t, this.t);
  for (i = 0; i < m; ++i)
    r[i] = op(this[i], a[i]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i = m; i < this.t; ++i)
      r[i] = op(this[i], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i = m; i < a.t; ++i)
      r[i] = op(f, a[i]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
}
function op_and(x, y) {
  return x & y;
}
function bnAnd(a) {
  var r = nbi();
  this.bitwiseTo(a, op_and, r);
  return r;
}
function op_or(x, y) {
  return x | y;
}
function bnOr(a) {
  var r = nbi();
  this.bitwiseTo(a, op_or, r);
  return r;
}
function op_xor(x, y) {
  return x ^ y;
}
function bnXor(a) {
  var r = nbi();
  this.bitwiseTo(a, op_xor, r);
  return r;
}
function op_andnot(x, y) {
  return x & ~y;
}
function bnAndNot(a) {
  var r = nbi();
  this.bitwiseTo(a, op_andnot, r);
  return r;
}
function bnNot() {
  var r = nbi();
  for (var i = 0; i < this.t; ++i)
    r[i] = this.DM & ~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}
function bnShiftLeft(n) {
  var r = nbi();
  if (n < 0)
    this.rShiftTo(-n, r);
  else
    this.lShiftTo(n, r);
  return r;
}
function bnShiftRight(n) {
  var r = nbi();
  if (n < 0)
    this.lShiftTo(-n, r);
  else
    this.rShiftTo(n, r);
  return r;
}
function lbit(x) {
  if (x == 0)
    return -1;
  var r = 0;
  if ((x & 65535) == 0) {
    x >>= 16;
    r += 16;
  }
  if ((x & 255) == 0) {
    x >>= 8;
    r += 8;
  }
  if ((x & 15) == 0) {
    x >>= 4;
    r += 4;
  }
  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }
  if ((x & 1) == 0)
    ++r;
  return r;
}
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0)
      return i * this.DB + lbit(this[i]);
  if (this.s < 0)
    return this.t * this.DB;
  return -1;
}
function cbit(x) {
  var r = 0;
  while (x != 0) {
    x &= x - 1;
    ++r;
  }
  return r;
}
function bnBitCount() {
  var r = 0, x = this.s & this.DM;
  for (var i = 0; i < this.t; ++i)
    r += cbit(this[i] ^ x);
  return r;
}
function bnTestBit(n) {
  var j = Math.floor(n / this.DB);
  if (j >= this.t)
    return this.s != 0;
  return (this[j] & 1 << n % this.DB) != 0;
}
function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
}
function bnSetBit(n) {
  return this.changeBit(n, op_or);
}
function bnClearBit(n) {
  return this.changeBit(n, op_andnot);
}
function bnFlipBit(n) {
  return this.changeBit(n, op_xor);
}
function bnpAddTo(a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] + a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c += a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0)
    r[i++] = c;
  else if (c < -1)
    r[i++] = this.DV + c;
  r.t = i;
  r.clamp();
}
function bnAdd(a) {
  var r = nbi();
  this.addTo(a, r);
  return r;
}
function bnSubtract(a) {
  var r = nbi();
  this.subTo(a, r);
  return r;
}
function bnMultiply(a) {
  var r = nbi();
  this.multiplyTo(a, r);
  return r;
}
function bnSquare() {
  var r = nbi();
  this.squareTo(r);
  return r;
}
function bnDivide(a) {
  var r = nbi();
  this.divRemTo(a, r, null);
  return r;
}
function bnRemainder(a) {
  var r = nbi();
  this.divRemTo(a, null, r);
  return r;
}
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
}
function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}
function bnpDAddOffset(n, w) {
  if (n == 0)
    return;
  while (this.t <= w)
    this[this.t++] = 0;
  this[w] += n;
  while (this[w] >= this.DV) {
    this[w] -= this.DV;
    if (++w >= this.t)
      this[this.t++] = 0;
    ++this[w];
  }
}
function NullExp() {
}
function nNop(x) {
  return x;
}
function nMulTo(x, y, r) {
  x.multiplyTo(y, r);
}
function nSqrTo(x, r) {
  x.squareTo(r);
}
function bnPow(e) {
  return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i;
  while (i > 0)
    r[--i] = 0;
  var j;
  for (j = r.t - this.t; i < j; ++i)
    r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
  for (j = Math.min(a.t, n); i < j; ++i)
    this.am(0, a[i], r, i, 0, n - i);
  r.clamp();
}
function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i = r.t = this.t + a.t - n;
  r.s = 0;
  while (--i >= 0)
    r[i] = 0;
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
  r.clamp();
  r.drShiftTo(1, r);
}
function Barrett(m) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}
function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t)
    return x.mod(this.m);
  else if (x.compareTo(this.m) < 0)
    return x;
  else {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
}
function barrettRevert(x) {
  return x;
}
function barrettReduce(x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0)
    x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
}
function barrettSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
function bnModPow(e, m) {
  var i = e.bitLength(), k, r = nbv(1), z;
  if (i <= 0)
    return r;
  else if (i < 18)
    k = 1;
  else if (i < 48)
    k = 3;
  else if (i < 144)
    k = 4;
  else if (i < 768)
    k = 5;
  else
    k = 6;
  if (i < 8)
    z = new Classic(m);
  else if (m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);
  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z.convert(this);
  if (k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }
  var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
  i = nbits(e[j]) - 1;
  while (j >= 0) {
    if (i >= k1)
      w = e[j] >> i - k1 & km;
    else {
      w = (e[j] & (1 << i + 1) - 1) << k1 - i;
      if (j > 0)
        w |= e[j - 1] >> this.DB + i - k1;
    }
    n = k;
    while ((w & 1) == 0) {
      w >>= 1;
      --n;
    }
    if ((i -= n) < 0) {
      i += this.DB;
      --j;
    }
    if (is1) {
      g[w].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z.sqrTo(r, r2);
        z.sqrTo(r2, r);
        n -= 2;
      }
      if (n > 0)
        z.sqrTo(r, r2);
      else {
        t = r;
        r = r2;
        r2 = t;
      }
      z.mulTo(r2, g[w], r);
    }
    while (j >= 0 && (e[j] & 1 << i) == 0) {
      z.sqrTo(r, r2);
      t = r;
      r = r2;
      r2 = t;
      if (--i < 0) {
        i = this.DB - 1;
        --j;
      }
    }
  }
  return z.revert(r);
}
function bnGCD(a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y) < 0) {
    var t = x;
    x = y;
    y = t;
  }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if (g < 0)
    return x;
  if (i < g)
    g = i;
  if (g > 0) {
    x.rShiftTo(g, x);
    y.rShiftTo(g, y);
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0)
      x.rShiftTo(i, x);
    if ((i = y.getLowestSetBit()) > 0)
      y.rShiftTo(i, y);
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x);
      x.rShiftTo(1, x);
    } else {
      y.subTo(x, y);
      y.rShiftTo(1, y);
    }
  }
  if (g > 0)
    y.lShiftTo(g, y);
  return y;
}
function bnpModInt(n) {
  if (n <= 0)
    return 0;
  var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d == 0)
      r = this[0] % n;
    else
      for (var i = this.t - 1; i >= 0; --i)
        r = (d * r + this[i]) % n;
  return r;
}
function bnModInverse(m) {
  var ac = m.isEven();
  if (this.isEven() && ac || m.signum() == 0)
    return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m, b);
        }
        a.rShiftTo(1, a);
      } else if (!b.isEven())
        b.subTo(m, b);
      b.rShiftTo(1, b);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c);
          d.subTo(m, d);
        }
        c.rShiftTo(1, c);
      } else if (!d.isEven())
        d.subTo(m, d);
      d.rShiftTo(1, d);
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      if (ac)
        a.subTo(c, a);
      b.subTo(d, b);
    } else {
      v.subTo(u, v);
      if (ac)
        c.subTo(a, c);
      d.subTo(b, d);
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0)
    return BigInteger.ZERO;
  if (d.compareTo(m) >= 0)
    return d.subtract(m);
  if (d.signum() < 0)
    d.addTo(m, d);
  else
    return d;
  if (d.signum() < 0)
    return d.add(m);
  else
    return d;
}
function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i])
        return true;
    return false;
  }
  if (x.isEven())
    return false;
  i = 1;
  while (i < lowprimes.length) {
    var m = lowprimes[i], j = i + 1;
    while (j < lowprimes.length && m < lplim)
      m *= lowprimes[j++];
    m = x.modInt(m);
    while (i < j)
      if (m % lowprimes[i++] == 0)
        return false;
  }
  return x.millerRabin(t);
}
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0)
    return false;
  var r = n1.shiftRight(k);
  t = t + 1 >> 1;
  if (t > lowprimes.length)
    t = lowprimes.length;
  var a = nbi();
  for (var i = 0; i < t; ++i) {
    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
    var y = a.modPow(r, this);
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this);
        if (y.compareTo(BigInteger.ONE) == 0)
          return false;
      }
      if (y.compareTo(n1) != 0)
        return false;
    }
  }
  return true;
}
var navigator2, dbits, canary, j_lm, BI_FP, BI_RM, BI_RC, rr, vv, lowprimes, lplim, jsbn_default;
var init_jsbn = __esm({
  "engine/sdk/core/vendor/jsbn.js"() {
    navigator2 = {};
    if (false) {
      navigator2 = typeof window !== "undefined" ? window.navigator : {};
    }
    canary = 244837814094590;
    j_lm = (canary & 16777215) == 15715070;
    if (j_lm && navigator2.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator2.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    BI_RC = new Array();
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    jsbn_default = BigInteger;
  }
});

// engine/sdk/core/vendor/sha256.js
function sha256(s) {
  var chrsz = 8;
  var hexcase = 0;
  function safe_add(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function S(X, n) {
    return X >>> n | X << 32 - n;
  }
  function R(X, n) {
    return X >>> n;
  }
  function Ch(x, y, z) {
    return x & y ^ ~x & z;
  }
  function Maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function Sigma0256(x) {
    return S(x, 2) ^ S(x, 13) ^ S(x, 22);
  }
  function Sigma1256(x) {
    return S(x, 6) ^ S(x, 11) ^ S(x, 25);
  }
  function Gamma0256(x) {
    return S(x, 7) ^ S(x, 18) ^ R(x, 3);
  }
  function Gamma1256(x) {
    return S(x, 17) ^ S(x, 19) ^ R(x, 10);
  }
  function core_sha256(m, l) {
    var K = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298);
    var HASH = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
    m[l >> 5] |= 128 << 24 - l % 32;
    m[(l + 64 >> 9 << 4) + 15] = l;
    for (var i = 0; i < m.length; i += 16) {
      a = HASH[0];
      b = HASH[1];
      c = HASH[2];
      d = HASH[3];
      e = HASH[4];
      f = HASH[5];
      g = HASH[6];
      h = HASH[7];
      for (var j = 0; j < 64; j++) {
        if (j < 16)
          W[j] = m[j + i];
        else
          W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
        T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
        T2 = safe_add(Sigma0256(a), Maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = safe_add(d, T1);
        d = c;
        c = b;
        b = a;
        a = safe_add(T1, T2);
      }
      HASH[0] = safe_add(a, HASH[0]);
      HASH[1] = safe_add(b, HASH[1]);
      HASH[2] = safe_add(c, HASH[2]);
      HASH[3] = safe_add(d, HASH[3]);
      HASH[4] = safe_add(e, HASH[4]);
      HASH[5] = safe_add(f, HASH[5]);
      HASH[6] = safe_add(g, HASH[6]);
      HASH[7] = safe_add(h, HASH[7]);
    }
    return HASH;
  }
  function str2binb(str) {
    var bin = Array();
    var mask = (1 << chrsz) - 1;
    for (var i = 0; i < str.length * chrsz; i += chrsz) {
      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << 24 - i % 32;
    }
    return bin;
  }
  function Utf8Encode(string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";
    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  }
  function binb2hex(binarray) {
    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
    var str = "";
    for (var i = 0; i < binarray.length * 4; i++) {
      str += hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 + 4 & 15) + hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 & 15);
    }
    return str;
  }
  s = Utf8Encode(s);
  return binb2hex(core_sha256(str2binb(s), s.length * chrsz));
}
var init_sha256 = __esm({
  "engine/sdk/core/vendor/sha256.js"() {
  }
});

// engine/sdk/core/lib/semantic-version.js
var correctSemVerPattern, optionalPatchPattern, SemanticVersion;
var init_semantic_version = __esm({
  "engine/sdk/core/lib/semantic-version.js"() {
    correctSemVerPattern = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/g;
    optionalPatchPattern = /^(0|[1-9]\d*)\.(0|[1-9]\d*)(\.(0|[1-9]\d*))?(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/g;
    SemanticVersion = class {
      get major() {
        return this._major;
      }
      get minor() {
        return this._minor;
      }
      get patch() {
        return this._patch;
      }
      constructor(version, patchVersionOptional = false) {
        const pattern = patchVersionOptional ? optionalPatchPattern : correctSemVerPattern;
        const groups = pattern.exec(version);
        pattern.lastIndex = 0;
        this._major = groups[1];
        this._minor = groups[2];
        this._patch = groups[3] || 0;
      }
      equals(other) {
        return this._major === other._major && this._minor === other._minor && this._patch === other._patch;
      }
      isMoreRecentThan(other) {
        if (this._major < other.major)
          return false;
        if (this._major > other.major)
          return true;
        if (this._minor < other.minor)
          return false;
        if (this._minor > other.minor)
          return true;
        if (this._patch <= other.patch)
          return false;
        if (this._patch > other.patch)
          return true;
      }
    };
  }
});

// engine/sdk/core/lib/license-checker.js
function byteArraytoHexString(byteArray) {
  return byteArray.map((byte) => {
    return `0${(byte & 255).toString(16)}`.slice(-2);
  }).join("");
}
var bd, TRACK_PATH, ENTERPRISE_LICENSE, APP_IDENTIFIERS, PLATFORM, FEATURES, EXPIRES_AT, DOMAINS, API_TOKEN, SIGNATURE, VERSION, L, FreeLicenseChecker, license_checker_default;
var init_license_checker = __esm({
  "engine/sdk/core/lib/license-checker.js"() {
    init_json_loader();
    init_jsbn();
    init_sha256();
    init_base64();
    init_semantic_version();
    init_utils();
    bd = (str) => utils_default.byteArrayToString(base64_default.decode(str));
    TRACK_PATH = "TDNSeVlXTnJQMkZ3YVV0bGVUMD0=";
    ENTERPRISE_LICENSE = "ZW50ZXJwcmlzZV9saWNlbnNl";
    APP_IDENTIFIERS = "YXBwX2lkZW50aWZpZXJz";
    PLATFORM = "cGxhdGZvcm0=";
    FEATURES = "ZmVhdHVyZXM=";
    EXPIRES_AT = "ZXhwaXJlc19hdA==";
    DOMAINS = "ZG9tYWlucw==";
    API_TOKEN = "YXBpX3Rva2Vu";
    SIGNATURE = "c2lnbmF0dXJl";
    VERSION = "dmVyc2lvbg==";
    L = class {
      constructor(license) {
        this._version = "2.4";
        this._l = typeof license === "string" ? license.trim() : license;
        this._e = this._parseBigInt("65537", 10);
        this._n = this._parseBigInt("681984042382424091378806337544846672160292647422517223678775230983366046720611873368204040735766698395282492937192783016867164773742859209434481353888637963692711665138989982680829529436715362566735813634679619274059040232728883894511099669775400556584329435375723951309340934658571478665059403241851229195311069345899870108307225910988692123234379186643268583453907260879685992156955936561142314233983397819356937109343127504441076920088455337597736475086676246750168976219763398350254797168313954762459542746440628077261880980924552698138857743609502132632199713575442848784271304503226045319991689413234228439044522583790713890093165912455428688507463773064216328753265963237930998706891042679105987175588970202082466871461192706070321938250462103821558100761330890228135620208935801286878657384108721268761878694436895194628411397454202904351577771506916746612289964053490210990342857409030179406810634136188751670648983222653319056818302012063874664196648868156305696644664362171542503665321455971335955948698828939948786720193132672749776162913092000667953299803216404664087988046584107737900256954976744353601826341965438148646041640662195744770544094748295945844184507459808803114917301124088082458306086473490516969815873631", 10);
        this._parseLicense();
      }
      v() {
        return this._sigValid() && !this.isExp();
      }
      _jsonValid() {
        try {
          this._decLic = JSON.parse(this._l);
        } catch (e) {
          this._decLic = {};
          return false;
        }
        return true;
      }
      _hostnameValid() {
        if (typeof window === "undefined")
          return true;
        if (!this._decLic[bd(APP_IDENTIFIERS)].length)
          return true;
        const { hostname } = window.location;
        let valid = false;
        this._decLic[bd(APP_IDENTIFIERS)].forEach((appIdentifier) => {
          if (utils_default.wildCardMatch(hostname, appIdentifier)) {
            valid = true;
          }
        });
        return valid;
      }
      _platformValid() {
        const licensePlatform = this._decLic[bd(PLATFORM)];
        const systemPlatform = false ? "HTML5" : "Server";
        return systemPlatform === licensePlatform;
      }
      c() {
        return new Promise((resolve, reject) => {
          const error = this._validateError();
          if (error !== null) {
            reject(error);
          }
          resolve();
        });
      }
      validate() {
        const error = this._validateError();
        if (error !== null) {
          return false;
        }
        return true;
      }
      _validateError() {
        const licenseType = typeof this._l;
        if (licenseType !== "string" || !this._jsonValid()) {
          const error = new Error();
          error.code = "ELICINVFMT";
          return error;
        }
        if (!this._sigValid()) {
          const error = new Error();
          error.code = "ELICINV";
          return error;
        }
        if (!this._hostnameValid()) {
          const error = new Error();
          error.code = "ELICINVHOST";
          return error;
        }
        if (!this._platformValid()) {
          const error = new Error();
          error.code = "ELICINVPLAT";
          return error;
        }
        if (this.isExp()) {
          const error = new Error();
          error.code = "ELICEXP";
          return error;
        }
        return null;
      }
      isToolAllowed(identifier) {
        return this._includesFeature(identifier);
      }
      isWhiteLabel() {
        return this._includesFeature("whitelabel", new SemanticVersion("2.4", true));
      }
      areCustomAssetsAllowed() {
        return this._includesFeature("customassets", new SemanticVersion("2.4", true));
      }
      t() {
        if (this._decLic.enterprise_license)
          return Promise.resolve();
        if (this._includesFeature("noexporttracking", new SemanticVersion("2.4", true)))
          return Promise.resolve();
        const trackPath = this._decLic[bd(DOMAINS)][0] + bd(bd(TRACK_PATH)) + this._decLic[bd(API_TOKEN)];
        const jsonLoader = new JSONLoader(trackPath);
        return jsonLoader.load().catch(() => {
        });
      }
      isENT() {
        if (!this._decLic)
          return false;
        return this._decLic[bd(ENTERPRISE_LICENSE)];
      }
      _sigValid() {
        return this._verify(this._message, this._sig);
      }
      exp() {
        return !!this._decLic[bd(EXPIRES_AT)];
      }
      dl() {
        return Math.ceil((this._expAt() - Date.now()) / (60 * 60 * 24 * 1e3));
      }
      isExp(now6 = Date.now()) {
        if (this._decLic[bd(EXPIRES_AT)] === null)
          return false;
        return now6 > this._expAt();
      }
      _expAt() {
        return this._decLic[bd(EXPIRES_AT)] * 1e3;
      }
      _verify(message, signature) {
        let verification;
        let messageDigest;
        messageDigest = this._encodeMessage(message);
        verification = this._decodeSignature(signature);
        verification = verification.substr(-64);
        const isValid = messageDigest === verification;
        return isValid;
      }
      _encodeMessage(message) {
        const messageDigest = sha256(message);
        return messageDigest;
      }
      _decodeSignature(signature) {
        let verification;
        signature = base64_default.decode(signature);
        signature = byteArraytoHexString(signature);
        signature = this._parseBigInt(signature, 16);
        verification = signature.modPowInt(this._e, this._n);
        verification = verification.toString(16);
        return verification;
      }
      _parseBigInt(str, base) {
        return new jsbn_default(str, base);
      }
      _parseLicense() {
        if (typeof this._l !== "string")
          return;
        if (!this._jsonValid())
          return;
        this._sig = this._decLic[bd(SIGNATURE)] || "";
        delete this._decLic[bd(SIGNATURE)];
        this._sig = this._sig.replace(/[^A-Za-z0-9+/=]/g, "");
        this._message = this._l.replace(new RegExp(`,"${bd(SIGNATURE)}":"([^"]*)"`), "");
      }
      _includesFeature(feature, minLicenseVersion = new SemanticVersion("1.0", true)) {
        const version = new SemanticVersion(this._decLic[bd(VERSION)], true);
        if (minLicenseVersion.isMoreRecentThan(version))
          return true;
        return this._decLic[bd(FEATURES)] && this._decLic[bd(FEATURES)].indexOf(feature) !== -1;
      }
    };
    FreeLicenseChecker = class {
      v() {
        return true;
      }
      c() {
        return Promise.resolve();
      }
      isToolAllowed(identifier) {
        return true;
      }
      isWhiteLabel() {
        return false;
      }
      areCustomAssetsAllowed() {
        return true;
      }
      t() {
        return Promise.resolve();
      }
      isENT() {
        return false;
      }
      exp() {
        return false;
      }
      dl() {
        return 0;
      }
      isExp(now6 = Date.now()) {
        return false;
      }
    };
    license_checker_default = L;
  }
});

// engine/shared/async/animation-frame.js
var root2, rAF, cAF, lastTime, vendors;
var init_animation_frame = __esm({
  "engine/shared/async/animation-frame.js"() {
    root2 = typeof window === "undefined" ? global : window;
    rAF = root2.requestAnimationFrame;
    cAF = root2.cancelAnimationFrame;
    lastTime = 0;
    vendors = ["ms", "moz", "webkit", "o"];
    for (let x = 0; x < vendors.length && !rAF; ++x) {
      rAF = root2[`${vendors[x]}RequestAnimationFrame`];
      cAF = root2[`${vendors[x]}CancelAnimationFrame`] || root2[`${vendors[x]}CancelRequestAnimationFrame`];
    }
    if (rAF) {
      rAF = rAF.bind(root2);
    }
    if (cAF) {
      cAF = cAF.bind(root2);
    }
    if (!rAF) {
      rAF = function(callback, element) {
        const currTime = new Date().getTime();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const id = setTimeout(function() {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    if (!cAF) {
      cAF = function(id) {
        clearTimeout(id);
      };
    }
  }
});

// engine/sdk/core/lib/math/cubic-bezier-curve.js
var CubicBezierCurve, cubic_bezier_curve_default;
var init_cubic_bezier_curve = __esm({
  "engine/sdk/core/lib/math/cubic-bezier-curve.js"() {
    init_log();
    init_vector2();
    CubicBezierCurve = class {
      constructor(p0 = new Vector2(0, 0), p1 = new Vector2(1, 1), p2 = new Vector2(2, -1), p3 = new Vector2(2, 0)) {
        this._p0 = p0.clone();
        this._p1 = p1.clone();
        this._p2 = p2.clone();
        this._p3 = p3.clone();
        this._segments = [];
        this._length = -1;
        this._sample = [];
      }
      set(p0 = new Vector2(0, 0), p1 = new Vector2(1, 1), p2 = new Vector2(2, 1), p3 = new Vector2(2, 0)) {
        this._p0 = p0.clone();
        this._p1 = p1.clone();
        this._p2 = p2.clone();
        this._p3 = p3.clone();
      }
      getLength() {
        return this._length;
      }
      calculateSegments(N = 100) {
        let t = 0;
        let len = 0;
        const segments = [];
        const step = 1 / N;
        let lastPoint = this._p0.clone();
        for (let i = 1; i <= N; i++) {
          const segment = [];
          segment.push({
            t,
            s: len,
            point: lastPoint
          });
          t += step;
          t = Math.min(t, 1);
          const point = this.evalAt(t);
          const delta = point.clone().subtract(lastPoint);
          len += delta.len();
          segment.push({
            t,
            s: len,
            point
          });
          segments.push(segment);
          lastPoint = point;
        }
        this._segments = segments;
        this._length = len;
        return len;
      }
      evalAt(t) {
        t = this.normalizeParameter(t);
        const a = this._p0.clone().multiply((1 - t) ** 3);
        const b = this._p1.clone().multiply(3 * (1 - t) * (1 - t) * t);
        const c = this._p2.clone().multiply(3 * (1 - t) * t * t);
        const d = this._p3.clone().multiply(t * t * t);
        return a.add(b).add(c).add(d);
      }
      isInSegment(s, segment) {
        s = this.normalizeArcLength(s);
        return s >= segment[0].s && s <= segment[1].s;
      }
      getArcLengthSegment(s) {
        s = this.normalizeArcLength(s);
        for (let i = 0; i < this._segments.length; i++) {
          const segment = this._segments[i];
          if (this.isInSegment(s, segment)) {
            return segment;
          }
        }
        return null;
      }
      normalizeArcLength(s) {
        return Math.max(Math.min(this._length, s), 0);
      }
      normalizeParameter(t) {
        return Math.max(Math.min(1, t), 0);
      }
      getParameterForArcLength(s) {
        const arcLen = this.normalizeArcLength(s);
        const segment = this.getArcLengthSegment(arcLen);
        if (!segment) {
          log_default.warn("CubicBezierCurve#getParameterForArcLength", "Segment not found.");
          return -1;
        }
        const a = (arcLen - segment[1].s) / (segment[0].s - segment[1].s);
        return a * segment[0].t + (1 - a) * segment[1].t;
      }
      evalAtArcLength(s) {
        return this.evalAt(this.getParameterForArcLength(s));
      }
      approximateAtArcLength(s) {
        const arcLen = this.normalizeArcLength(s);
        const segment = this.getArcLengthSegment(arcLen);
        if (!segment) {
          return -1;
        }
        const a = (arcLen - segment[1].s) / (segment[0].s - segment[1].s);
        return segment[0].point.clone().multiply(a).add(segment[1].point.clone().multiply(1 - a));
      }
      parameterSample(N = 100) {
        const step = 1 / N;
        const sample = [];
        let t = 0;
        for (let i = 0; i <= N + 1; i++) {
          sample.push(this.evalAt(t));
          t += step;
        }
        this._sample = sample;
        return [...sample];
      }
      arcLengthApproxSample(N = 100, excludeStartPoint = false, excludeEndPoint = false) {
        const step = this._length / N;
        const sample = [];
        let s = 0;
        for (let i = excludeStartPoint ? 1 : 0; i < N + 1; i++) {
          sample.push(this.approximateAtArcLength(s));
          s += step;
        }
        if (excludeEndPoint) {
          sample.pop();
        }
        this._sample = sample;
        return [...sample];
      }
    };
    cubic_bezier_curve_default = CubicBezierCurve;
  }
});

// engine/sdk/core/lib/math/range.js
var Range, range_default;
var init_range = __esm({
  "engine/sdk/core/lib/math/range.js"() {
    Range = class {
      constructor(min, max) {
        this.min = min;
        this.max = max;
      }
      getMin() {
        return this.min;
      }
      getMax() {
        return this.max;
      }
      getLength() {
        return this.max - this.min;
      }
      contains(value) {
        return this.min <= value && value <= this.max;
      }
    };
    range_default = Range;
  }
});

// engine/sdk/core/lib/math/vector3.js
var Vector3, vector3_default;
var init_vector3 = __esm({
  "engine/sdk/core/lib/math/vector3.js"() {
    Vector3 = class {
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        if (typeof this.x === "undefined") {
          this.x = 0;
        }
        if (typeof this.y === "undefined") {
          this.y = 0;
        }
        if (typeof this.z === "undefined") {
          this.z = 0;
        }
      }
      set(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      }
      clone() {
        return new Vector3(this.x, this.y, this.z);
      }
      copy(other) {
        this.x = other.x;
        this.y = other.y;
        this.z = other.z;
        return this;
      }
      clamp(minimum, maximum) {
        const minimumSet = minimum !== null && typeof minimum !== "undefined";
        const maximumSet = maximum !== null && typeof maximum !== "undefined";
        if (!(minimum instanceof Vector3) && minimumSet) {
          minimum = new Vector3(minimum, minimum, minimum);
        }
        if (!(maximum instanceof Vector3) && maximumSet) {
          maximum = new Vector3(maximum, maximum, maximum);
        }
        if (minimumSet) {
          this.x = Math.max(minimum.x, this.x);
          this.y = Math.max(minimum.y, this.y);
          this.z = Math.max(minimum.z, this.z);
        }
        if (maximumSet) {
          this.x = Math.min(maximum.x, this.x);
          this.y = Math.min(maximum.y, this.y);
          this.z = Math.min(maximum.z, this.z);
        }
        return this;
      }
      divide(divisor) {
        if (divisor instanceof Vector3) {
          this.x /= divisor.x;
          this.y /= divisor.y;
          this.z /= divisor.z;
        } else {
          this.x /= divisor;
          this.y /= divisor;
          this.z /= divisor;
        }
        return this;
      }
      subtract(subtrahend) {
        if (subtrahend instanceof Vector3) {
          this.x -= subtrahend.x;
          this.y -= subtrahend.y;
          this.z -= subtrahend.z;
        } else {
          this.x -= subtrahend;
          this.y -= subtrahend;
          this.z -= subtrahend;
        }
        return this;
      }
      multiply(factor) {
        if (factor instanceof Vector3) {
          this.x *= factor.x;
          this.y *= factor.y;
          this.z *= factor.z;
        } else {
          this.x *= factor;
          this.y *= factor;
          this.z *= factor;
        }
        return this;
      }
      add(addend) {
        if (addend instanceof Vector3) {
          this.x += addend.x;
          this.y += addend.y;
          this.z += addend.z;
        } else {
          this.x += addend;
          this.y += addend;
          this.z += addend;
        }
        return this;
      }
      equals(vec) {
        if (vec instanceof Vector3) {
          return vec.x === this.x && vec.y === this.y && vec.z === this.z;
        }
        return vec === this.x && vec === this.y && vec === this.z;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      }
      fract() {
        this.x %= 1;
        this.y %= 1;
        this.z %= 1;
        return this;
      }
      toInt() {
        this.x |= 0;
        this.y |= 0;
        this.z |= 0;
        return this;
      }
      abs() {
        this.x = Math.abs(this.x);
        this.y = Math.abs(this.y);
        this.z = Math.abs(this.z);
        return this;
      }
      len() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      min() {
        return Math.min(Math.min(this.x, this.y), this.z);
      }
      max() {
        return Math.max(Math.max(this.x, this.y), this.z);
      }
      toObject() {
        return { x: this.x, y: this.y, z: this.z };
      }
      toString() {
        return `Vector3({ x: ${this.x}, y: ${this.y}, z: ${this.z} })`;
      }
      roundDecimal(decimals) {
        this.x = parseFloat(this.x.toFixed(decimals));
        this.y = parseFloat(this.y.toFixed(decimals));
        this.z = parseFloat(this.z.toFixed(decimals));
        return this;
      }
      static fromObject(object) {
        return new Vector3(object.x, object.y, object.z);
      }
      static get NULL() {
        return new Vector3(0, 0, 0);
      }
    };
    vector3_default = Vector3;
  }
});

// engine/sdk/core/lib/math/index.js
var math_exports = {};
__export(math_exports, {
  ColorMatrix: () => color_matrix_default,
  CubicBezierCurve: () => cubic_bezier_curve_default,
  Matrix: () => Matrix,
  Range: () => range_default,
  Rectangle: () => Rectangle,
  Vector2: () => Vector2,
  Vector3: () => vector3_default
});
var init_math = __esm({
  "engine/sdk/core/lib/math/index.js"() {
    init_color_matrix();
    init_cubic_bezier_curve();
    init_matrix();
    init_range();
    init_rectangle();
    init_vector2();
    init_vector3();
  }
});

// engine/sdk/core/globals.js
var globals_exports2 = {};
__export(globals_exports2, {
  Base64: () => base64_default,
  Color: () => color_default,
  ColorMatrix: () => color_matrix_default,
  Configurable: () => configurable_default,
  Constants: () => constants_exports,
  CubicBezierCurve: () => cubic_bezier_curve_default,
  Engine: () => engine_default,
  EventEmitter: () => event_emitter_default,
  Events: () => Events,
  FreeLicenseChecker: () => FreeLicenseChecker,
  GLUtils: () => gl_utils_default,
  LicenseChecker: () => license_checker_default,
  Log: () => log_default,
  Matrix: () => Matrix,
  Range: () => range_default,
  Rectangle: () => Rectangle,
  Utils: () => utils_default,
  Vector2: () => Vector2,
  Vector3: () => vector3_default,
  cancelAnimationFrame: () => cAF,
  requestAnimationFrame: () => rAF
});
var init_globals2 = __esm({
  "engine/sdk/core/globals.js"() {
    init_log();
    init_constants2();
    init_constants();
    init_engine();
    init_base64();
    init_color();
    init_configurable();
    init_event_emitter();
    init_gl_utils();
    init_license_checker();
    init_utils();
    init_animation_frame();
    init_math();
  }
});

// engine/sdk/core/lib/pot-renderer.ts
var POTRenderer;
var init_pot_renderer = __esm({
  "engine/sdk/core/lib/pot-renderer.ts"() {
    init_container();
    init_sprite();
    init_render_texture();
    init_globals2();
    POTRenderer = class {
      constructor() {
        this._container = new Container();
        this._sprite = new Sprite();
        this._container.addChild(this._sprite);
      }
      render(renderer, inputSprite, inputTexture) {
        const textureDimensions = inputTexture.getDimensions();
        const nextPOT = this._getNextHighestPOT(textureDimensions);
        if (!this._renderTexture) {
          this._renderTexture = new RenderTexture(renderer, nextPOT.x, nextPOT.y);
        } else {
          this._renderTexture.resizeTo(nextPOT);
        }
        const newDimensions = this._renderTexture.getDimensions();
        this._sprite.setTexture(inputTexture);
        this._sprite.updateTransform();
        this._renderTexture.clear();
        this._renderTexture.render(this._container);
        this._updateSprite(renderer, inputSprite, textureDimensions, newDimensions);
      }
      _updateSprite(renderer, inputSprite, initialDimensions, newDimensions) {
        inputSprite.setTexture(this._renderTexture);
        this._renderTexture.setFrame(new Rectangle(0, 0, initialDimensions.x, initialDimensions.y));
      }
      _getNextHighestPOT(dimensions) {
        return new Vector2(utils_default.nextHighestPOT(dimensions.x), utils_default.nextHighestPOT(dimensions.y));
      }
      getRenderTexture() {
        return this._renderTexture;
      }
      dispose() {
        if (!this._renderTexture) {
          return;
        }
        this._renderTexture.dispose();
        delete this._renderTexture;
      }
    };
  }
});

// engine/sdk/core/engine/sprites/sprite.ts
var Sprite;
var init_sprite = __esm({
  "engine/sdk/core/engine/sprites/sprite.ts"() {
    init_pot_renderer();
    init_container();
    init_globals();
    Sprite = class extends Container {
      constructor(texture) {
        super();
        this._shader = null;
        this._width = 0;
        this._height = 0;
        this._anchor = new Vector2(0, 0);
        this._canvasSmoothingEnabled = true;
        this._smoothDownscaling = false;
        this._onTextureUpdate = this._onTextureUpdate.bind(this);
        this.setTexture(texture);
      }
      _onTextureUpdate() {
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      _renderWebGL(renderer) {
        const save = renderer.save();
        if (this._smoothDownscaling) {
          if (!this._potRenderer) {
            this._potRenderer = new POTRenderer();
          }
          if (this._texture) {
            this._potRenderer.render(renderer, this, this._texture);
          }
        }
        renderer.restore(save);
        renderer.setObjectRenderer(renderer.renderers.sprite);
        renderer.renderers.sprite.render(this);
      }
      _renderCanvas(renderer) {
        if (!this._texture)
          return;
        const transform = this._worldTransform;
        const textureFrame = this._texture.getFrame();
        const { width, height } = textureFrame;
        const pixelRatio = renderer.getCurrentRenderTarget().getPixelRatio();
        const dx = this._anchor.x * -width | 0;
        const dy = this._anchor.y * -height | 0;
        const ctx = renderer.getContext();
        ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * pixelRatio, transform.ty * pixelRatio);
        ctx.globalAlpha = this.getWorldAlpha();
        if (!this._texture)
          return;
        const baseTexture = this._texture.getBaseTexture();
        const texturePixelRatio = baseTexture.getPixelRatio();
        const source = baseTexture.getSource();
        ctx.imageSmoothingEnabled = this._canvasSmoothingEnabled;
        if ("beforeDraw" in renderer) {
          renderer.beforeDraw(ctx);
        }
        ctx.drawImage(source, 0, 0, (source.naturalWidth || width) * texturePixelRatio, (source.naturalHeight || height) * texturePixelRatio, dx * pixelRatio, dy * pixelRatio, width * pixelRatio, height * pixelRatio);
      }
      isAtPosition(position) {
        if (!this._texture)
          return void 0;
        const localPosition = this._worldTransform.applyInverseToVector(position);
        const textureFrame = this._texture.getFrame();
        const { width, height } = textureFrame;
        const upperLeft = new Vector2(-width, -height);
        upperLeft.multiply(this._anchor);
        const lowerRight = upperLeft.clone().add(width, height);
        if (localPosition.x < upperLeft.x || localPosition.x > lowerRight.x || localPosition.y < upperLeft.y || localPosition.y > lowerRight.y) {
          return false;
        }
        return true;
      }
      getLocalBounds() {
        if (this._localBoundsNeedUpdate && this._texture) {
          const bounds = this._localBounds;
          const textureFrame = this._texture.getFrame();
          bounds.x = -textureFrame.width * this._anchor.x;
          bounds.y = -textureFrame.height * this._anchor.y;
          bounds.width = textureFrame.width;
          bounds.height = textureFrame.height;
          this._localBoundsNeedUpdate = false;
        }
        return this._localBounds.clone();
      }
      getBounds() {
        if (this._boundsNeedUpdate && this._texture) {
          const bounds = this._bounds;
          const textureFrame = this._texture.getFrame();
          const worldTransform = this._worldTransform;
          const anchor = this._anchor;
          const positions = worldTransform.rectangleToCoordinates(textureFrame, anchor);
          let minX = positions[0].x;
          let minY = positions[0].y;
          let maxX = minX;
          let maxY = minY;
          positions.forEach(({ x, y }) => {
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
          });
          bounds.x = minX;
          bounds.width = Math.abs(maxX - minX);
          bounds.y = minY;
          bounds.height = Math.abs(maxY - minY);
          this._boundsNeedUpdate = false;
        }
        return this._bounds.clone();
      }
      getTexture() {
        return this._texture;
      }
      clearTexture(dispose = true) {
        if (!this._texture) {
          return;
        }
        this._texture.off("update", this._onTextureUpdate);
        dispose && this._texture.dispose();
        this._texture = null;
        if (this._potRenderer) {
          dispose && this._potRenderer.dispose();
          delete this._potRenderer;
        }
      }
      setTexture(texture) {
        if (!texture)
          return;
        if (this._texture) {
          this._texture.off("update", this._onTextureUpdate);
        }
        if (this._potRenderer) {
          this._potRenderer.getRenderTexture().getBaseTexture().setDirty(true);
        }
        this._texture = texture;
        if (texture.getBaseTexture().isLoaded()) {
          this._onTextureUpdate();
        }
        texture.on("update", this._onTextureUpdate);
      }
      getShader() {
        return this._shader;
      }
      setShader(shader) {
        this._shader = shader;
      }
      getWidth() {
        return this._width;
      }
      setWidth(width) {
        if (!this._texture)
          return;
        this._scale.x = width / this._texture.getFrame().width;
        this._width = width;
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      getHeight() {
        return this._height;
      }
      setHeight(height) {
        if (!this._texture)
          return;
        this._scale.y = height / this._texture.getFrame().height;
        this._height = height;
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      getDimensions() {
        return new Vector2(this._width, this._height);
      }
      getAnchor() {
        return this._anchor;
      }
      setAnchor(anchor, y) {
        this._anchor.set(anchor, y);
        this._boundsNeedUpdate = true;
        this._localBoundsNeedUpdate = true;
      }
      isSmoothDownscaling() {
        return this._smoothDownscaling;
      }
      setSmoothDownscaling(smoothDownscaling) {
        this._smoothDownscaling = smoothDownscaling;
      }
      dispose(texture = false, baseTexture = false) {
        if (this._texture) {
          this._texture.off("update", this._onTextureUpdate);
        }
        (texture || baseTexture) && this._texture && this._texture.dispose(baseTexture);
        if (this._potRenderer) {
          this._potRenderer.dispose();
        }
      }
    };
  }
});

// engine/sdk/core/engine/index.js
var Engine, engine_default;
var init_engine = __esm({
  "engine/sdk/core/engine/index.js"() {
    init_container();
    init_filters();
    init_filter();
    init_canvas_filter_manager();
    init_canvas_renderer();
    init_webgl_renderer();
    init_sprite();
    init_base_texture();
    init_render_texture();
    init_texture3();
    init_canvas_render_target();
    init_pixel_array_image();
    init_render();
    init_webgl_render_target();
    Engine = {
      CanvasFilterManager,
      Container,
      BaseTexture,
      Texture,
      RenderTexture,
      WebGLRenderTarget: WebglRenderTarget,
      CanvasRenderTarget,
      Sprite,
      Filter,
      Filters: filters_exports,
      PixelArrayImage,
      autoDetectRenderer(width, height, options = {}) {
        if (renderUtils.isSupported()) {
          return new WebGLRenderer(width, height, options);
        }
        return new CanvasRenderer(width, height, options);
      },
      canvasRenderer(width, height, options = {}) {
        return new CanvasRenderer(width, height, options);
      }
    };
    engine_default = Engine;
  }
});

// engine/sdk/core/lib/env.js
var Env, env_default;
var init_env = __esm({
  "engine/sdk/core/lib/env.js"() {
    Env = class {
      static current() {
        return process.env.ENV;
      }
      static isTest() {
        return process.env.ENV === "test";
      }
      static isDevelopment() {
        return process.env.ENV === "development";
      }
      static isProduction() {
        return process.env.ENV === "production" || !this.isTest() && !this.isDevelopment();
      }
    };
    env_default = Env;
  }
});

// engine/sdk/core/lib/array-stream.js
var ArrayStream, array_stream_default;
var init_array_stream = __esm({
  "engine/sdk/core/lib/array-stream.js"() {
    ArrayStream = class {
      constructor(buf) {
        this._head = 0;
        this._buf = buf;
      }
      peekInt8() {
        return this._buf[this._head];
      }
      peekInt16(littleEndian = false) {
        const a = this._buf[this._head];
        const b = this._buf[this._head + 1];
        if (!littleEndian) {
          return (a << 8) + b;
        }
        return (b << 8) + a;
      }
      peekInt24(littleEndian = false) {
        const a = this._buf[this._head];
        const b = this._buf[this._head + 1];
        const c = this._buf[this._head + 2];
        if (!littleEndian) {
          return (a << 16) + (b << 8) + c;
        }
        return (c << 16) + (b << 8) + a;
      }
      peekInt32(littleEndian = false) {
        const a = this._buf[this._head];
        const b = this._buf[this._head + 1];
        const c = this._buf[this._head + 2];
        const d = this._buf[this._head + 3];
        if (!littleEndian) {
          return (a << 32) + (b << 16) + (c << 8) + d;
        }
        return (d << 32) + (c << 16) + (b << 8) + a;
      }
      writeInt8(num) {
        this._buf[this._head] = num & 255;
      }
      writeInt16(num) {
        this._buf[this._head] = num >> 8;
        this._buf[this._head + 1] = num & 255;
      }
      readInt8() {
        const num = this.peekInt8();
        this._head += 1;
        return num;
      }
      readInt16(littleEndian = false) {
        const num = this.peekInt16(littleEndian);
        this._head += 2;
        return num;
      }
      readInt24(littleEndian = false) {
        const num = this.peekInt24(littleEndian);
        this._head += 3;
        return num;
      }
      readInt32(littleEndian = false) {
        const num = this.peekInt32(littleEndian);
        this._head += 4;
        return num;
      }
      readString(length) {
        let str = "";
        for (let i = 0; i < length; i++) {
          const character = this.readInt8();
          str += String.fromCharCode(character);
        }
        return str;
      }
      getHead() {
        return this._head;
      }
      setHead(head) {
        this._head = head;
      }
    };
    array_stream_default = ArrayStream;
  }
});

// engine/sdk/core/lib/jpeg/constants.js
var MARKERS, EXIF_TAGS, constants_default2;
var init_constants3 = __esm({
  "engine/sdk/core/lib/jpeg/constants.js"() {
    MARKERS = {
      SOI: 65496,
      SOS: 65498,
      APP0: 65504,
      APP1: 65505,
      JFIF: 65504,
      EXIF: 65505
    };
    EXIF_TAGS = {
      256: "ImageWidth",
      257: "ImageHeight",
      34665: "ExifIFDPointer",
      34853: "GPSInfoIFDPointer",
      40965: "InteroperabilityIFDPointer",
      258: "BitsPerSample",
      259: "Compression",
      262: "PhotometricInterpretation",
      274: "Orientation",
      277: "SamplesPerPixel",
      284: "PlanarConfiguration",
      530: "YCbCrSubSampling",
      531: "YCbCrPositioning",
      282: "XResolution",
      283: "YResolution",
      296: "ResolutionUnit",
      273: "StripOffsets",
      278: "RowsPerStrip",
      279: "StripByteCounts",
      513: "JPEGInterchangeFormat",
      514: "JPEGInterchangeFormatLength",
      301: "TransferFunction",
      318: "WhitePoint",
      319: "PrimaryChromaticities",
      529: "YCbCrCoefficients",
      532: "ReferenceBlackWhite",
      306: "DateTime",
      270: "ImageDescription",
      271: "Make",
      272: "Model",
      305: "Software",
      315: "Artist",
      33432: "Copyright"
    };
    constants_default2 = {
      MARKERS,
      EXIF_TAGS
    };
  }
});

// engine/sdk/core/lib/jpeg/exif-data.js
var invariant, MARKERS2, EXIF_TAGS2, EXIFData, exif_data_default;
var init_exif_data = __esm({
  "engine/sdk/core/lib/jpeg/exif-data.js"() {
    init_array_stream();
    init_utils();
    init_constants3();
    ({ invariant } = utils_default);
    ({ MARKERS: MARKERS2, EXIF_TAGS: EXIF_TAGS2 } = constants_default2);
    EXIFData = class {
      constructor(buf) {
        this._buf = buf;
        this._stream = new array_stream_default(this._buf);
        this._stream.setHead(0);
        this._parse();
        this._bigEndian = false;
      }
      isValid() {
        this._stream.setHead(0);
        const marker = this._stream.readInt16();
        if (marker !== MARKERS2.EXIF) {
          return false;
        }
        const length = this._stream.readInt16();
        if (!(length > 0)) {
          return false;
        }
        const header = this._stream.readString(4);
        if (header !== "Exif") {
          return false;
        }
        return true;
      }
      _parse() {
        if (!this.isValid()) {
          return;
        }
        this._stream.setHead(10);
        const tiffOffset = this._stream.getHead();
        this._bigEndian = false;
        const endian = this._stream.readInt16();
        if (endian === 18761) {
          this._bigEndian = false;
        } else if (endian === 19789) {
          this._bigEndian = true;
        } else {
          invariant(false, "Invalid TIFF data: No endian type found");
        }
        invariant(this._stream.readInt16(!this._bigEndian) === 42, "Invalid TIFF data: No 0x002A");
        const firstIFDOffset = this._stream.readInt32(!this._bigEndian);
        invariant(firstIFDOffset >= 8, "Invalid TIFF data: First IFD offset < 8");
        const ifdOffset = tiffOffset + firstIFDOffset;
        const tags = this._readTags(this._stream, tiffOffset, ifdOffset, this._bigEndian);
        this._tags = tags.tags;
        this._tagData = tags.tagData;
      }
      getTags() {
        return this._tags;
      }
      getTagData() {
        return this._tagData;
      }
      setOrientation(orientation) {
        if (this._tagData.Orientation) {
          const { entryOffset } = this._tagData.Orientation;
          this._stream.setHead(entryOffset + 8);
          this._stream.writeInt16(this._bigEndian ? orientation : (orientation & 255) << 8 | orientation >> 8 & 255);
        }
      }
      _readTags(stream, tiffStart, ifdStart, bigEndian) {
        stream.setHead(ifdStart);
        const entriesCount = stream.readInt16(!bigEndian);
        const tags = {};
        const tagData = [];
        for (let i = 0; i < entriesCount; i++) {
          const entryOffset = ifdStart + i * 12 + 2;
          stream.setHead(entryOffset);
          let tag = stream.readInt16(!bigEndian);
          let type;
          let numValues;
          let valueOffset;
          if (EXIF_TAGS2[tag]) {
            tag = EXIF_TAGS2[tag];
            type = stream.readInt16(!bigEndian);
            numValues = stream.readInt32(!bigEndian);
            valueOffset = stream.readInt32(!bigEndian) + tiffStart;
            let value = null;
            switch (type) {
              case 1:
              case 7:
                if (numValues === 1) {
                  value = stream.readInt8(!bigEndian);
                } else {
                  value = [];
                  for (let i2 = 0; i2 < numValues; i2++) {
                    value.push(stream.readInt8(!bigEndian));
                  }
                }
                break;
              case 2:
                stream.setHead(numValues > 4 ? valueOffset : entryOffset + 8);
                value = stream.readString(numValues);
                break;
              case 3:
                stream.setHead(numValues > 2 ? valueOffset : entryOffset + 8);
                if (numValues === 1) {
                  value = stream.readInt16(!bigEndian);
                } else {
                  value = [];
                  for (let i2 = 0; i2 < numValues; i2++) {
                    value.push(stream.readInt16(!bigEndian));
                  }
                }
                break;
              case 4:
              case 9:
                stream.setHead(numValues > 1 ? valueOffset : entryOffset + 8);
                if (numValues === 1) {
                  value = stream.readInt32(!bigEndian);
                } else {
                  value = [];
                  for (let i2 = 0; i2 < numValues; i2++) {
                    value.push(stream.readInt32(!bigEndian));
                  }
                }
                break;
              case 5:
              case 10:
                stream.setHead(valueOffset);
                if (numValues === 1) {
                  const numerator = stream.readInt32(!bigEndian);
                  const denominator = stream.readInt32(!bigEndian);
                  value = numerator / denominator;
                } else {
                  value = [];
                  for (let i2 = 0; i2 < numValues; i2++) {
                    const numerator = stream.readInt32(!bigEndian);
                    const denominator = stream.readInt32(!bigEndian);
                    const val = numerator / denominator;
                    value.push(val);
                  }
                }
                break;
            }
            tags[tag] = value;
            tagData[tag] = {
              value,
              numValues,
              entryOffset,
              valueOffset,
              type
            };
          }
        }
        return { tags, tagData };
      }
      getBuffer() {
        return this._buf;
      }
    };
    exif_data_default = EXIFData;
  }
});

// engine/sdk/core/lib/jpeg/jfif-data.js
var MARKERS3, JFIFData, jfif_data_default;
var init_jfif_data = __esm({
  "engine/sdk/core/lib/jpeg/jfif-data.js"() {
    init_array_stream();
    init_constants3();
    ({ MARKERS: MARKERS3 } = constants_default2);
    JFIFData = class {
      constructor(buf) {
        this._buf = buf;
        this._stream = new array_stream_default(this._buf);
        this._stream.setHead(0);
      }
      isValid() {
        this._stream.setHead(0);
        const marker = this._stream.readInt16();
        if (marker !== MARKERS3.APP0) {
          return false;
        }
        const length = this._stream.readInt16();
        if (!(length >= 16)) {
          return false;
        }
        const fileIdentifier = this._stream.readString(4);
        const fileIdentifierEndMarker = this._stream.readInt8();
        if (!(fileIdentifier === "JFIF")) {
          return false;
        }
        if (!(fileIdentifierEndMarker === 0)) {
          return false;
        }
        return true;
      }
      setUnitDensity(val) {
        this._stream.setHead(11);
        this._stream.writeInt8(val);
      }
      setDensityX(val) {
        this._stream.setHead(12);
        this._stream.writeInt16(val);
      }
      setDensityY(val) {
        this._stream.setHead(14);
        this._stream.writeInt16(val);
      }
      getUnitDensity() {
        this._stream.setHead(11);
        return this._stream.readInt8();
      }
      getDensityX() {
        this._stream.setHead(12);
        return this._stream.readInt16();
      }
      getDensityY() {
        this._stream.setHead(14);
        return this._stream.readInt16();
      }
      getBuffer() {
        return this._buf;
      }
    };
    jfif_data_default = JFIFData;
  }
});

// engine/sdk/core/lib/exif.js
var invariant2, MARKERS4, DATA_JPEG_PREFIX, JPEG_REGEX, EXIF, exif_default;
var init_exif = __esm({
  "engine/sdk/core/lib/exif.js"() {
    init_array_stream();
    init_base64();
    init_constants3();
    init_exif_data();
    init_jfif_data();
    init_utils();
    ({ invariant: invariant2 } = utils_default);
    ({ MARKERS: MARKERS4 } = constants_default2);
    DATA_JPEG_PREFIX = "data:image/jpeg;base64,";
    JPEG_REGEX = new RegExp(`^${DATA_JPEG_PREFIX}`, "i");
    EXIF = class {
      constructor(buf) {
        this._buf = buf;
        this._stream = new array_stream_default(this._buf);
        this._stream.setHead(0);
        this._segments = this._sliceIntoSegments(this._buf);
        this._exifData = new exif_data_default(this._getMarkerBuffer(MARKERS4.EXIF));
        this._jfifData = new jfif_data_default(this._getMarkerBuffer(MARKERS4.JFIF));
      }
      static toDataURL(data) {
        return DATA_JPEG_PREFIX + base64_default.encode(data);
      }
      static fromDataURL(dataURL) {
        const raw = dataURL.replace(DATA_JPEG_PREFIX, "");
        const data = base64_default.decode(raw);
        return data;
      }
      restoreSegmentsInArray(buffer) {
        buffer = this.restoreExifTagsToImageData(buffer);
        return this.restoreJfifSegmentToImageData(buffer);
      }
      restoreSegments(base64String) {
        let data = EXIF.fromDataURL(base64String);
        data = this.restoreSegmentsInArray(data);
        return EXIF.toDataURL(data);
      }
      restoreExifTagsToImageData(data) {
        if (!this._exifData.isValid()) {
          return data;
        }
        const segments = this._sliceIntoSegments(data);
        const segmentStart = segments[1][0];
        const dataBefore = data.slice(0, segmentStart);
        const dataAfter = data.slice(segmentStart);
        let newData = dataBefore.concat(this._exifData.getBuffer());
        newData = newData.concat(dataAfter);
        return newData;
      }
      restoreJfifSegmentToImageData(data) {
        if (!this._jfifData.isValid()) {
          return data;
        }
        const segments = this._sliceIntoSegments(data);
        const segment = this._findSegment(MARKERS4.JFIF, segments);
        let newData = [];
        if (segment) {
          const offset = segment[0];
          const end = segment[1];
          const dataBefore = data.slice(0, offset);
          const dataBuf = data.slice(offset, end);
          const dataAfter = data.slice(end);
          const jfifData = new jfif_data_default(dataBuf);
          jfifData.setDensityX(this._jfifData.getDensityX());
          jfifData.setDensityY(this._jfifData.getDensityY());
          jfifData.setUnitDensity(this._jfifData.getUnitDensity());
          newData = dataBefore.concat(dataBuf).concat(dataAfter);
        } else {
          return data;
        }
        return newData;
      }
      restoreExifTags(base64String) {
        const data = EXIF.fromDataURL(base64String);
        const newData = this.restoreExifTagsToImageData(data);
        return EXIF.toDataURL(newData);
      }
      restoreJfifSegment(base64String) {
        if (!this._jfifData.isValid()) {
          return base64String;
        }
        const data = EXIF.fromDataURL(base64String);
        const newData = this.restoreJfifSegmentToImageData(data);
        return EXIF.toDataURL(newData);
      }
      setOrientation(orientation) {
        return this._exifData.setOrientation(orientation);
      }
      static isJPEG(base64String) {
        return JPEG_REGEX.test(base64String);
      }
      static bufferIsJPEG(data) {
        return data[0] === 255 && data[1] === 216 && data[2] === 255;
      }
      static fromBase64String(base64String) {
        const raw = base64String.replace(DATA_JPEG_PREFIX, "");
        const data = base64_default.decode(raw);
        return new EXIF(data);
      }
      _findSegment(identifier, segments = this._segments) {
        for (let i = 0; i < segments.length; i++) {
          const offset = segments[i][0];
          const end = segments[i][1];
          this._stream.setHead(offset);
          const marker = this._stream.peekInt16();
          if (marker === identifier) {
            return [offset, end];
          }
        }
        return false;
      }
      _getLastSegment(segments = this._segments) {
        return segments[segments.length - 1];
      }
      _getMarkerBuffer(identifier, segments = this._segments) {
        const segment = this._findSegment(identifier, segments);
        if (segment) {
          const offset = segment[0];
          const end = segment[1];
          return this._buf.slice(offset, end);
        }
        return false;
      }
      _sliceIntoSegments(buf) {
        const stream = new array_stream_default(buf);
        const segments = [];
        while (stream.getHead() < buf.length) {
          const marker = stream.readInt16();
          if (marker === MARKERS4.SOI) {
            continue;
          }
          if (marker === MARKERS4.SOS) {
            break;
          }
          if (marker >= 65280 && marker <= 65535) {
            const length = stream.readInt16();
            const end = stream.getHead() + length - 2;
            segments.push([stream.getHead() - 4, end]);
            stream.setHead(end);
          } else {
            throw new Error(`Invalid marker: 0x${marker.toString(16)}`);
          }
        }
        this._stream.setHead(0);
        return segments;
      }
      getTags() {
        return this._exifData.getTags();
      }
      getTagData() {
        return this._exifData.getTagData();
      }
      dispose() {
        this._buf = [];
        this._segments = [];
      }
    };
    exif_default = EXIF;
  }
});

// engine/sdk/core/lib/image.js
var Image2, image_default;
var init_image = __esm({
  "engine/sdk/core/lib/image.js"() {
    if (false) {
      Image2 = typeof window !== "undefined" && window.Image;
    }
    if (true) {
      Image2 = require("canvas").Image;
    }
    image_default = Image2;
  }
});

// engine/sdk/core/lib/operations-stack.js
var OperationsStack, operations_stack_default;
var init_operations_stack = __esm({
  "engine/sdk/core/lib/operations-stack.js"() {
    init_globals2();
    init_event_emitter();
    OperationsStack = class extends event_emitter_default {
      constructor(operations = []) {
        super();
        this._onOperationUpdate = this._onOperationUpdate.bind(this);
        this._cacheEnabled = true;
        this._stack = operations;
        this._stack.forEach((operation) => {
          operation.on("update", this._onOperationUpdate);
        });
      }
      clear() {
        this.forEach((operation) => this.remove(operation));
        this._stack = [];
      }
      hasChanges() {
        return this._stack.filter((op) => !!op).some((op) => op.hasChanges());
      }
      _onOperationUpdate(operation, options) {
        this.emit(Events.OPERATION_UPDATED, operation, options);
      }
      enableCache() {
        this._cacheEnabled = true;
      }
      disableCache() {
        this._cacheEnabled = false;
      }
      forEach(iterator) {
        return this._stack.filter((op) => !!op).forEach(iterator);
      }
      render(sdk, inputTexture) {
        const currentTexture = inputTexture;
        const operations = this._stack.filter((op) => !!op).filter((op) => op.getEnabled());
        operations.reverse();
        const firstUndirtyOperation = operations.filter((o) => !o.isDirtyForRenderer(sdk.getRenderer()))[0];
        const firstUndirtyIndex = operations.indexOf(firstUndirtyOperation);
        operations.reverse();
        let startIndex = 0;
        if (firstUndirtyIndex !== -1) {
          startIndex = operations.length - firstUndirtyIndex - 1;
        }
        for (let index = 0; index < startIndex; index++) {
          log_default.info(this.constructor.name, `Skipping ${operations[index].constructor.name}`);
        }
        let promise = Promise.resolve(currentTexture);
        for (let index = startIndex; index < operations.length; index++) {
          const operation = operations[index];
          let lastTexture;
          let lastTextureOperation;
          promise = promise.then((inputTexture2) => {
            return operation.render(inputTexture2).then((outputTexture) => {
              if (lastTexture && outputTexture !== lastTexture && !this._cacheEnabled) {
                lastTextureOperation.disposeRenderTextures();
              }
              lastTexture = outputTexture;
              lastTextureOperation = operation;
              return outputTexture;
            });
          });
        }
        return promise.then((outputTexture) => {
          const renderDone = !operations.some((op) => op.isDirtyForRenderer(sdk.getRenderer()));
          return { outputTexture, renderDone };
        });
      }
      validateSettings() {
        return Promise.all(this._stack.filter((op) => !!op).map((op) => op.validateSettings()));
      }
      setAllToDirty(dimensionsChanged = false) {
        this.forEach((op) => op.setDirty(true, dimensionsChanged));
      }
      updateDirtinessForRenderer(renderer) {
        let dirtyFound = false;
        for (let i = 0; i < this._stack.length; i++) {
          const operation = this._stack[i];
          if (!operation)
            continue;
          if (operation.isDirtyForRenderer(renderer)) {
            dirtyFound = true;
          }
          if (dirtyFound) {
            operation.setDirtyForRenderer(true, renderer);
          }
        }
      }
      push(operation) {
        this._stack.push(operation);
        operation.on("update", this._onOperationUpdate);
      }
      pop() {
        const operation = this._stack.pop();
        if (operation) {
          operation.off("update", this._onOperationUpdate);
          operation.dispose();
        }
      }
      unshift(operation) {
        this._stack.unshift(operation);
        operation.on("update", this._onOperationUpdate);
      }
      clone() {
        return new OperationsStack(this._stack.slice(0));
      }
      get(index) {
        return this._stack[index];
      }
      getByIdentifier(identifier) {
        return utils_default.Array.find(this._stack, (item) => item && item.constructor.identifier === identifier);
      }
      getIndexByIdentifier(identifier) {
        return utils_default.Array.findIndex(this._stack, (item) => item && item.constructor.identifier === identifier);
      }
      moveToTop(identifier) {
        const index = utils_default.Array.findIndex(this._stack, (item) => item && item.constructor.identifier === identifier);
        if (index < 0 || index === this._stack.length - 1) {
          return;
        }
        const operation = this.getByIdentifier(identifier);
        this._stack.splice(index, 1);
        this._stack[this._stack.length] = operation;
      }
      set(index, operation) {
        if (this._stack[index]) {
          this._stack[index].off("update", this._onOperationUpdate);
          this._stack[index].dispose();
        }
        this._stack[index] = operation;
        operation.on("update", this._onOperationUpdate);
      }
      remove(operation) {
        const index = this._stack.indexOf(operation);
        if (index === -1) {
          return;
        }
        if (this._stack[index]) {
          this._stack[index].off("update", this._onOperationUpdate);
          this._stack[index].dispose();
        }
        this._stack.splice(index, 1);
      }
      removeAt(index) {
        if (this._stack[index]) {
          this._stack[index].off("update", this._onOperationUpdate);
          this._stack[index].dispose();
        }
        delete this._stack[index];
      }
      getStack() {
        return this._stack;
      }
      dispose() {
        this.forEach((operation) => {
          operation.dispose();
        });
      }
    };
    operations_stack_default = OperationsStack;
  }
});

// engine/sdk/core/lib/performance-test.js
var now2, PerformanceTest, performance_test_default;
var init_performance_test = __esm({
  "engine/sdk/core/lib/performance-test.js"() {
    init_globals2();
    now2 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();
    PerformanceTest = class {
      constructor(tag, name) {
        this._tag = tag;
        this._name = name;
        this._start = now2();
      }
      stop() {
        const end = now2();
        const ms = end - this._start;
        const fps = Math.round(1e3 / ms);
        log_default.info(this._tag, `${this._name} took ${ms.toFixed(2)}ms (${fps} FPS)`);
      }
    };
    performance_test_default = PerformanceTest;
  }
});

// engine/sdk/core/operations/operation.js
var Operation, operation_default;
var init_operation = __esm({
  "engine/sdk/core/operations/operation.js"() {
    init_log();
    init_constants();
    init_engine();
    init_configurable();
    init_performance_test();
    Operation = class extends configurable_default {
      constructor(sdk, options = {}) {
        super(options, {
          enabled: { type: "boolean" /* BOOLEAN */, default: true, serializable: false }
        });
        this._sdk = sdk;
        this._cacheEnabled = false;
        this._dirtiness = {};
        this._sprite = new engine_default.Sprite();
        this._container = new engine_default.Container();
        this._container.addChild(this._sprite);
      }
      _onOptionsChange() {
        this.setDirty(true);
      }
      render(inputTexture) {
        if (!this.getEnabled()) {
          log_default.info(this.constructor.name, "Disabled - skipping");
          return Promise.resolve(inputTexture);
        }
        if (!this._renderTexture) {
          const newDimensions = inputTexture.getDimensions().floor();
          this._renderTexture = new engine_default.RenderTexture(this._sdk.getRenderer(), newDimensions.x, newDimensions.y);
        }
        const renderer = this._sdk.getRenderer();
        let promise;
        let perf;
        if (log_default.canLog("info")) {
          perf = new performance_test_default(this.constructor.name, "Rendering");
        }
        if (this.isDirtyForRenderer(renderer)) {
          this._sprite.setTexture(inputTexture);
          const newDimensions = this.getNewDimensions(inputTexture.getDimensions()).floor();
          this._renderTexture.resizeTo(newDimensions);
          this._renderTexture.clear();
          promise = this._render(inputTexture).then((stillDirty = false) => {
            this.setDirtyForRenderer(stillDirty, renderer);
            return this._renderTexture;
          });
        } else {
          log_default.info(this.constructor.name, "Rendering from cache");
          promise = Promise.resolve(this._renderTexture);
        }
        return promise.then((outputTexture) => {
          if (perf)
            perf.stop();
          return outputTexture;
        });
      }
      _render(inputTexture) {
        let renderFn;
        if (this._sdk.getRenderer().isOfType("webgl" /* WEBGL */)) {
          renderFn = this._renderWebGL.bind(this);
        } else {
          renderFn = this._renderCanvas.bind(this);
        }
        return renderFn(inputTexture);
      }
      _renderWebGL(inputTexture) {
        throw new Error("Operation#_renderWebGL is abstract and not implemented in inherited class.");
      }
      _renderCanvas(inputTexture) {
        throw new Error("Operation#_renderCanvas is abstract and not implemented in inherited class.");
      }
      getNewDimensions(dimensions) {
        return dimensions.clone();
      }
      onBeforeExport() {
        if (this.transform && this._tempTransformChange) {
          this.transform(this._tempTransformChange);
        }
        this._onBeforeExport();
      }
      onAfterExport() {
        if (this.transform && this._tempInverseTransformChange) {
          this.transform(this._tempInverseTransformChange);
        }
        this._onAfterExport();
      }
      _onBeforeExport() {
      }
      _onAfterExport() {
      }
      setTemporaryTransformChange(transformChange, inverseTransformChange) {
        this._tempTransformChange = transformChange;
        this._tempInverseTransformChange = inverseTransformChange;
      }
      reset() {
        this._dirty = true;
        this._glslPrograms = {};
      }
      isDirtyForRenderer(renderer) {
        const dirty = this._dirtiness[renderer.id];
        return typeof dirty === "undefined" ? true : dirty;
      }
      setDirtyForRenderer(dirty, renderer, dimensionsChanged = false) {
        this._dirtiness[renderer.id] = dirty;
      }
      setDirty(dirty, dimensionsChanged = false) {
        for (const rendererId in this._dirtiness) {
          this.setDirtyForRenderer(dirty, { id: rendererId }, dimensionsChanged);
        }
      }
      getSDK() {
        return this._sdk;
      }
      getInputDimensions(incorporateZoom = true) {
        let dimensions = this._sdk.getInputDimensions();
        if (incorporateZoom) {
          dimensions.multiply(this._sdk.getZoom()).floor();
        }
        let opFound;
        this._sdk.getOperationsStack().forEach((op) => {
          if (opFound)
            return;
          if (op === this) {
            opFound = true;
            return;
          }
          dimensions = op.getNewDimensions(dimensions);
        });
        return dimensions.floor();
      }
      clone() {
        const Operation2 = this.constructor;
        return new Operation2(this._sdk, this.serializeOptions());
      }
      disposeRenderTextures() {
        if (this._renderTexture) {
          this._renderTexture.dispose();
        }
        this._renderTexture = null;
      }
      dispose() {
        this.disposeRenderTextures();
        this._sprite.dispose();
      }
    };
    Operation.identifier = null;
    operation_default = Operation;
  }
});

// engine/sdk/core/operations/exif-orientation-operation.js
var OptionType5, ExifOrientationOperation, exif_orientation_operation_default;
var init_exif_orientation_operation = __esm({
  "engine/sdk/core/operations/exif-orientation-operation.js"() {
    init_globals2();
    init_vector2();
    init_operation();
    ({ OptionType: OptionType5 } = constants_exports);
    ExifOrientationOperation = class extends operation_default {
      getRotation() {
        let degrees = 0;
        switch (this.getTags().Orientation) {
          case 7:
          case 8:
            degrees = -90;
            break;
          case 3:
          case 4:
            degrees = -180;
            break;
          case 5:
          case 6:
            degrees = 90;
            break;
        }
        return degrees;
      }
      _getFlipVertically() {
        const { Orientation } = this.getTags();
        return [5, 7].indexOf(Orientation) !== -1;
      }
      _getFlipHorizontally() {
        const { Orientation } = this.getTags();
        return [2, 4].indexOf(Orientation) !== -1;
      }
      _getFinalOptions() {
        return {
          rotation: this.getRotation(),
          flipVertically: this._getFlipVertically(),
          flipHorizontally: this._getFlipHorizontally()
        };
      }
      _render(sdk) {
        const options = this._getFinalOptions();
        const actualDegrees = options.rotation % 360;
        const radians = actualDegrees * (Math.PI / 180);
        this._sprite.setScale(options.flipHorizontally ? -1 : 1, options.flipVertically ? -1 : 1);
        this._sprite.setRotation(radians);
        this._sprite.setAnchor(0.5, 0.5);
        this._sprite.updateTransform();
        const bounds = this._sprite.getBounds();
        this._renderTexture.resizeTo(new Vector2(bounds.width, bounds.height));
        this._sprite.setPosition(this._renderTexture.getDimensions().divide(2));
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      getNewDimensions(dimensions) {
        const options = this._getFinalOptions();
        dimensions = dimensions.clone();
        if (options.rotation % 180) {
          dimensions.flip();
        }
        return dimensions;
      }
      applyTo(image) {
        const options = this._getFinalOptions();
        const canvas = utils_default.createCanvas();
        if (Math.abs(options.rotation % 180) === 90) {
          canvas.width = image.height;
          canvas.height = image.width;
        } else {
          canvas.width = image.width;
          canvas.height = image.height;
        }
        const context = canvas.getContext("2d");
        const rotation = options.rotation * Math.PI / 180;
        const adjustX = 0.5 * (canvas.width - image.width);
        const adjustY = 0.5 * (canvas.height - image.height);
        context.translate(adjustX, adjustY);
        context.translate(0.5 * image.width, 0.5 * image.height);
        context.rotate(rotation);
        context.translate(-0.5 * image.width, -0.5 * image.height);
        if (options.flipVertically) {
          context.translate(0, image.height);
          context.scale(1, -1);
        }
        if (options.flipHorizontally) {
          context.translate(image.width, 0);
          context.scale(-1, 1);
        }
        context.drawImage(image, 0, 0);
        return canvas;
      }
    };
    ExifOrientationOperation.identifier = "exif-orientation";
    ExifOrientationOperation.prototype.availableOptions = {
      tags: { type: OptionType5.OBJECT, default: {} }
    };
    exif_orientation_operation_default = ExifOrientationOperation;
  }
});

// engine/sdk/core/operations/index.js
var operations_exports = {};
__export(operations_exports, {
  ExifOrientationOperation: () => exif_orientation_operation_default
});
var init_operations = __esm({
  "engine/sdk/core/operations/index.js"() {
    init_exif_orientation_operation();
  }
});

// engine/sdk/core/lib/image-exporter.js
var ImageExporter, image_exporter_default;
var init_image_exporter = __esm({
  "engine/sdk/core/lib/image-exporter.js"() {
    init_cleanUpCanvasMemory();
    init_constants();
    init_engine();
    init_color();
    init_configurable();
    init_image();
    init_utils();
    ImageExporter = class extends configurable_default {
      constructor(sdk, options = {}) {
        super(options);
        this._sdk = sdk;
      }
      export() {
        const { imageFormat, transparent } = this._options;
        const rerenderIfNeeded = (response) => {
          if (!response.renderDone) {
            return this._sdk.render().then((response2) => {
              return rerenderIfNeeded(response2);
            });
          }
          return response;
        };
        return this.validateSettings().then(() => {
          return this._prepareSDK().then((response) => {
            return rerenderIfNeeded(response);
          });
        }).then((response) => {
          const { outputTexture, renderDone } = response;
          const renderer = this._sdk.getRenderer();
          const clearColor = renderer.getClearColor();
          if (imageFormat === "image/png" && transparent) {
            renderer.setClearColor(new color_default(0, 0, 0, 0));
          }
          let canvas = renderer.getCanvas();
          if (renderer.isOfType("webgl" /* WEBGL */)) {
            canvas = this._createCanvasFromTexture(outputTexture);
          }
          renderer.setClearColor(clearColor);
          return this._encodeImageFormat(canvas);
        }).then((result) => {
          return this._restoreExifMetadata(result, imageFormat);
        }).then((result) => {
          return this._restoreSDK().then(() => result);
        });
      }
      _restoreExifMetadata(result, imageFormat, quality) {
        if (imageFormat === ImageFormat.JPEG) {
          const exif = this._sdk.getExif();
          if (exif) {
            if (false) {
              if (typeof result === "string") {
                result = exif.restoreSegments(result);
              }
            }
            if (true) {
              const { renderType } = this._options;
              if (renderType === RenderType.BUFFER) {
                result = Buffer.from(exif.restoreSegmentsInArray([...result]));
              } else if (renderType === RenderType.DATAURL && typeof result === "string") {
                result = exif.restoreSegments(result);
              }
            }
          }
        }
        return Promise.resolve(result);
      }
      _encodeAsDataURL(canvas, imageFormat, quality) {
        if (utils_default.isBrowser) {
          const image = canvas.toDataURL(imageFormat, quality);
          cleanUpCanvasMemory(canvas);
          return Promise.resolve(image);
        }
        try {
          const image = canvas.toDataURL(imageFormat, quality);
          cleanUpCanvasMemory(canvas);
          return Promise.resolve(image);
        } catch (error) {
          return Promise.error(error);
        }
      }
      _encodeAsHTMLImage(canvas, imageFormat, quality) {
        return this._encodeAsDataURL(canvas, imageFormat, quality).then((dataURI) => {
          const outputImage = new image_default();
          outputImage.src = dataURI;
          cleanUpCanvasMemory(canvas);
          return Promise.resolve(outputImage);
        });
      }
      _encodeAsBuffer(canvas, imageFormat, quality) {
        if (true) {
          if (imageFormat === ImageFormat.JPEG) {
            const buffer = canvas.toBuffer(imageFormat, {
              quality,
              progressive: true,
              chromaSubsampling: false
            });
            cleanUpCanvasMemory(canvas);
            return Promise.resolve(buffer);
          }
          if (imageFormat === ImageFormat.PNG) {
            const buffer = canvas.toBuffer(imageFormat, { quality });
            cleanUpCanvasMemory(canvas);
            return Promise.resolve(buffer);
          }
          if (imageFormat === ImageFormat.RAW) {
            const buffer = canvas.toBuffer(imageFormat);
            cleanUpCanvasMemory(buffer);
            return Promise.resolve(buffer);
          }
          return Promise.reject(new Error(`Unsupported imageFormat: ${imageFormat}`));
        }
        return Promise.reject(new Error("Unsupported platform for RenderType"));
      }
      _encodeAsMSBlob(canvas, imageFormat, quality) {
        const blob = canvas.msToBlob();
        cleanUpCanvasMemory(canvas);
        return Promise.resolve(blob);
      }
      _encodeAsBLOB(canvas, imageFormat, quality) {
        return new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            resolve(blob);
          }, imageFormat, quality);
        });
      }
      _encodeImageFormat(canvas) {
        const { imageFormat, quality } = this._options;
        let { renderType } = this._options;
        if (renderType === RenderType.BLOB && canvas.msToBlob && !canvas.toBlob) {
          renderType = RenderType.MSBLOB;
        }
        switch (renderType) {
          case RenderType.IMAGE: {
            return this._encodeAsHTMLImage(canvas, imageFormat, quality);
          }
          case RenderType.DATAURL: {
            return this._encodeAsDataURL(canvas, imageFormat, quality);
          }
          case RenderType.BUFFER: {
            return this._encodeAsBuffer(canvas, imageFormat, quality);
          }
          case RenderType.MSBLOB: {
            return this._encodeAsMSBlob(canvas, imageFormat, quality);
          }
          case RenderType.BLOB: {
            return this._encodeAsBLOB(canvas, imageFormat, quality);
          }
        }
        return Promise.reject(new Error(`Unsupported RenderType: ${renderType}!`));
      }
      _prepareSDK() {
        const renderer = this._sdk.getRenderer();
        this._sdkSettings = {
          dimensions: renderer.getDimensions().clone(),
          textureQuality: this._sdk.getTextureQuality(),
          rendererPixelRatio: renderer.getPixelRatio(),
          renderMode: this._sdk.getRenderMode()
        };
        this._sdk.setRenderMode("export");
        this._sdk.setTextureQuality(1);
        const resizeCanvas = renderer.isOfType("canvas" /* CANVAS */);
        renderer.setPixelRatio(1);
        renderer.resizeTo(this._sdk.getFinalDimensions(), resizeCanvas);
        this._sdk.setAllOperationsToDirty(true);
        const stack = this._sdk.getOperationsStack();
        stack.forEach((operation) => {
          operation.disposeRenderTextures();
        });
        stack.disableCache();
        return this._sdk.render();
      }
      _restoreSDK() {
        const stack = this._sdk.getOperationsStack();
        stack.enableCache();
        this._sdk.setRenderMode(this._sdkSettings.renderMode);
        const renderer = this._sdk.getRenderer();
        const resizeCanvas = renderer.isOfType("canvas" /* CANVAS */);
        renderer.setPixelRatio(this._sdkSettings.rendererPixelRatio);
        renderer.resizeTo(this._sdkSettings.dimensions, resizeCanvas);
        this._sdk.setTextureQuality(this._sdkSettings.textureQuality);
        this._sdk.setAllOperationsToDirty(true);
        return this._sdk.render();
      }
      _createCanvasFromTexture(texture) {
        const renderer = this._sdk.getRenderer();
        const finalDimensions = this._sdk.getFinalDimensions();
        const gl = this._sdk.getRenderer().getContext();
        const fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        const glTexture = texture.getBaseTexture().getGLTextureForRenderer(renderer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
        const pixels = new Uint8Array(finalDimensions.x * finalDimensions.y * 4);
        gl.readPixels(0, 0, finalDimensions.x, finalDimensions.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        const hasTransparency = this._checkPixelsForTransparency(pixels);
        let renderTexture;
        if (hasTransparency) {
          const sprite = new engine_default.Sprite(texture);
          sprite.setFilters([new engine_default.Filters.UnpremultiplyFilter()]);
          const container = new engine_default.Container();
          container.addChild(sprite);
          renderTexture = new engine_default.RenderTexture(renderer, finalDimensions.x, finalDimensions.y);
          renderTexture.render(container);
          const glTexture2 = renderTexture.getBaseTexture().getGLTextureForRenderer(renderer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture2, 0);
          gl.readPixels(0, 0, finalDimensions.x, finalDimensions.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          renderer.setRenderTarget();
          renderTexture.dispose();
        }
        const canvas = utils_default.createCanvas();
        canvas.width = finalDimensions.x;
        canvas.height = finalDimensions.y;
        const context = canvas.getContext("2d");
        const imageData = context.createImageData(finalDimensions.x, finalDimensions.y);
        imageData.data.set(pixels);
        context.putImageData(imageData, 0, 0);
        gl.deleteFramebuffer(fbo);
        return canvas;
      }
      _checkPixelsForTransparency(pixels) {
        const finalDimensions = this._sdk.getFinalDimensions();
        const maxIndex = finalDimensions.x * finalDimensions.y * 4;
        let value;
        for (let i = 3; i < maxIndex; i += 4) {
          value = pixels[i];
          if (value !== 255) {
            return true;
          }
        }
        return false;
      }
    };
    ImageExporter.prototype.availableOptions = {
      renderType: {
        type: "string" /* STRING */,
        available: utils_default.values(RenderType),
        default: RenderType.IMAGE
      },
      imageFormat: {
        type: "string" /* STRING */,
        available: utils_default.values(ImageFormat),
        default: ImageFormat.PNG
      },
      quality: { type: "number" /* NUMBER */, default: 0.8 },
      transparent: {
        type: "boolean" /* BOOLEAN */,
        default: true
      }
    };
    image_exporter_default = ImageExporter;
  }
});

// engine/sdk/core/sdk.js
var Rectangle2, Constants, Engine2, Utils2, EventEmitter2, Events2, Vector22, Log3, Base642, Color2, bd2, RenderType2, ImageFormat2, RendererType3, PhotoEditorSDK, sdk_default;
var init_sdk = __esm({
  "engine/sdk/core/sdk.js"() {
    init_globals2();
    init_exif();
    init_image();
    init_image_exporter();
    init_operations_stack();
    init_performance_test();
    init_operations();
    ({
      Rectangle: Rectangle2,
      Constants,
      Engine: Engine2,
      Utils: Utils2,
      EventEmitter: EventEmitter2,
      Events: Events2,
      Vector2: Vector22,
      Log: Log3,
      Base64: Base642,
      Color: Color2
    } = globals_exports2);
    bd2 = (str) => Utils2.byteArrayToString(Base642.decode(str));
    ({ RenderType: RenderType2, ImageFormat: ImageFormat2, RendererType: RendererType3 } = Constants);
    PhotoEditorSDK = class extends EventEmitter2 {
      constructor(preferredRenderer, options = {}) {
        super();
        __publicField(this, "_onContextLost", () => {
          this.emit("context-lost");
        });
        __publicField(this, "_initWatermark", () => {
          if (this._options.watermark && this._options.watermark.watermarkURI) {
            this._watermarkOperation = this.createOperation("watermark", {
              watermarkURI: this._options.watermark.watermarkURI,
              alignment: this._options.watermark.alignment,
              inset: this._options.watermark.inset,
              size: this._options.watermark.size,
              crossOrigin: this._options.crossOrigin
            });
          }
        });
        this._onOperationUpdate = this._onOperationUpdate.bind(this);
        this._onContextRestored = this._onContextRestored.bind(this);
        this.version = "4.27.0";
        this[bd2("VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=")] = true;
        this._preferredRenderer = preferredRenderer;
        this._options = __spreadProps(__spreadValues({}, options), {
          extensions: {},
          renderMode: "dynamic",
          versionCheck: true,
          displayWelcomeMessage: true,
          image: null,
          canvas: null,
          transparent: false,
          textureQuality: 1,
          zoom: 1,
          spriteScale: 1,
          rotation: 0,
          smoothDownscaling: false,
          smoothUpscaling: false,
          crossOrigin: "anonymous",
          logLevel: "warn",
          pixelRatio: Math.max(typeof window !== "undefined" && window.devicePixelRatio || 1, 1)
        });
        if (this._options.smoothUpscaling) {
          Engine2.BaseTexture.DefaultMagFilter = Engine2.BaseTexture.LinearFilter;
        }
        this._options.extensions = Object.assign(this._options.extensions, {
          operations: [],
          controls: [],
          languages: []
        });
        Log3.setLevel(this._options.logLevel);
        this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")] = false;
        if (!this[bd2("X29wdGlvbnM=")][bd2("bGljZW5zZQ==")]) {
          this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")] = true;
          this._l = new globals_exports2[bd2("RnJlZUxpY2Vuc2VDaGVja2Vy")]();
        } else {
          const L2 = globals_exports2[bd2("TGljZW5zZUNoZWNrZXI=")];
          this._l = new L2(this[bd2("X29wdGlvbnM=")][bd2("bGljZW5zZQ==")]);
          this._cv(true).then(() => {
            this._ct();
          }).catch((e) => {
            Log3.error(bd2("TGljZW5zaW5n"), e.message);
          });
        }
        this._defaultRenderMode = this._options.renderMode;
        this._renderMode = this._options.renderMode;
        this._textureQuality = this._options.textureQuality;
        this._offset = new Vector22();
        this._zoom = this._options.zoom;
        this._spriteScale = this._options.spriteScale;
        this._rotation = this._options.rotation;
        this._operations = {};
        this._operationsStack = null;
        this.setOperationsStack(new operations_stack_default());
        this._container = new Engine2.Container();
        this._sprite = new Engine2.Sprite();
        this._container.addChild(this._sprite);
        this._inputTexture = this._options.inputTexture;
        this._currentInputTexture = null;
        this._currentTexture = null;
        this._resizedTexture = null;
        this._resizedContainer = new Engine2.Container();
        this._resizedSprite = new Engine2.Sprite();
        this._resizedContainer.addChild(this._resizedSprite);
        this._texturesToDispose = [];
        this.setSmoothDownscaling(this._options.smoothDownscaling);
        this._registerOperations();
        this._initRenderer();
        const renderer = this._renderer.constructor.type;
        if (this._options.displayWelcomeMessage) {
          if (true) {
            Log3.log("Version:", `${this.version} (${renderer}) - https://img.ly/photo-sdk`);
          }
        }
        if (this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")]) {
          Log3.log(bd2("VGhlIFBob3RvRWRpdG9yIFNESyBpcyBhIGNvbW1lcmNpYWwgcHJvZHVjdC4gQmVmb3JlIGJlaW5nIGFibGUgdG8gdXNlIGl0IHdpdGhvdXQgbGltaXRhdGlvbnMsIHlvdSBuZWVkIHRvIHVubG9jayB0aGUgU0RLIHdpdGggYSBsaWNlbnNlIGZpbGUuIFlvdSBjYW4gb2J0YWluIGEgdGltZS1saW1pdGVkIGV2YWx1YXRpb24gbGljZW5zZSBieSBzdGFydGluZyBhIHRyaWFsIGF0IGh0dHBzOi8vd3d3LmltZy5seS9zaWdudXAgb3IgeW91IGNhbiBwdXJjaGFzZSBhIGxpY2Vuc2UgYnkgcmVxdWVzdGluZyBhIHF1b3RlIGF0IGh0dHBzOi8vd3d3LmltZy5seS9wcmljaW5nLgoKQmVjYXVzZSB5b3UgZGlkIG5vdCBzcGVjaWZ5IGEgbGljZW5zZSBmaWxlIHlldCwgdGhlIFNESyB3aWxsIG5vdyBkaXNwbGF5IGEgd2F0ZXJtYXJrIGltYWdlIG9uIHRvcCBvZiBhbnkgcGhvdG9zIHlvdSBkaXNwbGF5IG9yIGV4cG9ydCB3aXRoIGl0LiBGb3IgaW5zdHJ1Y3Rpb25zIGZvciBob3cgdG8gdW5sb2NrIHRoZSBTREssIHBsZWFzZSB2aXNpdCBodHRwczovL2ltZy5seS9kb2NzL3Blc2RrL3dlYi9pbnRyb2R1Y3Rpb24vZ2V0dGluZ19zdGFydGVkLg=="));
        }
        if (this._options.image) {
          this.setImage(this._options.image, this._options.exif);
        }
      }
      _ct() {
        if (this._l.exp()) {
          const expired = this._l.isExp();
          if (expired) {
            Log3.error(bd2("TGljZW5zaW5n"), bd2("WW91ciB0cmlhbCBsaWNlbnNlIGhhcyBleHBpcmVkLiBQbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAaW1nLmx5Lg=="));
          } else {
            Log3.warn(bd2("TGljZW5zaW5n"), bd2("WW91ciB0cmlhbCBsaWNlbnNlIHdpbGwgZXhwaXJlIGluICVkIGRheXMu").replace("%d", this._l.dl()));
          }
        }
      }
      _cv(print = false) {
        return this._l.c().catch((e) => {
          this[bd2("VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=")] = false;
          let errorMessage = bd2("SW52YWxpZCBsaWNlbnNlLg==");
          if (print) {
            if (e.code === "ELICEXP") {
              errorMessage = bd2("WW91ciB0cmlhbCBsaWNlbnNlIGhhcyBleHBpcmVkLiBQbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAaW1nLmx5Lg==");
            } else if (e.code === "ELICINVHOST") {
              errorMessage = bd2("VGhlIGJ1bmRsZSBpZGVudGlmaWVycyB0aGF0IHlvdSBzcGVjaWZpZWQgaW4geW91ciBsaWNlbnNlIGZpbGUgZG8gbm90IG1hdGNoIHRoZSBhcHAncyBidW5kbGUgaWRlbnRpZmllci4gUGxlYXNlIHVwZGF0ZSBhbmQgcmVkb3dubG9hZCB5b3VyIGxpY2Vuc2UgZnJvbSB5b3VyIGN1c3RvbWVyIGRhc2hib2FyZCBhdCBodHRwczovL3d3dy5pbWcubHkvbG9naW4u");
            } else if (e.code === "ELICINVPLAT") {
              errorMessage = bd2("VGhlIGxpY2Vuc2UgdGhhdCB5b3Ugc3BlY2lmaWVkIGlzIGZvciBhbm90aGVyIHBsYXRmb3JtLiBQbGVhc2UgZG93bmxvYWQgeW91ciBsaWNlbnNlIGZvciB0aGUgd2ViIHBsYXRmb3JtIGZyb20geW91ciBjdXN0b21lciBkYXNoYm9hcmQgYXQgaHR0cHM6Ly93d3cuaW1nLmx5L2xvZ2luLg==");
            } else if (e.code === "ELICINVFMT") {
              errorMessage = bd2("SW52YWxpZCBsaWNlbnNlIGZvcm1hdC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UncmUgcGFzc2luZyB5b3VyIGxpY2Vuc2UgYXMgYSBzdHJpbmcsIG5vdCBhcyBgJGZvcm1hdGAu").replace("$format", typeof this._options.license);
            } else if (e.code === "ELICINV") {
              errorMessage = bd2("VGhlIHNpZ25hdHVyZSBvZiB5b3VyIGxpY2Vuc2UgaXMgbm90IHZhbGlkLiBQbGVhc2UgdHJ5IHRvIHJlZG93bmxvYWQgeW91ciBsaWNlbnNlIGZyb20geW91ciBjdXN0b21lciBkYXNoYm9hcmQgYXQgaHR0cHM6Ly93d3cuaW1nLmx5L2xvZ2luLg==");
            } else {
              errorMessage = bd2("SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIGxpY2Vuc2UgeWV0LCBwbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAaW1nLmx5IHRvIG9idGFpbiBhIGxpY2Vuc2Ugb3IgbG9nIGluIHRvIHlvdXIgY3VzdG9tZXIgZGFzaGJvYXJkLg==");
            }
          }
          e.message = errorMessage;
          throw new Error(e);
        });
      }
      _t() {
        this._l.t();
      }
      _fl() {
        return this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")];
      }
      _onOperationUpdate(...args) {
        this.emit(Events2.OPERATION_UPDATED, ...args);
      }
      _onContextRestored() {
        Log3.warn(this.constructor.name, "Trying to re-render after WebGL context has been restored.");
        this.setAllOperationsToDirty();
        this._operationsStack.forEach((operation) => {
          operation.disposeRenderTextures();
        });
        this.render();
      }
      export(renderType = RenderType2.DATAURL, imageFormat = ImageFormat2.PNG, quality = 0.8, transparent = true, unsupported = false) {
        return this._cv(true).then(() => {
          if (this.hasChanges() && !unsupported) {
            this._t();
          }
          this._operationsStack.forEach((op) => {
            op.onBeforeExport();
          });
          const imageExporter = new image_exporter_default(this, {
            renderType,
            imageFormat,
            quality,
            transparent
          });
          return imageExporter.export().then((result) => {
            this._operationsStack.forEach((op) => {
              op.onAfterExport();
            });
            return Promise.resolve(result);
          });
        });
      }
      render(renderOutput = true) {
        if (!this._inputTexture) {
          throw new Error("You need to set an image before calling PhotoEditorSDK#render.");
        }
        const context = this._renderer.getContext();
        if (context.startFrame) {
          context.startFrame();
        }
        let perfTest;
        if (Log3.canLog("info")) {
          perfTest = new performance_test_default("\u26A1\u26A1\u26A1", "Frame rendering");
        }
        Log3.info("\u26A1\u26A1\u26A1", "Rendering starts");
        const stack = this._operationsStack;
        stack.updateDirtinessForRenderer(this._renderer);
        return this._prepareTexture().then((texture) => {
          if (this._renderMode === "export") {
            texture = this._inputTexture;
          }
          this._currentTexture = texture;
          this._sprite.setTexture(texture);
          this._container.updateTransform();
        }).then(() => stack.validateSettings()).then(() => {
          if (this._fl() || !this[bd2("VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=")]) {
            if (!stack.getByIdentifier("license-watermark")) {
              this.createOperation("license-watermark");
            } else {
              stack.moveToTop("license-watermark");
            }
          }
          if (!stack.getByIdentifier("watermark")) {
            this._initWatermark();
          } else {
            stack.moveToTop("watermark");
          }
          return stack.render(this, this._currentTexture);
        }).then((response) => {
          const { outputTexture } = response;
          this._currentTexture = outputTexture;
          this._sprite.setTexture(this._currentTexture);
          switch (this._renderMode) {
            case "dynamic": {
              const center = this._renderer.getDimensions().clone().divide(2).add(this._offset);
              this._container.setScale(this._zoom / this.getTextureScale(), this._zoom / this.getTextureScale());
              this._container.setPosition(center);
              this._sprite.setAnchor(0.5, 0.5);
              this._sprite.setScale(this._spriteScale, this._spriteScale);
              this._sprite.setRotation(this._rotation);
              break;
            }
            case "export":
              this._container.setScale(1, 1);
              this._container.setPosition(0, 0);
              this._sprite.setAnchor(0, 0);
              this._sprite.setPosition(0, 0);
              this._sprite.setScale(this._spriteScale, this._spriteScale);
              this._sprite.setRotation(0);
              break;
            case "adapter":
              this._container.setScale(1, 1);
              this._container.setPosition(0, 0);
              this._sprite.setAnchor(0, 0);
              this._sprite.setPosition(0, 0);
              this._sprite.setScale(1, 1);
              this._sprite.setRotation(0);
              break;
          }
          if (renderOutput) {
            this._renderer.render(this._container);
          }
          return response;
        }).then((response) => {
          if (perfTest) {
            perfTest.stop();
          }
          if (context.endFrame) {
            context.endFrame();
          }
          this._disposeTextures();
          return response;
        });
      }
      getTextureScale() {
        return Math.min(1, this._textureQuality * this._options.pixelRatio);
      }
      _prepareTexture() {
        return new Promise((resolve, reject) => {
          const textureScale = this.getTextureScale();
          if (this._textureQuality === 1) {
            return resolve(this._inputTexture);
          }
          const dimensions = this.getInputDimensions().multiply(textureScale).floor();
          let needsRerender;
          if (!this._resizedTexture) {
            this._resizedTexture = new Engine2.RenderTexture(this._renderer, dimensions.x, dimensions.y);
            needsRerender = true;
          } else if (!this._resizedTexture.getDimensions().equals(dimensions)) {
            this._resizedTexture.resizeTo(dimensions);
            needsRerender = true;
          }
          if (needsRerender) {
            this._resizedSprite.setScale(textureScale, textureScale);
            this._resizedSprite.setTexture(this._inputTexture);
            this._resizedTexture.render(this._resizedContainer);
          }
          resolve(this._resizedTexture);
        });
      }
      _registerOperations() {
        this._operations = {};
        for (const operationName in operations_exports) {
          const operation = operations_exports[operationName];
          this._operations[operation.identifier] = operation;
        }
        this._operations = __spreadValues(__spreadValues({}, this._operations), this._options.extensions.operations);
      }
      registerOperations(operations) {
        operations.forEach((operation) => {
          this._operations[operation.identifier] = operation;
        });
      }
      setAllOperationsToDirty(dimensionsChanged = false) {
        this._operationsStack.setAllToDirty(dimensionsChanged);
      }
      createOperation(identifier, options = {}, addToStack = true) {
        const Operation2 = this._operations[identifier];
        if (!Operation2) {
          throw new Error(`No operation with identifier \`${identifier}\` found.`);
        }
        const operation = new Operation2(this, options);
        if (addToStack) {
          this.addOperation(operation);
        }
        return operation;
      }
      addOperation(operation) {
        this._operationsStack.push(operation);
      }
      removeOperation(operation) {
        this._operationsStack.remove(operation);
      }
      getInputDimensions() {
        const frame = this._inputTexture.getFrame();
        return new Vector22(frame.width, frame.height);
      }
      getFinalDimensions(incorporateSpriteScale = false) {
        let dimensions = this.getInputDimensions();
        const operationsStack = this._operationsStack;
        operationsStack.forEach((operation) => {
          if (!operation.getEnabled())
            return;
          dimensions = operation.getNewDimensions(dimensions);
        });
        if (incorporateSpriteScale) {
          dimensions.multiply(this._spriteScale);
        }
        return dimensions.floor();
      }
      getOutputDimensions(incorporateSpriteScale = false) {
        return this.getFinalDimensions(incorporateSpriteScale).clone().multiply(this._zoom).floor();
      }
      getOutputTextureDimensions(incorporateSpriteScale = false) {
        const textureScale = this.getTextureScale();
        let dimensions = this.getInputDimensions().multiply(textureScale).floor();
        this._operationsStack.forEach((op) => {
          dimensions = op.getNewDimensions(dimensions);
        });
        return dimensions;
      }
      getCrossOrigin() {
        return Utils2.getCrossOrigin(this._options.crossOrigin || "Anonymous");
      }
      _initRenderer() {
        const rendererOptions = {
          canvas: this._options.canvas,
          pixelRatio: this._options.pixelRatio,
          debug: this._options.debug,
          transparent: this._options.transparent,
          clearColor: this._options.clearColor
        };
        let width;
        let height;
        if (this._renderMode !== "export" && this._options.canvas) {
          const { canvas } = this._options;
          width = canvas.width;
          height = canvas.height;
        } else if (this._inputTexture) {
          const dimensions = this.getFinalDimensions();
          width = dimensions.x;
          height = dimensions.y;
        } else {
          width = 1;
          height = 1;
        }
        switch (this._preferredRenderer) {
          case RendererType3.WEBGL:
            this._renderer = Engine2.autoDetectRenderer(width, height, rendererOptions);
            this._renderer.on("context-restored", this._onContextRestored);
            this._renderer.on("context-lost", this._onContextLost);
            break;
          case RendererType3.CANVAS:
            this._renderer = Engine2.canvasRenderer(width, height, rendererOptions);
            this._renderer.on("context-restored", this._onContextRestored);
            break;
          default:
            Log3.warn("PhotoEditorSDK", `PhotoEditorSDK Error: Renderer \`${this._preferredRenderer}\` not supported. Falling back to automatically detected renderer.`);
            this._renderer = Engine2.autoDetectRenderer(width, height, rendererOptions);
        }
      }
      resizeTo(dimensions) {
        this._renderer.resizeTo(dimensions, true);
      }
      reset() {
        this._operationsStack.clear();
      }
      parseExif(image) {
        if (!image) {
          return;
        }
        let { src } = image;
        let isJPEG = false;
        let base64String = null;
        if (false) {
          isJPEG = exif_default.isJPEG(src);
          base64String = src;
        } else if (image instanceof image_default && image.rawSource) {
          let buf = image.rawSource;
          if (!(image.rawSource instanceof Buffer)) {
            const source = image.rawSource.replace("data:image/jpeg;base64,", "");
            buf = Buffer.from(source, "base64");
            src = image.rawSource;
          } else {
            src = image.rawSource.toString("base64");
          }
          isJPEG = exif_default.bufferIsJPEG(buf);
          if (isJPEG) {
            base64String = src;
          }
        }
        if (isJPEG) {
          let exif = null;
          try {
            exif = exif_default.fromBase64String(base64String);
          } catch (e) {
          }
          if (!exif) {
            return;
          }
          return exif;
        }
      }
      _handleExifOrientation() {
        const exifTags = this._exif.getTags();
        if (exifTags && exifTags.Orientation) {
          const rotationNeedsChange = exifTags.Orientation !== 1 && exifTags.Orientation !== 2;
          const flipNeedsChange = [2, 4, 5, 7].indexOf(exifTags.Orientation) !== -1;
          if (rotationNeedsChange || flipNeedsChange) {
            if (typeof navigator === "undefined") {
              if (!this._exifOperation) {
                this._exifOperation = this.createOperation("exif-orientation");
              }
              this._exifOperation.setTags(exifTags);
            } else {
              const userAgent = window && window.navigator && window.navigator.userAgent || "";
              if (!!userAgent.match(/msie|trident/i) || userAgent.indexOf("Edge") !== -1 || !CSS.supports("image-orientation", "from-image")) {
                if (!this._exifOperation) {
                  this._exifOperation = this.createOperation("exif-orientation");
                }
                this._exifOperation.setTags(exifTags);
              }
            }
            this._exif.setOrientation(1);
          }
        }
      }
      correctExifOrientation(image) {
        const exifData = this.parseExif(image);
        if (!exifData) {
          return image;
        }
        const tags = exifData.getTags();
        if (tags && tags.Orientation) {
          const rotationNeedsChange = tags.Orientation !== 1 && tags.Orientation !== 2;
          const flipNeedsChange = [2, 4, 5, 7].indexOf(tags.Orientation) !== -1;
          if (rotationNeedsChange || flipNeedsChange) {
            if (typeof navigator === "undefined") {
              const exifOperation = this.createOperation("exif-orientation", {}, false);
              exifOperation.setTags(tags);
              image = exifOperation.applyTo(image);
            } else {
              const userAgent = window && window.navigator && window.navigator.userAgent || "";
              if (!!userAgent.match(/msie|trident/i) || userAgent.indexOf("Edge") !== -1 || !CSS.supports("image-orientation", "from-image")) {
                const exifOperation = this.createOperation("exif-orientation", {}, false);
                exifOperation.setTags(tags);
                image = exifOperation.applyTo(image);
              }
            }
            exifData.setOrientation(1);
            tags.Orientation = 1;
            return image;
          }
        }
        return image;
      }
      hasImage() {
        return this._image !== null && typeof this._image !== "undefined";
      }
      getImage() {
        return this._image;
      }
      disposeTexture(texture) {
        this._texturesToDispose.push(texture);
      }
      _disposeTextures() {
        for (let i = 0; i < this._texturesToDispose.length; i++) {
          this._texturesToDispose[i].dispose();
        }
        this._texturesToDispose = [];
      }
      setImage(image, exif = null, dimensions = null) {
        this._disposeTextures();
        if (this._exifOperation) {
          this.removeOperation(this._exifOperation);
          this._exifOperation = null;
        }
        this._options.image = image;
        this._image = image;
        this._exif = exif || this.parseExif(image);
        if (this._exif) {
          this._handleExifOrientation();
        }
        const baseTexture = new Engine2.BaseTexture(this._image);
        const frame = new Rectangle2(0, 0, this._image.naturalWidth || this._image.width, this._image.naturalHeight || this._image.height);
        if (dimensions) {
          frame.width = dimensions.x;
          frame.height = dimensions.y;
        }
        if (this._resizedTexture) {
          this._resizedTexture.dispose();
        }
        this._resizedTexture = null;
        if (this._inputTexture) {
          this.disposeTexture(this._inputTexture.getBaseTexture());
        }
        this._inputTexture = new Engine2.Texture(baseTexture, frame);
        this._currentTexture = this._inputTexture;
        this._sprite.clearTexture(false);
        this._sprite.setTexture(this._inputTexture);
        this.emit("new-image");
        this.setAllOperationsToDirty(true);
      }
      setInputTexture(texture) {
        this._inputTexture = texture;
      }
      getCanvas() {
        return this._renderer.getCanvas();
      }
      setCanvas(canvas) {
        this._renderer.setCanvas(canvas);
      }
      getSprite() {
        return this._sprite;
      }
      getContainer() {
        return this._container;
      }
      getOperationsStack() {
        return this._operationsStack;
      }
      setOperationsStack(operationsStack) {
        if (this._operationsStack) {
          this._operationsStack.off(Events2.OPERATION_UPDATED, this._onOperationUpdate);
        }
        this._operationsStack = operationsStack;
        this._operationsStack.on(Events2.OPERATION_UPDATED, this._onOperationUpdate);
      }
      getOperations() {
        return this._operations;
      }
      getRenderer() {
        return this._renderer;
      }
      getOffset() {
        return this._offset;
      }
      setOffset(offset, y) {
        if (offset instanceof Vector22) {
          this._offset.copy(offset);
        } else {
          this._offset.set(offset, y);
        }
      }
      getRenderMode() {
        return this._renderMode;
      }
      setRenderMode(renderMode) {
        this._renderMode = renderMode;
      }
      getZoom() {
        return this._zoom;
      }
      setZoom(zoom) {
        this._zoom = zoom;
        this._container.setScale(this._zoom, this._zoom);
        this._container.updateTransform();
      }
      getTextureQuality() {
        if (this._renderMode === "export") {
          return 1;
        }
        return this._textureQuality;
      }
      setTextureQuality(textureQuality) {
        if (textureQuality !== this._textureQuality) {
          this.setAllOperationsToDirty(true);
        }
        this._textureQuality = Math.min(1, textureQuality);
        if (this._textureQuality === 1 && this._resizedTexture) {
          this._resizedTexture.dispose();
          this._resizedTexture = null;
        }
      }
      getSpriteScale() {
        return this._spriteScale;
      }
      setSpriteScale(spriteScale) {
        this._spriteScale = spriteScale;
        this._sprite.setScale(spriteScale, spriteScale);
        this._sprite.updateTransform();
      }
      getPixelRatio() {
        return this._options.pixelRatio;
      }
      getExif() {
        return this._exif;
      }
      getOptions() {
        return this._options;
      }
      getInputTexture() {
        return this._inputTexture;
      }
      setSmoothDownscaling(smoothDownscaling) {
        this._options.smoothDownscaling = smoothDownscaling;
        this._sprite.setSmoothDownscaling(smoothDownscaling);
        this._resizedSprite.setSmoothDownscaling(smoothDownscaling);
      }
      setRotation(rotation) {
        this._rotation = rotation;
      }
      getRotation() {
        return this._rotation;
      }
      hasChanges() {
        return this.getOperationsStack().hasChanges();
      }
      dispose() {
        this._operationsStack.dispose();
        this._renderer.dispose();
        if (this._exif) {
          this._exif.dispose();
        }
        if (this._resizedTexture) {
          this._resizedTexture.dispose();
        }
      }
    };
    sdk_default = PhotoEditorSDK;
  }
});

// engine/sdk/core/exports.js
var UI, exports_default;
var init_exports = __esm({
  "engine/sdk/core/exports.js"() {
    init_log();
    init_loaders();
    init_constants();
    init_engine();
    init_base64();
    init_color();
    init_configurable();
    init_env();
    init_event_emitter();
    init_exif();
    init_image();
    init_license_checker();
    init_math();
    init_operations_stack();
    init_utils();
    init_operations();
    init_operation();
    init_sdk();
    sdk_default.version = "4.27.0";
    sdk_default.Math = math_exports;
    sdk_default.Operations = operations_exports;
    sdk_default.Engine = engine_default;
    sdk_default.Color = color_default;
    sdk_default.LicenseChecker = license_checker_default;
    sdk_default.Operation = operation_default;
    sdk_default.EventEmitter = event_emitter_default;
    sdk_default.Utils = utils_default;
    sdk_default.Env = env_default;
    sdk_default.OperationsStack = operations_stack_default;
    sdk_default.EXIF = exif_default;
    sdk_default.Image = image_default;
    sdk_default.Configurable = configurable_default;
    sdk_default.Log = log_default;
    sdk_default.Loaders = loaders_exports;
    sdk_default.RenderType = RenderType;
    sdk_default.ImageFormat = ImageFormat;
    sdk_default.OptionType = OptionType;
    sdk_default.RendererType = RendererType;
    sdk_default.UniformType = UniformType;
    sdk_default.Base64 = base64_default;
    UI = {};
    sdk_default.UI = UI;
    exports_default = sdk_default;
  }
});

// engine/sdk/core/index.js
var init_core = __esm({
  "engine/sdk/core/index.js"() {
    init_exports();
    init_exports();
  }
});

// engine/sdk/operations/shared/shaders/adjustments/adjustments.frag
var adjustments_default;
var init_adjustments = __esm({
  "engine/sdk/operations/shared/shaders/adjustments/adjustments.frag"() {
    adjustments_default = "precision highp float;\n\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nuniform float u_gamma;\nuniform float u_shadows;\nuniform float u_highlights;\nuniform float u_whites;\nuniform float u_blacks;\n\nuniform mat4 u_colorMatrix;\nuniform vec4 u_colorOffset;\n\nconst float EPSILON = 0.0000001;\n\nfloat calculateLuminance(vec3 rgb) {\n    // This is the luminance calculation part of the RGB to HSL formular.\n    vec4 p = mix(\n        vec4(rgb.gb, 0.0, -1.0 / 3.0),\n        vec4(rgb.bg, -1.0, 2.0 / 3.0),\n        vec4(rgb.g < rgb.b)\n    );\n\n    vec4 q = mix(\n        vec4(rgb.r, p.yzx),\n        vec4(p.xyw, rgb.r),\n        vec4(rgb.r < p.x)\n    );\n\n    float croma = q.x - min(q.w, q.y);\n    float luminance = q.x - croma * 0.5;\n    return luminance;\n}\n\nvec3 map(vec3 x, float in_min, float in_max, float out_min, float out_max){\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\nvoid main() {\n\n  vec4 color = clamp(texture2D(u_image, v_texCoord), 0.0, 1.0);\n  color.rgb /= max(color.a, EPSILON); // Revert premultiplied alpha\n\n  // Apply gamma\n  if (u_gamma != 1.0) {\n    color.rgb = pow(color.rgb, vec3(1.0 / max(u_gamma, EPSILON)));\n  }\n\n  // Apply shadows and highlights\n  float luminance = calculateLuminance(color.rgb);\n\n  float shadow = u_shadows >= 0.0\n    ? clamp(\n          pow(luminance, 1.0 / (u_shadows + 1.0))\n          + pow(luminance, 2.0 / (u_shadows + 1.0)) * -0.76\n          - luminance\n    , 0.0, max(u_shadows, 1.0))\n    : -clamp(\n          pow(luminance, 1.0 / (-u_shadows + 1.0))\n          + pow(luminance, 2.0 / (-u_shadows + 1.0)) * -0.76\n          - luminance\n    , 0.0, max(-u_shadows, 1.0));\n\n  float highlight = u_highlights < 0.0\n    ? clamp(\n          1.0\n          - pow(1.0 - luminance, 1.0 / (1.0 - u_highlights))\n          - pow(1.0 - luminance, 2.0 / (1.0 - u_highlights)) * -0.8\n          - luminance\n     , -1.0, 0.0)\n    : -clamp(\n          1.0\n          - pow(1.0 - luminance, 1.0 / (1.0 + u_highlights))\n          - pow(1.0 - luminance, 2.0 / (1.0 + u_highlights)) * -0.8\n          - luminance\n     , -1.0, 0.0);\n\n  // Bright color need more contrast and dark color need more brightness.\n  // This is to keep saturatation because the color information of a dark colors is lost.\n  float shadowContrast   = shadow * luminance * luminance;\n  float shadowBrightness = shadow - shadowContrast;\n\n  float offset = luminance + shadowContrast + highlight;\n  color.rgb = clamp(offset * ((color.rgb + shadowBrightness) / max(luminance, EPSILON)), 0.0, 1.0);\n  \n  // Apply Color Matrix\n  color.rgb = clamp(color * u_colorMatrix + u_colorOffset, 0.0, 1.0).rgb;\n  color.rgb = map(color.rgb, 0.0, 1.0, u_blacks / 2.0, 1.0 + u_whites / 2.0);\n  color = clamp(color, 0.0, 1.0);\n  color.rgb *= color.a; // Reset premultiplied alpha\n\n  gl_FragColor = color;\n}\n";
  }
});

// engine/sdk/operations/shared/filters/adjustments-filter.js
function map(x, inMin, inMax, outMin, outMax) {
  return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}
var ColorMatrix2, EPSILON2, calculateLuminance, AdjustmentsFilter, adjustments_filter_default;
var init_adjustments_filter = __esm({
  "engine/sdk/operations/shared/filters/adjustments-filter.js"() {
    init_core();
    init_adjustments();
    ({ ColorMatrix: ColorMatrix2 } = math_exports);
    EPSILON2 = 1e-7;
    calculateLuminance = (color) => {
      const max = Math.max(color.r, color.g, color.b);
      const min = Math.min(color.r, color.g, color.b);
      return (max + min) / 2;
    };
    AdjustmentsFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = adjustments_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const {
          colorMatrix,
          gamma,
          shadows,
          highlights,
          whites,
          blacks
        } = this._options;
        const applyGamma = gamma !== 1;
        const applyShadowsAndHighlights = shadows !== 0 || highlights !== 0;
        let color = new color_default(0, 0, 0, 0);
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          color.r = imageData.data[index] / 255;
          color.g = imageData.data[index + 1] / 255;
          color.b = imageData.data[index + 2] / 255;
          if (applyGamma) {
            color.r = Math.pow(color.r, 1 / Math.max(gamma, EPSILON2));
            color.g = Math.pow(color.g, 1 / Math.max(gamma, EPSILON2));
            color.b = Math.pow(color.b, 1 / Math.max(gamma, EPSILON2));
          }
          if (applyShadowsAndHighlights) {
            const luminance = calculateLuminance(color);
            const shadow = shadows >= 0 ? utils_default.clamp(Math.pow(luminance, 1 / (shadows + 1)) + Math.pow(luminance, 2 / (shadows + 1)) * -0.76 - luminance, 0, Math.max(shadows, 1)) : -utils_default.clamp(Math.pow(luminance, 1 / (-shadows + 1)) + Math.pow(luminance, 2 / (-shadows + 1)) * -0.76 - luminance, 0, Math.max(-shadows, 1));
            const highlight = highlights < 0 ? utils_default.clamp(1 - Math.pow(1 - luminance, 1 / (1 - highlights)) - Math.pow(1 - luminance, 2 / (1 - highlights)) * -0.8 - luminance, -1, 0) : -utils_default.clamp(1 - Math.pow(1 - luminance, 1 / (1 + highlights)) - Math.pow(1 - luminance, 2 / (1 + highlights)) * -0.8 - luminance, -1, 0);
            const shadowContrast = shadow * luminance * luminance;
            const shadowBrightness = shadow - shadowContrast;
            const offset = luminance + shadowContrast + highlight;
            color.r = utils_default.clamp(offset * ((color.r + shadowBrightness) / Math.max(luminance, EPSILON2)), 0, 1);
            color.g = utils_default.clamp(offset * ((color.g + shadowBrightness) / Math.max(luminance, EPSILON2)), 0, 1);
            color.b = utils_default.clamp(offset * ((color.b + shadowBrightness) / Math.max(luminance, EPSILON2)), 0, 1);
          }
          color = colorMatrix.apply(color).clamp(0, 1);
          color.r = map(color.r, 0, 1, blacks / 2, 1 + whites / 2);
          color.g = map(color.g, 0, 1, blacks / 2, 1 + whites / 2);
          color.b = map(color.b, 0, 1, blacks / 2, 1 + whites / 2);
          imageData.data[index] = color.r * 255;
          imageData.data[index + 1] = color.g * 255;
          imageData.data[index + 2] = color.b * 255;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    AdjustmentsFilter.prototype.availableOptions = {
      gamma: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "f" /* FLOAT */
      },
      shadows: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      },
      highlights: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "f" /* FLOAT */
      },
      whites: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      },
      blacks: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      },
      colorMatrix: {
        type: "color-matrix" /* COLOR_MATRIX */,
        default: new ColorMatrix2(),
        uniformType: "mat4" /* MAT4 */
      },
      colorOffset: {
        type: "array" /* ARRAY */,
        default: [],
        uniformType: "4f" /* FLOAT4 */
      }
    };
    adjustments_filter_default = AdjustmentsFilter;
  }
});

// engine/sdk/operations/shared/shaders/adjustments/clarity.frag
var clarity_default;
var init_clarity = __esm({
  "engine/sdk/operations/shared/shaders/adjustments/clarity.frag"() {
    clarity_default = "precision mediump float;\n\n// Input Image with config WRAP_S and WRAP_T: CLAMP_TO_EDGE\nuniform sampler2D u_image;\n\n// Size of one pixel == vec2(1.0 / u_image.width, 1.0 / u_image.height)\nuniform vec2 u_pixelDimension;\n\n// Range (-1.0 - 1.0)\nuniform float u_clarity;\n\nvarying vec2 v_texCoord;\n\nuniform mat4 u_colorMatrix;\nuniform vec4 u_colorOffset;\n\nconst float EPSILON = 0.000001;\n\nvec4 unpremultiply(vec4 col) {\n    col.rgb /= max(col.a, EPSILON);\n    return col;\n}\n\nvoid main() {\n    vec4 color = texture2D(u_image, v_texCoord);\n    color = unpremultiply(color);\n\n    // L = Left, R = Right, C = Center, T = Top, B = Bottom\n    vec4 colLB = texture2D(u_image, v_texCoord + vec2(-u_pixelDimension.x, -u_pixelDimension.y));\n    vec4 colLC = texture2D(u_image, v_texCoord + vec2(-u_pixelDimension.x,                 0.0));\n    vec4 colLT = texture2D(u_image, v_texCoord + vec2(-u_pixelDimension.x,  u_pixelDimension.y));\n\n    vec4 colCL = texture2D(u_image, v_texCoord + vec2(                0.0, -u_pixelDimension.y));\n    vec4 colCR = texture2D(u_image, v_texCoord + vec2(                0.0,  u_pixelDimension.y));\n    \n    vec4 colRB = texture2D(u_image, v_texCoord + vec2( u_pixelDimension.x, -u_pixelDimension.y));\n    vec4 colRC = texture2D(u_image, v_texCoord + vec2( u_pixelDimension.x,                 0.0));\n    vec4 colRT = texture2D(u_image, v_texCoord + vec2( u_pixelDimension.x,  u_pixelDimension.y));\n\n    vec4 mergedColor = color;\n    mergedColor.rgb += unpremultiply(colLB).rgb + unpremultiply(colLC).rgb + unpremultiply(colLT).rgb;\n    mergedColor.rgb += unpremultiply(colCL).rgb + unpremultiply(colCR).rgb;\n    mergedColor.rgb += unpremultiply(colRB).rgb + unpremultiply(colRC).rgb + unpremultiply(colRT).rgb;\n\n    mergedColor /= 9.0;\n\n    float grayValue = clamp(color.r * 0.3 + color.g * 0.59 + color.b * 0.1, 0.111111, 0.999999);\n    // 1.0 and 0.0 result in white not black, therefore we clamp\n\n    // Here we create a function that will map values below 0.1 to 0. Values above 0.2 will be mapped to 1,\n    // and for values between 0.1 and 0.2 it will produce a gradient.\n    // The funtion is mirror at 0.5, meaning values between 0.8 and 0.9 will result in a decending gradient.\n    // And values above 0.9 will be mapped to 0.\n    float frequenceFactor = min(smoothstep(1.0 - grayValue, 0.0, 0.11), smoothstep(grayValue, 0.0, 0.11));\n\n    // here we apply the high pass filter. Its strength is determined by the uniform ,\n    // and the frequence factor. That means the only the mid tones are affected by this filter.\n    // Clarity input is ranging from -1 to 1. But we want to strengthen the effect.\n    // Therefore we see this little magic number '3.7'.\n    color.rgb = clamp(color + clamp((color - mergedColor) * u_clarity * 3.7 * frequenceFactor, 0.0, 10.0), 0.0, 1.0).rgb;\n\n    // apply exposure but only to the mid tones.\n    color.rgb = color.rgb * pow(2.0, u_clarity * 0.27 * frequenceFactor);\n\n    // apply contrast and desaturation matrix\n    color.rgb = clamp(color * u_colorMatrix + u_colorOffset, 0.0, 1.0).rgb;\n\n    color.rgb *= color.a; // Premultiply alpha\n\n    gl_FragColor = clamp(color, 0.0, 1.0);\n}\n";
  }
});

// engine/sdk/operations/adjustments-operation/clarity-filter.js
var Vector23, ColorMatrix3, ClarityFilter, clarity_filter_default;
var init_clarity_filter = __esm({
  "engine/sdk/operations/adjustments-operation/clarity-filter.js"() {
    init_core();
    init_clarity();
    ({ Vector2: Vector23, ColorMatrix: ColorMatrix3 } = math_exports);
    ClarityFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = clarity_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const outputContext = outputTarget.getContext();
        const inputCanvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const { clarity } = this._options;
        const { colorMatrix } = this._options;
        const colorOffset = new color_default(this._options.colorOffset[0], this._options.colorOffset[1], this._options.colorOffset[2], this._options.colorOffset[3]);
        const { width } = inputCanvas;
        const { height } = inputCanvas;
        const inputImageData = inputContext.getImageData(0, 0, width, height);
        const outputImageData = outputContext.createImageData(width, height);
        this.canvasShader(inputImageData, outputImageData, clarity, colorMatrix, colorOffset);
        outputContext.putImageData(outputImageData, 0, 0);
      }
      canvasShader(inputImageData, outputImageData, clarity, colorMatrix, colorOffset) {
        const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
        const smoothstep = (edge0, edge1, x) => {
          const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
          return t * t * (3 - 2 * t);
        };
        const stride = inputImageData.width * 4;
        const { length } = inputImageData.data;
        const maxIdx = length - 1;
        const minIdx = 0;
        const inData = inputImageData.data;
        const outData = outputImageData.data;
        const tmpColor = new color_default();
        const divisor = 255 * 9;
        const sampleEdge = (idx) => {
          idx = idx < minIdx ? minIdx : idx;
          idx = idx > maxIdx ? maxIdx : idx;
          return inData[idx];
        };
        for (let idx = 0; idx < length; idx += 4) {
          let colorR = sampleEdge(idx + 0);
          let colorG = sampleEdge(idx + 1);
          let colorB = sampleEdge(idx + 2);
          let colorA = sampleEdge(idx + 3);
          const mergedR = (colorR + sampleEdge(idx - 4 - stride + 0) + sampleEdge(idx - 4 + 0) + sampleEdge(idx - 4 + stride + 0) + sampleEdge(idx - stride + 0) + sampleEdge(idx + stride + 0) + sampleEdge(idx + 4 - stride + 0) + sampleEdge(idx + 4 + 0) + sampleEdge(idx + 4 + stride)) / divisor;
          const mergedG = (colorG + sampleEdge(idx - 4 - stride + 1) + sampleEdge(idx - 4 + 1) + sampleEdge(idx - 4 + stride + 1) + sampleEdge(idx - stride + 1) + sampleEdge(idx + stride + 1) + sampleEdge(idx + 4 - stride + 1) + sampleEdge(idx + 4 + 1) + sampleEdge(idx + 4 + stride + 1)) / divisor;
          const mergedB = (colorB + sampleEdge(idx - 4 - stride + 2) + sampleEdge(idx - 4 + 2) + sampleEdge(idx - 4 + stride + 2) + sampleEdge(idx - stride + 2) + sampleEdge(idx + stride + 2) + sampleEdge(idx + 4 - stride + 2) + sampleEdge(idx + 4 + 2) + sampleEdge(idx + 4 + stride + 2)) / divisor;
          const mergedA = (colorA + sampleEdge(idx - 4 - stride + 3) + sampleEdge(idx - 4 + 3) + sampleEdge(idx - 4 + stride + 3) + sampleEdge(idx - stride + 3) + sampleEdge(idx + stride + 3) + sampleEdge(idx + 4 - stride + 3) + sampleEdge(idx + 4 + 3) + sampleEdge(idx + 4 + stride + 3)) / divisor;
          colorR /= 255;
          colorG /= 255;
          colorB /= 255;
          colorA /= 255;
          const grayValue = clamp(colorR * 0.3 + colorG * 0.59 + colorB * 0.1, 0.111111, 0.999999);
          const frequenceFactor = Math.min(smoothstep(1 - grayValue, 0, 0.11), smoothstep(grayValue, 0, 0.11));
          const scalar = clarity * 3.7 * frequenceFactor;
          const scale = Math.pow(2, clarity * 0.27 * frequenceFactor);
          const outR = clamp(colorR + clamp((colorR - mergedR) * scalar, 0, 10), 0, 1) * scale;
          const outG = clamp(colorG + clamp((colorG - mergedG) * scalar, 0, 10), 0, 1) * scale;
          const outB = clamp(colorB + clamp((colorB - mergedB) * scalar, 0, 10), 0, 1) * scale;
          const outA = clamp(colorA + clamp((colorA - mergedA) * scalar, 0, 10), 0, 1);
          tmpColor.set(outR, outG, outB, outA);
          const outColor = colorMatrix.apply(tmpColor).clamp(0, 1);
          outData[idx + 0] = outColor.r * 255;
          outData[idx + 1] = outColor.g * 255;
          outData[idx + 2] = outColor.b * 255;
          outData[idx + 3] = outColor.a * 255;
        }
      }
    };
    ClarityFilter.prototype.availableOptions = {
      clarity: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      },
      pixelDimension: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector23(100, 100),
        uniformType: "2f" /* FLOAT2 */
      },
      colorMatrix: {
        type: "color-matrix" /* COLOR_MATRIX */,
        default: new ColorMatrix3(),
        uniformType: "mat4" /* MAT4 */
      },
      colorOffset: {
        type: "array" /* ARRAY */,
        default: [],
        uniformType: "4f" /* FLOAT4 */
      }
    };
    clarity_filter_default = ClarityFilter;
  }
});

// engine/sdk/operations/shared/shaders/adjustments/sharpness.frag
var sharpness_default;
var init_sharpness = __esm({
  "engine/sdk/operations/shared/shaders/adjustments/sharpness.frag"() {
    sharpness_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec2 u_pixelDimension;\nuniform float u_sharpness;\n \nconst float EPSILON = 0.000001;\n \nvoid main() {\n    vec4 color = clamp(texture2D(u_image, v_texCoord), 0.0, 1.0);\n\n    float factor        = mix(0.2, -1.0, float(u_sharpness > 0.0));\n    vec4 sharpenedColor = mix(0.2,  5.0, float(u_sharpness > 0.0)) * color;\n \n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2(-1.0,  0.0)), 0.0, 1.0);\n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2( 0.0, -1.0)), 0.0, 1.0);\n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2( 0.0,  1.0)), 0.0, 1.0);\n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2( 1.0,  0.0)), 0.0, 1.0);\n \n    color.rgb /= max(color.a, EPSILON); // unpremultiply\n    sharpenedColor.rgb /= max(sharpenedColor.a, EPSILON); // unpremultiply\n \n    sharpenedColor = clamp(sharpenedColor, 0.0, 1.0);\n \n    color = clamp(mix(color, sharpenedColor, abs(u_sharpness)), 0.0, 1.0);\n      \n    gl_FragColor = vec4(color.rgb * color.a, color.a); // premultiply\n}";
  }
});

// engine/sdk/operations/adjustments-operation/sharpness-filter.js
var Vector24, SharpnessFilter, sharpness_filter_default;
var init_sharpness_filter = __esm({
  "engine/sdk/operations/adjustments-operation/sharpness-filter.js"() {
    init_core();
    init_sharpness();
    ({ Vector2: Vector24 } = math_exports);
    SharpnessFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = sharpness_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const outputContext = outputTarget.getContext();
        const inputCanvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const { sharpness } = this._options;
        const { width } = inputCanvas;
        const { height } = inputCanvas;
        const inputImageData = inputContext.getImageData(0, 0, width, height);
        const outputImageData = outputContext.createImageData(width, height);
        this.canvasShader(inputImageData, outputImageData, sharpness);
        outputContext.putImageData(outputImageData, 0, 0);
      }
      canvasShader(inputImageData, outputImageData, sharpness) {
        const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
        const EPSILON3 = 1e-6;
        const { width } = inputImageData;
        const { height } = inputImageData;
        const inData = inputImageData.data;
        const outData = outputImageData.data;
        const mix = (x, y, a) => {
          return x * (1 - a) + y * a;
        };
        const sample = (idx) => {
          return clamp(inData[idx] / 255, 0, 1);
        };
        const clampedIndex = (x, y) => {
          const sampleX = clamp(x, 0, width - 1);
          const sampleY = clamp(y, 0, height - 1);
          return 4 * (sampleX + width * sampleY);
        };
        const color = [];
        const sharpenedColor = [];
        const dXOffsets = [-1, 0, 0, 1];
        const dYOffsets = [0, -1, 1, 0];
        const factor = sharpness > 0 ? -1 : 0.2;
        const totalWeight = sharpness > 0 ? 5 : 0.2;
        const absSharpness = Math.abs(sharpness);
        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            const idx = clampedIndex(x, y);
            color[0] = sample(idx + 0);
            color[1] = sample(idx + 1);
            color[2] = sample(idx + 2);
            color[3] = sample(idx + 3);
            sharpenedColor[0] = totalWeight * color[0] * color[3];
            sharpenedColor[1] = totalWeight * color[1] * color[3];
            sharpenedColor[2] = totalWeight * color[2] * color[3];
            sharpenedColor[3] = totalWeight * color[3];
            for (let i = 0; i < 4; i++) {
              const dX = dXOffsets[i];
              const dY = dYOffsets[i];
              const offsetIndex = clampedIndex(x + dX, y + dY);
              const tempA = sample(offsetIndex + 3);
              sharpenedColor[3] += factor * tempA;
              for (let c = 0; c < 3; c++) {
                sharpenedColor[c] += factor * sample(offsetIndex + c) * tempA;
              }
            }
            for (let i = 0; i < 3; i++) {
              sharpenedColor[i] /= Math.max(sharpenedColor[3], EPSILON3);
              sharpenedColor[i] = clamp(sharpenedColor[i], 0, 1);
            }
            sharpenedColor[3] = clamp(sharpenedColor[3], 0, 1);
            for (let i = 0; i < 4; i++) {
              color[i] = clamp(mix(color[i], sharpenedColor[i], absSharpness), 0, 1);
              outData[idx + i] = color[i] * 255;
            }
          }
        }
      }
    };
    SharpnessFilter.prototype.availableOptions = {
      sharpness: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      },
      pixelDimension: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector24(100, 100),
        uniformType: "2f" /* FLOAT2 */
      }
    };
    sharpness_filter_default = SharpnessFilter;
  }
});

// engine/sdk/operations/shared/shaders/adjustments/temperature.frag
var temperature_default;
var init_temperature = __esm({
  "engine/sdk/operations/shared/shaders/adjustments/temperature.frag"() {
    temperature_default = "precision mediump float;\n\n// Input Image with config WRAP_S and WRAP_T: CLAMP_TO_EDGE\nuniform sampler2D u_image;\n\n// Range (-1.0 - 1.0)\nuniform float u_temperature;\n\nconst lowp vec3 warmFilter = vec3(0.93, 0.54, 0.0);\n\nconst mediump mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\nconst mediump mat3 YIQtoRGB = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n\nconst float EPSILON = 0.0000001;\n\nvarying vec2 v_texCoord;\nvoid main() {\n  float temperature = u_temperature;\n  const float tint = 0.0;\n  vec4 source = texture2D(u_image, v_texCoord);\n\n  source.rgb /= max(source.a, EPSILON);   // Revert premultiplied alpha\n\n  vec3 yiq = RGBtoYIQ * source.rgb;\n  yiq.b = clamp(yiq.b + tint*0.5226*0.1, -0.5226, 0.5226);\n  vec3 rgb = YIQtoRGB * yiq;\n\n  vec3 processed = mix(\n    (1.0 - 2.0 * (1.0 - rgb) * (1.0 - warmFilter)),\n    (2.0 * rgb * warmFilter),\n    vec3(rgb.r < 0.5, rgb.g < 0.5, rgb.b < 0.5)\n  );\n\n  vec4 color = vec4(mix(rgb, processed, temperature), source.a);\n\n  color.rgb *= color.a;   // Premultiply alpha again\n\n  gl_FragColor = color;\n}\n";
  }
});

// engine/sdk/operations/adjustments-operation/temperature-filter.js
var Vector32, TemperatureFilter, temperature_filter_default;
var init_temperature_filter = __esm({
  "engine/sdk/operations/adjustments-operation/temperature-filter.js"() {
    init_core();
    init_temperature();
    ({ Vector3: Vector32 } = math_exports);
    TemperatureFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = temperature_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const outputContext = outputTarget.getContext();
        const inputCanvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const { temperature } = this._options;
        const { width } = inputCanvas;
        const { height } = inputCanvas;
        const inputImageData = inputContext.getImageData(0, 0, width, height);
        const outputImageData = outputContext.createImageData(width, height);
        this.canvasShader(inputImageData, outputImageData, temperature);
        outputContext.putImageData(outputImageData, 0, 0);
      }
      canvasShader(inputImageData, outputImageData, temperature) {
        const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
        const mix = (x, y, a) => x * (1 - a) + y * a;
        const mat3Vec3DotProduct = (mat3, vec3) => {
          const outX = mat3[0] * vec3[0] + mat3[3] * vec3[1] + mat3[6] * vec3[2];
          const outY = mat3[1] * vec3[0] + mat3[4] * vec3[1] + mat3[7] * vec3[2];
          const outZ = mat3[2] * vec3[0] + mat3[5] * vec3[1] + mat3[8] * vec3[2];
          return [outX, outY, outZ];
        };
        const { length } = inputImageData.data;
        const maxIdx = length - 1;
        const minIdx = 0;
        const inData = inputImageData.data;
        const outData = outputImageData.data;
        const sampleEdge = (idx) => {
          idx = idx < minIdx ? minIdx : idx;
          idx = idx > maxIdx ? maxIdx : idx;
          return inData[idx];
        };
        const warmFilter = [0.93, 0.54, 0];
        const RGBtoYIQ = [
          0.299,
          0.587,
          0.114,
          0.596,
          -0.274,
          -0.322,
          0.212,
          -0.523,
          0.311
        ];
        const YIQtoRGB = [
          1,
          0.956,
          0.621,
          1,
          -0.272,
          -0.647,
          1,
          -1.105,
          1.702
        ];
        const tint = 0;
        for (let idx = 0; idx < length; idx += 4) {
          const colorR = sampleEdge(idx + 0) / 255;
          const colorG = sampleEdge(idx + 1) / 255;
          const colorB = sampleEdge(idx + 2) / 255;
          const colorA = sampleEdge(idx + 3) / 255;
          const source = [colorR, colorG, colorB];
          const yiq = mat3Vec3DotProduct(RGBtoYIQ, source);
          yiq.z = clamp(yiq.z + tint * 0.5226 * 0.1, -0.5226, 0.5226);
          const rgb = mat3Vec3DotProduct(YIQtoRGB, yiq);
          const processed = [
            rgb[0] < 0.5 ? 2 * rgb[0] * warmFilter[0] : 1 - 2 * (1 - rgb[0]) * (1 - warmFilter[0]),
            rgb[1] < 0.5 ? 2 * rgb[1] * warmFilter[1] : 1 - 2 * (1 - rgb[1]) * (1 - warmFilter[1]),
            rgb[2] < 0.5 ? 2 * rgb[2] * warmFilter[2] : 1 - 2 * (1 - rgb[2]) * (1 - warmFilter[2])
          ];
          outData[idx + 0] = mix(rgb[0], processed[0], temperature) * 255;
          outData[idx + 1] = mix(rgb[1], processed[1], temperature) * 255;
          outData[idx + 2] = mix(rgb[2], processed[2], temperature) * 255;
          outData[idx + 3] = colorA * 255;
        }
      }
    };
    TemperatureFilter.prototype.availableOptions = {
      temperature: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      }
    };
    temperature_filter_default = TemperatureFilter;
  }
});

// engine/sdk/operations/adjustments-operation/index.js
var ColorMatrix4, AdjustmentsOperation, adjustments_operation_default;
var init_adjustments_operation = __esm({
  "engine/sdk/operations/adjustments-operation/index.js"() {
    init_core();
    init_adjustments_filter();
    init_clarity_filter();
    init_sharpness_filter();
    init_temperature_filter();
    ({ ColorMatrix: ColorMatrix4 } = math_exports);
    AdjustmentsOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._clarityFilter = new clarity_filter_default();
        this._temperatureFilter = new temperature_filter_default();
        this._sharpnessFilter = new sharpness_filter_default();
        this._filter = new adjustments_filter_default();
        this._sprite.setFilters([
          this._clarityFilter,
          this._temperatureFilter,
          this._filter
        ]);
      }
      _render(sdk) {
        const dimensions = sdk.getDimensions();
        dimensions.x = 1 / dimensions.x;
        dimensions.y = 1 / dimensions.y;
        const clarityColorMatrix = new ColorMatrix4();
        clarityColorMatrix.multiply(ColorMatrix4.createSaturationMatrix(-0.3 * this._options.clarity + 1));
        clarityColorMatrix.multiply(ColorMatrix4.createContrastMatrix(0.1 * this._options.clarity + 1));
        this._clarityFilter.set({
          clarity: this._options.clarity,
          pixelDimension: dimensions,
          colorMatrix: clarityColorMatrix,
          colorOffset: clarityColorMatrix.getOffsets()
        });
        this._temperatureFilter.set({
          temperature: this._options.temperature
        });
        this._sharpnessFilter.set({
          sharpness: this._options.sharpness,
          pixelDimension: dimensions
        });
        const colorMatrix = new ColorMatrix4();
        colorMatrix.multiply(ColorMatrix4.createExposureMatrix(this._options.exposure));
        colorMatrix.multiply(ColorMatrix4.createSaturationMatrix(this._options.saturation + 1));
        colorMatrix.multiply(ColorMatrix4.createContrastMatrix((this._options.contrast > 0 ? this._options.contrast * 2 : this._options.contrast) + 1));
        colorMatrix.multiply(ColorMatrix4.createBrightnessMatrix(this._options.brightness));
        this._filter.set({
          gamma: this._options.gamma,
          shadows: this._options.shadows,
          highlights: this._options.highlights,
          whites: this._options.whites,
          blacks: this._options.blacks,
          colorMatrix,
          colorOffset: colorMatrix.getOffsets()
        });
        const filters = [];
        if (this._options.clarity !== 0) {
          filters.push(this._clarityFilter);
        }
        if (this._options.sharpness !== 0) {
          filters.push(this._sharpnessFilter);
        }
        if (this._options.temperature !== 0) {
          filters.push(this._temperatureFilter);
        }
        filters.push(this._filter);
        this._sprite.setFilters(filters);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      dispose() {
        super.dispose();
        this._filter.dispose();
        this._clarityFilter.dispose();
        this._temperatureFilter.dispose();
        this._sharpnessFilter.dispose();
      }
    };
    AdjustmentsOperation.identifier = "adjustments";
    AdjustmentsOperation.prototype.availableOptions = {
      brightness: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      saturation: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      contrast: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      gamma: {
        type: "number" /* NUMBER */,
        default: 1,
        minValue: 0.5,
        midValue: 1,
        maxValue: 2
      },
      exposure: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      shadows: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -2,
        midValue: 0,
        maxValue: 2
      },
      highlights: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      clarity: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      whites: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      blacks: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      temperature: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      },
      sharpness: {
        type: "number" /* NUMBER */,
        default: 0,
        minValue: -1,
        midValue: 0,
        maxValue: 1
      }
    };
    exports_default.Operations.AdjustmentsOperation = AdjustmentsOperation;
    adjustments_operation_default = AdjustmentsOperation;
  }
});

// engine/sdk/operations/shared/shaders/generic/blur.frag
var blur_default;
var init_blur = __esm({
  "engine/sdk/operations/shared/shaders/generic/blur.frag"() {
    blur_default = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n    float radius = u_blurRadius;\n\n    const float steps = 30.0;\n\n    for (float t = -steps; t <= steps; t++) {\n        float percent = (t + offset - 0.5) / steps;\n        float weight = 1.0 - abs(percent);\n\n        // Somehow `sample` is a keyword in headless-gl\n        vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        color += _sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n}\n";
  }
});

// engine/sdk/operations/shared/filters/blur-filter.js
var Vector25, BlurFilter, blur_filter_default;
var init_blur_filter = __esm({
  "engine/sdk/operations/shared/filters/blur-filter.js"() {
    init_core();
    init_blur();
    ({ Vector2: Vector25 } = math_exports);
    BlurFilter = class extends engine_default.Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = blur_default;
        this._lastBlurRadius = null;
        this._lastDimensions = new Vector25(0, 0);
        this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false, blurRadius = null) {
        if (this._options.blurQuality === "low") {
          this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
          return;
        }
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        if (this._lastBlurRadius === this._options.blurRadius) {
          outputContext.drawImage(canvas, 0, 0);
        }
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const outputData = outputContext.getImageData(0, 0, canvas.width, canvas.height);
        let radius = this._options.blurRadius;
        const { delta } = this._options;
        const steps = 30;
        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const i = x + y * canvas.width;
            const index = i * 4;
            let colorR = 0;
            let colorG = 0;
            let colorB = 0;
            let colorA = 0;
            let total = 0;
            if (blurRadius) {
              radius = blurRadius(x / canvas.width, y / canvas.height);
            }
            const rand = this._random(x, 1 - y / canvas.height);
            for (let t = -steps; t <= steps; t++) {
              const percent = (t + rand - 0.5) / steps;
              const weight = 1 - Math.abs(percent);
              const offsetX = delta.x * percent * radius;
              const offsetY = delta.y * percent * radius;
              const clampedX = Math.max(Math.min(x + offsetX, canvas.width - 1), 0);
              const clampedY = Math.max(Math.min(y + offsetY, canvas.height - 1), 0);
              const i2 = (Math.round(clampedY) * canvas.width + Math.round(clampedX)) * 4;
              const sampleA = imageData.data[i2 + 3];
              const sampleR = sampleA * imageData.data[i2];
              const sampleG = sampleA * imageData.data[i2 + 1];
              const sampleB = sampleA * imageData.data[i2 + 2];
              colorR += sampleR * weight;
              colorG += sampleG * weight;
              colorB += sampleB * weight;
              colorA += sampleA * weight;
              total += weight;
            }
            colorR /= total;
            colorG /= total;
            colorB /= total;
            colorA /= total;
            outputData.data[index] = colorR / colorA;
            outputData.data[index + 1] = colorG / colorA;
            outputData.data[index + 2] = colorB / colorA;
            outputData.data[index + 3] = colorA;
          }
        }
        outputContext.putImageData(outputData, 0, 0);
        this._lastDimensions.copy(new Vector25(canvas.width, canvas.height));
      }
      _renderLQBlur(renderer, inputTarget, outputTarget, clear) {
        const inputDimensions = inputTarget.getDimensions();
        const dimensionsChanged = !this._lastDimensions.equals(inputDimensions);
        this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
        this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
        outputTarget.setPixelRatio(inputTarget.getPixelRatio());
        outputTarget.resizeTo(inputTarget.getDimensions());
        if (this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged) {
          this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
          this._lastBlurRadius = this._options.blurRadius;
        }
        const outputContext = outputTarget.getContext();
        outputContext.drawImage(this._blurredRenderTarget.getCanvas(), 0, 0);
        this._lastDimensions.copy(inputDimensions);
      }
      _random(x, y) {
        const a = 12.9898;
        const b = 78.233;
        const c = 43758.5453;
        const dt = x * a + y * b;
        const sn = dt - 3.14 * Math.floor(dt / 3.14);
        const tempR = Math.sin(sn) * c;
        return tempR - Math.floor(tempR);
      }
    };
    BlurFilter.prototype.availableOptions = {
      blurRadius: {
        type: "number" /* NUMBER */,
        default: 30,
        uniformType: "f" /* FLOAT */
      },
      delta: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector25(1, 1),
        uniformType: "2f" /* FLOAT2 */
      },
      texSize: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector25(100, 100),
        uniformType: "2f" /* FLOAT2 */
      },
      blurQuality: { type: "string" /* STRING */, default: "low" }
    };
    blur_filter_default = BlurFilter;
  }
});

// engine/sdk/operations/blur-operation/index.js
var Vector26, BlurOperation, blur_operation_default;
var init_blur_operation = __esm({
  "engine/sdk/operations/blur-operation/index.js"() {
    init_core();
    init_blur_filter();
    ({ Vector2: Vector26 } = math_exports);
    BlurOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._lastBlurRadius = this._options.blurRadius;
        const blurOption = {
          blurQuality: {
            type: "string" /* STRING */
          }
        };
        this._horizontalFilter = new blur_filter_default({}, blurOption);
        this._verticalFilter = new blur_filter_default({}, blurOption);
        this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
        this._horizontalFilter.setDelta(new Vector26(0.5, 0.5));
        this._verticalFilter.setDelta(new Vector26(-0.5, 0.5));
        this._filter = new blur_filter_default({}, blurOption);
      }
      _renderWebGL(inputTexture) {
        return this._renderBlur(inputTexture);
      }
      _renderCanvas(inputTexture) {
        if (this._options.highQualityCanvasBlur) {
          return this._renderBlur(inputTexture);
        }
        return this._renderLQCanvasBlur(inputTexture);
      }
      _renderBlur(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const shortestSide = inputDimensions.min();
        const { blurRadius } = this._options;
        const commonOptions = {
          blurRadius: blurRadius * shortestSide,
          texSize: inputDimensions,
          blurQuality: "high"
        };
        this._horizontalFilter.set(commonOptions);
        this._verticalFilter.set(commonOptions);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      _renderLQCanvasBlur(inputTexture) {
        const { blurRadius } = this._options;
        const inputDimensions = inputTexture.getDimensions();
        this._filter.set({
          blurRadius,
          texSize: inputDimensions,
          blurQuality: "low"
        });
        this._sprite.setFilters([this._filter]);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      transform(transformChange) {
        const size = this.getBlurRadius();
        const blurRadius = transformChange.applyToRelativeSize(size);
        this.set({ blurRadius }, false);
      }
      dispose() {
        super.dispose();
        this._filter.dispose();
        this._verticalFilter.dispose();
        this._horizontalFilter.dispose();
      }
      hasChanges() {
        return true;
      }
    };
    BlurOperation.identifier = "blur";
    BlurOperation.prototype.availableOptions = {
      blurRadius: { type: "number" /* NUMBER */, default: 0.025 },
      highQualityCanvasBlur: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.BlurOperation = BlurOperation;
    blur_operation_default = BlurOperation;
  }
});

// engine/sdk/operations/shared/shaders/generic/blend.frag
var blend_default;
var init_blend = __esm({
  "engine/sdk/operations/shared/shaders/generic/blend.frag"() {
    blend_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_filteredImage;\nuniform float u_intensity;\n\nvoid main() {\n  vec4 color0 = texture2D(u_image, v_texCoord);\n  vec4 color1 = texture2D(u_filteredImage, v_texCoord);\n  gl_FragColor = mix(color0, color1, u_intensity);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives-stack.js
var BlendFilter, PrimitivesStack, primitives_stack_default;
var init_primitives_stack = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives-stack.js"() {
    init_core();
    init_blend();
    BlendFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = blend_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const outputContext = outputTarget.getContext();
        const { filteredCanvas } = this._options;
        outputContext.save();
        outputContext.drawImage(canvas, 0, 0);
        outputContext.globalAlpha = this._options.intensity;
        outputContext.drawImage(filteredCanvas, 0, 0);
        outputContext.restore();
      }
    };
    BlendFilter.prototype.availableOptions = {
      filteredImage: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "i" /* INT */
      },
      filteredCanvas: { type: "object" /* OBJECT */, default: null },
      intensity: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "f" /* FLOAT */
      }
    };
    PrimitivesStack = class {
      constructor(intensity = 1) {
        this._intensity = intensity;
        this._stack = [];
        this._dirtiness = {};
        this._renderTextures = {};
        this._container = new engine_default.Container();
        this._sprite = new engine_default.Sprite();
        this._container.addChild(this._sprite);
        this._blendFilter = new BlendFilter();
      }
      push(primitive) {
        this._stack.push(primitive);
      }
      clear() {
        this._stack = [];
      }
      render(sdk, inputTexture, outputTexture) {
        if (this.isEmpty()) {
          return Promise.resolve();
        }
        const renderer = sdk.getRenderer();
        this._sprite.setTexture(inputTexture);
        let filteredRenderTexture = this._renderTextures[renderer.id];
        if (!filteredRenderTexture) {
          const frame = sdk.getSprite().getTexture().getFrame();
          filteredRenderTexture = new engine_default.RenderTexture(sdk.getRenderer(), frame.width, frame.height);
          this._renderTextures[renderer.id] = filteredRenderTexture;
        }
        const textureDimensions = outputTexture.getDimensions();
        filteredRenderTexture.resizeTo(textureDimensions);
        const shouldRender = this.isDirtyForRenderer(renderer);
        if (shouldRender) {
          this._stack.forEach((p) => {
            p.update(sdk);
          });
          const filters = this._stack.map((p) => p.getFilter());
          this._sprite.setFilters(filters);
          filteredRenderTexture.render(this._container);
          this.setDirtyForRenderer(false, renderer);
        }
        this._blendFilter.setIntensity(this._intensity);
        if (renderer.isOfType("canvas" /* CANVAS */)) {
          this._blendFilter.setFilteredCanvas(filteredRenderTexture.getRenderTarget().getCanvas());
        } else if (renderer.isOfType("webgl" /* WEBGL */)) {
          const baseTexture = filteredRenderTexture.getBaseTexture();
          baseTexture.setGLUnit(this._blendFilter.getFilteredImage());
          renderer.updateTexture(baseTexture, false);
        }
        this._sprite.setFilters([this._blendFilter]);
        outputTexture.clear(color_default.TRANSPARENT);
        outputTexture.render(this._container);
        if (shouldRender) {
          this.disposeRenderTextures();
        }
        return Promise.resolve();
      }
      setIntensity(intensity) {
        this._intensity = intensity;
      }
      isEmpty() {
        return this._stack.length === 0;
      }
      isDirtyForRenderer(renderer) {
        if (!(renderer.id in this._dirtiness)) {
          this._dirtiness[renderer.id] = true;
        }
        return this._dirtiness[renderer.id];
      }
      setDirtyForRenderer(dirty, renderer) {
        this._dirtiness[renderer.id] = dirty;
      }
      setDirty(dirty) {
        for (const rendererId in this._dirtiness) {
          this._dirtiness[rendererId] = dirty;
        }
      }
      disposeRenderTextures() {
        for (const rendererId in this._renderTextures) {
          this._renderTextures[rendererId].dispose();
          delete this._renderTextures[rendererId];
        }
      }
      dispose() {
        this.disposeRenderTextures();
        this._stack.forEach((primitive) => primitive.dispose());
        this._stack = [];
        this._blendFilter.dispose();
        this._sprite.dispose();
      }
    };
    primitives_stack_default = PrimitivesStack;
  }
});

// engine/sdk/operations/filter-operation/filters/filter.js
var Filter2, filter_default;
var init_filter2 = __esm({
  "engine/sdk/operations/filter-operation/filters/filter.js"() {
    init_core();
    init_primitives_stack();
    Filter2 = class extends configurable_default {
      constructor(options = {}, additionalOptions = {}) {
        super(options, __spreadValues({
          intensity: {
            type: "number" /* NUMBER */,
            default: 1,
            setter(intensity) {
              this._stack && this._stack.setIntensity(intensity);
              return intensity;
            }
          },
          dirty: {
            type: "boolean" /* BOOLEAN */,
            default: true
          }
        }, additionalOptions));
        this._stack = new primitives_stack_default(this._options.intensity);
      }
      render(sdk, inputTexture, outputTexture) {
        return this._stack.render(sdk, inputTexture, outputTexture).then((response) => {
          this.setDirty(false);
          return response;
        });
      }
      setDirtyForRenderer(dirty, renderer) {
        this._stack.setDirtyForRenderer(dirty, renderer);
      }
      disposeRenderTextures() {
        this._stack.disposeRenderTextures();
      }
      dispose() {
        this._stack.dispose();
      }
    };
    Filter2.identifier = null;
    Filter2.isIdentity = false;
    Filter2.displayName = null;
    Filter2.PrimitivesStack = primitives_stack_default;
    filter_default = Filter2;
  }
});

// engine/sdk/operations/shared/shaders/primitives/brightness.frag
var brightness_default;
var init_brightness = __esm({
  "engine/sdk/operations/shared/shaders/primitives/brightness.frag"() {
    brightness_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_brightness;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4((texColor.rgb + vec3(u_brightness) * texColor.a), texColor.a);;\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/primitive.js
var Primitive, primitive_default;
var init_primitive = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/primitive.js"() {
    init_core();
    Primitive = class extends configurable_default {
      update() {
      }
      getFilter() {
        return this._filter;
      }
      dispose() {
        if (this._filter) {
          this._filter.dispose();
          this._filter = null;
        }
      }
    };
    primitive_default = Primitive;
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/brightness.js
var BrightnessFilter, Brightness, brightness_default2;
var init_brightness2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/brightness.js"() {
    init_core();
    init_brightness();
    init_primitive();
    BrightnessFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = brightness_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        let { brightness } = this._options;
        if (brightness === 0) {
          outputContext.putImageData(imageData, 0, 0);
          return;
        }
        brightness *= 255;
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          imageData.data[index] += brightness;
          imageData.data[index + 1] += brightness;
          imageData.data[index + 2] += brightness;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    BrightnessFilter.prototype.availableOptions = {
      brightness: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      }
    };
    Brightness = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new BrightnessFilter();
      }
      update() {
        this._filter.setBrightness(this._options.brightness);
      }
    };
    Brightness.prototype.availableOptions = BrightnessFilter.prototype.availableOptions;
    brightness_default2 = Brightness;
  }
});

// engine/sdk/operations/shared/shaders/primitives/contrast.frag
var contrast_default;
var init_contrast = __esm({
  "engine/sdk/operations/shared/shaders/primitives/contrast.frag"() {
    contrast_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_contrast;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(((texColor.rgb - vec3(0.5)) * u_contrast + vec3(0.5) * texColor.a), texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/contrast.js
var ContrastFilter, Contrast, contrast_default2;
var init_contrast2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/contrast.js"() {
    init_core();
    init_contrast();
    init_primitive();
    ContrastFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = contrast_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const { contrast } = this._options;
        if (contrast === 1) {
          return;
        }
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          imageData.data[index] = (imageData.data[index] - 127) * contrast + 127;
          imageData.data[index + 1] = (imageData.data[index + 1] - 127) * contrast + 127;
          imageData.data[index + 2] = (imageData.data[index + 2] - 127) * contrast + 127;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    ContrastFilter.prototype.availableOptions = {
      contrast: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "f" /* FLOAT */
      }
    };
    Contrast = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new ContrastFilter();
      }
      update() {
        this._filter.setContrast(this._options.contrast);
      }
    };
    Contrast.prototype.availableOptions = ContrastFilter.prototype.availableOptions;
    contrast_default2 = Contrast;
  }
});

// engine/sdk/operations/shared/shaders/primitives/color-matrix.frag
var color_matrix_default2;
var init_color_matrix2 = __esm({
  "engine/sdk/operations/shared/shaders/primitives/color-matrix.frag"() {
    color_matrix_default2 = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform mat4 u_colorMatrix;\nuniform vec4 u_colorMatrixOffset;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = texColor * u_colorMatrix + u_colorMatrixOffset;\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/color-matrix.js
var ColorMatrix5, ColorMatrixFilter, ColorMatrixPrimitive, color_matrix_default3;
var init_color_matrix3 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/color-matrix.js"() {
    init_core();
    init_color_matrix2();
    init_primitive();
    ({ ColorMatrix: ColorMatrix5 } = math_exports);
    ColorMatrixFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = color_matrix_default2;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const { colorMatrix } = this._options;
        let color = new color_default(0, 0, 0, 0);
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          color.r = imageData.data[index] / 255;
          color.g = imageData.data[index + 1] / 255;
          color.b = imageData.data[index + 2] / 255;
          color = colorMatrix.apply(color);
          imageData.data[index] = color.r * 255;
          imageData.data[index + 1] = color.g * 255;
          imageData.data[index + 2] = color.b * 255;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    ColorMatrixFilter.prototype.availableOptions = {
      colorMatrix: {
        type: "color-matrix" /* COLOR_MATRIX */,
        default: new ColorMatrix5(),
        uniformType: "mat4" /* MAT4 */
      },
      colorMatrixOffset: {
        type: "array" /* ARRAY */,
        default: [],
        uniformType: "4f" /* FLOAT4 */
      }
    };
    ColorMatrixPrimitive = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new ColorMatrixFilter();
      }
      update() {
        this._filter.setColorMatrix(this._options.colorMatrix);
      }
    };
    ColorMatrixPrimitive.prototype.availableOptions = ColorMatrixFilter.prototype.availableOptions;
    color_matrix_default3 = ColorMatrixPrimitive;
  }
});

// engine/sdk/operations/shared/shaders/primitives/desaturation.frag
var desaturation_default;
var init_desaturation = __esm({
  "engine/sdk/operations/shared/shaders/primitives/desaturation.frag"() {
    desaturation_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_desaturation;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n  vec3 gray = vec3(dot(grayXfer, texColor.xyz));\n  gl_FragColor = vec4(mix(texColor.xyz, gray, u_desaturation) * texColor.a, texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/desaturation.js
var DesaturationFilter, Desaturation, desaturation_default2;
var init_desaturation2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/desaturation.js"() {
    init_core();
    init_desaturation();
    init_primitive();
    DesaturationFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = desaturation_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const grayXfer = [0.3, 0.59, 0.11];
        const { desaturation } = this._options;
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          const gray = grayXfer[0] * imageData.data[index] / 255 + grayXfer[1] * imageData.data[index + 1] / 255 + grayXfer[2] * imageData.data[index + 2] / 255;
          imageData.data[index] += (gray * 255 - imageData.data[index]) * desaturation;
          imageData.data[index + 1] += (gray * 255 - imageData.data[index + 1]) * desaturation;
          imageData.data[index + 2] += (gray * 255 - imageData.data[index + 2]) * desaturation;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    DesaturationFilter.prototype.availableOptions = {
      desaturation: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "f" /* FLOAT */
      }
    };
    Desaturation = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new DesaturationFilter();
      }
      update() {
        this._filter.setDesaturation(this._options.desaturation);
      }
    };
    Desaturation.prototype.availableOptions = DesaturationFilter.prototype.availableOptions;
    desaturation_default2 = Desaturation;
  }
});

// engine/sdk/operations/shared/shaders/primitives/duotone.frag
var duotone_default;
var init_duotone = __esm({
  "engine/sdk/operations/shared/shaders/primitives/duotone.frag"() {
    duotone_default = 'precision highp float;\n\nuniform sampler2D u_image;\nuniform vec4 u_lightColor;\nuniform vec4 u_darkColor;\nuniform float u_intensity;\nvarying vec2 v_texCoord;\n\nconst float EPSILON = 0.0000001;\nconst vec3 GRAYSCALE_WEIGHTS = vec3(0.2126, 0.7152, 0.0722);\n\nvec4 duotoneKernel(vec4 sampledCol, vec4 light, vec4 dark, float intensity) {\n  vec4 color = clamp(sampledCol, 0.0, 1.0);\n  color.rgb /= max(color.a, EPSILON);\n  color = clamp(color, 0.0, 1.0); // necessary to get rid of all extended sRGB issues with OpenGL ES\n \n  // Apply intensity as "symmetric gamma"\n  if (intensity > 0.0) {\n    color.rgb = 1.0 - pow(1.0 - color.rgb, vec3(max(intensity + 1.0, EPSILON)));\n  } else {\n    color.rgb = pow(color.rgb, vec3(max(-intensity + 1.0, EPSILON)));\n  }\n \n  // Colorimetric (perceptual luminance-preserving) RGB to grayscale conversion\n  // https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale\n  float luminance = dot(GRAYSCALE_WEIGHTS, color.rgb);\n \n  // Apply DuoTone\n  vec4 duotone = mix(dark, light, clamp(luminance, 0.0, 1.0));\n  duotone.a *= color.a;\n  \n  duotone.rgb *= duotone.a;\n\n  return duotone;\n}\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = duotoneKernel(texColor, u_lightColor, u_darkColor, u_intensity);\n}';
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/duotone.js
var DuoToneFilter, DuoTone, duotone_default2;
var init_duotone2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/duotone.js"() {
    init_core();
    init_duotone();
    init_primitive();
    DuoToneFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = duotone_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const { lightColor, darkColor, intensity } = this._options;
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          const r = imageData.data[index] / 255;
          const g = imageData.data[index + 1] / 255;
          const b = imageData.data[index + 2] / 255;
          const a = imageData.data[index + 3] / 255;
          const color = new color_default(r, g, b, a);
          const duotone = this._duoToneKernel(color, lightColor, darkColor, intensity);
          imageData.data[index] = duotone.r * 255;
          imageData.data[index + 1] = duotone.g * 255;
          imageData.data[index + 2] = duotone.b * 255;
          imageData.data[index + 3] = duotone.a * 255;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
      _duoToneKernel(color, light, dark, intensity) {
        const EPSILON3 = 1e-7;
        color.clone().clamp(0, 1);
        if (intensity > 0) {
          const exp = Math.max(intensity + 1, EPSILON3);
          color.r = 1 - Math.pow(1 - color.r, exp);
          color.g = 1 - Math.pow(1 - color.g, exp);
          color.b = 1 - Math.pow(1 - color.b, exp);
        } else {
          const exp = Math.max(-intensity + 1, EPSILON3);
          color.r = Math.pow(color.r, exp);
          color.g = Math.pow(color.g, exp);
          color.b = Math.pow(color.b, exp);
        }
        const luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
        const clampedLuminance = Math.min(Math.max(luminance, 0), 1);
        const duotone = dark.clone().mix(light, clampedLuminance);
        duotone.a *= color.a;
        return duotone;
      }
    };
    DuoToneFilter.prototype.availableOptions = {
      lightColor: {
        type: "color" /* COLOR */,
        default: color_default.RED,
        uniformType: "4f" /* FLOAT4 */
      },
      darkColor: {
        type: "color" /* COLOR */,
        default: color_default.BLACK,
        uniformType: "4f" /* FLOAT4 */
      },
      intensity: {
        type: "number" /* NUMBER */,
        default: 0.5,
        uniformType: "f" /* FLOAT */
      }
    };
    DuoTone = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new DuoToneFilter();
      }
      update() {
        this._filter.setLightColor(this._options.lightColor);
        this._filter.setDarkColor(this._options.darkColor);
        const shaderIntensity = 2 * this._options.intensity - 1;
        this._filter.setIntensity(shaderIntensity);
      }
    };
    DuoTone.prototype.availableOptions = DuoToneFilter.prototype.availableOptions;
    duotone_default2 = DuoTone;
  }
});

// engine/sdk/operations/shared/shaders/primitives/gamma.frag
var gamma_default;
var init_gamma = __esm({
  "engine/sdk/operations/shared/shaders/primitives/gamma.frag"() {
    gamma_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec3 u_gamma;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec3 rgb = vec3(texColor.r, texColor.g, texColor.b);\n  rgb = pow(rgb, u_gamma);\n  gl_FragColor = vec4(rgb * texColor.a, texColor.a);;\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/gamma.js
var GammaFilter, Gamma, gamma_default2;
var init_gamma2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/gamma.js"() {
    init_core();
    init_gamma();
    init_primitive();
    GammaFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = gamma_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const { gamma } = this._options;
        const gammaArrayRed = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          gammaArrayRed[i] = 255 * Math.pow(i / 255, gamma.r);
        }
        const gammaArrayGreen = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          gammaArrayGreen[i] = 255 * Math.pow(i / 255, gamma.g);
        }
        const gammaArrayBlue = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          gammaArrayBlue[i] = 255 * Math.pow(i / 255, gamma.b);
        }
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          imageData.data[index] = gammaArrayRed[imageData.data[index]];
          imageData.data[index + 1] = gammaArrayGreen[imageData.data[index + 1]];
          imageData.data[index + 2] = gammaArrayBlue[imageData.data[index + 2]];
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    GammaFilter.prototype.availableOptions = {
      gamma: {
        type: "color" /* COLOR */,
        default: color_default.WHITE,
        uniformType: "3f" /* FLOAT3 */
      }
    };
    Gamma = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new GammaFilter();
      }
      update() {
        this._filter.setGamma(this._options.gamma);
      }
    };
    Gamma.prototype.availableOptions = GammaFilter.prototype.availableOptions;
    gamma_default2 = Gamma;
  }
});

// engine/sdk/operations/shared/shaders/primitives/glow.frag
var glow_default;
var init_glow = __esm({
  "engine/sdk/operations/shared/shaders/primitives/glow.frag"() {
    glow_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n\n  vec2 textureCoord = v_texCoord - vec2(0.5, 0.5);\n  textureCoord /= 0.75;\n\n  float d = 1.0 - dot(textureCoord, textureCoord);\n  d = clamp(d, 0.2, 1.0);\n  vec3 newColor = texColor.rgb * d * u_color.rgb;\n  gl_FragColor = vec4(vec3(newColor) * texColor.a, texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/glow.js
var GlowFilter, Glow, glow_default2;
var init_glow2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/glow.js"() {
    init_core();
    init_glow();
    init_primitive();
    GlowFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = glow_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const { color } = this._options;
        let d;
        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const index = (canvas.width * y + x) * 4;
            const x01 = x / canvas.width;
            const y01 = y / canvas.height;
            const nx = (x01 - 0.5) / 0.75;
            const ny = (y01 - 0.5) / 0.75;
            const scalarX = nx * nx;
            const scalarY = ny * ny;
            d = 1 - (scalarX + scalarY);
            d = Math.min(Math.max(d, 0.1), 1);
            imageData.data[index] *= d * color.r;
            imageData.data[index + 1] = imageData.data[index + 1] * (d * color.g);
            imageData.data[index + 2] = imageData.data[index + 2] * (d * color.b);
            imageData.data[index + 3] = 255;
          }
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    GlowFilter.prototype.availableOptions = {
      color: {
        type: "color" /* COLOR */,
        default: color_default.WHITE,
        uniformType: "3f" /* FLOAT3 */
      }
    };
    Glow = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new GlowFilter();
      }
      update() {
        this._filter.setColor(this._options.color);
      }
    };
    Glow.prototype.availableOptions = GlowFilter.prototype.availableOptions;
    glow_default2 = Glow;
  }
});

// engine/sdk/operations/shared/shaders/primitives/gobblin.frag
var gobblin_default;
var init_gobblin = __esm({
  "engine/sdk/operations/shared/shaders/primitives/gobblin.frag"() {
    gobblin_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  texColor.b = texColor.g * 0.33;\n  texColor.r = texColor.r * 0.6;\n  texColor.b += texColor.r * 0.33;\n  texColor.g = texColor.g * 0.7;\n  gl_FragColor = texColor;\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/gobblin.js
var GobblinFilter, Gobblin, gobblin_default2;
var init_gobblin2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/gobblin.js"() {
    init_core();
    init_gobblin();
    init_primitive();
    GobblinFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = gobblin_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const index = (canvas.width * y + x) * 4;
            imageData.data[index + 2] = imageData.data[index + 1] * 0.33;
            imageData.data[index] *= 0.6;
            imageData.data[index + 2] += imageData.data[index] * 0.33;
            imageData.data[index + 1] = imageData.data[index + 1] * 0.7;
            imageData.data[index + 3] = 255;
          }
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    Gobblin = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new GobblinFilter();
      }
    };
    gobblin_default2 = Gobblin;
  }
});

// engine/sdk/operations/shared/shaders/primitives/grayscale.frag
var grayscale_default;
var init_grayscale = __esm({
  "engine/sdk/operations/shared/shaders/primitives/grayscale.frag"() {
    grayscale_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nvec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, W);\n  gl_FragColor = vec4(vec3(luminance) * texColor.a, texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/grayscale.js
var GrayscaleFilter, Grayscale, grayscale_default2;
var init_grayscale2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/grayscale.js"() {
    init_core();
    init_grayscale();
    init_primitive();
    GrayscaleFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = grayscale_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const index = (canvas.width * y + x) * 4;
            const luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
            imageData.data[index] = luminance;
            imageData.data[index + 1] = luminance;
            imageData.data[index + 2] = luminance;
          }
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    Grayscale = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new GrayscaleFilter();
      }
    };
    grayscale_default2 = Grayscale;
  }
});

// engine/sdk/operations/shared/shaders/primitives/lookup-table.frag
var lookup_table_default;
var init_lookup_table = __esm({
  "engine/sdk/operations/shared/shaders/primitives/lookup-table.frag"() {
    lookup_table_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_lookupTable;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float r = texture2D(u_lookupTable, vec2(texColor.r, 0.0)).r;\n  float g = texture2D(u_lookupTable, vec2(texColor.g, 0.0)).g;\n  float b = texture2D(u_lookupTable, vec2(texColor.b, 0.0)).b;\n\n  gl_FragColor = vec4(vec3(r, g, b) * texColor.a, texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/lookup-table.js
var LookupTableFilter, LookupTable, lookup_table_default2;
var init_lookup_table2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/lookup-table.js"() {
    init_core();
    init_lookup_table();
    init_primitive();
    LookupTableFilter = class extends engine_default.Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = lookup_table_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const table = this._options.lookupTableData;
        for (let i = 0; i < canvas.width * canvas.height; i++) {
          const index = i * 4;
          const r = imageData.data[index];
          imageData.data[index] = table[r * 4];
          const g = imageData.data[index + 1];
          imageData.data[index + 1] = table[1 + g * 4];
          const b = imageData.data[index + 2];
          imageData.data[index + 2] = table[2 + b * 4];
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    LookupTableFilter.prototype.availableOptions = {
      lookupTable: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "i" /* INT */
      },
      lookupTableData: { type: "array" /* ARRAY */, default: [] }
    };
    LookupTable = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new LookupTableFilter({
          lookupTable: this._options.textureGLUnit
        });
        this._textures = {};
        this._renderers = {};
      }
      update(sdk) {
        const renderer = sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          this._updateWebGLTexture(sdk);
        } else if (renderer.isOfType("canvas" /* CANVAS */)) {
          this._filter.setLookupTableData(this._options.data);
        }
      }
      _updateWebGLTexture(sdk) {
        if (typeof this._options.data === "undefined") {
          throw new Error("LookupTable: No data specified.");
        }
        const data = new Uint8Array(this._options.data);
        const renderer = sdk.getRenderer();
        const { id } = renderer;
        this._renderers[id] = renderer;
        if (!this._textures[id]) {
          this._textures[id] = new engine_default.BaseTexture();
        }
        const texture = this._textures[id];
        const pixelArrayImage = new engine_default.PixelArrayImage(256, 1, data);
        texture.setSource(pixelArrayImage);
        texture.setGLUnit(this._options.textureGLUnit);
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          renderer.updateTexture(texture);
        }
      }
      dispose() {
        super.dispose();
        for (const id in this._textures) {
          this._textures[id].dispose();
          delete this._textures[id];
        }
        delete this._options.data;
      }
    };
    lookup_table_default2 = LookupTable;
  }
});

// engine/sdk/operations/shared/shaders/primitives/lookup-table-image.frag
var lookup_table_image_default;
var init_lookup_table_image = __esm({
  "engine/sdk/operations/shared/shaders/primitives/lookup-table-image.frag"() {
    lookup_table_image_default = "/**\n * Based off of GPUImage's LookupFilter:\n * https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageLookupFilter.m\n */\n\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_lookupTable;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float blueColor = texColor.b * 63.0;\n\n  vec2 quad1;\n  quad1.y = floor(floor(blueColor) / 8.0);\n  quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\n  vec2 quad2;\n  quad2.y = floor(ceil(blueColor) / 8.0);\n  quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\n  vec2 texCoord1;\n  texCoord1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.r);\n  texCoord1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.g);\n\n  vec2 texCoord2;\n  texCoord2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.r);\n  texCoord2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.g);\n\n  vec4 newColor1 = texture2D(u_lookupTable, texCoord1);\n  vec4 newColor2 = texture2D(u_lookupTable, texCoord2);\n\n  vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n  gl_FragColor = mix(texColor, vec4(newColor.rgb, texColor.w), texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/lookup-table-image.js
var Vector27, TEXTURE_GL_UNIT, LookupTableImageFilter, LookupTableImage, lookup_table_image_default2;
var init_lookup_table_image2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/lookup-table-image.js"() {
    init_core();
    init_lookup_table_image();
    init_primitive();
    ({ Vector2: Vector27 } = math_exports);
    TEXTURE_GL_UNIT = 3;
    LookupTableImageFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._precomputeQuads();
        this._fragmentSource = lookup_table_image_default;
      }
      _precomputeQuads() {
        this._quads = [];
        for (let i = 0; i < 256; i++) {
          const blueColor = i / 255 * 63;
          const quad = new Vector27();
          quad.y = (blueColor | 0) * 0.125 | 0;
          quad.x = (blueColor | 0) - quad.y * 8;
          this._quads.push(quad);
        }
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const lutImage = this._options.lookupTableImage;
        const lutCanvas = this._createImageCanvas(lutImage);
        const lutContext = lutCanvas.getContext("2d");
        const inputImageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const filterImageData = lutContext.getImageData(0, 0, lutImage.width, lutImage.height);
        const texCoord = new Vector27();
        for (let index = 0; index < canvas.width * canvas.height * 4; index += 4) {
          const r = inputImageData.data[index];
          const g = inputImageData.data[index + 1];
          const b = inputImageData.data[index + 2];
          const a = inputImageData.data[index + 3] / 255;
          const quad = this._quads[b];
          const tileSideLength = 64;
          texCoord.x = quad.x * tileSideLength;
          texCoord.y = quad.y * tileSideLength;
          texCoord.x += Math.floor(r / 4);
          texCoord.y += Math.floor(g / 4);
          const texCoordIndex = (lutImage.width * texCoord.y + texCoord.x) * 4 | 0;
          let newR = filterImageData.data[texCoordIndex];
          newR = r * (1 - a) + newR * a;
          let newG = filterImageData.data[texCoordIndex + 1];
          newG = g * (1 - a) + newG * a;
          let newB = filterImageData.data[texCoordIndex + 2];
          newB = b * (1 - a) + newB * a;
          inputImageData.data[index] = newR;
          inputImageData.data[index + 1] = newG;
          inputImageData.data[index + 2] = newB;
        }
        outputContext.putImageData(inputImageData, 0, 0);
      }
      _createImageCanvas(image) {
        const canvas = utils_default.createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0);
        return canvas;
      }
    };
    LookupTableImageFilter.prototype.availableOptions = {
      lookupTable: {
        type: "number" /* NUMBER */,
        default: TEXTURE_GL_UNIT,
        uniformType: "i" /* INT */
      },
      lookupTableImage: { type: "image" /* IMAGE */, uniformType: null }
    };
    LookupTableImage = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new LookupTableImageFilter();
        this._textures = {};
      }
      update(sdk) {
        const renderer = sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          this._updateWebGLTexture(sdk);
        } else if (renderer.isOfType("canvas" /* CANVAS */)) {
          this._filter.setLookupTableImage(this._options.image);
        }
      }
      _updateWebGLTexture(sdk) {
        const renderer = sdk.getRenderer();
        const { id } = renderer;
        if (!this._textures[id]) {
          this._textures[id] = new engine_default.BaseTexture();
        }
        const texture = this._textures[id];
        texture.setSource(this._options.image);
        texture.setGLUnit(TEXTURE_GL_UNIT);
        renderer.updateTexture(texture);
      }
      dispose() {
        super.dispose();
        for (const id in this._textures) {
          delete this._textures[id];
        }
      }
    };
    LookupTableImage.prototype.availableOptions = {
      image: { type: "image" /* IMAGE */ }
    };
    lookup_table_image_default2 = LookupTableImage;
  }
});

// engine/sdk/operations/shared/shaders/primitives/saturation.frag
var saturation_default;
var init_saturation = __esm({
  "engine/sdk/operations/shared/shaders/primitives/saturation.frag"() {
    saturation_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_saturation;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, luminanceWeighting);\n\n  vec3 greyScaleColor = vec3(luminance);\n\n  gl_FragColor = vec4(mix(greyScaleColor, texColor.rgb, u_saturation) * texColor.a, texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/saturation.js
var SaturationFilter, Saturation, saturation_default2;
var init_saturation2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/saturation.js"() {
    init_core();
    init_saturation();
    init_primitive();
    SaturationFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = saturation_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const { saturation } = this._options;
        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const index = (canvas.width * y + x) * 4;
            const luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
            imageData.data[index] = luminance * (1 - saturation) + imageData.data[index] * saturation;
            imageData.data[index + 1] = luminance * (1 - saturation) + imageData.data[index + 1] * saturation;
            imageData.data[index + 2] = luminance * (1 - saturation) + imageData.data[index + 2] * saturation;
          }
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    SaturationFilter.prototype.availableOptions = {
      saturation: {
        type: "number" /* NUMBER */,
        default: 0,
        uniformType: "f" /* FLOAT */
      }
    };
    Saturation = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new SaturationFilter();
      }
      update() {
        this._filter.setSaturation(this._options.saturation);
      }
    };
    Saturation.prototype.availableOptions = SaturationFilter.prototype.availableOptions;
    saturation_default2 = Saturation;
  }
});

// engine/sdk/operations/shared/shaders/primitives/soft-color-overlay.frag
var soft_color_overlay_default;
var init_soft_color_overlay = __esm({
  "engine/sdk/operations/shared/shaders/primitives/soft-color-overlay.frag"() {
    soft_color_overlay_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec4 overlayVec4 = vec4(u_color, texColor.a);\n  gl_FragColor = max(overlayVec4 * texColor.a, texColor);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/soft-color-overlay.js
var SoftColorOverlayFilter, SoftColorOverlay, soft_color_overlay_default2;
var init_soft_color_overlay2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/soft-color-overlay.js"() {
    init_core();
    init_soft_color_overlay();
    init_primitive();
    SoftColorOverlayFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = soft_color_overlay_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const index = (canvas.width * y + x) * 4;
            imageData.data[index] = Math.max(this._options.color.r * 255, imageData.data[index]);
            imageData.data[index + 1] = Math.max(this._options.color.g * 255, imageData.data[index + 1]);
            imageData.data[index + 2] = Math.max(this._options.color.b * 255, imageData.data[index + 2]);
          }
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    SoftColorOverlayFilter.prototype.availableOptions = {
      color: {
        type: "color" /* COLOR */,
        default: color_default.WHITE,
        uniformType: "3f" /* FLOAT3 */
      }
    };
    SoftColorOverlay = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new SoftColorOverlayFilter();
      }
      update() {
        this._filter.setColor(this._options.color);
      }
    };
    SoftColorOverlay.prototype.availableOptions = SoftColorOverlayFilter.prototype.availableOptions;
    soft_color_overlay_default2 = SoftColorOverlay;
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/tone-curve.js
var ToneCurve, tone_curve_default;
var init_tone_curve = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/tone-curve.js"() {
    init_core();
    init_lookup_table2();
    ToneCurve = class extends lookup_table_default2 {
      constructor(...args) {
        super(...args);
        if (!this._options.rgbControlPoints) {
          this._options.rgbControlPoints = {
            red: this._options.controlPoints,
            green: this._options.controlPoints,
            blue: this._options.controlPoints
          };
        }
        this._updateLookupTable();
      }
      _updateLookupTable() {
        const r = this._calculateSplineCurve(this._options.rgbControlPoints.red);
        const g = this._calculateSplineCurve(this._options.rgbControlPoints.green);
        const b = this._calculateSplineCurve(this._options.rgbControlPoints.blue);
        this._options.data = this._buildLookupTable(r, g, b);
      }
      _buildLookupTable(r, g, b) {
        const data = [];
        for (let i = 0; i < 256; i++) {
          data.push(Math.min(Math.max(i + r[i], 0), 255));
          data.push(Math.min(Math.max(i + g[i], 0), 255));
          data.push(Math.min(Math.max(i + b[i], 0), 255));
          data.push(255);
        }
        return data;
      }
      _calculateSplineCurve(points) {
        points = points.sort(function(a, b) {
          return a[0] > b[0];
        });
        const splinePoints = this._getSplineCurve(points);
        const firstSplinePoint = splinePoints[0];
        let i;
        if (firstSplinePoint[0] > 0) {
          for (i = 0; i < firstSplinePoint[0]; i++) {
            splinePoints.unshift([0, 0]);
          }
        }
        const preparedPoints = [];
        for (i = 0; i < splinePoints.length; i++) {
          const newPoint = splinePoints[i];
          const origPoint = [newPoint[0], newPoint[0]];
          let distance = Math.sqrt(Math.pow(origPoint[0] - newPoint[0], 2) + Math.pow(origPoint[1] - newPoint[1], 2));
          if (origPoint[1] > newPoint[1]) {
            distance = -distance;
          }
          preparedPoints.push(distance);
        }
        return preparedPoints;
      }
      _getSplineCurve(points) {
        const sdA = this._secondDerivative(points);
        const n = sdA.length;
        const sd = [];
        let i;
        for (i = 0; i < n; i++) {
          sd[i] = sdA[i];
        }
        const output = [];
        for (i = 0; i < n - 1; i++) {
          const cur = points[i];
          const next = points[i + 1];
          for (let x = cur[0]; x < next[0]; x++) {
            const t = (x - cur[0]) / (next[0] - cur[0]);
            const a = 1 - t;
            const b = t;
            const h = next[0] - cur[0];
            let y = a * cur[1] + b * next[1] + h * h / 6 * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);
            if (y > 255) {
              y = 255;
            } else if (y < 0) {
              y = 0;
            }
            output.push([x, y]);
          }
        }
        if (output.length === 255) {
          output.push(points[points.length - 1]);
        }
        return output;
      }
      _secondDerivative(points) {
        const n = points.length;
        if (n <= 0 || n === 1) {
          return null;
        }
        const matrix2 = [];
        const result = [];
        let i;
        let k;
        matrix2[0] = [0, 1, 0];
        for (i = 1; i < n - 1; i++) {
          const P1 = points[i - 1];
          const P2 = points[i];
          const P3 = points[i + 1];
          matrix2[i] = matrix2[i] || [];
          matrix2[i][0] = (P2[0] - P1[0]) / 6;
          matrix2[i][1] = (P3[0] - P1[0]) / 3;
          matrix2[i][2] = (P3[0] - P2[0]) / 6;
          result[i] = (P3[1] - P2[1]) / (P3[0] - P2[0]) - (P2[1] - P1[1]) / (P2[0] - P1[0]);
        }
        result[0] = 0;
        result[n - 1] = 0;
        matrix2[n - 1] = [0, 1, 0];
        for (i = 1; i < n; i++) {
          k = matrix2[1][0] / matrix2[i - 1][1];
          matrix2[i][1] -= k * matrix2[i - 1][2];
          matrix2[i][0] = 0;
          result[i] -= k * result[i - 1];
        }
        for (i = n - 2; i > 0; i--) {
          k = matrix2[i][2] / matrix2[i + 1][1];
          matrix2[i][1] -= k * matrix2[i + 1][0];
          matrix2[i][2] = 0;
          result[i] -= k * result[i + 1];
        }
        const y2 = [];
        for (i = 0; i < n; i++) {
          y2[i] = result[i] / matrix2[i][1];
        }
        return y2;
      }
    };
    ToneCurve.prototype.availableOptions = {
      rgbControlPoints: { type: "object" /* OBJECT */ },
      controlPoints: { type: "array" /* ARRAY */, default: [] },
      textureGLUnit: { type: "number" /* NUMBER */, default: 1 }
    };
    tone_curve_default = ToneCurve;
  }
});

// engine/sdk/operations/shared/shaders/primitives/x400.frag
var x400_default;
var init_x400 = __esm({
  "engine/sdk/operations/shared/shaders/primitives/x400.frag"() {
    x400_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float gray = texColor.r * 0.3 + texColor.g * 0.3 + texColor.b * 0.3;\n  gray -= 0.2;\n  gray = clamp(gray, 0.0, 1.0);\n  gray += 0.15;\n  gray *= 1.4;\n  gl_FragColor = vec4(vec3(gray) * texColor.a, texColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/x400.js
var X400Filter, X400, x400_default2;
var init_x4002 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/x400.js"() {
    init_core();
    init_x400();
    init_primitive();
    X400Filter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = x400_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        for (let x = 0; x < canvas.width; x++) {
          for (let y = 0; y < canvas.height; y++) {
            const index = (canvas.width * y + x) * 4;
            let gray = imageData.data[index] / 255 * 0.3 + imageData.data[index + 1] / 255 * 0.3 + imageData.data[index + 2] / 255 * 0.3;
            gray -= 0.2;
            gray = Math.max(0, Math.min(1, gray));
            gray += 0.15;
            gray *= 1.4;
            gray *= 255;
            imageData.data[index] = gray;
            imageData.data[index + 1] = gray;
            imageData.data[index + 2] = gray;
          }
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    X400 = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new X400Filter();
      }
    };
    x400_default2 = X400;
  }
});

// engine/sdk/operations/shared/shaders/primitives/3d-lookup-table-image.frag
var d_lookup_table_image_default;
var init_d_lookup_table_image = __esm({
  "engine/sdk/operations/shared/shaders/primitives/3d-lookup-table-image.frag"() {
    d_lookup_table_image_default = "precision highp float;\n\nuniform sampler2D u_image;\n\nuniform sampler2D u_lookupTable;\n\nuniform float u_resolution;     // Texture-Resolution, must be power of 2: 64, 128, 256, 512, 1024, 2048, 4096\nuniform float u_horizontalTileCount; // Horizontal Blue Tiles\nuniform float u_verticalTileCount; // Vertical Blue Tiles\n\nvarying vec2 v_texCoord;\n\nconst float EPSILON = 0.000001;\n\n// Try to get the exact pixel of the lut map image\nvec3 lutColor(int texPosX, int texPosY) {\n    return texture2D(u_lookupTable, (0.5 / u_resolution) + vec2(float(texPosX), float(texPosY)) / u_resolution).rgb;\n}\n\nvec3 bilinearInterpolate(vec3 cRfGf, vec3 cRfGc, vec3 cRcGf, vec3 cRcGc, float redFract, float greenFract) {\n    return mix(mix(cRfGf, cRcGf, redFract), mix(cRfGc, cRcGc, redFract), greenFract);\n}\n\nvoid main() {\n    vec4 inputColor = clamp(texture2D(u_image, v_texCoord.xy), 0.0, 1.0);\n\n    vec3 sourceColor = vec3(inputColor.rgb / max(inputColor.a, EPSILON)); \n\n    vec3 ranges = vec3(\n        floor(u_resolution / u_horizontalTileCount - 1.0),\n        floor(u_resolution / u_verticalTileCount - 1.0),\n        floor(u_horizontalTileCount * u_horizontalTileCount - 1.0)\n    );\n    \n    vec3 tmp = sourceColor * ranges;\n    ivec3 floors = ivec3(tmp);\n    ivec3 ceils = ivec3(ceil(tmp));\n    vec3 fracts = fract(tmp);\n\n    // Map tile index to tile pixel pos.\n    ivec2 pixelsPerTile = ivec2(\n        u_resolution / u_horizontalTileCount, \n        u_resolution / u_verticalTileCount\n      );\n\n    ivec2 tileFloor; // Blue tile index\n    tileFloor.y = floors.z / int(u_horizontalTileCount);\n    tileFloor.x = (floors.z - (tileFloor.y * int(u_horizontalTileCount)));\n\n    ivec2 tileCeil; // Blue tile index\n    tileCeil.y = ceils.z / int(u_horizontalTileCount);\n    tileCeil.x = (ceils.z - (tileCeil.y * int(u_horizontalTileCount)));\n    \n    tileFloor *= pixelsPerTile;\n    tileCeil *= pixelsPerTile; \n    \n    \n    // Interpolate between red and green\n    vec3 lutColorFB = bilinearInterpolate(\n        lutColor(tileFloor.x + floors.x, tileFloor.y + floors.y),\n        lutColor(tileFloor.x + floors.x, tileFloor.y + ceils.y),\n        lutColor(tileFloor.x + ceils.x,  tileFloor.y + floors.y),\n        lutColor(tileFloor.x + ceils.x,  tileFloor.y + ceils.y),\n        fracts.x, fracts.y\n    );\n    vec3 lutColorCB = bilinearInterpolate(\n        lutColor(tileCeil.x + floors.x, tileCeil.y + floors.y),\n        lutColor(tileCeil.x + floors.x, tileCeil.y + ceils.y),\n        lutColor(tileCeil.x + ceils.x,  tileCeil.y + floors.y),\n        lutColor(tileCeil.x + ceils.x,  tileCeil.y + ceils.y),\n        fracts.x, fracts.y\n    );\n\n    // Interpolate between the blue values\n    vec3 interpolation = mix(lutColorFB, lutColorCB, fracts.z);\n\n    // Round Color Values to prevent that for ex. 254.999999 is cutting to 254 instead of 255;\n    interpolation = clamp(floor(interpolation * 255. + .5) / 255., 0.0, 1.0);\n\n    gl_FragColor = vec4(interpolation.rgb * inputColor.a, inputColor.a);\n}\n";
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/3d-lookup-table-image.js
var Vector28, Vector33, TEXTURE_GL_UNIT2, ThreeDLookupTableImageFilter, LookupTableImage2, d_lookup_table_image_default2;
var init_d_lookup_table_image2 = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/3d-lookup-table-image.js"() {
    init_core();
    init_d_lookup_table_image();
    init_primitive();
    ({ Vector2: Vector28, Vector3: Vector33 } = math_exports);
    TEXTURE_GL_UNIT2 = 3;
    ThreeDLookupTableImageFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._precomputeQuads();
        this._fragmentSource = d_lookup_table_image_default;
      }
      _precomputeQuads() {
        this._quads = [];
        for (let i = 0; i < 256; i++) {
          const blueColor = i / 255 * 63;
          const quad = new Vector28();
          quad.y = (blueColor | 0) * 0.125 | 0;
          quad.x = (blueColor | 0) - quad.y * 8;
          this._quads.push(quad);
        }
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const {
          resolution,
          horizontalTileCount,
          verticalTileCount
        } = this._options;
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const lutImage = this._options.lookupTableImage;
        const lutCanvas = this._createImageCanvas(lutImage);
        const lutContext = lutCanvas.getContext("2d");
        let lutImageDimensions = { width: 128, height: 128 };
        if (resolution) {
          lutImageDimensions = { width: resolution, height: resolution };
        } else if (lutImage.width && lutImage.height) {
          lutImageDimensions = { width: lutImage.width, height: lutImage.height };
        }
        const inputImageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const lutImageData = lutContext.getImageData(0, 0, lutImageDimensions.width, lutImageDimensions.height);
        const ranges = new Vector33(lutImageDimensions.width / horizontalTileCount - 1 | 0, lutImageDimensions.height / verticalTileCount - 1 | 0, horizontalTileCount * verticalTileCount - 1 | 0);
        const inputColor = new color_default();
        const outputColor = new color_default();
        const lutColorFB = new color_default();
        const lutColorCB = new color_default();
        const cRfGf = new color_default();
        const cRfGc = new color_default();
        const cRcGf = new color_default();
        const cRcGc = new color_default();
        const tileFloor = new Vector28();
        const tileCeil = new Vector28();
        const mix = (target, x, y, a) => {
          target.r = x.r * (1 - a) + y.r * a;
          target.g = x.g * (1 - a) + y.g * a;
          target.b = x.b * (1 - a) + y.b * a;
        };
        const lookup = (target, x, y) => {
          x = 0.5 + x | 0;
          y = 0.5 + y | 0;
          const index = (y * lutImageDimensions.width + x) * 4;
          target.r = lutImageData.data[index] / 255;
          target.g = lutImageData.data[index + 1] / 255;
          target.b = lutImageData.data[index + 2] / 255;
          target.a = lutImageData.data[index + 3] / 255;
        };
        const interpolateTempA = new color_default();
        const interpolateTempB = new color_default();
        const bilinearInterpolate = (target, cRfGf2, cRfGc2, cRcGf2, cRcGc2, redFract, greenFract) => {
          mix(interpolateTempA, cRfGf2, cRcGf2, redFract);
          mix(interpolateTempB, cRfGc2, cRcGc2, redFract);
          mix(target, interpolateTempA, interpolateTempB, greenFract);
        };
        const pixelsPerTile = new Vector28(lutImageDimensions.width, lutImageDimensions.height).divide(horizontalTileCount, verticalTileCount).floor();
        for (let index = 0; index < canvas.width * canvas.height * 4; index += 4) {
          inputColor.set(inputImageData.data[index] / 255, inputImageData.data[index + 1] / 255, inputImageData.data[index + 2] / 255, inputImageData.data[index + 3] / 255);
          const tmp = new Vector33(inputColor.r * ranges.x, inputColor.g * ranges.y, inputColor.b * ranges.z);
          const floors = tmp.clone().floor().toInt();
          const ceils = tmp.clone().ceil().toInt();
          const fracts = tmp.clone().fract();
          tileFloor.y = floors.z / horizontalTileCount | 0;
          tileFloor.x = floors.z - tileFloor.y * horizontalTileCount | 0;
          tileCeil.y = ceils.z / horizontalTileCount | 0;
          tileCeil.x = ceils.z - tileCeil.y * horizontalTileCount | 0;
          tileFloor.multiply(pixelsPerTile);
          tileCeil.multiply(pixelsPerTile);
          lookup(cRfGf, tileFloor.x + floors.x, tileFloor.y + floors.y);
          lookup(cRfGc, tileFloor.x + floors.x, tileFloor.y + ceils.y);
          lookup(cRcGf, tileFloor.x + ceils.x, tileFloor.y + floors.y);
          lookup(cRcGc, tileFloor.x + ceils.x, tileFloor.y + ceils.y);
          bilinearInterpolate(lutColorFB, cRfGf, cRfGc, cRcGf, cRcGc, fracts.x, fracts.y);
          lookup(cRfGf, tileCeil.x + floors.x, tileCeil.y + floors.y);
          lookup(cRfGc, tileCeil.x + floors.x, tileCeil.y + ceils.y);
          lookup(cRcGf, tileCeil.x + ceils.x, tileCeil.y + floors.y);
          lookup(cRcGc, tileCeil.x + ceils.x, tileCeil.y + ceils.y);
          bilinearInterpolate(lutColorCB, cRfGf, cRfGc, cRcGf, cRcGc, fracts.x, fracts.y);
          mix(outputColor, lutColorFB, lutColorCB, fracts.z);
          inputImageData.data[index] = Math.ceil(outputColor.r * 255);
          inputImageData.data[index + 1] = Math.ceil(outputColor.g * 255);
          inputImageData.data[index + 2] = Math.ceil(outputColor.b * 255);
        }
        outputContext.putImageData(inputImageData, 0, 0);
      }
      _createImageCanvas(image) {
        const canvas = utils_default.createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0);
        return canvas;
      }
    };
    ThreeDLookupTableImageFilter.prototype.availableOptions = {
      lookupTable: {
        type: "number" /* NUMBER */,
        default: TEXTURE_GL_UNIT2,
        uniformType: "i" /* INT */
      },
      lookupTableImage: { type: "image" /* IMAGE */, uniformType: null },
      resolution: { type: "number" /* NUMBER */, uniformType: "f" /* FLOAT */ },
      horizontalTileCount: {
        type: "number" /* NUMBER */,
        default: 5,
        uniformType: "f" /* FLOAT */
      },
      verticalTileCount: {
        type: "number" /* NUMBER */,
        default: 5,
        uniformType: "f" /* FLOAT */
      }
    };
    LookupTableImage2 = class extends primitive_default {
      constructor(...args) {
        super(...args);
        this._filter = new ThreeDLookupTableImageFilter();
        this._textures = {};
      }
      update(sdk) {
        const renderer = sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          this._updateWebGLTexture(sdk);
        } else if (renderer.isOfType("canvas" /* CANVAS */)) {
          this._filter.setLookupTableImage(this._options.image);
        }
        const {
          resolution,
          verticalTileCount,
          horizontalTileCount,
          image
        } = this._options;
        this._filter.set({
          resolution: resolution || image.width,
          verticalTileCount,
          horizontalTileCount
        });
      }
      _updateWebGLTexture(sdk) {
        const renderer = sdk.getRenderer();
        const { id } = renderer;
        if (!this._textures[id]) {
          this._textures[id] = new engine_default.BaseTexture();
        }
        const texture = this._textures[id];
        texture.setSource(this._options.image);
        texture.setGLUnit(TEXTURE_GL_UNIT2);
        texture.setMinFilter(engine_default.BaseTexture.NearestFilter);
        renderer.updateTexture(texture);
      }
      dispose() {
        super.dispose();
        for (const id in this._textures) {
          delete this._textures[id];
        }
      }
    };
    LookupTableImage2.prototype.availableOptions = {
      image: { type: "image" /* IMAGE */ },
      resolution: { type: "number" /* NUMBER */ },
      horizontalTileCount: { type: "number" /* NUMBER */, default: 5 },
      verticalTileCount: { type: "number" /* NUMBER */, default: 5 }
    };
    d_lookup_table_image_default2 = LookupTableImage2;
  }
});

// engine/sdk/operations/filter-operation/filters/primitives/index.js
var primitives_exports = {};
__export(primitives_exports, {
  Brightness: () => brightness_default2,
  ColorMatrixPrimitive: () => color_matrix_default3,
  Contrast: () => contrast_default2,
  Desaturation: () => desaturation_default2,
  DuoTone: () => duotone_default2,
  Gamma: () => gamma_default2,
  Glow: () => glow_default2,
  Gobblin: () => gobblin_default2,
  Grayscale: () => grayscale_default2,
  LookupTable: () => lookup_table_default2,
  LookupTableImage: () => lookup_table_image_default2,
  Saturation: () => saturation_default2,
  SoftColorOverlay: () => soft_color_overlay_default2,
  ThreeDLookupTableImage: () => d_lookup_table_image_default2,
  ToneCurve: () => tone_curve_default,
  X400: () => x400_default2
});
var init_primitives = __esm({
  "engine/sdk/operations/filter-operation/filters/primitives/index.js"() {
    init_brightness2();
    init_contrast2();
    init_color_matrix3();
    init_desaturation2();
    init_duotone2();
    init_gamma2();
    init_glow2();
    init_gobblin2();
    init_grayscale2();
    init_lookup_table2();
    init_lookup_table_image2();
    init_saturation2();
    init_soft_color_overlay2();
    init_tone_curve();
    init_x4002();
    init_d_lookup_table_image2();
  }
});

// engine/sdk/operations/filter-operation/filters/identity-filter.js
var IdentityFilter, identity_filter_default;
var init_identity_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/identity-filter.js"() {
    init_filter2();
    init_primitives();
    IdentityFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new brightness_default2({
          brightness: 0
        }));
      }
      render(sdk, inputTexture, outputTexture) {
        if (this._stack.isEmpty()) {
          this._stack.push(new brightness_default2({
            brightness: 0
          }));
        }
        return super.render(sdk, inputTexture, outputTexture);
      }
    };
    IdentityFilter.isIdentity = true;
    IdentityFilter.identifier = "identity";
    identity_filter_default = IdentityFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/a15-filter.js
var A15Filter, a15_filter_default;
var init_a15_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/a15-filter.js"() {
    init_filter2();
    init_primitives();
    A15Filter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new contrast_default2({
          contrast: 0.63
        }));
        this._stack.push(new brightness_default2({
          brightness: 0.12
        }));
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 38],
              [94, 94],
              [148, 142],
              [175, 187],
              [255, 255]
            ],
            green: [
              [0, 0],
              [77, 53],
              [171, 190],
              [255, 255]
            ],
            blue: [
              [0, 10],
              [48, 85],
              [174, 228],
              [255, 255]
            ]
          }
        }));
      }
    };
    A15Filter.identifier = "a15";
    a15_filter_default = A15Filter;
  }
});

// engine/sdk/operations/filter-operation/filters/breeze-filter.js
var BreezeFilter, breeze_filter_default;
var init_breeze_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/breeze-filter.js"() {
    init_filter2();
    init_primitives();
    BreezeFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new desaturation_default2({
          desaturation: 0.5
        }));
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [170, 170],
              [212, 219],
              [234, 242],
              [255, 255]
            ],
            green: [
              [0, 0],
              [170, 168],
              [234, 231],
              [255, 255]
            ],
            blue: [
              [0, 0],
              [170, 170],
              [212, 208],
              [255, 255]
            ]
          }
        }));
      }
    };
    BreezeFilter.identifier = "breeze";
    breeze_filter_default = BreezeFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/bw-filter.js
var BWFilter, bw_filter_default;
var init_bw_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/bw-filter.js"() {
    init_filter2();
    init_primitives();
    BWFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new grayscale_default2());
      }
    };
    BWFilter.identifier = "bw";
    bw_filter_default = BWFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/bwhard-filter.js
var BWHardFilter, bwhard_filter_default;
var init_bwhard_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/bwhard-filter.js"() {
    init_filter2();
    init_primitives();
    BWHardFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new grayscale_default2());
        this._stack.push(new contrast_default2({
          contrast: 1.5
        }));
      }
    };
    BWHardFilter.identifier = "bwhard";
    bwhard_filter_default = BWHardFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/celsius-filter.js
var CelsiusFilter, celsius_filter_default;
var init_celsius_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/celsius-filter.js"() {
    init_filter2();
    init_primitives();
    CelsiusFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 69],
              [55, 110],
              [202, 230],
              [255, 255]
            ],
            green: [
              [0, 44],
              [89, 93],
              [185, 141],
              [255, 189]
            ],
            blue: [
              [0, 76],
              [39, 82],
              [218, 138],
              [255, 171]
            ]
          }
        }));
      }
    };
    CelsiusFilter.identifier = "celsius";
    celsius_filter_default = CelsiusFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/chest-filter.js
var ChestFilter, chest_filter_default;
var init_chest_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/chest-filter.js"() {
    init_filter2();
    init_primitives();
    ChestFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [44, 44],
              [124, 143],
              [221, 204],
              [255, 255]
            ],
            green: [
              [0, 0],
              [130, 127],
              [213, 199],
              [255, 255]
            ],
            blue: [
              [0, 0],
              [51, 52],
              [219, 204],
              [255, 255]
            ]
          }
        }));
      }
    };
    ChestFilter.identifier = "chest";
    chest_filter_default = ChestFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/duotone-filter.js
var DuoToneFilter2, duotone_filter_default;
var init_duotone_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/duotone-filter.js"() {
    init_core();
    init_filter2();
    init_primitives();
    DuoToneFilter2 = class extends filter_default {
      constructor(...args) {
        super(...args, {
          intensity: {
            type: "number" /* NUMBER */,
            default: 0.5,
            required: true,
            setter(intensity) {
              if (this._filterPrimitive) {
                this._filterPrimitive.setIntensity(intensity);
                this._stack.setIntensity(1);
              }
              this._dirty = true;
              return intensity;
            }
          }
        });
        this._filterPrimitive = new duotone_default2({
          lightColor: this._options.lightColor || color_default.WHITE,
          darkColor: this._options.darkColor || color_default.BLACK,
          intensity: this._options.intensity || 0.5
        });
        this._stack.push(this._filterPrimitive);
      }
    };
    DuoToneFilter2.prototype.availableOptions = {
      lightColor: {
        type: "color" /* COLOR */,
        default: color_default.WHITE,
        required: true,
        setter(color) {
          if (this._filterPrimitive) {
            this._filterPrimitive.setLightColor(color);
          }
          this.setDirty && this.setDirty(true);
          return color;
        }
      },
      darkColor: {
        type: "color" /* COLOR */,
        default: color_default.BLACK,
        required: true,
        setter(color) {
          if (this._filterPrimitive) {
            this._filterPrimitive.setDarkColor(color);
          }
          this.setDirty && this.setDirty(true);
          return color;
        }
      },
      intensity: {
        type: "number" /* NUMBER */,
        default: 0.5,
        required: true
      }
    };
    DuoToneFilter2.identifier = "duotone";
    duotone_filter_default = DuoToneFilter2;
  }
});

// engine/sdk/operations/filter-operation/filters/fixie-filter.js
var FixieFilter, fixie_filter_default;
var init_fixie_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/fixie-filter.js"() {
    init_filter2();
    init_primitives();
    FixieFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [44, 28],
              [63, 48],
              [128, 132],
              [235, 248],
              [255, 255]
            ],
            green: [
              [0, 0],
              [20, 10],
              [60, 45],
              [190, 209],
              [211, 231],
              [255, 255]
            ],
            blue: [
              [0, 31],
              [41, 62],
              [150, 142],
              [234, 212],
              [255, 224]
            ]
          }
        }));
      }
    };
    FixieFilter.identifier = "fixie";
    fixie_filter_default = FixieFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/food-filter.js
var FoodFilter, food_filter_default;
var init_food_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/food-filter.js"() {
    init_filter2();
    init_primitives();
    FoodFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new saturation_default2({
          saturation: 1.35
        }));
        this._stack.push(new contrast_default2({
          contrast: 1.1
        }));
      }
    };
    FoodFilter.identifier = "food";
    food_filter_default = FoodFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/fridge-filter.js
var FridgeFilter, fridge_filter_default;
var init_fridge_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/fridge-filter.js"() {
    init_filter2();
    init_primitives();
    FridgeFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 9],
              [21, 11],
              [45, 24],
              [255, 220]
            ],
            green: [
              [0, 12],
              [21, 21],
              [42, 42],
              [150, 150],
              [170, 173],
              [255, 210]
            ],
            blue: [
              [0, 28],
              [43, 72],
              [128, 185],
              [255, 220]
            ]
          }
        }));
      }
    };
    FridgeFilter.identifier = "fridge";
    fridge_filter_default = FridgeFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/front-filter.js
var FrontFilter, front_filter_default;
var init_front_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/front-filter.js"() {
    init_filter2();
    init_primitives();
    FrontFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 65],
              [28, 67],
              [67, 113],
              [125, 183],
              [187, 217],
              [255, 229]
            ],
            green: [
              [0, 52],
              [42, 59],
              [104, 134],
              [169, 209],
              [255, 240]
            ],
            blue: [
              [0, 52],
              [65, 68],
              [93, 104],
              [150, 153],
              [255, 198]
            ]
          }
        }));
      }
    };
    FrontFilter.identifier = "front";
    front_filter_default = FrontFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/glam-filter.js
var GlamFilter, glam_filter_default;
var init_glam_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/glam-filter.js"() {
    init_filter2();
    init_primitives();
    GlamFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new contrast_default2({
          contrast: 1.1
        }));
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [94, 74],
              [181, 205],
              [255, 255]
            ],
            green: [
              [0, 0],
              [127, 127],
              [255, 255]
            ],
            blue: [
              [0, 0],
              [102, 73],
              [227, 213],
              [255, 255]
            ]
          }
        }));
      }
    };
    GlamFilter.identifier = "glam";
    glam_filter_default = GlamFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/gobblin-filter.js
var GobblinFilter2, gobblin_filter_default;
var init_gobblin_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/gobblin-filter.js"() {
    init_filter2();
    init_primitives();
    GobblinFilter2 = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new gobblin_default2());
      }
    };
    GobblinFilter2.identifier = "gobblin";
    gobblin_filter_default = GobblinFilter2;
  }
});

// engine/sdk/operations/filter-operation/filters/k1-filter.js
var K1Filter, k1_filter_default;
var init_k1_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/k1-filter.js"() {
    init_filter2();
    init_primitives();
    K1Filter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          controlPoints: [
            [0, 0],
            [53, 32],
            [91, 80],
            [176, 205],
            [255, 255]
          ]
        }));
        this._stack.push(new saturation_default2({
          saturation: 0.9
        }));
      }
    };
    K1Filter.identifier = "k1";
    k1_filter_default = K1Filter;
  }
});

// engine/sdk/operations/filter-operation/filters/k2-filter.js
var K2Filter, k2_filter_default;
var init_k2_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/k2-filter.js"() {
    init_core();
    init_filter2();
    init_primitives();
    K2Filter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          controlPoints: [
            [0, 0],
            [54, 33],
            [77, 82],
            [94, 103],
            [122, 126],
            [177, 193],
            [229, 232],
            [255, 255]
          ]
        }));
        this._stack.push(new soft_color_overlay_default2({
          color: new color_default(40 / 255, 40 / 255, 40 / 255)
        }));
      }
    };
    K2Filter.identifier = "k2";
    k2_filter_default = K2Filter;
  }
});

// engine/sdk/operations/filter-operation/filters/k6-filter.js
var K6Filter, k6_filter_default;
var init_k6_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/k6-filter.js"() {
    init_filter2();
    init_primitives();
    K6Filter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new saturation_default2({
          saturation: 0.5
        }));
      }
    };
    K6Filter.identifier = "k6";
    k6_filter_default = K6Filter;
  }
});

// engine/sdk/operations/filter-operation/filters/kdynamic-filter.js
var KDynamicFilter, kdynamic_filter_default;
var init_kdynamic_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/kdynamic-filter.js"() {
    init_filter2();
    init_primitives();
    KDynamicFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          controlPoints: [
            [0, 0],
            [17, 27],
            [46, 69],
            [90, 112],
            [156, 200],
            [203, 243],
            [255, 255]
          ]
        }));
        this._stack.push(new saturation_default2({
          saturation: 0.7
        }));
      }
    };
    KDynamicFilter.identifier = "kdynamic";
    kdynamic_filter_default = KDynamicFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/lenin-filter.js
var LeninFilter, lenin_filter_default;
var init_lenin_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/lenin-filter.js"() {
    init_filter2();
    init_primitives();
    LeninFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new desaturation_default2({
          desaturation: 0.4
        }));
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 20],
              [40, 20],
              [106, 111],
              [129, 153],
              [190, 223],
              [255, 255]
            ],
            green: [
              [0, 20],
              [40, 20],
              [62, 41],
              [106, 108],
              [132, 159],
              [203, 237],
              [255, 255]
            ],
            blue: [
              [0, 40],
              [40, 40],
              [73, 60],
              [133, 160],
              [191, 297],
              [203, 237],
              [237, 239],
              [255, 255]
            ]
          }
        }));
      }
    };
    LeninFilter.identifier = "lenin";
    lenin_filter_default = LeninFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/lomo-filter.js
var LomoFilter, lomo_filter_default;
var init_lomo_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/lomo-filter.js"() {
    init_filter2();
    init_primitives();
    LomoFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          controlPoints: [
            [0, 0],
            [87, 20],
            [131, 156],
            [183, 205],
            [255, 200]
          ]
        }));
      }
    };
    LomoFilter.identifier = "lomo";
    lomo_filter_default = LomoFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/mellow-filter.js
var MellowFilter, mellow_filter_default;
var init_mellow_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/mellow-filter.js"() {
    init_filter2();
    init_primitives();
    MellowFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [41, 84],
              [87, 134],
              [255, 255]
            ],
            green: [
              [0, 0],
              [255, 216]
            ],
            blue: [
              [0, 0],
              [255, 131]
            ]
          }
        }));
      }
    };
    MellowFilter.identifier = "mellow";
    mellow_filter_default = MellowFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/metal-filter.js
var ColorMatrix6, MetalFilter, metal_filter_default;
var init_metal_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/metal-filter.js"() {
    init_core();
    init_filter2();
    init_primitives();
    ({ ColorMatrix: ColorMatrix6 } = math_exports);
    MetalFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        const matrix1 = new ColorMatrix6(0.8158218291630716, 0, 0, 0, -0.01779810181190647, 0, 0.8098360655737704, 0, 0, 0.0916393442622953, 0, 0, 0.4596336773932402, 0, 0.12760574782432707, 0, 0, 0, 1, 0);
        this._stack.push(new color_matrix_default3({
          colorMatrix: matrix1
        }));
        const gammaColor = new color_default(0.8, 0.6, 0.9);
        this._stack.push(new gamma_default2({
          gamma: gammaColor
        }));
      }
    };
    MetalFilter.identifier = "metal";
    metal_filter_default = MetalFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/morning-filter.js
var MorningFilter, morning_filter_default;
var init_morning_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/morning-filter.js"() {
    init_filter2();
    init_primitives();
    MorningFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 40],
              [255, 230]
            ],
            green: [
              [0, 10],
              [255, 225]
            ],
            blue: [
              [0, 20],
              [255, 181]
            ]
          }
        }));
        this._stack.push(new glow_default2());
      }
    };
    MorningFilter.identifier = "morning";
    morning_filter_default = MorningFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/orchid-filter.js
var OrchidFilter, orchid_filter_default;
var init_orchid_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/orchid-filter.js"() {
    init_filter2();
    init_primitives();
    OrchidFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [115, 130],
              [195, 215],
              [255, 255]
            ],
            green: [
              [0, 0],
              [148, 153],
              [172, 215],
              [255, 255]
            ],
            blue: [
              [0, 46],
              [58, 75],
              [178, 205],
              [255, 255]
            ]
          },
          textureGLUnit: 2
        }));
        this._stack.push(new tone_curve_default({
          controlPoints: [
            [0, 0],
            [117, 151],
            [189, 217],
            [255, 255]
          ],
          textureGLUnit: 3
        }));
        this._stack.push(new desaturation_default2({
          desaturation: 0.65
        }));
      }
    };
    OrchidFilter.identifier = "orchid";
    orchid_filter_default = OrchidFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/pola-filter.js
var PolaFilter, pola_filter_default;
var init_pola_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/pola-filter.js"() {
    init_filter2();
    init_primitives();
    PolaFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [94, 74],
              [181, 205],
              [255, 255]
            ],
            green: [
              [0, 0],
              [34, 34],
              [99, 76],
              [176, 190],
              [255, 255]
            ],
            blue: [
              [0, 0],
              [102, 73],
              [227, 213],
              [255, 255]
            ]
          }
        }));
        this._stack.push(new saturation_default2({
          saturation: 0.8
        }));
        this._stack.push(new contrast_default2({
          contrast: 1.5
        }));
      }
    };
    PolaFilter.identifier = "pola";
    pola_filter_default = PolaFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/pola669-filter.js
var Pola669Filter, pola669_filter_default;
var init_pola669_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/pola669-filter.js"() {
    init_filter2();
    init_primitives();
    Pola669Filter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [56, 18],
              [196, 209],
              [255, 255]
            ],
            green: [
              [0, 38],
              [71, 84],
              [255, 255]
            ],
            blue: [
              [0, 0],
              [131, 133],
              [204, 211],
              [255, 255]
            ]
          }
        }));
        this._stack.push(new saturation_default2({
          saturation: 0.8
        }));
        this._stack.push(new contrast_default2({
          contrast: 1.5
        }));
      }
    };
    Pola669Filter.identifier = "pola669";
    pola669_filter_default = Pola669Filter;
  }
});

// engine/sdk/operations/filter-operation/filters/quozi-filter.js
var QuoziFilter, quozi_filter_default;
var init_quozi_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/quozi-filter.js"() {
    init_filter2();
    init_primitives();
    QuoziFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new desaturation_default2({
          desaturation: 0.65
        }));
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 50],
              [40, 78],
              [118, 170],
              [181, 211],
              [255, 255]
            ],
            green: [
              [0, 27],
              [28, 45],
              [109, 157],
              [157, 195],
              [179, 208],
              [206, 212],
              [255, 240]
            ],
            blue: [
              [0, 50],
              [12, 55],
              [46, 103],
              [103, 162],
              [194, 182],
              [241, 201],
              [255, 219]
            ]
          }
        }));
      }
    };
    QuoziFilter.identifier = "quozi";
    quozi_filter_default = QuoziFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/semired-filter.js
var SemiredFilter, semired_filter_default;
var init_semired_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/semired-filter.js"() {
    init_filter2();
    init_primitives();
    SemiredFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 129],
              [75, 153],
              [181, 227],
              [255, 255]
            ],
            green: [
              [0, 8],
              [111, 85],
              [212, 158],
              [255, 226]
            ],
            blue: [
              [0, 5],
              [75, 22],
              [193, 90],
              [255, 229]
            ]
          }
        }));
        this._stack.push(new glow_default2());
      }
    };
    SemiredFilter.identifier = "semired";
    semired_filter_default = SemiredFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/sunny-filter.js
var SunnyFilter, sunny_filter_default;
var init_sunny_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/sunny-filter.js"() {
    init_filter2();
    init_primitives();
    SunnyFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 0],
              [62, 82],
              [141, 154],
              [255, 255]
            ],
            green: [
              [0, 39],
              [56, 96],
              [192, 176],
              [255, 255]
            ],
            blue: [
              [0, 0],
              [174, 99],
              [255, 235]
            ]
          },
          textureGLUnit: 2
        }));
        this._stack.push(new tone_curve_default({
          controlPoints: [
            [0, 0],
            [55, 20],
            [158, 191],
            [255, 255]
          ],
          textureGLUnit: 3
        }));
      }
    };
    SunnyFilter.identifier = "sunny";
    sunny_filter_default = SunnyFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/texas-filter.js
var TexasFilter, texas_filter_default;
var init_texas_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/texas-filter.js"() {
    init_filter2();
    init_primitives();
    TexasFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new tone_curve_default({
          rgbControlPoints: {
            red: [
              [0, 72],
              [89, 99],
              [176, 212],
              [255, 237]
            ],
            green: [
              [0, 49],
              [255, 192]
            ],
            blue: [
              [0, 72],
              [255, 151]
            ]
          }
        }));
      }
    };
    TexasFilter.identifier = "texas";
    texas_filter_default = TexasFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/x400-filter.js
var X400Filter2, x400_filter_default;
var init_x400_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/x400-filter.js"() {
    init_filter2();
    init_primitives();
    X400Filter2 = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._stack.push(new x400_default2());
      }
    };
    X400Filter2.identifier = "x400";
    x400_filter_default = X400Filter2;
  }
});

// engine/sdk/operations/filter-operation/filters/lut-filter.js
var LUTFilter, lut_filter_default;
var init_lut_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/lut-filter.js"() {
    init_core();
    init_filter2();
    init_primitives();
    LUTFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        this._lutPrimitive = new lookup_table_image_default2({
          image: this._options.image
        });
        this._stack.push(this._lutPrimitive);
      }
    };
    LUTFilter.prototype.availableOptions = {
      image: {
        type: "image" /* IMAGE */,
        required: true,
        setter(image) {
          if (this._lutPrimitive) {
            this._lutPrimitive.setImage(image);
          }
          this.setDirty(true);
          return image;
        }
      }
    };
    LUTFilter.identifier = "lut";
    lut_filter_default = LUTFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/3d-lut-filter.js
var ThreeDLUTFilter, d_lut_filter_default;
var init_d_lut_filter = __esm({
  "engine/sdk/operations/filter-operation/filters/3d-lut-filter.js"() {
    init_core();
    init_filter2();
    init_primitives();
    ThreeDLUTFilter = class extends filter_default {
      constructor(...args) {
        super(...args);
        const {
          image,
          resolution,
          verticalTileCount,
          horizontalTileCount
        } = this._options;
        this._lutPrimitive = new d_lookup_table_image_default2({
          image,
          resolution,
          verticalTileCount,
          horizontalTileCount
        });
        this._stack.push(this._lutPrimitive);
      }
    };
    ThreeDLUTFilter.prototype.availableOptions = {
      image: {
        type: "image" /* IMAGE */,
        required: true,
        setter(image) {
          if (this._lutPrimitive) {
            this._lutPrimitive.setImage(image);
          }
          this.setDirty(true);
          return image;
        }
      },
      resolution: { type: "number" /* NUMBER */ },
      horizontalTileCount: { type: "number" /* NUMBER */, default: 5 },
      verticalTileCount: { type: "number" /* NUMBER */, default: 5 }
    };
    ThreeDLUTFilter.identifier = "3d-lut";
    d_lut_filter_default = ThreeDLUTFilter;
  }
});

// engine/sdk/operations/filter-operation/filters/index.js
var filters_exports2 = {};
__export(filters_exports2, {
  A15Filter: () => a15_filter_default,
  BWFilter: () => bw_filter_default,
  BWHardFilter: () => bwhard_filter_default,
  BreezeFilter: () => breeze_filter_default,
  CelsiusFilter: () => celsius_filter_default,
  ChestFilter: () => chest_filter_default,
  DuoToneFilter: () => duotone_filter_default,
  FixieFilter: () => fixie_filter_default,
  FoodFilter: () => food_filter_default,
  FridgeFilter: () => fridge_filter_default,
  FrontFilter: () => front_filter_default,
  GlamFilter: () => glam_filter_default,
  GobblinFilter: () => gobblin_filter_default,
  IdentityFilter: () => identity_filter_default,
  K1Filter: () => k1_filter_default,
  K2Filter: () => k2_filter_default,
  K6Filter: () => k6_filter_default,
  KDynamicFilter: () => kdynamic_filter_default,
  LUTFilter: () => lut_filter_default,
  LeninFilter: () => lenin_filter_default,
  LomoFilter: () => lomo_filter_default,
  MellowFilter: () => mellow_filter_default,
  MetalFilter: () => metal_filter_default,
  MorningFilter: () => morning_filter_default,
  OrchidFilter: () => orchid_filter_default,
  Pola669Filter: () => pola669_filter_default,
  PolaFilter: () => pola_filter_default,
  QuoziFilter: () => quozi_filter_default,
  SemiredFilter: () => semired_filter_default,
  SunnyFilter: () => sunny_filter_default,
  TexasFilter: () => texas_filter_default,
  ThreeDLUTFilter: () => d_lut_filter_default,
  X400Filter: () => x400_filter_default
});
var init_filters2 = __esm({
  "engine/sdk/operations/filter-operation/filters/index.js"() {
    init_identity_filter();
    init_a15_filter();
    init_breeze_filter();
    init_bw_filter();
    init_bwhard_filter();
    init_celsius_filter();
    init_chest_filter();
    init_duotone_filter();
    init_fixie_filter();
    init_food_filter();
    init_fridge_filter();
    init_front_filter();
    init_glam_filter();
    init_gobblin_filter();
    init_k1_filter();
    init_k2_filter();
    init_k6_filter();
    init_kdynamic_filter();
    init_lenin_filter();
    init_lomo_filter();
    init_mellow_filter();
    init_metal_filter();
    init_morning_filter();
    init_orchid_filter();
    init_pola_filter();
    init_pola669_filter();
    init_quozi_filter();
    init_semired_filter();
    init_sunny_filter();
    init_texas_filter();
    init_x400_filter();
    init_lut_filter();
    init_d_lut_filter();
  }
});

// engine/sdk/operations/filter-operation/index.js
var FilterOperation, filter_operation_default;
var init_filter_operation = __esm({
  "engine/sdk/operations/filter-operation/index.js"() {
    init_core();
    init_filters2();
    init_filter2();
    init_identity_filter();
    init_primitives();
    FilterOperation = class extends operation_default {
      _render(inputTexture) {
        return this._selectedFilter.render(this._sdk, inputTexture, this._renderTexture);
      }
      render(inputTexture) {
        if (this._selectedFilter.getDirty()) {
          this.setDirty(true);
        }
        if (!this.getEnabled()) {
          this.setDirtyForRenderer(false, this._sdk.getRenderer());
          return Promise.resolve(inputTexture);
        }
        return super.render(inputTexture);
      }
      setDirtyForRenderer(dirty, renderer) {
        super.setDirtyForRenderer(dirty, renderer);
        this._selectedFilter.setDirtyForRenderer(dirty, renderer);
      }
      disposeRenderTextures() {
        super.disposeRenderTextures();
        if (this._selectedFilter) {
          this._selectedFilter.disposeRenderTextures();
        }
      }
      dispose() {
        super.dispose();
        if (this._selectedFilter) {
          this._selectedFilter.dispose();
        }
      }
      restoreSnapshot(serializedOptions) {
        const options = __spreadValues({}, serializedOptions);
        delete options.filter;
        if (serializedOptions.filter) {
          const FilterConstructor = serializedOptions.filter.constructor;
          if (FilterConstructor.identifier === "3d-lut") {
            this.setFilter(new FilterConstructor({
              image: serializedOptions.filter.getImage(),
              resolution: serializedOptions.filter.getResolution(),
              horizontalTileCount: serializedOptions.filter.getHorizontalTileCount(),
              verticalTileCount: serializedOptions.filter.getVerticalTileCount()
            }));
          } else if (FilterConstructor.identifier === "duotone") {
            this.setFilter(new FilterConstructor({
              lightColor: serializedOptions.filter.getLightColor(),
              darkColor: serializedOptions.filter.getDarkColor(),
              intensity: serializedOptions.filter.getIntensity()
            }));
          } else {
            this.setFilter(new FilterConstructor());
          }
        }
        this.set(options);
      }
      resetToDefaultFilterIntensity() {
        const filterOptions = this._selectedFilter && this._selectedFilter.availableOptions;
        const defaultIntensity = filterOptions && filterOptions.intensity.default;
        this.setIntensity(defaultIntensity || 1);
      }
    };
    FilterOperation.identifier = "filter";
    FilterOperation.prototype.availableOptions = {
      identifier: {
        type: "string" /* STRING */,
        default: "identity"
      },
      intensity: {
        type: "number" /* NUMBER */,
        default: 1,
        setter(intensity) {
          this._selectedFilter && this._selectedFilter.setIntensity(intensity);
          return intensity;
        }
      },
      filter: {
        type: "object" /* OBJECT */,
        default: new identity_filter_default(),
        setter(Filter3) {
          if (this._selectedFilter) {
            this._selectedFilter.dispose();
            this._selectedFilter = null;
          }
          this._selectedFilter = Filter3;
          if (typeof this._options.intensity !== "undefined") {
            this._selectedFilter.set({
              intensity: this._options.intensity
            });
          }
          return Filter3;
        }
      }
    };
    FilterOperation.FilterPrimitives = primitives_exports;
    FilterOperation.Filters = filters_exports2;
    FilterOperation.Filter = filter_default;
    exports_default.Operations.FilterOperation = FilterOperation;
    filter_operation_default = FilterOperation;
  }
});

// engine/sdk/operations/flip-operation/index.js
var Vector29, FlipOperation, flip_operation_default;
var init_flip_operation = __esm({
  "engine/sdk/operations/flip-operation/index.js"() {
    init_core();
    ({ Vector2: Vector29 } = math_exports);
    FlipOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._flipContainer = new engine_default.Container();
      }
      _render(inputTexture) {
        const {
          outputResolution,
          flipHorizontally,
          flipVertically
        } = this._options;
        if (flipHorizontally || flipVertically) {
          const dimensions = inputTexture.getDimensions();
          if (!this._flipRenderTexture) {
            this._flipRenderTexture = new engine_default.RenderTexture(this._sdk.getRenderer(), dimensions.x, dimensions.y);
            this._flipSprite = new engine_default.Sprite(this._flipRenderTexture);
            this._flipContainer.addChild(this._flipSprite);
          } else {
            this._flipRenderTexture.resizeTo(dimensions);
          }
          const scaleX = flipHorizontally ? -1 : 1;
          const scaleY = flipVertically ? -1 : 1;
          this._flipSprite.setScale(scaleX, scaleY);
          this._flipSprite.setPivot(0, 0);
          this._flipSprite.setPosition(dimensions.x * (1 - scaleX) * 0.5, dimensions.y * (1 - scaleY) * 0.5);
          this._flipRenderTexture.clear();
          this._flipRenderTexture.render(this._container);
          this._renderTexture.render(this._flipContainer);
        } else {
          this._renderTexture.render(this._container);
        }
        return Promise.resolve();
      }
    };
    FlipOperation.identifier = "flip";
    FlipOperation.prototype.availableOptions = {
      flipHorizontally: { type: "boolean" /* BOOLEAN */, default: false },
      flipVertically: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.FlipOperation = FlipOperation;
    flip_operation_default = FlipOperation;
  }
});

// engine/sdk/operations/frame-operation/index.js
var Vector210, FrameOperation, frame_operation_default;
var init_frame_operation = __esm({
  "engine/sdk/operations/frame-operation/index.js"() {
    init_core();
    ({ Vector2: Vector210 } = math_exports);
    FrameOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._colorOverlayFilter = new engine_default.Filters.ColorOverlayFilter({
          color: this.getTintColor()
        });
        this._frameContainer = new engine_default.Container();
        this._resetSprites();
        if (this._options.frame) {
          this._createSpritesForFrame(this._options.frame);
        }
      }
      _resetSprites() {
        this._spriteGroups = {
          top: {},
          left: {},
          right: {},
          bottom: {}
        };
        this._sprites = [];
        this._repeatSprites = {
          top: [],
          left: [],
          right: [],
          bottom: []
        };
      }
      _createSpritesForFrame(frame) {
        if (!frame)
          return this._disposeSprites();
        const { imageGroups, layoutMode } = frame;
        this._layoutMode = layoutMode || "horizontal-inside";
        this._disposeSprites();
        ["top", "left", "right", "bottom"].forEach((group) => {
          if (typeof imageGroups[group] === "undefined")
            return;
          ["start", "mid", "end"].forEach((part) => {
            if (typeof imageGroups[group][part] === "undefined")
              return;
            let image = imageGroups[group][part];
            if ("image" in image) {
              image = image.image;
            }
            const texture = engine_default.Texture.fromImage(image);
            const sprite = new engine_default.Sprite(texture);
            this._spriteGroups[group][part] = sprite;
            this._sprites.push(sprite);
            this._frameContainer.addChild(sprite);
          });
        });
      }
      _render(inputTexture) {
        const dimensions = this._renderTexture.getDimensions();
        if (this._options.frame) {
          this._colorOverlayFilter.setColor(this.getTintColor());
          this._updateSprites(inputTexture);
        }
        if (!this._frameRenderTexture) {
          this._frameRenderTexture = new engine_default.RenderTexture(this._sdk.getRenderer(), dimensions.x, dimensions.y);
          this._frameSprite = new engine_default.Sprite(this._frameRenderTexture);
          this._container.addChild(this._frameSprite);
        } else {
          this._frameRenderTexture.resizeTo(dimensions);
        }
        this._frameSprite.setAlpha(this._options.alpha);
        if (this._options.frame && this._options.frame.tintable) {
          this._frameSprite.setFilters([this._colorOverlayFilter]);
        } else {
          this._frameSprite.setFilters([]);
        }
        this._frameRenderTexture.clear();
        this._frameRenderTexture.render(this._frameContainer);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      _updateSprites(inputTexture) {
        const dimensions = inputTexture.getDimensions();
        this._frameWidth = Math.ceil(inputTexture.getDimensions().min() * this._options.scale);
        this._updateHorizontalSpriteGroup(inputTexture, "top", 0);
        this._updateHorizontalSpriteGroup(inputTexture, "bottom", dimensions.y - this._frameWidth);
        this._updateVerticalSpriteGroup(inputTexture, "left", 0);
        this._updateVerticalSpriteGroup(inputTexture, "right", dimensions.x - this._frameWidth);
      }
      _updateHorizontalSpriteGroup(inputTexture, group, offset = 0) {
        const dimensions = inputTexture.getDimensions();
        const verticalInside = this._layoutMode === "vertical-inside";
        const startSprite = this._spriteGroups[group].start;
        const midSprite = this._spriteGroups[group].mid;
        const endSprite = this._spriteGroups[group].end;
        let startWidth = 0;
        let endWidth = 0;
        let textureDimensions;
        let textureRatio;
        if (startSprite) {
          textureDimensions = startSprite.getTexture().getDimensions();
          textureRatio = textureDimensions.y / textureDimensions.x;
          startWidth = Math.floor(this._frameWidth / textureRatio);
          const startPosition = new Vector210(0, offset);
          startPosition.x = verticalInside ? this._frameWidth : 0;
          startSprite.setPosition(startPosition);
          startSprite.setHeight(this._frameWidth);
          startSprite.setWidth(startWidth);
        }
        if (endSprite) {
          textureDimensions = endSprite.getTexture().getDimensions();
          textureRatio = textureDimensions.y / textureDimensions.x;
          endWidth = Math.floor(this._frameWidth * textureRatio);
          const endPosition = new Vector210(dimensions.x - endWidth, offset);
          endPosition.x -= verticalInside ? this._frameWidth : 0;
          endSprite.setPosition(endPosition);
          endSprite.setHeight(this._frameWidth);
          endSprite.setWidth(endWidth);
        }
        if (midSprite) {
          textureDimensions = midSprite.getTexture().getDimensions();
          textureRatio = textureDimensions.y / textureDimensions.x;
          const midPosition = new Vector210(startWidth, offset);
          let midWidth = dimensions.x - startWidth - endWidth;
          if (verticalInside) {
            midPosition.x += this._frameWidth;
            midWidth -= this._frameWidth * 2;
          }
          midSprite.setPosition(midPosition);
          midSprite.setWidth(midWidth);
          midSprite.setHeight(this._frameWidth);
          if (true) {
            midSprite._canvasSmoothingEnabled = false;
          }
          if (this._options.frame.imageGroups[group].mid.mode === "repeat") {
            const defaultSpriteWidth = this._frameWidth / textureRatio;
            const requiredRepeatSprites = Math.ceil(midWidth / defaultSpriteWidth);
            let consumedWidth = 0;
            if (requiredRepeatSprites !== -1) {
              let spriteWidth = Math.round(midWidth / requiredRepeatSprites);
              midSprite.setWidth(spriteWidth);
              consumedWidth += spriteWidth;
              this._ensureRepeatSpritesExist(requiredRepeatSprites - 1, group, midSprite);
              for (let i = 0; i < requiredRepeatSprites - 1; i++) {
                spriteWidth = Math.round((midWidth - consumedWidth) / (requiredRepeatSprites - i - 1));
                const sprite = this._repeatSprites[group][i];
                const spritePosition = midPosition.clone().add(consumedWidth, 0).floor();
                sprite.setPosition(spritePosition);
                sprite.setWidth(spriteWidth);
                sprite.setHeight(this._frameWidth);
                consumedWidth += spriteWidth;
              }
            }
          }
        }
      }
      _ensureRepeatSpritesExist(requiredSpritesCount, group, sourceSprite) {
        sourceSprite.getTexture().setMaxListeners(requiredSpritesCount + 1);
        const existingSpritesCount = this._repeatSprites[group].length;
        if (requiredSpritesCount > existingSpritesCount) {
          const missingRepeatSprites = requiredSpritesCount - existingSpritesCount;
          for (let i = 0; i < missingRepeatSprites; i++) {
            const sprite = new engine_default.Sprite(sourceSprite.getTexture());
            this._repeatSprites[group].push(sprite);
            this._frameContainer.addChild(sprite);
            this._sprites.push(sprite);
          }
        } else if (requiredSpritesCount < existingSpritesCount) {
          const spareRepeatSprites = this._repeatSprites[group].splice(requiredSpritesCount);
          spareRepeatSprites.forEach((sprite) => {
            const index = this._sprites.indexOf(sprite);
            if (index === -1)
              return;
            this._sprites.splice(index, 1);
            this._frameContainer.removeChild(sprite);
            sprite.dispose();
          });
        }
      }
      _updateVerticalSpriteGroup(inputTexture, group, offset = 0) {
        const dimensions = inputTexture.getDimensions();
        const horizontalInside = this._layoutMode === "horizontal-inside";
        const startSprite = this._spriteGroups[group].start;
        const midSprite = this._spriteGroups[group].mid;
        const endSprite = this._spriteGroups[group].end;
        let startHeight = 0;
        let endHeight = 0;
        let textureDimensions;
        let textureRatio;
        if (startSprite) {
          textureDimensions = startSprite.getTexture().getDimensions();
          textureRatio = textureDimensions.y / textureDimensions.x;
          startHeight = Math.floor(this._frameWidth * textureRatio);
          const startPosition = new Vector210(offset, 0);
          startPosition.y = horizontalInside ? this._frameWidth : 0;
          startSprite.setPosition(startPosition);
          startSprite.setWidth(this._frameWidth);
          startSprite.setHeight(startHeight);
        }
        if (endSprite) {
          textureDimensions = endSprite.getTexture().getDimensions();
          textureRatio = textureDimensions.y / textureDimensions.x;
          endHeight = Math.floor(this._frameWidth * textureRatio);
          const endPosition = new Vector210(offset, dimensions.y - endHeight);
          endPosition.y -= horizontalInside ? this._frameWidth : 0;
          endSprite.setPosition(endPosition);
          endSprite.setWidth(this._frameWidth);
          endSprite.setHeight(endHeight);
        }
        if (midSprite) {
          textureDimensions = midSprite.getTexture().getDimensions();
          textureRatio = textureDimensions.y / textureDimensions.x;
          const midPosition = new Vector210(offset, startHeight);
          let midHeight = dimensions.y - startHeight - endHeight;
          if (horizontalInside) {
            midPosition.y += this._frameWidth;
            midHeight -= this._frameWidth * 2;
          }
          midSprite.setPosition(midPosition);
          midSprite.setHeight(midHeight);
          midSprite.setWidth(this._frameWidth);
          if (true) {
            midSprite._canvasSmoothingEnabled = false;
          }
          if (this._options.frame.imageGroups[group].mid.mode === "repeat") {
            const defaultSpriteHeight = this._frameWidth * textureRatio;
            const requiredRepeatSprites = Math.ceil(midHeight / defaultSpriteHeight);
            let consumedHeight = 0;
            if (requiredRepeatSprites !== -1) {
              let spriteHeight = Math.round(midHeight / requiredRepeatSprites);
              midSprite.setHeight(spriteHeight);
              consumedHeight += spriteHeight;
              this._ensureRepeatSpritesExist(requiredRepeatSprites - 1, group, midSprite);
              for (let i = 0; i < requiredRepeatSprites - 1; i++) {
                spriteHeight = Math.round((midHeight - consumedHeight) / (requiredRepeatSprites - i - 1));
                const sprite = this._repeatSprites[group][i];
                const spritePosition = midPosition.clone().add(0, consumedHeight).floor();
                sprite.setPosition(spritePosition);
                sprite.setHeight(spriteHeight);
                sprite.setWidth(this._frameWidth);
                consumedHeight += spriteHeight;
              }
            }
          }
        }
      }
      _disposeSprites() {
        this._sprites.forEach((sprite) => {
          this._frameContainer.removeChild(sprite);
          sprite.getTexture().dispose();
          sprite.dispose();
        });
        this._resetSprites();
      }
      dispose() {
        super.dispose();
        this._disposeSprites();
        if (this._colorOverlayFilter)
          this._colorOverlayFilter.dispose();
        if (this._frameRenderTexture)
          this._frameRenderTexture.dispose();
      }
      static validateFrame(frame) {
        if (!frame)
          return;
        const { imageGroups, layoutMode } = frame;
        if (typeof frame.identifier !== "string") {
          throw new Error("Frame needs a property `identifier` of type String.");
        }
        if (typeof frame.imageGroups !== "object") {
          throw new Error("Frame needs a property `imageGroups` of type Object.");
        }
        const validateImageGroup = (group) => {
          const { start, end, mid } = imageGroups[group];
          if (typeof imageGroups[group] === "undefined")
            return;
          if (typeof imageGroups[group] !== "object") {
            throw new Error(`Frame: \`imageGroups.${group}\` needs to be of type Object.`);
          }
          if (typeof start !== "undefined" && !(start instanceof image_default || typeof HTMLImageElement !== "undefined" && start instanceof HTMLImageElement)) {
            throw new Error(`Frame: \`imageGroups.${group}.start\` needs to be of type Image.`);
          }
          if (typeof mid !== "undefined" && !(start instanceof image_default || typeof HTMLImageElement !== "undefined" && start instanceof HTMLImageElement) && typeof mid !== "object") {
            throw new Error(`Frame: \`imageGroups.${group}.mid\` needs to be of type Image or Object.`);
          }
          if (typeof end !== "undefined" && !(end instanceof image_default || typeof HTMLImageElement !== "undefined" && end instanceof HTMLImageElement)) {
            throw new Error(`Frame: \`imageGroups.${group}.end\` needs to be of type Image.`);
          }
        };
        if (typeof layoutMode !== "undefined" && ["vertical-inside", "horizontal-inside"].indexOf(layoutMode) === -1) {
          throw new Error(`Frame: \`layoutMode\` must be one of vertical-inside, horizontal-inside`);
        }
        if (typeof tintable !== "undefined" && typeof tintable !== "boolean") {
          throw new Error(`Frame: \`tintable\` needs to be of type Boolean.`);
        }
        validateImageGroup("top");
        validateImageGroup("left");
        validateImageGroup("right");
        validateImageGroup("bottom");
      }
    };
    FrameOperation.identifier = "frame";
    FrameOperation.prototype.availableOptions = {
      frame: {
        type: "object" /* OBJECT */,
        validation: FrameOperation.validateFrame,
        setter(frame, initial) {
          if (!initial) {
            this._createSpritesForFrame(frame);
          }
          return frame;
        },
        default: null
      },
      alpha: { type: "number" /* NUMBER */, default: 1 },
      tintColor: { type: "color" /* COLOR */, default: new color_default(1, 1, 1, 0) },
      scale: { type: "number" /* NUMBER */, default: 0.1 }
    };
    exports_default.Operations.FrameOperation = FrameOperation;
    frame_operation_default = FrameOperation;
  }
});

// engine/sdk/operations/license-watermark-operation/watermark.js
var watermark;
var init_watermark = __esm({
  "engine/sdk/operations/license-watermark-operation/watermark.js"() {
    watermark = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAAAAADRE4smAAAsTElEQVR4Ae1d4bHjOM5ECAgBISgEZLDOwMrAysDMwMpAzkCTAUNQCAyBIfCr2ifI1DNh+c1tfTMg3b9udtZXC7tJdgMgCP8foJAUBIJx92eoEy5puAKkHH1jX0AchqoJcLwGlv1fDVAnyKtfQMoB1WLQKBBCyuCgVvQhvQGoF3RPb2Bs/AsgEDS6BqbGvwACaHsT+AV1AK/4W18AQy3gCxTAR2vAQxW4xHSD3/kC/qlI9NK7hqg6H8SLspiPv4C+kv0v6ouZQuUEEMfndUtcOQH6qJ9nR2sg1kD+FSdQ4GLS4MA82B+uZvJJRQXkFwT8uRp2VQl99xuGiOyTX4//+AuYqtj/BBGPiVITATjtEel4pdRFAJ/2uP08K9KBYXwPaT5OC9Vlg/kneQ0cUwHcQvz6F7BAXVuA/3GNsG8ofqBQmw3uUg7dCglcZQSgJHizvO1qy4OM3wPCH64BV1fnR8QfdkqAcWD86Q86KP9+o/EjGMfwrhVSpPPUWvy9YoMbsEIqAVrSgXBSCFC3FdK/sV+txc/Kv93OEpgrawiYfybsSWkIaMcK3SurB1P8Ufyk2OB2rNCoEKCV+BW2tGOFXG2N0RiUkkgZUfmumrFCfW0EgNOPKlxB6YtvQAcqRrix+BfFBjdjhVgnQL3xk+cyWwYQVG6FLjOs6PTjotaSCF5T8iUXJLSo3gqxT4kLPig6BKheB1/+/dvzEwGi/KParSDN+arAtMFTA/Gz3+8KTiF/tVZoaxx034zwwlAPvsc/7cifx+8U8tdqhfqwXxVihOMAgnp1sJA/lzu9Tv4KrRD7fFVki2VE+IuB3anvT0z/Y/x9KBRKexPkJ+77njv835YA3kvuaPm79z+6zDGtiP5Mv1sSObMv7gr8l5MfkMclCZaJf9sK0TUWd4U58N8b/NWnb5jo9+KPShM4EvzN4DGmPcL5p1ZIgVghhr8VNBZjuP4P8Rsr/fReGW72UyukIKDJeRYz/rQkoiAYHWkSTz+2QgrOVq657bG8xYAlHWBEQzcdf+OH43SAcPp7o3/N3un34zeS98Vbeonu51ZIYCHve/tPhvl4e+QXdP/JMB9KOkRN/42gJf0ni5eiNfILzjH9J4t3NLn/0QH737etzhj5Bdf0GhP9XlXMRt2Lwu+TX4/fUtH3+t+Jl0H/Co3+/hPmQomPjJQV8iu//9Hi5fk3rJAnU3VMnfyXeJzI8HbIL7i8vf+RT8m9a4WsFH3vzzFPzo3LM/mXlN6P3wT5NeXqJ+fmIP/9+0xJfHsJ2Cj69tqap/BE/lILG49z8CMXCGWl6Bu0Ne/2//19LDa942lalvlMZUKNaOBhA0Xw4578xZQQzvJT0y5+Qx0PFz1b2ZXThFxMoF0LVsh3IDCSALqjPg1QwEX6hC1Wp5DfxAqIp+MyiS/rx+m7FQps7l7j+E6O3Jf1Y8DdPxXy23IAsXunTHIqH6BD/k/lJDGlABaN/Epd5FpuBD5ZIL8gHJd8TkGr6VIoN8J6cc/Gwqf3aoRz+dMRBLNDm62c03s1wshlBe0en2GLQ84mhfyaTOQKZl7e9RWg1ggnVO4D/TJ+q5UV8mstLX0Fjz/E1wW/Uo/EoGb9gu1O5vhWgTzqBGAwAER9C3RKj4SqlIO5sacEpPNfJ38OBstHAIdJlwD/vDXk3wNYPQLwFmHO/6wE9rKwPWilv2DkcRNWy9esng45olr9PhuYbQ+JtQ3Qq4VdTSo6S+FvZ5pXNSC/1+NL2ZdkpuNXDjTI42f9BNPj90ohMRh42UyYqhRuemUJ6GJ3MLMC5ECDlAaFAPG9MnEoN9IFMvCymaxUhQCjniXL0ZeXiTPR8Qqi449nNnL5ik8oCqURDb1l7RQCeM0kRX2jGIKBxP8lJgHk8XdpB1eO32F8ofV49H6+oKWXfVIkpRkCi0sgcP/qpOhn7ye2sfmlBLmKobK8FbB0RATbo037qCazx9dL4L4WtXtrCS/dzcLuN4yvbcy4bmzRMgHQv0hmDOoSEB044pMaYMvsh10I/nUqE4fCRjFazfaWWNwdXF7tu8JGgXbHdwkBgvK3DgowvQFq15WGstWLeFw0DaYn14DEf/zwn1ozNoZRKWm8//Bfb3i0JZYJIPHHN24BX5NxDfjqzdrhjQkGFCxvgaFIgHRTVsd01DR5tj7OX0D7M0CXeLiYrvneiwSQ0h0fzoK4Ku0AhhBfpbTno1kQtNh+7HZQCOA1hRToVUnU2Z/jK2BtpsFVSaLZ1ECsEECPP02kNgQGsj/NXxBUkxDOek+UA2NAjQABdZPkXX/qR68PSrG8BjYM+t+G+XLq+zEqrDGFRSFAcppE0jGBRWAqI6JmE3WQ9Unu8BS/SwewpADZB3p/eNdNqXtbHXOHt3Q9ssHwvJ6X9CYCWah7BDq+AK1YoUO4v7/j5Xpgg+FZB1Os4/cXyRo6RQWqVnCs4fdnr031jBoBJH6u4vfvo+bks5KPL2d9vPXfP/frE2rFkCWmBCVR36djeAQ7Qx4HbXKRi0VVg0s6RBysdLwspKjA6FKCoqrrjZ9+eE97XBUn5IdyXMcMCJ2dmn8gpSDIIUH5dz2F4zlxpobcXpU1AF6p/45mh9yyks0tqMChT6DUfynYnHCqXuCasOiEmLXUxhBNDrnFosWJXdEG/wIPapf/EEwOeew0AbdQcQ08VQb4cFh6OMNfC3XC97lUDInAcNfiB3IFCsSRrOV5BYEKTsg/uV5/MC7cn420O+mH4JAnPlCLv/BcQvQXNFbvVhiQrQFwL9YK3UPKEUa2NOFBYQDv7JF7md1EdrMPIYRlujDaerNSV+5Z0AwYXia4u370SwghzGNPxjL9Snsb7u4vY1B0sFW4N6a8nnK+99YrvDr/leaeZdf3zjXEj1d+a9bt9fsa8HJwmn6+mafCAa8L4fu++uHtlzgvMS1lHagwIORrgBUrZAXkc/EejvP3w/7A72zHL2p9KEhh9SS857ZHt0I2Nr+9cuHjCk73Le0xWo4faM7Fi8SnY8anNaBbIRObn3bFWU8JbfFGoEL8wRT/47a2VSnsn05CzoTwgRUyUvSKqPW9h+fhlz4JYJAzwaYO7PPgOk0KB/d9H8QkiGDXCtFccHmFzMY+umu+QmASX2AvfmVqcYnRw/CNAVnEnS0rpBe9WOV/950BfRJALAoHYZOxtJcqhSP2307CMd/ubVohWf7H/Hffyts3SgJYI/UmdeC91KWqMLqLiiz4VSSTN8j/k6YDI+KeLXNGgKHUCBjPNtNeuhRm9SnIWBSOHu2lfXX+T2qNBNJUEA4zGU376lLY6z0O3TOZ4mCc/4Uit1MIEOX/TG93MPTEmS6FWWOAeL7BzstmgkGb51AocisMgE3uDAr5jZX/dSmMGgN+fSuReDJ3zUsw61ZQYUA2KNIL+U3Bvy+FtUeR445Mgc3zX81suCIBpJDEOvkrkcLajLDu8YE41ML/U0kf9CUCxE04LDr565DCYh2VxC/FEcEWKCqxKEVujs8E2HIeevD1SOHiPvgL7H4Dig9Si9xdeCZADzoqk8JlBkQQVMN/vchL4YkAE+ioTAorDOgq4n8ijRsLFBgAevW3Vil8XP21rwOVMAsMAL32V6UUVh74a4v/uRkG/U3LOqWwMCPqN32sTz0LKjduz6MOQc/7ViqFV3RRz/tWy//0/DAC6KhZCstJeFz3qq0kJhiVza8RKSwMsL//6SUxhf8Cp2x+DUhhAS0D1IGT4mtf9vs6ZfNrRQofo9KSmIrWpDA0wf/3+30blMI6Ki6JKfxvUwq/j6q6IxW0I4W7tvgfj940b0wK+w5qRFAHeTtlvGGbUjgw6KjUB0VlvF2DUjg6bJD/vbL5tSeFp5r5T/pkOK9sfo1JYc/N8l/Z/JqSwvHcMP/vyubXkBRmhHpx3B3JoKANHdgAlO5IDQ1JYQUf/rcmhQUf/rcqhVsAxWb5r0hhT9AU3NGzNm1J4cAN8l/J+zYohaOD9tD/DZvfnyUe/3n+I8Ifg//jmx/58Oel8B/N+/Z/cu/hP7z54e2Pdx5STOEEfwzs/2zn3f3PHv7zX9B5ODj80zJs+pPzY/nPZ2Ju0CrEifEn/laBsc0cHLYXv/IN9E3m4Pp43WViTtAY8Ba3aWON5aBlbvuMz/ETNIJrfFxG4awdA7GJ6LNHqfL4Ox8RWgCG3ZNU960d4xKnlkpwgTIrSHhrxw/E7DaK6KD5a2PklhLQoXsUJZfYkB9Y8iepxAr5NmryMq81PMSvU14eqBf37QsI9O2emkeoFnilx0Ocp7AdgxhaqUjy7WF9fP9gADexAK4xzY8dcKAHA06///KAwSc7ZQ/E/nEO+tpvIsmUJd52QL/NXcKv+MOp+txHSml57IH/iBgaVkZ4qt/6+G0HjCgMWAi4bvLnfn/Y9sARoM+e5lu4kfhlB2S4xM0O9tRKE27ETQUC3pMwAIdm4pcdcPZJMEETkNKnJMBvMQn+qTrvG1OcSF7rcPtGvFC/9cOrT2m5kGTAut3LJUvlhz/N35+gpWz06Ii01H74c5CDLit94sP29YFrJn9MgnMW/yC2r3p0Pr90MmzZzlCr7dMf645Z/Czjh6ov+n67f71I6fMuJ38D5J8uX0d+v/I+rDtggMohNic697Xgs9LnIJaoWuD2sJ4YgCmLP3z54KpB4FehIwWvTqzQ15dT+eE/SLCS650yK3iv/hoe+Yji+0T2sjBhAqxXAIjyjbj6PiHAmFnhE9du/f4N8+H7vPwP6YJ1VP3hL/HTVgeQ+CO1cfh3m+85i+hZrdDYgvL14vtWLzjRGn/1RV8vJn/1PYPPHtzoK099bQl+3l++li9gEPdfd+pLCL8kwfbizFz34S+hFudwTQSC6lNfJymBtTSD4ZYEAfP4fWil4yskgcvvX8dx/Yula2XulNuXAF1sYgOA8fvYPfF9dK99A5D4w2nO4xcrTN5zI1f9PIv4391+7MOI9ccfHK6kn9+4/VkhJYaFt6CPbz8i16J888O9EP8vRS8PUAl4waf+t+Xw9ieHiJUo3/Acv89aoEnRyxGrSX255/dIhk0HRYdKwuxWS9F3F3+/i39hvVTsqkl9RVL6/4DTiHrCrKsj7RUH0OLHF59yWE3qy3dPfkiWd/fiU1xH3nfCkh90x58yD17KGR6pg+gJsypsYU5jhAx3PX4RhvHfT3FXw0VXh/IFvDf6xT0WAF7R8JAT9+hz9f4p/tAdTQbqvOXZGLj7nS9xeIpx1oLbbMIlJmdV+fot/q9N/Vv8+gEvNgFvpnXgJQ6yBZwK8/5C8nx0TYa9yEeTh/9Z6n1TfJr3h8W0FxLhI/5oeEjc+ovLiJv5WfTwAOVvQGSyIJ6sKt8t/jcFbf81lvUs8RuWwXSXXzyvf+BhxiSk9HVNhvRP2VK+nBf7jz8ldyS6/FNosugr7L2r87aVT8k1GfmUtS+A/I6582O0Q3c7/pQwYFTkowWcQj5imzJPc+GDTwmmVT4tIiYMYc74fpL4py9ZwMfk37eLiZiwBIyZ9esyT8OKpxHJkGOQazIiJuyAokg39om3+C9Rv+zRxfV37/u7XBTL5WNAm/Nt8RrD5mlo1j2NNMdF11+CXJRaFPloJf5/A172I45id5j56cQ5B7ONUlLs4vBlfk+Zp5mV/f9pKNgAbPCRenfakh8hyineHwpaKYlmi4GA7clgvjjHWzhLklPcK88OKdURvy4Bb+uxIuwdpBTE/GdKwB/L4HwgbFwvRnr5lC31u9AWsZSzOP+DQKmOyP8Om3x0aGa8LaxVXr9nLms05svk5wt9i19uxpJ8ythN3yC716OcNWq1LR5nP55R/pVI24youB4GExrq94Z11+e0tfmwJ4B7isML4TtRPhAXZukXcnEwlfoSeDH/538NzgyAMXnWPxSuu6oBytGB0bMp6w8Sv/R90vzvH9Gh1iMu2lAG4kohBE3NxpYk1ipc+REOh6+Oz4KTpSVtWDBrlOu3wUhkavOLad3HNvN/jXrH55QyxO4R/1XCN1f09bxecxw3KS/aRp2MKBDbs2QjE60giFeTfYwkfhl1qc+EFwTxTp1fTYAZIEmT5+bn/N78zqT//hucVAAvsnnYwJbp+ueh5kni1zUsbbnyPmTxC5ylAZ9LbmM7Ocn5oJx1F4tLd8n8+DwZbsb5cN7kS1u677TJYD38WTKHYnsFg62WxyGzsZeNv/5lEgtlLE6W+SFTv79k8ANmQz6zfm+vkR+3Y4PyE5SAraW9HotXbOwqhxhkL3CofAGn/DqEX/8w2kp99WvRY0tjMWT85fJVT1688D/sOgdZrPDZ3E3fEcXGbk99fDl75b7DWVa9yxPBYbOCZGrMwcIy2DKsNlCGvKPiF3mVABFWeKmdREuN4FK+9ZSVAPOcL7LyqSDdkmOuiMJXGjywpc1PjrgxzwPozucqtT2UnXJHAHCewAzu+zy9S3uMimbK58B5UdKbifDO1kXvEXclcJi6+yvlG5LEL1bn4QjAGih71pe7VQpHpiDfjP61RQLOloBkfkwhT10PUv8BD8BBL9/KtoEwbicF4GIsfKV5fZPCTu9kRMkMSMmUHhVwNvqmLV5jOq2LG9IZAHsEBYMk/8XxTMyXYC3zozWvbxVd4sMJIbzSJ1z4tJ4lRvnPIT2sIKSIr56D4rTFP37PgxlE3ugRsnn3BZDb7YHJ56lCo6PxwiP6dP7iP5QzGBzWfDBmme/F/O+fp65G3Iq+xQUg3T6DeMUBurgvhhge+BN4lXLgFL8o9n5JaZLh8LP92VicZ3ul6KtVfRda9f64HhVdSAJPhvkfnZwJUd0nRfGNKXknR2UfzN8BH/eZ6+GstkmL4ospDXHd9Ogek1yFsQiSSrZc9iJVLQoD+pQiSfwAXe8ujGAXIoVfYsgz/D6lsd9kL/LF9WSc/x28GX+6/ssZHlTRY9cKvoTPTvoxpQBeoU1l/BcsW5p8wpiSsxu/fo/7JfjRJDz0KSWULJB5DBLIYfzrybeElDxYjl8J7o3LUotL6UsD93Cv5EkUeePmHbXopQUmAsxS9K0AXkzgYdZ4cFuZgGIlM+F5LQe+Fb8wgIFiPVOB6R0PtzoflyRp5ORT1uFVD1+In4Lsl4xQDbq3s8Y3EcQIyLXwH99Xiw5oEfnXGsT59dI/2Wj8uMiR0RrE+XRRJEOb8cM4QJPgrXY8c8vxtwtxfk3HP0G7wCgjENoExRQYWoaTJ1EaxeCgbaCBw98KPvjggw8++OCDDz744IMPPvjggw8++OCDDz744IMP8NZD22APDeMaU9sEIN9w+4k81dAu8CpjdxqAPoqpVcgYcmyY/A01oOlz+Klh8rdLAJqTgNokv+AXtAH9AT5ul/zN3kAKSdDiDaQh5QjQHkLK0TfH/+YJsKQcAzSGLuWIrd6/EbRnhCntAO1hVAZWt4KYchBA2yqoPSMcWifAqXECzClHB82hS40ZYTzrGqiNPAjvosSUY2kh7xsIHnAt2WCpe11VFRQaKPru3W7fFAGk7hVIUUGxhaJvyq/dc8rhWql7hbOigmonvyB0xUSAa6bulW5YVEFYPfkFcg4244Kk7iUIVFJBVD/5BQs9H4FTE0VfwbWggromyJ+fg0vK4Nso+u6kUFe/ERbyP+EmR2DlBOh8KiMwANXvgygkBYFgbMEGu6ThCqAQoI0vIA6DToAm1sBCoYWGAPLqF9CIDR40CoTQhhHuQ3oDUC/ont7A2PgXQCBodA1MjX8BBND2JvCrmrwHvvsFVGqD+aJUw17DV5P3vcHvfAH/VCR66V1DVJ0P4kVZzMdfQF9R3tfrjlBHqMfxedUS106APurn2dEaiBUVPU6gwMWkwdVU9wov14iCCsgvCPhzNTxWJfTdbxgiqqjo637uCKeqir4RD4hSGQE47RHpYKVURwBfKHf+cA10NdzyEMwHaaHqbDD/JK+BYyqAW4hf/wIWqGsL8D+uEfYtxK9/AaGqez5ihXS4yghA6RuGHzYKhLou++pWSF0Drq7Oj4g/7JQA48D40x900P/9FuNHMI7hXSukSOeptfh73QY3YIV0ArSiA+GkEKBuK6R/Y79ai5/1f7uRJTBX1hAw/0zYk94Q0IgVuldWD6b4o/hJt8GNWKFRJ0AT8etsacQKudoaozHoJZECov5dtWGF+toIAKcfVbiC3hDQhg7UjXAb8S+6DW7DCrFCgKrjJ89ltgwgqNwKXWZlXK4QoNaSiEyL8SUXJLSo3gqxT4kLPig6BKhcB8u0mPMTAaL8o9qtIM35qsC0wVMD8bPf7wpOIX+1VmhrHHTfjPDCFc4AFkw5+XfxO4X8tVqhPuxXhRjhOICgXh0s5M/lTq+Qv04rxD5fFdliGRH+YmB36vsT0/8Yfx8KhdLeBPmJ+77nDv+3JYD3kjta/u79jy5zTCuiP9PvlkTO7Iu7Av/l5AfkcUmCZeLftkJ0jcVdYQ789wZ/9YXZZr8Vf1SawJHgbwaPsTje7n0rpEKsEMPfChqLMVz/h/iNlX56rww3+6kVUhDQ5DyLGX9aElEQjI40iacfWyEFZ1OzTTcs+LMX0RSMaGm87c9/OE4HCKe/fbK/hun34zeS98Vbeonu51ZIYCHve/tPhvl4e+QXdP/JMB9KOkRN/42gJf0ni5eiNfILzjH9J4t3NLn/0QH737etzhj5Bdf0GhP9XlXMRt2Lwu+TX4/fUtH3+t+Jl0H/Co3+/hPmQomPjJQJ8uu//9Hi5fk3rJAnU3VMnfyXeJzI8HbIL7i8vf+RT8m9a4WsFH3vzzFPzo3LM/mXlN6I3xL5NeXqJ+fmIP/9+0xJfHsJ2Cj69tqap/BE/lILG49z8CMXCGWl6Bu0Ne/2//19LDa942lalvlMZUKNaOBhA0Xw4578xZQQzvsXoSR+Qx0PFz1b2ZXThFxMoF0LVsh3IDCSALqjPg1QwEX6hC1WZ4L8ygqIp+MyiS/rx+m7FQps7l7j+E6O3Jf1Y8DdPxXy23IAsXunTHIqH6BD/k/lJDGlABaN/Epd5FpuBD4J+S0gHJd8TkGr6VIoN8J6cc/Gwqf3aoRz+dMRBLNDm62c03s1wshlBe0en2GLQ84mjfyKTOQKZl7e9RWg1ggnVO4D/TJ+q5U18istLX0Fjz9EreCnP4E5qFm/YLuTOb5VII86ARgMAFHfAp3aI6Eo5WBu7CkB6fzXyZ+DwfIRwGHSJcA/bw359wBWjwC8RZjzP2uBvSpsD1rpLxh53ITV8jWrp0OOqFa/zwZm20NibQP0emFXkYrOUvjbmeZVDcjv9fhS9iWZ6fiVAw3y+Fk/wfT4vVJIDAZeNhOmKoWbXlsCqtgdzKwAOdAgpUEhQHyvTBzKjXSBDLxsJitVIcCoZ8ly9OVl4kx0vILo+OOZjVy+4hOKQmlEQ29ZO4UAXjNJUd8ohmAg8X+JSQB5/F3awZXjdxhfaD0evZ8vaOllnxRJaYbA4hII3L86KfrZ+4ltbH4pQa5iqCxvBSwdEcH2aNM+qsns8fUSuK9F7d5gwktxs7D7DeNrGzOuG1u0TAD0L5IZg7oERAeO+KQG2DL7YReCf53KxKGwUYxWs70lFncHl1f7rrBRoN3xXUKAoPytgwIMb4D6daWhbPUiHhdNg+nJNSDxHz/8p9aMjWFUShrvP/zXGx5tiWUCSPzxjVvA12RcA756tHh4Y4IBBctbYCgSIN2U1TEdNU2erY/zF9D+DNAlHi6ma773IgGkdMeHsyCuSjuAIcRXKe35aBYELbYfux0UAnhNIQV6VRJ19uf4ClibaXBVkmg2NRArBNDjTxOpDYGB7E/zFwTVJISz3hPlwBhQI0BA3SR515/60WuDUmyvgQ2D/rdhvpz6fowKa0xhUQiQnC6RNExgEZjKiKjbRA1kfZI7PMXv0gEsKUD2gd4f3nXT694mx9zhLV2PbDA8r+clvYlAFuoegY4vQCtW6BDu7+94uR7YYHjWwRTr+P1FsoZOVYGKFRxr+P3Za1M9o0YAiZ+r+P37qDj5vOTjy1kfb/33z/36hFoxZIkpQUnU9+kYHsHOkMdBm1zkYlHV4JIOEQcrHS8LKSowupSgqOp646cf3tMeV8UJ+aEc1zEDQmen5h9IKQhySFD+XU/heE6cqSG3V2UNgFfqv6PZIbesZHMLKnDoEyj1XwomJ5zqF7gmLDohZi21MUSTQ26xaHFiV7TBv8CD2uU/BJNDHjtNwC1UXANPlQE+HJYezvDXQp3wfS4VQyIw3LX4gVyBAnEka3leQaCCE/JPrtcfjAv3ZyPtTvohOOSJDyzErz2XEP0FbdW7FQbkawDci7VC95ByhJEtTXhQGMA7e+ReZjeR3exDCGGZLozW3qxUlHseNAOGlwnurh/9EkII89iTsUy/0t6Gu/vLGBQdbBXujSmvp5zvvfUKr85/pbln2fW9cw3x45XfmnV7/b4GvBycpp9v5qlwwOtC+L6vfnj7Jc5LTEtZByoMCPkaYMUKWQH5XLyH4/z9sD/wO9vxi1ofClJYPQnvue1RrJCZzW+vXPi4gtN9S3uMluMHmnPxIvHpmPFpDShWyMjmp15x1lNCW7wRqBB/MMX/uK1tVQr7p5OQMyF8YIWMFL0ian3v4Xn4pU8CGORMsKkD+zy4TpPCwX3fBzEJIti1QjQXXF4hs7GP7pqvEJjEFxiLX59aXGL0MHxjQBZxZ84KKUUvVvnffWdAnwQQi8JB2GQs7aVK4Yj9t5NwzLZ7o1ZIlv8x/9238vaNkgDWSL1JHXgvdakqjO6iIgt+FcnkDfL/pOnAiLhny5wRYCg1AsazzbSXLoVZfQoyFoWjR3tpX53/k1ojgTQVhMNMRtO+uhT2eo9D90ymOBjnf6HI7RQCRPk/09odTD1xpkth1hggnm+w87KZYNDmORSK3AoDYJM7g0J+Y+V/XQqjxoBf30oknsxd8xLMuhVUGJANivRCflPw70th7VHkuCNTYPP8VzMbrkgAKSSxQv56pLA2I6x7fCAOtfD/VNIHfYkAcRMOi0L+aqSwWEcl8UtxRLAFikosSpGb4zMBtpyHEnxVUri4D/4C5Ruw7IOUIncXngnQg4L6pHCZAREENfFfKfJSeCLABDoqk8IKA7qK+J9I48YCBQaAXv2tVQofV3/t60AlzAIDQK/9VSuF9Qf+GuF/boZBf9OyTikszIjaTR/7U8+Cyo3b86hD0PO+lUrhFV1U8r418z89P4wAOqqVwnISHte9KiyJCUZl82tECgsD7O9/eklM4b/AKZtfA1JYQMsAdeCk+NqX/b5O2fxakcIHqLckpqI1KQxN8P/9ft/mpLCOqktiCv/blMLvo6ruSAXtSOGuLf7HozfNG5PCvoMaEdRB3k4Zb9imFA4MCur1QVEZb9egFI4OG+R/r2x+7UnhqWb+kz4ZziubX2NS2HOz/Fc2v6akcDw3zP+7svk1JIUZoWocdEcyKGhABzYAvTtSQ0NSWMGH/61J4Q//Bc1J4YZAsU3+61LYEzQFd/SsTVtSOHCD/Ffyvg1K4eigPfTK5tcQuG3++9Y2P+Ur8Nwy/6ODhkExhRM0i7tsfu1icNgy/2eGD+zDMhAaByI0DPIB2kbfsgbDmxSiWwV7aURoErNy/aSxXNwErYKU6yetpeP5E3/bW4BvL+724le+gb7JQmwfr7ty3Kk99Ru7PBcdsDXlm2Z8jp+gBci77UNejnINpQSu2cukefydb8QPYNi9S3rfenIvcWqpDytQZgUJb+34gZhdSRYdNH9tjNxSF0LoHp1pS2zIDyz5u6RihXwbjZkytD88xK/Tn5+qFPftCwj0bViBR6gWeKXHa+ynsB2DGFppS+Pbw/r4/sEAbmIBXGOaHzvgQA8GnH7/+SmD77bLHoj94xz0tV9Hl1GbvO2Afhu+iV/xh1P1uY+U0vLYA/8RMTSsjPBUv/Xx2w4YURiwEHDd5M/9/rDtgSNAn73PvHAj8csOyHCJmx3sqZX204ibCgS8J2EADs3ELzvg7JNgaqv0KQnwW0yCf6rO+8YUJ5In29z+Nkao3/rh1ae0XEgyYN3u+bql8sOfZtnlJH7K5s+PSEvthz8HOeiy0ic+bF8fuGbyxyQ4Z/EP1ds+Qefzm8fDlu0MVds+QR/SAzGLn2UGZQstjxscwCKlz7uc/A2Qf7p8Hfn9yvuw7oABKofYnOjc14LPSp+DWKJqgdvrymIApiz+8OWDqwaBX4WOFLw6sUJfX07lh/8gwUqud8qs4L3668jkI4rvE9nLwoQJsF4BIMo3ovi+lQBjZoVPXLv1+zfMh+/z8j+kC9ZR9Ye/xE9bHUDij9TG4d9tvucsome1QmMLyteL71u94ERr/NUXfb2Y/NX3DD57da2vPPW1Jfh5P4FHvoChbvcvqS8h/JI2yLODc92Hv4RaHMY6EQiqT32dpATW0iCuWxIEzOP3oZWOr5AELh/CE8f1L5auleGjbl8CdLGJDQDG77OXxffRvfYNQOIPpzmPX6wwec+NXPXzLOJ/d/uxDyPWH39wuJJ+fuP2Z4WUGBbegj6+/Yhci/LND/dC/L8UvTxAJeAFn/rflsPbnxwiVqJ8w3P8PmuBJkUvR6wm9eWeH6UbNh0UHSoJs1stRd9d/P0u/oX1UrGrJvUVSen/A04j6gmzro60VxxAix9ffMphNakv3z35IVne3YtPcR153wlLftAdf8o8eClneKQOoifMqrCFOY0RMtz1+EUYxn8/xV0NF10dyhfw3ugX91gAeEXDQ07co8/V+6f4Q3c0Gajzlmdj4O53vsThKcZZC26zCZeYnFXl67f4vzb1b/HrB7zYBLyZ1oGXOMgWcCrM+wvJ89E1GfYiH00e/mep903xad4fFtNeSISP+KMoJbsTHmXEzfwseniA8jcgMlkQT1aV7xb/m4K2/5rNf5b4Dctgussvntc/8DBjElL6uiZD+qdsKV/Oi/3Hn5I7El3+KTRZ9BX23oXK9Oan5JqMfMraF0B+x9z5Mdqhux1/ShgwavLRAE4hf2eFMk9z4YNPCaZVPi0iJgxhzvh+kvinL1nAx+Tft4uJmLAEjJn16zJPw+JpFMmQY5BrMvbGRVMU6cY+8Rb/JeqXPbq4/u59f5eLYrl8DGhzvi1eY9g8Dc26p5HmuOj6S5CLUosmH43E/2/Ay37EUewOMz+dOOdgtlFKil0cvszvKfM0s7L/Pw0FG3L56DuwAXfakh8hyineHwpaKYlmi4GA7clgvjjHWzhLklPcK29PKtURvy4Bb+vFSuwdpBTE/GdKwB/L4HwgbFwvRnr5lC31u9AWsZSzOP+DQKmOyP8Om3x0aGa8LaxVXr9nLms05svk5wt9i19uxpJ8ythN3yC716OcNWq1LR5nP55R/pVI24youB4GExrq94Z11+e0tfmwJ4B7isML4TtRPhAXZukXcnEwlfoSeDH/538NzgyAMXnWPxSuu6oBytGB0bMp6w8Sv/R90vzvH9Gh1iMu2lAG4kohBE3NxpYk1ipc+REOh6+Oz4KTpSVtWDBrlOu3wUhkavOLad3HNvN/jXrH55QyxO4R/1XCN1f09bxecxw3KS/aRp2MKBDbs+QjE40giFeTfYwkfhl1qc+EFwTxTp1fTYAZIEmT5+bn/N78zqT//hucVAAvsnnYwJbp+ueh5kni1zUsbbnyPmTxC5ylAZ9LbmM7Ocn5oJx1F4tLd8n8+DwZbsb5cN7kS1u677TJYD38WTKHYnsFg62WxyGzsZeNv/5lEgtlLE6W+SFTv79k8ANmQz6zfm+vkR+3Y4PyE5SAraW9HotXbOwqhxhkL3CofAGn/DqEX/8w2kp99WvRY0tjMWT85fJVT1688D/sOgdZrPDZ3E3fEcXGbk99fDl75b7DWVa9yxPBYbOCZGrMwcIy2DKsNlCGvKPiF3mVABFWeKmdREuN4FK+9ZSVAPOcL7LyqSDdkmOuiMJXGjywpc1PjrgxzwPozucqtT2UnXJHAHCewAzu+zy9S3uMimbK58B5UdKbifDO1kXvEXclcJi6+yvlG5LEL1bn4QjAGih71pe7VQpHpiDfjP61RQLOl4BkfiwhT10PUv8BD8BBL9/KtoEwbicF4GIpfL15fZPCTu9kRMkMSMmUHhVwNvqmLV5jOq2LG9IZAHsEBYMk/8XxTMyXYCvzozevbxVd4sMJIbzSJ1z4tJ4lRvnPIT2sIKSIr56D4rTFP37PgxlE3ugRsnn3BZDb7YHJ56lCo6PxwiP6dP7iP5QzGBzWfDBmme/F/O+fp65G3Iq+xQUg3T6DeMUBurgrhlge+BN4lXLgFL8o9n5JaZLh8LP92VicZ3ul6KtVfRda9f64HhVdSAJPhvkfnZwJUd0nRfGNKXknR2UfzN8BH/eZ6+GstkmL4ospDXHd9Ogek1yFsQiSSrZc9iJVLQoD+pQiSfwAXe8ujGAXIoVfYsgz/D6lsd9kL/LF9WSc/x28GX+6/ssZHlTRY9cKvoTPTvoxpQBeoU1l/BcsW5p8wpiSMx2/co/7JfjRJDz0KSWULJB5DIeBSPzrybeElDyYjV8P7o3LUotL6UsD93Cv5EkUeePmHbXopQUmAsxS9K0AXkzgYdZ4cFuZgGIlM+F5LQe+Fb8wgIFiPVOB6R0PtzoflyRp5ORT1uFVD1+In4Lsl4xQDbq3s8Y3EcQIyLXwH99Xiw5oEfnXGsT59dI/2Wj8uMiR0RrE+XRRJEOb8cM4QJPgrXY8c8vxNwtxfm3HP0G7wCgjENoExRQYWoaTJ1EaxeCgbaC5w/+DDz744IMPPvjggw8++OCDDz744IMPDABvPbQN9tAwrjG1TQDyDdceZU53u8CrzFxoAPocjlYhM2ixXfK31H2gD2GmhsnfLgFoTgJqk/yCX9AMlNeXuF3yN9t+HpKgxfbzIeUI0B5CytE3x//mCbCkHAM0hi7liK02XwvaM8KUdoD2MCrTSltBTDkIoG0V1J4RDq0T4NQ4AeaUo4Pm0KXGjDCeFQ3UTB6Ed1FiyrG0kPcNBA+4lmyw1L2uqgoKLRR9d263b4oAUvcKpKig2ELRN+V3LjnlcK3UvcJZUUG1k18QumIiwDVT90o3LKogrJ78AjkHm3FBUvcSBCqpIKqf/IKFno/AqYmir+BaUEFdE+TPz8ElZfBtFH13Uqir3wgL+Z9wkyOwcgJ0PpURGID+qA/6P9HpZtdg1QgHAAAAAElFTkSuQmCC";
  }
});

// engine/sdk/operations/license-watermark-operation/watermark.frag
var watermark_default;
var init_watermark2 = __esm({
  "engine/sdk/operations/license-watermark-operation/watermark.frag"() {
    watermark_default = "uniform sampler2D u_image;\nuniform sampler2D u_watermarkTex;\n\nvarying vec2 v_texCoord;\n\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  vec4 watermarkColor = texture2D(u_watermarkTex, v_texCoord);\n\n  if (watermarkColor.r > 0.8) {\n    gl_FragColor = mix(color, watermarkColor, 0.3);\n  } else {\n    gl_FragColor = color;\n  }\n}\n";
  }
});

// engine/sdk/operations/license-watermark-operation/watermark-filter.js
var WatermarkFilter;
var init_watermark_filter = __esm({
  "engine/sdk/operations/license-watermark-operation/watermark-filter.js"() {
    init_core();
    init_watermark2();
    WatermarkFilter = class extends engine_default.Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = watermark_default;
      }
      _applyWebGL(renderer, inputTarget, outputTarget, clear = false) {
        const gl = renderer.getContext();
        const { canvas } = gl;
        const shader = this.getShaderForRenderer(renderer);
        const frame = inputTarget.getFrame();
        const existingCanvas = this._watermarkCanvas;
        if (!existingCanvas || frame.width !== existingCanvas.width || frame.height !== existingCanvas.height) {
          this._createWatermarkCanvas(frame.width, frame.height);
        }
        const texture = engine_default.Texture.fromCanvas(this._watermarkCanvas);
        const baseTexture = texture.getBaseTexture();
        renderer.updateTexture(baseTexture);
        baseTexture.setGLUnit(1);
        renderer.setRenderTarget(outputTarget);
        if (clear) {
          outputTarget.clear();
        }
        renderer.setShader(shader);
        const projectionMatrix = renderer.getCurrentRenderTarget().getProjectionMatrix().toArray();
        shader.setUniform("u_projMatrix", projectionMatrix);
        shader.syncUniforms();
        gl.uniform1i(gl.getUniformLocation(shader.getProgram(), "u_watermarkTex"), 1);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, inputTarget.getTexture());
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, baseTexture.getGLTextureForRenderer(renderer));
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        texture.dispose();
      }
      _createWatermarkCanvas(width, height) {
        const image = this._options.watermarkImage;
        const watermarkCanvas = utils_default.createCanvas();
        watermarkCanvas.width = width;
        watermarkCanvas.height = height;
        const watermarkContext = watermarkCanvas.getContext("2d");
        const wattermarkPattern = watermarkContext.createPattern(image, "repeat");
        watermarkContext.fillStyle = wattermarkPattern;
        watermarkContext.fillRect(0, 0, watermarkCanvas.width, watermarkCanvas.height);
        this._watermarkCanvas = watermarkCanvas;
        this._watermarkContext = watermarkContext;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const canvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const image = this._options.watermarkImage;
        this._createWatermarkCanvas(canvas.width, canvas.height);
        const imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
        const waterMarkImageData = this._watermarkContext.getImageData(0, 0, canvas.width, canvas.height);
        const inputColor = new color_default();
        const overlayColor = new color_default();
        const outputColor = new color_default();
        for (let i = 0; i < canvas.width * canvas.height * 4; i += 4) {
          inputColor.set(imageData.data[i] / 255, imageData.data[i + 1] / 255, imageData.data[i + 2] / 255, imageData.data[i + 3] / 255);
          overlayColor.set(waterMarkImageData.data[i] / 255, waterMarkImageData.data[i + 1] / 255, waterMarkImageData.data[i + 2] / 255, waterMarkImageData.data[i + 3] / 255);
          if (overlayColor.r > 0.8) {
            outputColor.copy(inputColor.clone().mix(overlayColor, 0.3));
          } else {
            outputColor.copy(inputColor);
          }
          imageData.data[i] = outputColor.r * 255;
          imageData.data[i + 1] = outputColor.g * 255;
          imageData.data[i + 2] = outputColor.b * 255;
          imageData.data[i + 3] = outputColor.a * 255;
        }
        outputContext.putImageData(imageData, 0, 0);
      }
    };
    WatermarkFilter.prototype.availableOptions = {
      watermarkImage: { type: "object" /* OBJECT */, required: true }
    };
  }
});

// engine/sdk/operations/license-watermark-operation/index.js
var LicenseWatermarkOperation, license_watermark_operation_default;
var init_license_watermark_operation = __esm({
  "engine/sdk/operations/license-watermark-operation/index.js"() {
    init_core();
    init_watermark();
    init_watermark_filter();
    LicenseWatermarkOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        __publicField(this, "_applyWatermarkFilter", () => {
          if (!this._watermarkFilter) {
            this._watermarkFilter = new WatermarkFilter({
              watermarkImage: this._watermarkImage
            });
          }
          this._sprite.setFilters([this._watermarkFilter]);
          this._renderTexture.render(this._container);
          return Promise.resolve();
        });
        __publicField(this, "_loadWatermarkImage", () => {
          if (!this._watermarkImage) {
            return new Promise((resolve, reject) => {
              this._watermarkImage = new image_default();
              this._watermarkImage.onload = resolve;
              this._watermarkImage.src = watermark;
            });
          }
          return Promise.resolve();
        });
        this._watermarkFilter = null;
        this._watermarkImage = null;
      }
      _render(sdk) {
        return this._loadWatermarkImage().then(this._applyWatermarkFilter);
      }
      dispose() {
        if (this._watermarkFilter) {
          this._watermarkFilter.dispose();
        }
        super.dispose();
      }
    };
    LicenseWatermarkOperation.identifier = "license-watermark";
    LicenseWatermarkOperation.prototype.availableOptions = {};
    exports_default.Operations.LicenseWatermarkOperation = LicenseWatermarkOperation;
    license_watermark_operation_default = LicenseWatermarkOperation;
  }
});

// engine/sdk/operations/linear-focus-operation/linear-focus.frag
var linear_focus_default;
var init_linear_focus = __esm({
  "engine/sdk/operations/linear-focus-operation/linear-focus.frag"() {
    linear_focus_default = "/*!\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform vec2 u_controlPoint1;\nuniform vec2 u_controlPoint2;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    vec2 vector = u_controlPoint2 - u_controlPoint1;\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    float radius = smoothstep(0.0, 1.0,\n      abs(\n        clamp(dot(v_texCoord - u_controlPoint1, vector) / dot(vector, vector), 0.0, 1.0)\n      )\n    ) * u_blurRadius;\n\n    for (float t = -30.0; t <= 30.0; t++) {\n      float percent = (t + offset - 0.5) / 30.0;\n      float weight = 1.0 - abs(percent);\n      vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n      color += _sample * weight;\n      total += weight;\n    }\n\n    gl_FragColor = color / total;\n}\n";
  }
});

// engine/sdk/operations/linear-focus-operation/linear-focus-filter.js
var Vector211, LinearFocusFilter, linear_focus_filter_default;
var init_linear_focus_filter = __esm({
  "engine/sdk/operations/linear-focus-operation/linear-focus-filter.js"() {
    init_core();
    init_blur_filter();
    init_linear_focus();
    ({ Vector2: Vector211 } = math_exports);
    LinearFocusFilter = class extends engine_default.Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = linear_focus_default;
        this._lastBlurRadius = null;
        this._lastControlPoint1 = new Vector211();
        this._lastControlPoint2 = new Vector211();
        this._blurFilter = new blur_filter_default();
        this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
        this._maskRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        if (this._options.blurQuality === "low") {
          this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
          return;
        }
        const inputDimensions = inputTarget.getDimensions();
        const dimensionsChanged = !outputTarget.getDimensions().equals(inputDimensions);
        const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
        if (shouldUpdateBlur) {
          const delta = new Vector211(this._options.delta.x, this._options.delta.y);
          this._blurFilter.setDelta(delta);
          const options = {
            blurRadius: this._options.blurRadius,
            texSize: inputDimensions
          };
          const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
          const smoothstep = (e0, e1, x) => {
            const t = clamp((x - e0) / (e1 - e0), 0, 1);
            return t * t * (3 - 2 * t);
          };
          const controlVec = this._options.controlPoint2.clone().subtract(this._options.controlPoint1.clone());
          const { blurRadius } = this._options;
          const radius = (x, y) => {
            return smoothstep(0, 1, Math.abs(clamp(new Vector211(x, y).subtract(this._options.controlPoint1).dot(controlVec) / controlVec.dot(controlVec), 0, 1))) * blurRadius;
          };
          this._blurFilter.set(options);
          this._blurFilter._applyCanvas(renderer, inputTarget, outputTarget, clear, radius);
          this._lastBlurRadius = this._options.blurRadius;
        }
      }
      _renderLQBlur(renderer, inputTarget, outputTarget, clear = false) {
        const inputDimensions = inputTarget.getDimensions();
        const dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
        this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
        this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
        this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
        this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
        const shouldUpdateMask = !this._lastControlPoint1.equals(this._options.controlPoint1) || !this._lastControlPoint2.equals(this._options.controlPoint2) || dimensionsChanged;
        const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
        if (shouldUpdateMask) {
          this._renderMask();
          this._lastControlPoint1 = this._options.controlPoint1.clone();
          this._lastControlPoint2 = this._options.controlPoint2.clone();
        }
        if (shouldUpdateBlur) {
          this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
          this._lastBlurRadius = this._options.blurRadius;
        }
        this._applyMask(inputTarget, outputTarget);
      }
      _renderMask() {
        const canvas = this._maskRenderTarget.getCanvas();
        const context = this._maskRenderTarget.getContext();
        const canvasDimensions = new Vector211(canvas.width, canvas.height);
        const controlPoint1 = this._options.controlPoint1.clone().multiply(canvasDimensions);
        const controlPoint2 = this._options.controlPoint2.clone().multiply(canvasDimensions);
        const gradient = context.createLinearGradient(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y);
        gradient.addColorStop(0, "#FFFFFF");
        gradient.addColorStop(1, "#000000");
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);
      }
      _applyMask(inputTarget, outputTarget) {
        const outputContext = outputTarget.getContext();
        const inputCanvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const blurredContext = this._blurredRenderTarget.getContext();
        const maskContext = this._maskRenderTarget.getContext();
        const inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
        const pixels = inputImageData.data;
        const blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        let alpha;
        for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
          alpha = maskPixels[i] / 255;
          pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
          pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
          pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
        }
        outputContext.putImageData(inputImageData, 0, 0);
      }
      dispose() {
        super.dispose();
        this._blurFilter.dispose();
        this._blurredRenderTarget.dispose();
        this._maskRenderTarget.dispose();
      }
    };
    LinearFocusFilter.prototype.availableOptions = {
      blurRadius: {
        type: "number" /* NUMBER */,
        default: 30,
        uniformType: "f" /* FLOAT */
      },
      controlPoint1: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector211(0, 0.5),
        uniformType: "2f" /* FLOAT2 */
      },
      controlPoint2: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector211(1, 0.5),
        uniformType: "2f" /* FLOAT2 */
      },
      delta: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector211(1, 1),
        uniformType: "2f" /* FLOAT2 */
      },
      texSize: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector211(100, 100),
        uniformType: "2f" /* FLOAT2 */
      }
    };
    linear_focus_filter_default = LinearFocusFilter;
  }
});

// engine/sdk/operations/linear-focus-operation/index.js
var Vector212, LinearFocusOperation, linear_focus_operation_default;
var init_linear_focus_operation = __esm({
  "engine/sdk/operations/linear-focus-operation/index.js"() {
    init_core();
    init_linear_focus_filter();
    ({ Vector2: Vector212 } = math_exports);
    LinearFocusOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._lastBlurRadius = this._options.blurRadius;
        this._lastControlPoint1 = this._options.controlPoint1.clone();
        this._lastControlPoint2 = this._options.controlPoint2.clone();
        const blurOption = {
          blurQuality: {
            type: "string" /* STRING */
          }
        };
        this._horizontalFilter = new linear_focus_filter_default({}, blurOption);
        this._verticalFilter = new linear_focus_filter_default({}, blurOption);
        this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
        this._horizontalFilter.setDelta(new Vector212(0.5, 0.5));
        this._verticalFilter.setDelta(new Vector212(-0.5, 0.5));
        this._filter = new linear_focus_filter_default({}, blurOption);
      }
      rotate(degrees) {
        const { controlPoint1 } = this._options;
        const { controlPoint2 } = this._options;
        if (degrees === 90) {
          controlPoint1.flip();
          controlPoint1.x = 1 - controlPoint1.x;
          controlPoint2.flip();
          controlPoint2.x = 1 - controlPoint2.x;
        } else if (degrees === -90) {
          controlPoint1.flip();
          controlPoint1.y = 1 - controlPoint1.y;
          controlPoint2.flip();
          controlPoint2.y = 1 - controlPoint2.y;
        }
        this.set({ controlPoint1, controlPoint2 });
      }
      flip(direction) {
        const { controlPoint1 } = this._options;
        const { controlPoint2 } = this._options;
        switch (direction) {
          case "horizontal":
            controlPoint1.x = 1 - controlPoint1.x;
            controlPoint2.x = 1 - controlPoint2.x;
            break;
          case "vertical":
            controlPoint1.y = 1 - controlPoint1.y;
            controlPoint2.y = 1 - controlPoint2.y;
            break;
        }
        this.set({ controlPoint1, controlPoint2 });
      }
      transform(transformChange) {
        const newOptions = {};
        ["controlPoint1", "controlPoint2"].forEach((optionName) => {
          const vector = this.getOption(optionName);
          newOptions[optionName] = transformChange.applyToRelativePoint(vector);
        });
        ["blurRadius"].forEach((optionName) => {
          const size = this.getOption(optionName);
          newOptions[optionName] = transformChange.applyToRelativeSize(size);
        });
        this.set(newOptions, false);
      }
      _renderWebGL(inputTexture) {
        return this._renderBlur(inputTexture);
      }
      _renderCanvas(inputTexture) {
        if (this._options.highQualityCanvasBlur) {
          return this._renderBlur(inputTexture);
        }
        return this._renderLQCanvasBlur(inputTexture);
      }
      _renderBlur(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const shortestSide = inputDimensions.min();
        const { blurRadius, controlPoint1, controlPoint2 } = this._options;
        const commonOptions = {
          blurRadius: blurRadius * shortestSide,
          controlPoint1: controlPoint1.clone(),
          controlPoint2: controlPoint2.clone(),
          texSize: inputDimensions,
          blurQuality: "high"
        };
        this._horizontalFilter.set(commonOptions);
        this._verticalFilter.set(commonOptions);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      _renderLQCanvasBlur(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const { blurRadius, controlPoint1, controlPoint2 } = this._options;
        this._filter.set({
          blurRadius,
          controlPoint1: controlPoint1.clone(),
          controlPoint2: controlPoint2.clone(),
          texSize: inputDimensions,
          blurQuality: "low"
        });
        this._sprite.setFilters([this._filter]);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      dispose() {
        super.dispose();
        this._filter.dispose();
        this._verticalFilter.dispose();
        this._horizontalFilter.dispose();
      }
      hasChanges() {
        return true;
      }
    };
    LinearFocusOperation.identifier = "linear-focus";
    LinearFocusOperation.prototype.availableOptions = {
      controlPoint1: { type: "vector2" /* VECTOR2 */, default: new Vector212(0, 0.5) },
      controlPoint2: { type: "vector2" /* VECTOR2 */, default: new Vector212(1, 0.5) },
      blurRadius: { type: "number" /* NUMBER */, default: 0.025 },
      highQualityCanvasBlur: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.LinearFocusOperation = LinearFocusOperation;
    linear_focus_operation_default = LinearFocusOperation;
  }
});

// engine/sdk/operations/mirrored-focus-operation/mirrored-focus.frag
var mirrored_focus_default;
var init_mirrored_focus = __esm({
  "engine/sdk/operations/mirrored-focus-operation/mirrored-focus.frag"() {
    mirrored_focus_default = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform float u_gradientSize;\nuniform float u_size;\nuniform vec2 u_start;\nuniform vec2 u_end;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    vec2 normal = normalize(vec2(u_start.y - u_end.y, u_end.x - u_start.x));\n    float radius = smoothstep(0.0, 1.0,\n      (abs(\n        dot(v_texCoord * u_texSize - u_start, normal)\n      ) - u_size) / u_gradientSize\n    ) * u_blurRadius;\n\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        color += _sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n}\n";
  }
});

// engine/sdk/operations/mirrored-focus-operation/mirrored-focus-filter.js
var Vector213, MirroredFocusFilter, mirrored_focus_filter_default;
var init_mirrored_focus_filter = __esm({
  "engine/sdk/operations/mirrored-focus-operation/mirrored-focus-filter.js"() {
    init_core();
    init_blur_filter();
    init_mirrored_focus();
    ({ Vector2: Vector213 } = math_exports);
    MirroredFocusFilter = class extends engine_default.Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = mirrored_focus_default;
        this._lastBlurRadius = null;
        this._lastGradientRadius = null;
        this._lastStart = new Vector213();
        this._lastEnd = new Vector213();
        this._blurFilter = new blur_filter_default();
        this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
        this._maskRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        if (this._options.blurQuality === "low") {
          this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
          return;
        }
        const inputDimensions = inputTarget.getDimensions();
        const dimensionsChanged = !outputTarget.getDimensions().equals(inputDimensions);
        const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
        if (shouldUpdateBlur) {
          const delta = new Vector213(this._options.delta.x, this._options.delta.y);
          this._blurFilter.setDelta(delta);
          const options = {
            blurRadius: this._options.blurRadius,
            texSize: inputDimensions
          };
          const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
          const smoothstep = (e0, e1, x) => {
            const t = clamp((x - e0) / (e1 - e0), 0, 1);
            return t * t * (3 - 2 * t);
          };
          const {
            blurRadius,
            gradientSize,
            size,
            start,
            end,
            texSize
          } = this._options;
          const normal = new Vector213(start.y - end.y, end.x - start.x);
          normal.divide(normal.len());
          const radius = (x, y) => {
            return smoothstep(0, 1, (Math.abs(texSize.clone().multiply(x, y).subtract(start).dot(normal)) - size) / gradientSize) * blurRadius;
          };
          this._blurFilter.set(options);
          this._blurFilter._applyCanvas(renderer, inputTarget, outputTarget, clear, radius);
          this._lastBlurRadius = this._options.blurRadius;
        }
      }
      _renderLQBlur(renderer, inputTarget, outputTarget, clear = false) {
        const inputDimensions = inputTarget.getDimensions();
        const dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
        this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
        this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
        this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
        this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
        const shouldUpdateMask = !this._lastStart.equals(this._options.start) || !this._lastEnd.equals(this._options.end) || this._lastGradientRadius !== this._options.size || dimensionsChanged;
        const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
        if (shouldUpdateMask) {
          this._renderMask();
          this._lastStart = this._options.start.clone();
          this._lastEnd = this._options.end.clone();
          this._lastGradientRadius = this._options.size;
        }
        if (shouldUpdateBlur) {
          this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
          this._lastBlurRadius = this._options.blurRadius;
        }
        this._applyMask(inputTarget, outputTarget);
      }
      _renderMask() {
        const canvas = this._maskRenderTarget.getCanvas();
        const context = this._maskRenderTarget.getContext();
        const pixelRatio = this._maskRenderTarget.getPixelRatio();
        const canvasDimensions = new Vector213(canvas.width, canvas.height);
        const size = this._options.size * canvasDimensions.min() * pixelRatio;
        const gradientSize = this._options.gradientSize * canvasDimensions.min() * pixelRatio;
        const start = this._options.start.clone().multiply(canvasDimensions);
        const end = this._options.end.clone().multiply(canvasDimensions);
        const dist = end.clone().subtract(start);
        const middle = start.clone().add(dist.clone().divide(2));
        const totalDist = dist.len();
        const factor = dist.clone().divide(totalDist);
        const gradientStart = middle.clone().add((size + gradientSize) * factor.y, -(size + gradientSize) * factor.x);
        const gradientEnd = middle.clone().add(-(size + gradientSize) * factor.y, (size + gradientSize) * factor.x);
        const gradient = context.createLinearGradient(gradientStart.x, gradientStart.y, gradientEnd.x, gradientEnd.y);
        const fullGradientSize = gradientEnd.clone().subtract(gradientStart).len();
        gradient.addColorStop(0, "#000000");
        gradient.addColorStop(gradientSize / 2 / fullGradientSize, "#FFFFFF");
        gradient.addColorStop(1 - gradientSize / 2 / fullGradientSize, "#FFFFFF");
        gradient.addColorStop(1, "#000000");
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);
      }
      _applyMask(inputTarget, outputTarget) {
        const outputContext = outputTarget.getContext();
        const inputCanvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const blurredContext = this._blurredRenderTarget.getContext();
        const maskContext = this._maskRenderTarget.getContext();
        const inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
        const pixels = inputImageData.data;
        const blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        let alpha;
        for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
          alpha = maskPixels[i] / 255;
          pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
          pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
          pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
        }
        outputContext.putImageData(inputImageData, 0, 0);
      }
      dispose() {
        super.dispose();
        this._blurFilter.dispose();
      }
    };
    MirroredFocusFilter.prototype.availableOptions = {
      blurRadius: {
        type: "number" /* NUMBER */,
        default: 30,
        uniformType: "f" /* FLOAT */
      },
      size: {
        type: "number" /* NUMBER */,
        default: 50,
        uniformType: "f" /* FLOAT */
      },
      gradientSize: {
        type: "number" /* NUMBER */,
        default: 50,
        uniformType: "f" /* FLOAT */
      },
      start: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector213(0, 0.5),
        uniformType: "2f" /* FLOAT2 */
      },
      end: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector213(1, 0.5),
        uniformType: "2f" /* FLOAT2 */
      },
      delta: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector213(1, 1),
        uniformType: "2f" /* FLOAT2 */
      },
      texSize: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector213(100, 100),
        uniformType: "2f" /* FLOAT2 */
      }
    };
    mirrored_focus_filter_default = MirroredFocusFilter;
  }
});

// engine/sdk/operations/mirrored-focus-operation/index.js
var Vector214, MirroredFocusOperation, mirrored_focus_operation_default;
var init_mirrored_focus_operation = __esm({
  "engine/sdk/operations/mirrored-focus-operation/index.js"() {
    init_core();
    init_mirrored_focus_filter();
    ({ Vector2: Vector214 } = math_exports);
    MirroredFocusOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._lastBlurRadius = this._options.blurRadius;
        this._lastSize = this._options.size;
        this._lastGradientSize = this._options.gradientSize;
        const blurOption = {
          blurQuality: {
            type: "string" /* STRING */
          }
        };
        this._horizontalFilter = new mirrored_focus_filter_default({}, blurOption);
        this._verticalFilter = new mirrored_focus_filter_default({}, blurOption);
        this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
        this._horizontalFilter.setDelta(new Vector214(0.5, 0.5));
        this._verticalFilter.setDelta(new Vector214(-0.5, 0.5));
        this._filter = new mirrored_focus_filter_default({}, blurOption);
        this._renderBlur.bind(this);
      }
      rotate(degrees) {
        const { start } = this._options;
        const { end } = this._options;
        if (degrees === 90) {
          start.flip();
          start.x = 1 - start.x;
          end.flip();
          end.x = 1 - end.x;
        } else if (degrees === -90) {
          start.flip();
          start.y = 1 - start.y;
          end.flip();
          end.y = 1 - end.y;
        }
        this.set({ start, end });
      }
      flip(direction) {
        const { start } = this._options;
        const { end } = this._options;
        switch (direction) {
          case "horizontal":
            start.x = 1 - start.x;
            end.x = 1 - end.x;
            break;
          case "vertical":
            start.y = 1 - start.y;
            end.y = 1 - end.y;
            break;
        }
        this.set({ start, end });
      }
      transform(transformChange) {
        const newOptions = {};
        ["start", "end"].forEach((optionName) => {
          const vector = this.getOption(optionName);
          newOptions[optionName] = transformChange.applyToRelativePoint(vector);
        });
        ["blurRadius", "size", "gradientSize"].forEach((optionName) => {
          const size = this.getOption(optionName);
          newOptions[optionName] = transformChange.applyToRelativeSize(size);
        });
        this.set(newOptions, false);
      }
      _renderWebGL(inputTexture) {
        return this._renderBlur(inputTexture);
      }
      _renderCanvas(inputTexture) {
        if (this._options.highQualityCanvasBlur) {
          return this._renderBlur(inputTexture);
        }
        return this._renderLQCanvasBlur(inputTexture);
      }
      _renderBlur(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const shortestSide = inputDimensions.min();
        const start = this._options.start.clone();
        const end = this._options.end.clone();
        const { blurRadius, size, gradientSize } = this._options;
        const commonOptions = {
          blurRadius: blurRadius * shortestSide,
          size: size * shortestSide,
          gradientSize: gradientSize * shortestSide,
          start: start.clone().multiply(inputDimensions),
          end: end.clone().multiply(inputDimensions),
          texSize: inputDimensions,
          blurQuality: "high"
        };
        this._horizontalFilter.set(commonOptions);
        this._verticalFilter.set(commonOptions);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      _renderLQCanvasBlur(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const { blurRadius, size, gradientSize, start, end } = this._options;
        this._filter.set({
          blurRadius,
          gradientSize,
          size,
          start: start.clone(),
          end: end.clone(),
          texSize: inputDimensions,
          blurQuality: "low"
        });
        this._sprite.setFilters([this._filter]);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      dispose() {
        super.dispose();
        this._filter.dispose();
        this._verticalFilter.dispose();
        this._horizontalFilter.dispose();
      }
      hasChanges() {
        return true;
      }
    };
    MirroredFocusOperation.identifier = "mirrored-focus";
    MirroredFocusOperation.prototype.availableOptions = {
      start: { type: "vector2" /* VECTOR2 */, default: new Vector214(0, 0.5) },
      end: { type: "vector2" /* VECTOR2 */, default: new Vector214(1, 0.5) },
      blurRadius: { type: "number" /* NUMBER */, default: 0.025 },
      size: { type: "number" /* NUMBER */, default: 0.1 },
      gradientSize: { type: "number" /* NUMBER */, default: 0.1 },
      highQualityCanvasBlur: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.MirroredFocusOperation = MirroredFocusOperation;
    mirrored_focus_operation_default = MirroredFocusOperation;
  }
});

// engine/sdk/operations/orientation-operation/index.js
var Vector215, OrientationOperation, orientation_operation_default;
var init_orientation_operation = __esm({
  "engine/sdk/operations/orientation-operation/index.js"() {
    init_core();
    ({ Vector2: Vector215 } = math_exports);
    OrientationOperation = class extends operation_default {
      _render(sdk) {
        const actualDegrees = this._options.rotation % 360;
        const radians = actualDegrees * (Math.PI / 180);
        const rot90Or270 = actualDegrees === 90 || actualDegrees === 270;
        const xorFlips = this._options.flipHorizontally !== this._options.flipVertically;
        const actualFlipVert = rot90Or270 && xorFlips ? !this._options.flipVertically : this._options.flipVertically;
        const actualFlipHoriz = rot90Or270 && xorFlips ? !this._options.flipHorizontally : this._options.flipHorizontally;
        this._sprite.setScale(actualFlipHoriz ? -1 : 1, actualFlipVert ? -1 : 1);
        this._sprite.setRotation(radians);
        this._sprite.setAnchor(0.5, 0.5);
        this._sprite.updateTransform();
        const bounds = this._sprite.getBounds();
        this._renderTexture.resizeTo(new Vector215(bounds.width, bounds.height));
        this._sprite.setPosition(this._renderTexture.getDimensions().divide(2).round());
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      getNewDimensions(dimensions) {
        dimensions = dimensions.clone();
        if (this._options.rotation % 180) {
          dimensions.flip();
        }
        return dimensions;
      }
      flip(direction) {
        const { rotation } = this._options;
        if (rotation === 90 || rotation === 270) {
          if (direction === "vertical") {
            direction = "horizontal";
          } else {
            direction = "vertical";
          }
        }
        switch (direction) {
          case "vertical":
            this.setFlipVertically(!this.getFlipVertically());
            break;
          case "horizontal":
            this.setFlipHorizontally(!this.getFlipHorizontally());
            break;
        }
      }
    };
    OrientationOperation.identifier = "orientation";
    OrientationOperation.prototype.availableOptions = {
      rotation: {
        type: "number" /* NUMBER */,
        default: 0,
        validation(value) {
          if (value % 90 !== 0) {
            throw new Error("OrientationOperation: `rotation` has to be a multiple of 90.");
          }
        },
        setter: (value) => (value + 360) % 360
      },
      flipVertically: { type: "boolean" /* BOOLEAN */, default: false },
      flipHorizontally: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.OrientationOperation = OrientationOperation;
    orientation_operation_default = OrientationOperation;
  }
});

// engine/sdk/operations/output-operation/index.js
var Vector216, OutputOperation, output_operation_default;
var init_output_operation = __esm({
  "engine/sdk/operations/output-operation/index.js"() {
    init_core();
    ({ Vector2: Vector216 } = math_exports);
    OutputOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._flipContainer = new engine_default.Container();
      }
      _render(inputTexture) {
        const {
          position,
          rotation,
          scale,
          pivot,
          outputResolution
        } = this._options;
        const textureScale = this._sdk.getTextureScale();
        const resolution = outputResolution.clone().multiply(textureScale).ceil();
        this._renderTexture.resizeTo(resolution);
        this._sprite.setRotation(rotation);
        this._sprite.setPosition(position);
        this._sprite.setPivot(pivot);
        this._sprite.setScale(scale);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      getNewDimensions(inputDimensions) {
        const textureScale = this._sdk.getTextureScale();
        return this._options.outputResolution.clone().multiply(textureScale).ceil();
      }
    };
    OutputOperation.identifier = "output";
    OutputOperation.prototype.availableOptions = {
      position: { type: "vector2" /* VECTOR2 */, default: new Vector216(0, 0) },
      rotation: { type: "number" /* NUMBER */, default: 0 },
      scale: { type: "vector2" /* VECTOR2 */, default: new Vector216(1, 1) },
      pivot: { type: "vector2" /* VECTOR2 */, default: new Vector216(0, 0) },
      outputResolution: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector216(100, 100)
      }
    };
    exports_default.Operations.OutputOperation = OutputOperation;
    output_operation_default = OutputOperation;
  }
});

// engine/sdk/operations/overlay-operation/index.js
var OverlayFilter2, Vector217, GL_UNIT, OverlayOperation, overlay_operation_default;
var init_overlay_operation = __esm({
  "engine/sdk/operations/overlay-operation/index.js"() {
    init_core();
    ({ OverlayFilter: OverlayFilter2 } = engine_default.Filters);
    ({ Vector2: Vector217 } = math_exports);
    GL_UNIT = 4;
    OverlayOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._overlayTexture = engine_default.Texture.fromImage(this._options.image);
        this._overlayContainer = new engine_default.Container();
        this._overlaySprite = new engine_default.Sprite();
        this._overlaySprite.setTexture(this._overlayTexture);
        this._overlaySprite.setAnchor(0, 0);
        this._overlayContainer.addChild(this._overlaySprite);
        this._overlayFilter = new engine_default.Filters.OverlayFilter({
          overlayImage: this._overlayTexture.getBaseTexture().getGLUnit(),
          overlayTexture: this._overlayTexture
        });
        this._sprite.setFilters([this._overlayFilter]);
        this._renderedOverlaySprite = new engine_default.Sprite();
        this._renderedOverlayContainer = new engine_default.Container();
        this._renderedOverlayContainer.addChild(this._renderedOverlaySprite);
        this._overlayRendered = false;
        this._lastInputDimensions = new Vector217(0, 0);
      }
      setOption(name, value) {
        super.setOption(name, value);
        if (name === "image" && value && this._sdk) {
          const renderer = this._sdk.getRenderer();
          const baseTexture = this._overlayTexture.getBaseTexture();
          baseTexture.setSource(value);
          if (renderer.isOfType("webgl" /* WEBGL */)) {
            renderer.updateTexture(baseTexture);
          }
          this._overlayRendered = false;
        }
      }
      _render(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const { image, alpha, blendMode } = this._options;
        if (!image) {
          this._sprite.setFilters([]);
          this._renderTexture.render(this._container);
          return Promise.resolve();
        }
        if (!this._overlayRendered || !this._lastInputDimensions.equals(inputDimensions)) {
          this._renderOverlayToRenderTexture(inputTexture);
          this._overlayRendered = true;
          this._lastInputDimensions.copy(inputDimensions);
        }
        this._overlayFilter.set({
          blendMode,
          overlayImage: this._overlayRenderTexture.getBaseTexture().getGLUnit(),
          overlayTexture: this._overlayRenderTexture,
          alpha
        });
        this._sprite.setFilters([this._overlayFilter]);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      _renderOverlayToRenderTexture(inputTexture) {
        const renderer = this._sdk.getRenderer();
        const textureDimensions = inputTexture.getDimensions();
        if (!this._overlayRenderTexture) {
          this._overlayRenderTexture = new engine_default.RenderTexture(renderer, textureDimensions.x, textureDimensions.y);
          this._renderedOverlaySprite.setTexture(this._overlayRenderTexture);
        }
        const { width, height } = this._options.image;
        const dimensions = utils_default.resizeVectorToFill(new Vector217(width, height), textureDimensions);
        const { flipHorizontally, flipVertically } = this._options;
        const scaleX = flipHorizontally ? -1 : 1;
        const scaleY = flipVertically ? -1 : 1;
        this._overlaySprite.setWidth(dimensions.x * scaleX);
        this._overlaySprite.setHeight(dimensions.y * scaleY);
        this._overlaySprite.setPosition(textureDimensions.x * (1 - scaleX) * 0.5, textureDimensions.y * (1 - scaleY) * 0.5);
        const baseTexture = this._overlayRenderTexture.getBaseTexture();
        this._overlayRenderTexture.resizeTo(textureDimensions);
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          baseTexture.setGLUnit(GL_UNIT);
          renderer.updateTexture(baseTexture, false);
        }
        this._overlayRenderTexture.render(this._overlayContainer);
      }
      dispose() {
        super.dispose();
        if (this._overlaySprite)
          this._overlaySprite.dispose();
        if (this._overlayRenderTexture)
          this._renderedOverlaySprite.dispose();
        if (this._overlayFilter)
          this._overlayFilter.dispose();
        if (this._overlayTexture)
          this._overlayTexture.dispose();
        if (this._overlayRenderTexture)
          this._overlayRenderTexture.dispose();
        if (this._renderedOverlaySprite)
          this._renderedOverlaySprite.dispose();
      }
    };
    OverlayOperation.identifier = "overlay";
    OverlayOperation.BLEND_MODES = OverlayFilter2.BLEND_MODES;
    OverlayOperation.prototype.availableOptions = {
      identifier: { type: "string" /* STRING */ },
      image: { type: "image" /* IMAGE */ },
      blendMode: {
        type: "number" /* NUMBER */,
        default: OverlayFilter2.BLEND_MODES.MULTIPLY,
        available: Object.keys(OverlayFilter2.BLEND_MODES).map((o) => OverlayFilter2.BLEND_MODES[o])
      },
      alpha: { type: "number" /* NUMBER */, default: 1 },
      flipHorizontally: { type: "boolean" /* BOOLEAN */, default: false },
      flipVertically: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.OverlayOperation = OverlayOperation;
    overlay_operation_default = OverlayOperation;
  }
});

// engine/sdk/operations/radial-focus-operation/radial-focus.frag
var radial_focus_default;
var init_radial_focus = __esm({
  "engine/sdk/operations/radial-focus-operation/radial-focus.frag"() {
    radial_focus_default = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_radius;\nuniform float u_blurRadius;\nuniform float u_gradientRadius;\nuniform vec2 u_position;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nconst float blurSteps = 30.0;\nconst float EPSILON = 0.000000001;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    vec2 coord = v_texCoord * u_texSize;\n    vec2 diff = coord - u_position;\n    float dist = sqrt(diff.x * diff.x + diff.y * diff.y);\n\n    float blurPercentage = smoothstep( \n      0.0, 1.0,\n      (abs(dist) - u_radius) / u_gradientRadius\n    );\n\n    float radius = blurPercentage * u_blurRadius;\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    for (float t = -blurSteps; t <= blurSteps; t++) {\n        float percent = (t + offset - 0.5) / blurSteps;\n        float weight = 1.0 - abs(percent);\n        vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        color += _sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / max(total, EPSILON);\n}\n";
  }
});

// engine/sdk/operations/radial-focus-operation/radial-focus-filter.js
var Vector218, RadialFocusFilter, radial_focus_filter_default;
var init_radial_focus_filter = __esm({
  "engine/sdk/operations/radial-focus-operation/radial-focus-filter.js"() {
    init_core();
    init_blur_filter();
    init_radial_focus();
    ({ Vector2: Vector218 } = math_exports);
    RadialFocusFilter = class extends engine_default.Filter {
      constructor(...args) {
        super(...args);
        this._fragmentSource = radial_focus_default;
        this._lastBlurRadius = null;
        this._lastGradientRadius = null;
        this._lastPosition = new Vector218();
        this._blurFilter = new blur_filter_default();
        this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
        this._maskRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        if (this._options.blurQuality === "low") {
          this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
          return;
        }
        const inputDimensions = inputTarget.getDimensions();
        const dimensionsChanged = !outputTarget.getDimensions().equals(inputDimensions);
        const { blurRadius, position, texSize, gradientRadius } = this._options;
        const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== blurRadius || dimensionsChanged;
        if (shouldUpdateBlur) {
          const delta = new Vector218(this._options.delta.x, this._options.delta.y);
          this._blurFilter.setDelta(delta);
          const options = {
            blurRadius,
            texSize: inputDimensions
          };
          const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
          const smoothstep = (e0, e1, x) => {
            const t = clamp((x - e0) / (e1 - e0), 0, 1);
            return t * t * (3 - 2 * t);
          };
          const radius = (x, y) => {
            return smoothstep(0, 1, (Math.abs(texSize.clone().multiply(x, y).subtract(position).len()) - this._options.radius) / (gradientRadius * 2)) * blurRadius;
          };
          this._blurFilter.set(options);
          this._blurFilter._applyCanvas(renderer, inputTarget, outputTarget, clear, radius);
          this._lastBlurRadius = blurRadius;
        }
      }
      _renderLQBlur(renderer, inputTarget, outputTarget, clear = false) {
        const inputDimensions = inputTarget.getDimensions();
        const dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
        this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
        this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
        this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
        this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
        const shouldUpdateMask = !this._lastPosition.equals(this._options.position) || this._lastGradientRadius !== this._options.gradientRadius || dimensionsChanged;
        const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
        if (shouldUpdateMask) {
          this._renderMask();
          this._lastPosition = this._options.position.clone();
          this._lastGradientRadius = this._options.gradientRadius;
        }
        if (shouldUpdateBlur) {
          this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
          this._lastBlurRadius = this._options.blurRadius;
        }
        this._applyMask(inputTarget, outputTarget);
      }
      _renderMask() {
        const canvas = this._maskRenderTarget.getCanvas();
        const context = this._maskRenderTarget.getContext();
        const canvasDimensions = new Vector218(canvas.width, canvas.height);
        const pixelRatio = this._maskRenderTarget.getPixelRatio();
        const position = this._options.position.clone().multiply(canvasDimensions);
        let { radius, gradientRadius } = this._options;
        radius *= canvas.height;
        gradientRadius *= canvas.height;
        const gradient = context.createRadialGradient(position.x, position.y, 0, position.x, position.y, (radius + gradientRadius) * pixelRatio);
        gradient.addColorStop(0, "#FFFFFF");
        gradient.addColorStop(radius / (radius + gradientRadius), "#FFFFFF");
        gradient.addColorStop(1, "#000000");
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvasDimensions.x, canvasDimensions.y);
      }
      _applyMask(inputTarget, outputTarget) {
        const outputContext = outputTarget.getContext();
        const inputCanvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const blurredContext = this._blurredRenderTarget.getContext();
        const maskContext = this._maskRenderTarget.getContext();
        const inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
        const pixels = inputImageData.data;
        const blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        let alpha;
        for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
          alpha = maskPixels[i] / 255;
          pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
          pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
          pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
        }
        outputContext.putImageData(inputImageData, 0, 0);
      }
      dispose() {
        super.dispose();
        this._blurFilter.dispose();
        this._blurredRenderTarget.dispose();
        this._maskRenderTarget.dispose();
      }
    };
    RadialFocusFilter.prototype.availableOptions = {
      blurRadius: {
        type: "number" /* NUMBER */,
        default: 30,
        uniformType: "f" /* FLOAT */
      },
      radius: {
        type: "number" /* NUMBER */,
        default: 50,
        uniformType: "f" /* FLOAT */
      },
      gradientRadius: {
        type: "number" /* NUMBER */,
        default: 25,
        uniformType: "f" /* FLOAT */
      },
      position: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector218(0.5, 0.5),
        uniformType: "2f" /* FLOAT2 */
      },
      delta: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector218(1, 1),
        uniformType: "2f" /* FLOAT2 */
      },
      texSize: {
        type: "vector2" /* VECTOR2 */,
        default: new Vector218(100, 100),
        uniformType: "2f" /* FLOAT2 */
      }
    };
    radial_focus_filter_default = RadialFocusFilter;
  }
});

// engine/sdk/operations/radial-focus-operation/index.js
var Vector219, RadialFocusOperation, radial_focus_operation_default;
var init_radial_focus_operation = __esm({
  "engine/sdk/operations/radial-focus-operation/index.js"() {
    init_core();
    init_radial_focus_filter();
    ({ Vector2: Vector219 } = math_exports);
    RadialFocusOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._lastBlurRadius = this._options.blurRadius;
        this._lastGradientRadius = this._options.gradientRadius;
        const blurOptions = {
          blurQuality: {
            type: "string" /* STRING */
          }
        };
        this._horizontalFilter = new radial_focus_filter_default({}, blurOptions);
        this._verticalFilter = new radial_focus_filter_default({}, blurOptions);
        this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
        this._horizontalFilter.setDelta(new Vector219(0.5, 0.5));
        this._verticalFilter.setDelta(new Vector219(-0.5, 0.5));
        this._filter = new radial_focus_filter_default({}, blurOptions);
      }
      rotate(degrees) {
        const { position } = this._options;
        if (degrees === 90) {
          position.flip();
          position.x = 1 - position.x;
        } else if (degrees === -90) {
          position.flip();
          position.y = 1 - position.y;
        }
        this.set({ position });
      }
      flip(direction) {
        const { position } = this._options;
        switch (direction) {
          case "horizontal":
            position.x = 1 - position.x;
            break;
          case "vertical":
            position.y = 1 - position.y;
            break;
        }
        this.set({ position });
      }
      transform(transformChange) {
        const newOptions = {};
        const vector = this.getPosition();
        newOptions.position = transformChange.applyToRelativePoint(vector);
        ["radius", "blurRadius", "gradientRadius"].forEach((optionName) => {
          const size = this.getOption(optionName);
          newOptions[optionName] = transformChange.applyToRelativeSize(size);
        });
        this.set(newOptions, false);
      }
      _renderWebGL(inputTexture) {
        return this._renderBlur(inputTexture);
      }
      _renderCanvas(inputTexture) {
        if (this._options.highQualityCanvasBlur) {
          return this._renderBlur(inputTexture);
        }
        return this._renderLQCanvasBlur(inputTexture);
      }
      _renderBlur(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const shortestSide = inputDimensions.min();
        const { position, blurRadius, radius, gradientRadius } = this._options;
        const commonOptions = {
          blurRadius: blurRadius * shortestSide,
          radius: radius * shortestSide,
          gradientRadius: gradientRadius * shortestSide,
          position: position.clone().multiply(inputDimensions),
          texSize: inputDimensions,
          blurQuality: "high"
        };
        this._horizontalFilter.set(commonOptions);
        this._verticalFilter.set(commonOptions);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      _renderLQCanvasBlur(inputTexture) {
        const { blurRadius, radius, gradientRadius, position } = this._options;
        const inputDimensions = inputTexture.getDimensions();
        this._filter.set({
          blurRadius,
          radius,
          gradientRadius,
          position,
          texSize: inputDimensions,
          blurQuality: "low"
        });
        this._sprite.setFilters([this._filter]);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      dispose() {
        super.dispose();
        this._filter.dispose();
        this._verticalFilter.dispose();
        this._horizontalFilter.dispose();
      }
      hasChanges() {
        return true;
      }
    };
    RadialFocusOperation.identifier = "radial-focus";
    RadialFocusOperation.prototype.availableOptions = {
      position: { type: "vector2" /* VECTOR2 */, default: new Vector219(0.5, 0.5) },
      radius: { type: "number" /* NUMBER */, default: 0.25 },
      gradientRadius: { type: "number" /* NUMBER */, default: 0.125 },
      blurRadius: { type: "number" /* NUMBER */, default: 0.025 },
      highQualityCanvasBlur: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.RadialFocusOperation = RadialFocusOperation;
    radial_focus_operation_default = RadialFocusOperation;
  }
});

// engine/sdk/operations/shared/shaders/generic/mask.frag
var mask_default;
var init_mask = __esm({
  "engine/sdk/operations/shared/shaders/generic/mask.frag"() {
    mask_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_filterImage;\nuniform sampler2D u_maskImage;\n\nvoid main() {\n  vec4 color0 = texture2D(u_image, v_texCoord);\n  vec4 color1 = texture2D(u_filterImage, v_texCoord);\n  vec4 mask = texture2D(u_maskImage, v_texCoord);\n  gl_FragColor = mix(color0, color1, mask);\n}\n";
  }
});

// engine/sdk/operations/shared/filters/mask-filter.js
var MaskFilter, mask_filter_default;
var init_mask_filter = __esm({
  "engine/sdk/operations/shared/filters/mask-filter.js"() {
    init_core();
    init_mask();
    MaskFilter = class extends engine_default.Filter {
      constructor() {
        super();
        this._fragmentSource = mask_default;
      }
      _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
        const inputCanvas = inputTarget.getCanvas();
        const inputContext = inputTarget.getContext();
        const outputContext = outputTarget.getContext();
        const { maskCanvas, filterCanvas } = this._options;
        const maskContext = maskCanvas.getContext("2d");
        const filterContext = filterCanvas.getContext("2d");
        const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        const existingImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
        const existingPixels = existingImageData.data;
        const newPixels = filterContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
        let alpha;
        for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
          alpha = maskPixels[i] / 255;
          existingPixels[i] = alpha * newPixels[i] + (1 - alpha) * existingPixels[i];
          existingPixels[i + 1] = alpha * newPixels[i + 1] + (1 - alpha) * existingPixels[i + 1];
          existingPixels[i + 2] = alpha * newPixels[i + 2] + (1 - alpha) * existingPixels[i + 2];
        }
        outputContext.putImageData(existingImageData, 0, 0);
      }
    };
    MaskFilter.prototype.availableOptions = {
      maskImage: {
        type: "number" /* NUMBER */,
        default: 1,
        uniformType: "i" /* INT */
      },
      maskCanvas: { type: "object" /* OBJECT */, default: null },
      filterImage: {
        type: "number" /* NUMBER */,
        default: 2,
        uniformType: "i" /* INT */
      },
      filterCanvas: { type: "object" /* OBJECT */, default: null }
    };
    mask_filter_default = MaskFilter;
  }
});

// engine/sdk/operations/shared/sprite.js
var Vector220, Sprite2, sprite_default;
var init_sprite2 = __esm({
  "engine/sdk/operations/shared/sprite.js"() {
    init_core();
    ({ Vector2: Vector220 } = math_exports);
    Sprite2 = class extends configurable_default {
      constructor(operation, options) {
        super(options);
        this._isDisposed = false;
        this._operation = operation;
        this._dirtiness = {};
        this.id = utils_default.getUUID();
        this._renderTextures = {};
        this._identitySprite = new engine_default.Sprite();
        this._sprite = new engine_default.Sprite();
        this._hitTestSprite = new engine_default.Sprite();
        this._renderers = [];
      }
      applyScale(scale) {
      }
      applyRotation(degrees) {
        const inputDimensions = this._operation.getInputDimensions();
        let spriteDegrees = this.getRotation() * 180 / Math.PI;
        spriteDegrees += degrees;
        this.setRotation(spriteDegrees * Math.PI / 180);
        const actualDegrees = (degrees + 360) % 360;
        const radians = actualDegrees * Math.PI / 180;
        const cos = Math.cos(radians);
        const sin = Math.sin(radians);
        const relativePosition = this._options.position.clone().subtract(0.5).multiply(inputDimensions);
        const newRelativePosition = new Vector220(relativePosition.x * cos - relativePosition.y * sin, relativePosition.x * sin + relativePosition.y * cos).divide(inputDimensions.clone().flip());
        this.setPosition(new Vector220(0.5, 0.5).add(newRelativePosition));
      }
      applyFlip(direction) {
        const position = this.getPosition().clone();
        switch (direction) {
          case "horizontal":
            position.x = 1 - this._options.position.x;
            break;
          case "vertical":
            position.y = 1 - this._options.position.y;
            break;
        }
        this.setPosition(position);
      }
      applyTransform(transformChange) {
        const newOptions = {};
        newOptions.rotation = transformChange.applyToRotation(this.getRotation());
        newOptions.position = transformChange.applyToRelativePoint(this.getPosition());
        if (this._options.dimensions) {
          newOptions.dimensions = transformChange.applyToDimensions(this.getDimensions());
        }
        this.set(newOptions, false);
      }
      getDisplayObject() {
        return this._sprite;
      }
      getHitTestDisplayObject() {
        return this._sprite;
      }
      _getTexture() {
        throw new Error("Sprite#_getTexture is abstract and not implemented in child class.");
      }
      _prepareRenderTexture(sdk) {
        if (!this._renderTexture) {
          const texture = this._getTexture();
          this._renderTextureContainer = new engine_default.Container();
          this._renderTextureSprite = new engine_default.Sprite(texture);
          this._renderTextureContainer.addChild(this._renderTextureSprite);
          this._renderTexture = this._getRenderTexture(sdk.getRenderer(), texture.getDimensions());
        } else {
          this._renderTexture.clear();
        }
      }
      _rendersToRenderTexture(sdk) {
        return sdk.getOptions().smoothDownscaling && sdk.getRenderer().isOfType("webgl" /* WEBGL */);
      }
      _optionEquals(optionName, value) {
        if (optionName === "type") {
          return true;
        }
        return super._optionEquals(optionName, value);
      }
      update(sdk, inputDimensions) {
        if (this._isDisposed) {
          return;
        }
        if (this._rendersToRenderTexture(sdk)) {
          this._prepareRenderTexture(sdk);
          this._renderToRenderTexture(sdk);
        }
        this._updateSprite(inputDimensions);
      }
      _updateSprite(inputDimensions) {
        const sprites = [this._sprite, this._hitTestSprite];
        sprites.forEach((sprite) => {
          if (!sprite.getTexture())
            return;
          sprite.setAnchor(this._options.anchor);
          sprite.setPosition(this._options.position.clone().multiply(inputDimensions));
          if (typeof this._options.alpha !== "undefined") {
            sprite.setAlpha(this._options.alpha);
          }
          let { dimensions } = this._options;
          if (dimensions) {
            dimensions = dimensions.clone().multiply(this._operation.getSDK().getTextureScale());
            sprite.setWidth(dimensions.x);
            sprite.setHeight(dimensions.y);
          }
          sprite.updateTransform();
          const frame = sprite.getTexture().getFrame();
          const spriteDimensions = new Vector220(frame.width, frame.height);
          sprite.setPivot(this._options.pivot.clone().multiply(spriteDimensions));
          sprite.setRotation(this._options.rotation);
          sprite.updateTransform();
        });
      }
      _renderToRenderTexture(sdk) {
        const textureDimensions = this._getTexture().getDimensions();
        const renderTexture = this._getRenderTexture(sdk.getRenderer(), textureDimensions);
        const finalDimensions = textureDimensions.clone();
        if (this._options.smoothDownscaling) {
          finalDimensions.x = utils_default.nextHighestPOT(finalDimensions.x);
          finalDimensions.y = utils_default.nextHighestPOT(finalDimensions.y);
        }
        this._renderTexture.resizeTo(finalDimensions);
        this._renderTexture.render(this._renderTextureContainer);
        if (this._options.smoothDownscaling) {
          const relativeDifference = finalDimensions.clone().subtract(textureDimensions.x, textureDimensions.y).divide(finalDimensions);
          const uvs = renderTexture.getUVs().getUVs();
          uvs[0].x = uvs[3].x = 0;
          uvs[1].x = uvs[2].x = 1 - relativeDifference.x;
          uvs[0].y = uvs[1].y = 0;
          uvs[2].y = uvs[3].y = 1 - relativeDifference.y;
        }
        this._sprite.setTexture(renderTexture);
      }
      isDirtyForRenderer(renderer) {
        if (!(renderer.id in this._dirtiness)) {
          this._dirtiness[renderer.id] = true;
        }
        return this._dirtiness[renderer.id];
      }
      setDirtyForRenderer(dirty, renderer) {
        this._renderers[renderer.id] = renderer;
        this._dirtiness[renderer.id] = dirty;
      }
      setDirty(dirty) {
        for (const rendererId in this._dirtiness) {
          this.setDirtyForRenderer(dirty, this._renderers[rendererId]);
        }
      }
      _getRenderTexture(renderer, dimensions = new Vector220(100, 100)) {
        if (!this._renderTextures[renderer.id]) {
          this._renderTextures[renderer.id] = new engine_default.RenderTexture(renderer, dimensions.x, dimensions.y, 1);
        }
        return this._renderTextures[renderer.id];
      }
      dispose() {
        this._isDisposed = true;
        for (const rendererId in this._renderTextures) {
          this._renderTextures[rendererId].dispose();
        }
      }
      canBeDuplicated() {
        return true;
      }
      canBeDeleted() {
        return true;
      }
      canMaskCanvas() {
        return false;
      }
      canAdjustPadding() {
        return false;
      }
      canBeTakenToFront() {
        return true;
      }
      canBeFlippedHorizontally() {
        return true;
      }
    };
    sprite_default = Sprite2;
  }
});

// engine/sdk/operations/shared/sprites/brush/brushes/brush.js
var Vector221, Brush;
var init_brush = __esm({
  "engine/sdk/operations/shared/sprites/brush/brushes/brush.js"() {
    init_core();
    ({ Vector2: Vector221 } = math_exports);
    Brush = class extends configurable_default {
      constructor(...args) {
        super(...args);
        this._lastOptions = {};
        this._lastInputDimensions = new Vector221(0, 0);
        this._brush = null;
      }
      getBrushImage(inputDimensions) {
        if (this._brush && this.optionsEqual(this._lastOptions) && inputDimensions.equals(this._lastInputDimensions)) {
          return this._brush;
        }
        const { image, size } = this._options;
        image.width = image.height = Math.ceil(size * inputDimensions.min());
        const canvas = utils_default.createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
        const tintedBrush = this._tintImageData(context.getImageData(0, 0, canvas.width, canvas.height), canvas.width, canvas.height);
        context.putImageData(tintedBrush, 0, 0);
        this._lastOptions = this.serializeOptions(["size", "color"]);
        this._brush = canvas;
        this._lastInputDimensions = inputDimensions.clone();
        return canvas;
      }
      _tintImageData(imageData) {
        const { color } = this._options;
        for (let i = 0; i < imageData.data.length; i += 4) {
          imageData.data[i] += (color.r * 255 - imageData.data[i]) * color.a;
          imageData.data[i + 1] += (color.g * 255 - imageData.data[i + 1]) * color.a;
          imageData.data[i + 2] += (color.b * 255 - imageData.data[i + 2]) * color.a;
        }
        return imageData;
      }
      clone() {
        const Constructor = this.constructor;
        return new Constructor(this._options);
      }
    };
    Brush.prototype.availableOptions = {
      identifier: { type: "string" /* STRING */ },
      image: { type: "image" /* IMAGE */ },
      size: { type: "number" /* NUMBER */, default: 0.05 },
      color: { type: "color" /* COLOR */, default: color_default.RED }
    };
  }
});

// engine/sdk/operations/shared/sprites/brush/brushes/radial-brush.js
var RadialBrush;
var init_radial_brush = __esm({
  "engine/sdk/operations/shared/sprites/brush/brushes/radial-brush.js"() {
    init_core();
    init_brush();
    RadialBrush = class extends Brush {
      getBrushImage(inputDimensions) {
        if (this._brush && this.optionsEqual(this._lastOptions) && inputDimensions.equals(this._lastInputDimensions)) {
          return this._brush;
        }
        let { size, hardness, color } = this._options;
        const canvas = utils_default.createCanvas();
        canvas.width = canvas.height = Math.ceil(size * inputDimensions.min());
        const context = canvas.getContext("2d");
        color = color.clone();
        color.a = 1;
        if (canvas.width === 1) {
          context.fillStyle = color.toRGBA();
          context.fillRect(0, 0, 1, 1);
        } else {
          const gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, Math.min(canvas.width / 2 - 1, canvas.width / 2 * hardness), canvas.width / 2, canvas.height / 2, canvas.width / 2);
          gradient.addColorStop(0, color.toRGBA());
          const transparentColor = color.clone();
          transparentColor.a = 0;
          gradient.addColorStop(1, transparentColor.toRGBA());
          context.fillStyle = gradient;
          context.fillRect(0, 0, canvas.width, canvas.height);
        }
        this._lastOptions = this.serializeOptions(["size", "color", "hardness"]);
        this._brush = canvas;
        this._lastInputDimensions = inputDimensions.clone();
        return canvas;
      }
    };
    RadialBrush.identifier = "imgly_brush_radial";
    RadialBrush.prototype.availableOptions = __spreadProps(__spreadValues({}, Brush.prototype.availableOptions), {
      hardness: { type: "number" /* NUMBER */, default: 1 }
    });
  }
});

// engine/sdk/operations/shared/sprites/brush/control-point.js
var Vector222, CubicBezierCurve2, ControlPoint, control_point_default;
var init_control_point = __esm({
  "engine/sdk/operations/shared/sprites/brush/control-point.js"() {
    init_core();
    ({ Vector2: Vector222, CubicBezierCurve: CubicBezierCurve2 } = math_exports);
    ControlPoint = class {
      constructor(path, position, smooth = 3) {
        this._path = path;
        this._drawnCanvases = [];
        this._position = position;
        this._smooth = smooth;
      }
      getBezierCurve(beforeLastPoint, lastPoint, point, nextPoint) {
        if (!lastPoint) {
          return null;
        }
        let pointDx;
        let pointDy;
        if (!nextPoint) {
          pointDx = (point.x - lastPoint.x) / this._smooth;
          pointDy = (point.y - lastPoint.y) / this._smooth;
        } else {
          pointDx = (nextPoint.x - lastPoint.x) / this._smooth;
          pointDy = (nextPoint.y - lastPoint.y) / this._smooth;
        }
        let lastPointDx;
        let lastPointDy;
        if (!beforeLastPoint) {
          lastPointDx = (point.x - lastPoint.x) / this._smooth;
          lastPointDy = (point.y - lastPoint.y) / this._smooth;
        } else {
          lastPointDx = (point.x - beforeLastPoint.x) / this._smooth;
          lastPointDy = (point.y - beforeLastPoint.y) / this._smooth;
        }
        const p1 = lastPoint.clone().add(lastPointDx, lastPointDy);
        const p2 = point.clone().subtract(pointDx, pointDy);
        return new CubicBezierCurve2(lastPoint, p1, p2, point);
      }
      renderToCanvas(brush, canvas, beforeLastControlPoint, lastControlPoint, nextControlPoint, hardness = 1) {
        if (this._drawnCanvases.indexOf(canvas) !== -1) {
          return;
        }
        const canvasDimensions = new Vector222(canvas.width, canvas.height);
        const context = canvas.getContext("2d");
        const position = this._position.clone().multiply(canvasDimensions);
        const lastPosition = lastControlPoint ? lastControlPoint.getPosition().clone().multiply(canvasDimensions) : null;
        const beforeLastPosition = beforeLastControlPoint ? beforeLastControlPoint.getPosition().clone().multiply(canvasDimensions) : null;
        const nextPosition = nextControlPoint ? nextControlPoint.getPosition().clone().multiply(canvasDimensions) : null;
        const distance = position.clone().subtract(lastPosition).len();
        const step = brush.width / 10;
        const curve = this.getBezierCurve(beforeLastPosition, lastPosition, position, nextPosition);
        let sample;
        if (!curve) {
          sample = [position];
        } else {
          curve.calculateSegments(20);
          const length = curve.getLength();
          sample = curve.arcLengthApproxSample(Math.ceil(length / step));
        }
        for (let i = 0; i < sample.length; i++) {
          const pos = sample[i];
          let alpha = brush.width * 0.5 / (step * 2);
          alpha *= 1 - hardness;
          alpha = 1 / (1 + alpha);
          context.globalAlpha = alpha;
          context.drawImage(brush, pos.x - brush.width / 2, pos.y - brush.height / 2, brush.width, brush.height);
        }
        context.globalAlpha = 1;
        this._drawnCanvases.push(canvas);
      }
      setPosition(position) {
        this._position = position;
      }
      getPosition() {
        return this._position.clone();
      }
      setDirty() {
        this._drawnCanvases = [];
      }
    };
    control_point_default = ControlPoint;
  }
});

// engine/sdk/operations/shared/sprites/brush/path.js
var Path, path_default;
var init_path = __esm({
  "engine/sdk/operations/shared/sprites/brush/path.js"() {
    init_core();
    init_control_point();
    Path = class extends configurable_default {
      constructor(operation, options, canvas) {
        super(options);
        this._operation = operation;
        this._canvas = canvas || utils_default.createCanvas();
        this._context = this._canvas.getContext("2d");
      }
      serializeOption(optionName, toObject = false) {
        if (optionName === "controlPoints") {
          return this._options.controlPoints.map((controlPoint) => {
            const position = controlPoint.getPosition();
            return toObject ? position.toObject() : position.clone();
          });
        }
        return super.serializeOption(optionName, toObject);
      }
      _optionEquals(optionName, value) {
        if (optionName === "controlPoints") {
          const { controlPoints } = this._options;
          for (let i = 0, l = controlPoints.length; i < l; i++) {
            if (!controlPoints[i].getPosition().equals(value[i])) {
              return false;
            }
          }
          return true;
        }
        return super._optionEquals(optionName, value);
      }
      render(inputDimensions) {
        const { controlPoints, size } = this._options;
        if (controlPoints.length < 2) {
          return;
        }
        const brush = this.getBrush();
        const hardness = brush && brush.getHardness ? brush.getHardness() : 1;
        utils_default.ensureCanvasDimensions(this._canvas, inputDimensions);
        if (!this._brush || this._lastBrushSize !== size || !inputDimensions.equals(this._brushInputDimensions)) {
          this._brushInputDimensions = inputDimensions.clone();
          this._lastBrushSize = size;
        }
        let beforeLastControlPoint;
        let lastControlPoint;
        let controlPoint;
        let nextControlPoint;
        for (let i = 0; i < controlPoints.length; i++) {
          beforeLastControlPoint = controlPoints[i - 2];
          lastControlPoint = controlPoints[i - 1];
          controlPoint = controlPoints[i];
          nextControlPoint = controlPoints[i + 1];
          controlPoint.renderToCanvas(this._options.brush.getBrushImage(inputDimensions), this._canvas, beforeLastControlPoint, lastControlPoint, nextControlPoint, hardness);
        }
      }
      _createBrush(inputDimensions) {
        let { size, hardness, color } = this._options;
        const canvas = utils_default.createCanvas();
        canvas.width = canvas.height = Math.ceil(size * inputDimensions.min());
        const context = canvas.getContext("2d");
        color = color.clone();
        color.a = 1;
        if (canvas.width === 1) {
          context.fillStyle = color.toRGBA();
          context.fillRect(0, 0, 1, 1);
        } else {
          const gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, Math.min(canvas.width / 2 - 1, canvas.width / 2 * hardness), canvas.width / 2, canvas.height / 2, canvas.width / 2);
          gradient.addColorStop(0, color.toRGBA());
          const transparentColor = color.clone();
          transparentColor.a = 0;
          gradient.addColorStop(1, transparentColor.toRGBA());
          context.fillStyle = gradient;
          context.fillRect(0, 0, canvas.width, canvas.height);
        }
        return canvas;
      }
      addControlPoint(position) {
        const controlPoint = new control_point_default(this, position);
        this._options.controlPoints.push(controlPoint);
        this.emit("update", this);
      }
      getCanvas() {
        return this._canvas;
      }
      setCanvas(canvas) {
        this._canvas = canvas;
        this._context = canvas.getContext("2d");
      }
      setDirty() {
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._options.controlPoints.forEach((point) => {
          point.setDirty();
        });
      }
      forEachControlPoint(iterator) {
        this._options.controlPoints.forEach(iterator);
      }
      renderToCanvas(canvas) {
        const context = canvas.getContext("2d");
        context.save();
        context.globalAlpha = this._options.brush.getColor().a;
        context.drawImage(this._canvas, 0, 0);
        context.restore();
      }
      getCanvasDimensions() {
        return this._canvasDimensions;
      }
    };
    Path.prototype.availableOptions = {
      id: { type: "string" /* STRING */, default: () => utils_default.getUUID() },
      brush: { type: "object" /* OBJECT */, required: true },
      controlPoints: { type: "array" /* ARRAY */, default: [] },
      closed: { type: "boolean" /* BOOLEAN */, default: false }
    };
    path_default = Path;
  }
});

// engine/sdk/operations/shared/sprites/brush-sprite.js
var Vector223, BrushSprite, brush_sprite_default;
var init_brush_sprite = __esm({
  "engine/sdk/operations/shared/sprites/brush-sprite.js"() {
    init_core();
    init_sprite2();
    init_brush();
    init_radial_brush();
    init_path();
    ({ Vector2: Vector223 } = math_exports);
    BrushSprite = class extends sprite_default {
      constructor(...args) {
        super(...args);
        this._persistedPaths = [];
        this._outputCanvasDirty = true;
        this._outputCanvas = utils_default.createCanvas();
        this._outputContext = this._outputCanvas.getContext("2d");
        this._persistCanvas = utils_default.createCanvas();
        this._persistContext = this._persistCanvas.getContext("2d");
        this._nextCanvas = utils_default.createCanvas();
        this._texture = engine_default.Texture.fromCanvas(this._outputCanvas);
        this._sprite.setTexture(this._texture);
        this._onPathUpdate = this._onPathUpdate.bind(this);
      }
      applyFlip(direction) {
        this._options.paths.forEach((path) => {
          path.forEachControlPoint((controlPoint) => {
            const position = controlPoint.getPosition().clone();
            switch (direction) {
              case "horizontal":
                position.x = 1 - position.x;
                break;
              case "vertical":
                position.y = 1 - position.y;
                break;
            }
            controlPoint.setPosition(position);
          });
          path.setDirty(true);
        });
        this._reset();
      }
      applyRotation(degrees) {
        this._options.paths.forEach((path) => {
          path.forEachControlPoint((controlPoint) => {
            const position = controlPoint.getPosition().clone();
            if (degrees === 90) {
              position.flip();
              position.x = 1 - position.x;
            } else if (degrees === -90) {
              position.flip();
              position.y = 1 - position.y;
            }
            controlPoint.setPosition(position);
          });
          path.setDirty(true);
        });
        this._reset();
      }
      applyTransform(transformChange) {
        let lastBrush = null;
        this._options.paths.forEach((path) => {
          path.forEachControlPoint((controlPoint) => {
            controlPoint.setPosition(transformChange.applyToRelativePoint(controlPoint.getPosition()));
          });
          const brush = path.getBrush();
          if (brush !== lastBrush) {
            brush.setSize(transformChange.applyToRelativeSize(brush.getSize()));
            lastBrush = brush;
          }
          path.setDirty(true);
        });
        this._reset();
      }
      clearCanvas() {
        if (!this._outputCanvas) {
          return;
        }
        this._outputCanvasDirty = true;
        const { width, height } = this._outputCanvas;
        this._outputContext.clearRect(0, 0, width, height);
      }
      clearPersistCanvas() {
        if (!this._persistCanvas) {
          return;
        }
        const { width, height } = this._persistCanvas;
        this._persistContext.clearRect(0, 0, width, height);
      }
      serializeOptions(keys, toObject = false) {
        const options = super.serializeOptions(keys, toObject);
        if (!keys)
          options.type = "brush";
        return options;
      }
      serializeOption(optionName, toObject = false) {
        if (optionName === "paths") {
          return this._options.paths.map((path) => path.serializeOptions(void 0, toObject));
        }
        return super.serializeOption(optionName, toObject);
      }
      createPath(brush) {
        const path = new path_default(this._operation, { brush }, this._nextCanvas);
        path.on("update", this._onPathUpdate);
        this._options.paths.push(path);
        this.setDirty(true);
        return path;
      }
      _onPathUpdate() {
        this._operation.setDirty(true);
        this.setDirty(true);
      }
      _onPathPersist(path) {
        path.renderToCanvas(this._persistCanvas);
        this._nextCanvas = path.getCanvas();
        const context = this._nextCanvas.getContext("2d");
        context.clearRect(0, 0, this._nextCanvas.width, this._nextCanvas.height);
        this._persistedPaths.push(path);
      }
      _getTexture() {
        return this._texture;
      }
      setDirtyForRenderer(dirty, renderer, dimensionsChanged = false) {
        super.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
        if (dirty && dimensionsChanged) {
          this._persistedPaths = [];
          this.clearPersistCanvas();
          this._options.paths.forEach((path) => {
            path.setDirty(true);
          });
        }
      }
      setDirty(dirty, dimensionsChanged = false) {
        for (const rendererId in this._dirtiness) {
          this.setDirtyForRenderer(dirty, this._renderers[rendererId], dimensionsChanged);
        }
      }
      render(inputDimensions) {
        const renderer = this._operation.getSDK().getRenderer();
        if (!this.isDirtyForRenderer(renderer)) {
          return;
        }
        utils_default.ensureCanvasDimensions(this._outputCanvas, inputDimensions);
        utils_default.ensureCanvasDimensions(this._persistCanvas, inputDimensions);
        this._options.paths.forEach((path) => {
          path.render(inputDimensions);
          if (path.getClosed() && this._persistedPaths.indexOf(path) === -1) {
            this._onPathPersist(path);
          }
        });
        this.clearCanvas();
        this._outputContext.drawImage(this._persistCanvas, 0, 0);
        this._options.paths.forEach((path) => {
          if (!path.getClosed()) {
            path.renderToCanvas(this._outputCanvas);
          }
        });
        this.setDirtyForRenderer(false, renderer);
      }
      update(sdk, inputDimensions) {
        if (inputDimensions) {
          utils_default.ensureCanvasDimensions(this._outputCanvas, inputDimensions);
          utils_default.ensureCanvasDimensions(this._persistCanvas, inputDimensions);
          this._texture.getBaseTexture().update();
        }
        this.render(inputDimensions);
        const renderer = sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          renderer.updateTexture(this._texture.getBaseTexture());
        }
        super.update(sdk, inputDimensions);
      }
      _reset() {
        this._persistedPaths = [];
        if (this._operation) {
          this._operation.setDirty(true);
        }
        this.setDirty(true);
        this.clearCanvas();
        this.clearPersistCanvas();
      }
      getCanvas() {
        return this._outputCanvas;
      }
      _createRadialBrush() {
        return new RadialBrush();
      }
      _getTempCanvas() {
        return this._nextCanvas;
      }
      dispose() {
        super.dispose();
        this._texture && this._texture.getBaseTexture().dispose();
      }
    };
    BrushSprite.prototype.availableOptions = {
      id: { type: "string" /* STRING */, default: () => utils_default.getUUID() },
      position: { type: "vector2" /* VECTOR2 */, default: new Vector223(0, 0) },
      scale: { type: "vector2" /* VECTOR2 */, default: new Vector223(1, 1) },
      anchor: { type: "vector2" /* VECTOR2 */, default: new Vector223(0, 0) },
      pivot: { type: "vector2" /* VECTOR2 */, default: new Vector223(0, 0) },
      rotation: { type: "number" /* NUMBER */, default: 0 },
      paths: {
        type: "array" /* ARRAY */,
        default: [],
        setter(paths) {
          paths = paths.map((path) => {
            if (path instanceof path_default)
              return path;
            const { brush, closed } = path;
            const newPath = new path_default(this._operation, { brush, closed }, this._nextCanvas);
            path.controlPoints.forEach((position) => {
              newPath.addControlPoint(position);
            });
            return newPath;
          });
          this._reset();
          return paths;
        }
      }
    };
    BrushSprite.type = "brush";
    BrushSprite.Brush = Brush;
    BrushSprite.Path = path_default;
    BrushSprite.Brushes = {
      RadialBrush
    };
    brush_sprite_default = BrushSprite;
  }
});

// engine/sdk/operations/selective-blur-operation/index.js
var Vector224, SelectiveBlurOperation, selective_blur_operation_default;
var init_selective_blur_operation = __esm({
  "engine/sdk/operations/selective-blur-operation/index.js"() {
    init_core();
    init_blur_filter();
    init_mask_filter();
    init_brush_sprite();
    ({ Vector2: Vector224 } = math_exports);
    SelectiveBlurOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        const renderer = this._sdk.getRenderer();
        this._lastBlurRadius = null;
        this._blurredRenderTexture = new engine_default.RenderTexture(renderer, 100, 100, 1);
        this._maskRenderTexture = new engine_default.RenderTexture(renderer, 100, 100, 1);
        this._brushSprite = new brush_sprite_default(this);
        this._brushSpriteContainer = new engine_default.Container();
        const brushSprite = this._brushSprite.getDisplayObject();
        this._brushSpriteContainer.addChild(brushSprite);
        this._outputSprite = new engine_default.Sprite();
        this._outputContainer = new engine_default.Container();
        this._outputContainer.addChild(this._outputSprite);
        this._maskFilter = new mask_filter_default();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          this._horizontalFilter = new blur_filter_default();
          this._verticalFilter = new blur_filter_default();
          this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
          this._horizontalFilter.setDelta(new Vector224(1, 1));
          this._verticalFilter.setDelta(new Vector224(-1, 1));
          let baseTexture = this._maskRenderTexture.getBaseTexture();
          baseTexture.setGLUnit(this._maskFilter.getMaskImage());
          renderer.updateTexture(baseTexture, false);
          baseTexture = this._blurredRenderTexture.getBaseTexture();
          baseTexture.setGLUnit(this._maskFilter.getFilterImage());
          renderer.updateTexture(baseTexture, false);
        } else if (renderer.isOfType("canvas" /* CANVAS */)) {
          this._blurFilter = new blur_filter_default();
          this._sprite.setFilters([this._blurFilter]);
          this._maskFilter.setMaskCanvas(this._maskRenderTexture.getRenderTarget().getCanvas());
          this._maskFilter.setFilterCanvas(this._blurredRenderTexture.getRenderTarget().getCanvas());
        }
        this._outputSprite.setFilters([this._maskFilter]);
      }
      flip(direction) {
        this._brushSprite.applyFlip(direction);
        this.setDirty(true, true);
        this._lastBlurRadius = null;
      }
      rotate(degrees) {
        this._brushSprite.applyRotation(degrees);
        this.setDirty(true, true);
        this._lastBlurRadius = null;
      }
      transform(transformOperation, options) {
        this._brushSprite.applyTransform(transformOperation, options);
        this.setDirty(true, true);
        this._lastBlurRadius = null;
      }
      _render(inputTexture) {
        this._renderBlur(inputTexture);
        this._renderMask(inputTexture);
        this._outputSprite.setTexture(inputTexture);
        this._renderTexture.render(this._outputContainer);
        return Promise.resolve();
      }
      _renderMask(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const maskDimensions = this._maskRenderTexture.getDimensions();
        if (!maskDimensions.equals(inputDimensions)) {
          this._maskRenderTexture.resizeTo(inputDimensions);
        }
        this._brushSprite.update(this._sdk, inputDimensions);
        this._maskRenderTexture.clear(color_default.BLACK);
        this._maskRenderTexture.render(this._brushSpriteContainer);
        const renderer = this._sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          renderer.updateTexture(this._maskRenderTexture.getBaseTexture(), false);
        }
      }
      _renderBlur(inputTexture) {
        const inputDimensions = inputTexture.getDimensions();
        const blurredDimensions = this._blurredRenderTexture.getDimensions();
        if (!blurredDimensions.equals(inputDimensions)) {
          this._blurredRenderTexture.resizeTo(inputDimensions);
        }
        const { blurRadius } = this._options;
        if (this._lastBlurRadius !== blurRadius || !blurredDimensions.equals(inputDimensions)) {
          const renderer2 = this._sdk.getRenderer();
          let blurOptions;
          if (renderer2.isOfType("webgl" /* WEBGL */)) {
            const shortestSide = inputDimensions.min();
            blurOptions = {
              blurRadius: blurRadius * shortestSide,
              texSize: inputDimensions
            };
            this._horizontalFilter.set(blurOptions);
            this._verticalFilter.set(blurOptions);
          } else if (renderer2.isOfType("canvas" /* CANVAS */)) {
            blurOptions = { blurRadius };
            this._blurFilter.set(blurOptions);
          }
          this._blurredRenderTexture.render(this._container);
          this._lastBlurRadius = blurRadius;
        }
        const renderer = this._sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          renderer.updateTexture(this._blurredRenderTexture.getBaseTexture(), false);
        }
      }
      getBrush() {
        return this._brushSprite;
      }
      createPath(size, hardness = 1) {
        const brush = new brush_sprite_default.Brushes.RadialBrush({
          size,
          hardness,
          color: color_default.WHITE
        });
        const path = this._brushSprite.createPath(brush);
        this._options.paths.push(path);
        this.setDirty(true);
        return path;
      }
      setDirtyForRenderer(dirty, renderer, dimensionsChanged) {
        super.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
        this._brushSprite.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
      }
      dispose() {
        super.dispose();
        const renderer = this._sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          this._verticalFilter.dispose();
          this._horizontalFilter.dispose();
        } else {
          this._blurFilter.dispose();
        }
        this._brushSprite.dispose();
        this._maskFilter.dispose();
        this._blurredRenderTexture.dispose();
        this._maskRenderTexture.dispose();
      }
      hasChanges() {
        return true;
      }
    };
    SelectiveBlurOperation.identifier = "selective-blur";
    SelectiveBlurOperation.prototype.availableOptions = {
      blurRadius: { type: "number" /* NUMBER */, default: 0.05 },
      paths: {
        type: "array" /* ARRAY */,
        default: [],
        setter(paths) {
          if (this._brushSprite) {
            this._brushSprite.setPaths(paths);
          }
          return paths;
        }
      }
    };
    exports_default.Operations.SelectiveBlurOperation = SelectiveBlurOperation;
    selective_blur_operation_default = SelectiveBlurOperation;
  }
});

// engine/sdk/operations/sprite-operation/sprites/sticker-sprite.js
var Vector225, ColorMatrix7, StickerSprite, sticker_sprite_default;
var init_sticker_sprite = __esm({
  "engine/sdk/operations/sprite-operation/sprites/sticker-sprite.js"() {
    init_core();
    init_adjustments_filter();
    init_sprite2();
    ({ Vector2: Vector225, ColorMatrix: ColorMatrix7 } = math_exports);
    StickerSprite = class extends sprite_default {
      constructor(...args) {
        super(...args);
        const { image } = this._options;
        const src = image.src || image.filePath || image.toDataUrl && image.toDataURL();
        this._isSVG = src && (!!src.match(/\w+\.svg(?=\?|$)/i) || src.match(/data:image\/svg/i));
        if (this._isSVG) {
          this._canvas = utils_default.createCanvas();
          this._context = this._canvas.getContext("2d");
          this._options.smoothDownscaling = false;
        }
        if (image) {
          this._onImageUpdate();
        }
        this._tintFilter = new engine_default.Filters.TintFilter();
        this._adjustmentsFilter = new adjustments_filter_default();
        this._lastRenderedDimensions = Vector225.NULL;
        this._lastRenderedInputDimensions = Vector225.NULL;
        this._onOptionsChange = this._onOptionsChange.bind(this);
        this._options.adjustments.on("update", this._onOptionsChange);
      }
      applyScale(scale) {
        this.setDimensions(this.getDimensions().multiply(scale));
      }
      serializeOptions(keys, toObject = false) {
        const options = super.serializeOptions(keys, toObject);
        if (!keys)
          options.type = "sticker";
        return options;
      }
      _rendersToRenderTexture(sdk) {
        const smoothDownscaling = this._options.smoothDownscaling && !this._isSVG && sdk.getRenderer().isOfType("webgl" /* WEBGL */);
        return smoothDownscaling || this._hasAdjustments() || this._options.tintMode !== "none";
      }
      _getTexture() {
        return this._inputTexture;
      }
      update(sdk, inputDimensions) {
        const { dimensions, image } = this._options;
        if (dimensions.equals(Vector225.NULL)) {
          dimensions.set(image.width, image.height);
        }
        this._sprite.setSmoothDownscaling(this._isSVG ? false : this.getSmoothDownscaling());
        const isDirty = !this._lastRenderedInputDimensions.equals(inputDimensions) || !this._lastRenderedDimensions.equals(dimensions) || this._lastRenderedImage !== image;
        if (isDirty && this._isSVG && sdk.getRenderer().isOfType("webgl" /* WEBGL */)) {
          image.width = Math.round(dimensions.x);
          image.height = Math.round(dimensions.y);
          const maxDimensions = 4096;
          const imgAspect = image.width / image.height;
          if (image.width > maxDimensions) {
            image.width = maxDimensions;
            image.height = Math.round(image.width / imgAspect);
          }
          if (image.height > maxDimensions) {
            image.height = maxDimensions;
            image.width = Math.round(image.height * imgAspect);
          }
          this._canvas.width = image.width;
          this._canvas.height = image.height;
          this._context.clearRect(0, 0, image.width, image.height);
          this._context.drawImage(image, 0, 0, image.width, image.height);
          this._inputTexture.getBaseTexture().update();
        }
        if (this._rendersToRenderTexture(sdk)) {
          this._prepareRenderTexture(sdk);
        }
        const filters = [];
        if (this._rendersToRenderTexture(sdk)) {
          if (this._hasAdjustments()) {
            filters.push(this._adjustmentsFilter);
            const { adjustments } = this._options;
            const colorMatrix = new ColorMatrix7();
            colorMatrix.multiply(ColorMatrix7.createBrightnessMatrix(adjustments.getBrightness()));
            colorMatrix.multiply(ColorMatrix7.createSaturationMatrix(adjustments.getSaturation()));
            colorMatrix.multiply(ColorMatrix7.createContrastMatrix(adjustments.getContrast()));
            this._adjustmentsFilter.set({
              colorMatrix
            });
          }
          if (this._options.tintMode && this._options.tintMode !== "none") {
            filters.push(this._tintFilter);
            this._tintFilter.set({
              mode: engine_default.Filters.TintFilter.MODES[this._options.tintMode.toUpperCase()],
              color: this._options.tintColor
            });
            if (this._sprite.getTexture() && this._sprite.getTexture()._baseTexture) {
              this._sprite.getTexture()._baseTexture.setDirty(true);
            }
          }
          this._renderTextureSprite.setFilters(filters);
        }
        if (this._rendersToRenderTexture(sdk)) {
          this._renderToRenderTexture(sdk);
        } else {
          this._sprite.setTexture(this._inputTexture);
        }
        this._updateSprite(inputDimensions);
        this._applyFlip();
        this._lastRenderedDimensions.copy(dimensions);
        this._lastRenderedInputDimensions.copy(inputDimensions);
        this._lastRenderedImage = image;
      }
      _applyFlip() {
        const scale = this._sprite.getScale();
        const { flipHorizontally, flipVertically } = this._options;
        if (flipHorizontally && scale.x > 0 || !flipHorizontally && scale.x < 0) {
          scale.x *= -1;
        }
        if (flipVertically && scale.y > 0 || !flipVertically && scale.y < 0) {
          scale.y *= -1;
        }
        this._sprite.setScale(scale);
      }
      applyFlip(direction) {
        super.applyFlip(direction);
        const options = {
          rotation: this._options.rotation
        };
        const degrees = options.rotation / Math.PI * 180;
        const newDegrees = degrees * -1;
        options.rotation = newDegrees * Math.PI / 180;
        switch (direction) {
          case "horizontal":
            options.flipHorizontally = !this._options.flipHorizontally;
            this.set(options);
            break;
          case "vertical":
            options.flipVertically = !this._options.flipVertically;
            this.set(options);
            break;
        }
      }
      _hasAdjustments() {
        const { adjustments } = this._options;
        return adjustments.getBrightness() !== 0 || adjustments.getSaturation() !== 1 || adjustments.getContrast() !== 1;
      }
      _onImageUpdate() {
        let textureImage = this._options.image;
        const renderer = this._operation.getSDK().getRenderer();
        if (this._isSVG && renderer.isOfType("webgl" /* WEBGL */)) {
          textureImage = this._canvas;
        }
        if (this._inputTexture) {
          this._inputTexture.dispose();
          this._inputTexture = null;
        }
        this._inputTexture = engine_default.Texture.fromImage(textureImage);
        this._identitySprite.setTexture(this._inputTexture);
        this._sprite.setTexture(this._inputTexture);
        if (this._renderTexture) {
          this._renderTextureSprite.setTexture(this._inputTexture);
          this._renderTexture.resizeTo(this._inputTexture.getDimensions());
        }
        this.setDirty(true);
      }
      scalesUniformly() {
        return this._options.resizeMode === "keepAspect";
      }
      setOption(optionName, value, update = true) {
        super.setOption(optionName, value, update);
        if (optionName === "image" && this._identitySprite) {
          this._onImageUpdate();
        }
      }
      _onOptionsChange() {
        const dirtiness = this._dirtiness;
        for (const id in dirtiness) {
          dirtiness[id] = true;
        }
      }
      dispose() {
        super.dispose();
        if (this._inputTexture) {
          this._inputTexture.dispose();
          this._inputTexture = null;
        }
        this._tintFilter.dispose();
        this._adjustmentsFilter.dispose();
        this._options.adjustments.off("updated", this._onOptionsChange);
      }
    };
    StickerSprite.prototype.availableOptions = {
      id: { type: "string" /* STRING */, default: () => utils_default.getUUID() },
      identifier: { type: "string" /* STRING */, default: "" },
      image: { type: "image" /* IMAGE */, required: true },
      position: { type: "vector2" /* VECTOR2 */, default: Vector225.NULL },
      dimensions: { type: "vector2" /* VECTOR2 */, default: Vector225.NULL },
      anchor: { type: "vector2" /* VECTOR2 */, default: new Vector225(0, 0) },
      pivot: { type: "vector2" /* VECTOR2 */, default: new Vector225(0.5, 0.5) },
      rotation: { type: "number" /* NUMBER */, default: 0 },
      flipHorizontally: { type: "boolean" /* BOOLEAN */, default: false },
      flipVertically: { type: "boolean" /* BOOLEAN */, default: false },
      smoothDownscaling: { type: "boolean" /* BOOLEAN */, default: false },
      tintColor: { type: "color" /* COLOR */, default: color_default.WHITE },
      tintMode: {
        type: "string" /* STRING */,
        default: "none",
        available: ["none", "solid", "colorized"]
      },
      resizeMode: {
        type: "string" /* STRING */,
        default: "keepAspect",
        available: ["keepAspect", "unrestricted"]
      },
      alpha: { type: "number" /* NUMBER */, default: 1 },
      adjustments: {
        type: "configurable" /* CONFIGURABLE */,
        structure: {
          brightness: { type: "number" /* NUMBER */, default: 0 },
          saturation: { type: "number" /* NUMBER */, default: 1 },
          contrast: { type: "number" /* NUMBER */, default: 1 }
        }
      }
    };
    StickerSprite.type = "sticker";
    sticker_sprite_default = StickerSprite;
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/randomizer.js
var _Randomizer, Randomizer;
var init_randomizer = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/randomizer.js"() {
    _Randomizer = class {
      constructor(seed) {
        this._seed = seed === void 0 ? _Randomizer.TimeSeed() : seed;
      }
      seed(value) {
        this._seed = value === void 0 ? _Randomizer.TimeSeed() : value;
      }
      next() {
        let seed = this._seed | 0;
        const highPass = seed / _Randomizer.SEED_DIVIDER | 0;
        const lowPass = seed % _Randomizer.SEED_DIVIDER | 0;
        seed = _Randomizer.SEED_LOW_MULTIPLY * lowPass - _Randomizer.SEED_HIGH_MULTIPLY * highPass;
        if (seed <= 0) {
          seed += _Randomizer.MAX;
        }
        if (seed === -1) {
          seed = _Randomizer.MAX - 1;
        }
        this._seed = seed;
        return seed;
      }
      nextInRange(min, max) {
        if (max === void 0) {
          max = min;
          min = 0;
        }
        return min + this.next() % (max - min + 1);
      }
      nextBool(falseChance = 1, trueChance = 1) {
        return this.nextInRange(falseChance + trueChance - 1) >= falseChance;
      }
      static TimeSeed() {
        return Date.now();
      }
      pickNext(array) {
        if (!Array.isArray(array)) {
          return null;
        }
        return array[this.next() % array.length];
      }
    };
    Randomizer = _Randomizer;
    __publicField(Randomizer, "MAX", 2147483647);
    __publicField(Randomizer, "SEED_DIVIDER", 127773);
    __publicField(Randomizer, "SEED_LOW_MULTIPLY", 16807);
    __publicField(Randomizer, "SEED_HIGH_MULTIPLY", 2836);
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/size-value.js
var Rectangle3, SizeValue;
var init_size_value = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/size-value.js"() {
    init_core();
    ({ Rectangle: Rectangle3 } = math_exports);
    SizeValue = class {
      constructor(width = 0, height = 0) {
        this.width = width;
        this.height = height;
      }
      set(width, height) {
        this.width = width;
        this.height = height;
      }
      aspect() {
        return this.width / this.height;
      }
      rectangle(x, y) {
        return new Rectangle3(x, y, this.width, this.height);
      }
      clone() {
        return new SizeValue(this.width, this.height);
      }
      scale(sx, sy) {
        if (sy === void 0) {
          sy = sx;
        }
        this.width *= sx;
        this.height *= sy;
        return this;
      }
      copy(size) {
        this.width = size.width;
        this.height = size.height;
        return this;
      }
      fitInWidthWithOther(width, otherSizeValue = new SizeValue()) {
        this.copy(SizeValue.fitTwoInWidth(width, this, otherSizeValue)[0]);
        return this;
      }
      static fitTwoInWidth(width, size1, size2) {
        const crossRatio = size1.width * size2.height + size1.height * size2.width;
        const a = size2.height * width / crossRatio;
        const newWidth1 = size1.width * a;
        const newHeight = size1.height * a;
        return [
          new SizeValue(newWidth1, newHeight),
          new SizeValue(width - newWidth1, newHeight)
        ];
      }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/text-design-asset-manager.js
var import_p_map, TextDesignAssetManager, AssetManager;
var init_text_design_asset_manager = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/text-design-asset-manager.js"() {
    init_core();
    import_p_map = __toESM(require("p-map"));
    TextDesignAssetManager = class extends configurable_default {
      loadImages(images) {
        return __async(this, null, function* () {
          return (0, import_p_map.default)(images, (image) => __async(this, null, function* () {
            return this.addImage(image.path, image.fullPath, image.image);
          }));
        });
      }
      addImage(path, fullPath, image, crossOrigin = "anonymous") {
        const images = this.getImages();
        if (!image) {
          return new Promise((resolve, reject) => {
            image = new image_default();
            image.onload = () => {
              images[path] = { fullPath, image };
              resolve({ fullPath, image });
            };
            image.crossOrigin = utils_default.getCrossOriginValue(crossOrigin);
            image.onerror = reject;
            image.src = fullPath;
          });
        }
        images[path] = { fullPath, image };
        return Promise.resolve({ fullPath, image });
      }
      getImage(path) {
        const images = this.getImages();
        const image = images[path];
        return image ? image.image : null;
      }
      getVariation(identifier) {
        return this.getFonts()[identifier];
      }
      addFont(identifier, fontVariation) {
        const fonts = this.getFonts();
        fonts[identifier] = fontVariation;
        return fontVariation;
      }
    };
    TextDesignAssetManager.prototype.availableOptions = {
      images: { type: "object" /* OBJECT */, default: {} },
      fonts: { type: "object" /* OBJECT */, default: {} }
    };
    AssetManager = new TextDesignAssetManager();
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/text/text-design-font.js
var getPixel, isTransparent, isBlankScanline, getDescender, getAscender, strokeLine, hLine, drawRect, TextDesignFont;
var init_text_design_font = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/text/text-design-font.js"() {
    init_core();
    init_size_value();
    init_text_design_asset_manager();
    getPixel = (data, x, y, width) => {
      const index = y * (width * 4) + x * 4;
      const pixel = {
        r: data[index],
        g: data[index + 1],
        b: data[index + 2],
        a: data[index + 3]
      };
      return pixel;
    };
    isTransparent = (pixel) => pixel.a <= 254;
    isBlankScanline = (data, y, width) => {
      let isBlank = true;
      for (let x = 0; x < width; x++) {
        const pixel = getPixel(data, x, y, width);
        if (!isTransparent(pixel)) {
          isBlank = false;
          break;
        }
      }
      return isBlank;
    };
    getDescender = (pixels, width, height, startY, exitOnFirstBlank = false) => {
      let descender = 0;
      for (let y = startY + 1; y < height; y++) {
        if (!isBlankScanline(pixels, y, width)) {
          descender = y - startY + 1;
        } else if (exitOnFirstBlank) {
          break;
        }
      }
      return descender;
    };
    getAscender = (pixels, width, height, startY, exitOnFirstBlank = false) => {
      let ascender = 0;
      for (let y = startY - 1; y >= 0; y--) {
        if (!isBlankScanline(pixels, y, width)) {
          ascender = startY - y;
        } else if (exitOnFirstBlank) {
          break;
        }
      }
      return ascender;
    };
    strokeLine = (ctx, fromX, fromY, toX, toY) => {
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();
    };
    hLine = (ctx, y, xmin, xmax, color = "red") => {
      ctx.save();
      ctx.strokeStyle = color;
      strokeLine(ctx, xmin, y, xmax, y);
      ctx.restore();
    };
    drawRect = (ctx, x, y, width, height, color = "blue") => {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.strokeRect(x, y, width, height);
      ctx.restore();
    };
    TextDesignFont = class extends configurable_default {
      constructor(options) {
        super(options);
        const fontVariation = AssetManager.getVariation(this.getFontIdentifier());
        if (!fontVariation) {
          log_default.warn(`TextDesignFont: Unable to find font '${this._fontIdentifier}'`);
        }
        this.set({ fontVariation });
        this._metrics = null;
        this._canvas = utils_default.createCanvas();
        this._context = this._canvas.getContext("2d");
        this._isDirty = true;
      }
      _onOptionsChange() {
        this._isDirty = true;
      }
      setOption(optionName, value, update = true, initial = false) {
        super.setOption(optionName, value, update, initial);
        if (optionName === "fontIdentifier" && !initial) {
          this.updateFontVariation();
        }
      }
      updateFontVariation() {
        const fontVariation = AssetManager.getVariation(this.getFontIdentifier());
        if (!fontVariation) {
          log_default.warn(`TextDesignFont: Unable to find font '${this._fontIdentifier}'`);
        }
        this.setFontVariation(fontVariation);
        return fontVariation;
      }
      setOptions(options = {}) {
        this._options = __spreadValues(__spreadValues({}, this._options), options);
        this._isDirty = true;
      }
      _applyTextOptions(ctx = this._context, options = {}) {
        const { fontSize, fontVariation, lineHeight, textColor, alignment } = __spreadValues(__spreadValues({}, this._options), options);
        const {
          fontStyle,
          fontWeight,
          fontFamily
        } = fontVariation.serializeOptions();
        if (true) {
          ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
        }
        if (false) {
          ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px / ${lineHeight} ${fontFamily}`;
        }
        ctx.fillStyle = textColor;
        ctx.textBaseline = "alphabetic";
        ctx.textAlign = alignment || "left";
      }
      getTextMetrics() {
        if (!this._metrics || this._isDirty) {
          this._calculateTextMetrics();
        }
        return __spreadValues({}, this._metrics);
      }
      getSizeValue() {
        if (!this._metrics || this._isDirty) {
          this._calculateTextMetrics();
        }
        return new SizeValue(this._metrics.width, this._metrics.height);
      }
      fitWidth(width) {
        const variation = this.getFontVariation();
        if (!variation) {
          log_default.warn("TextDesignFont#fitText: missing font variation");
          return;
        }
        this._applyTextOptions(this._context, { fontSize: 50 });
        const measuredWidth = this._context.measureText(this.getText()).width;
        const scale = width / measuredWidth;
        const fontSize = Math.floor(scale * 50);
        this.setFontSize(fontSize);
        this._calculateTextMetrics();
        return this.getTextMetrics();
      }
      fitHeight(height) {
        const variation = this.getFontVariation();
        if (!variation) {
          log_default.warn("TextDesignFont#fitText: missing font variation");
          return;
        }
        const measuredHeight = this._calculateTextMetrics({ fontSize: 50 }).height;
        const scale = height / measuredHeight;
        const fontSize = Math.floor(scale * 50);
        this.setFontSize(fontSize);
        this._calculateTextMetrics();
        return this.getTextMetrics();
      }
      _calculateTextMetrics(overrideOptions = {}) {
        const canvas = this._canvas;
        const ctx = this._context;
        const options = __spreadValues(__spreadValues({}, this._options), overrideOptions);
        const text = this.getText();
        this._applyTextOptions(ctx, options);
        const textWidth = Math.ceil(ctx.measureText(text).width);
        const canvasWidth = Math.floor(textWidth + options.fontSize * 2);
        const canvasHeight = Math.floor(options.fontSize * 3);
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const xPos = Math.floor(options.fontSize);
        const yPos = Math.floor(canvasHeight * (3 / 5));
        this._applyTextOptions(ctx, options);
        ctx.fillText(text, xPos, yPos);
        const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const ascender = getAscender(pixels, canvasWidth, canvasHeight, yPos, this._options.excludeAccents);
        const descender = getDescender(pixels, canvasWidth, canvasHeight, yPos, this._options.excludeAccents);
        const width = textWidth;
        const height = ascender + descender;
        this._metrics = {
          width,
          height,
          ascender,
          descender
        };
        this._isDirty = false;
        return __spreadValues({}, this._metrics);
      }
      draw(ctx = this._context, x = 0, y = 0, options, debug = false) {
        ctx.save();
        if (!this._metrics || this._isDirty) {
          this._calculateTextMetrics();
        }
        this._applyTextOptions(ctx, options);
        ctx.fillText(this.getText(), x, y + this._metrics.ascender);
        if (debug) {
          drawRect(ctx, x, y, this._metrics.width, this._metrics.height);
          hLine(ctx, y + this._metrics.ascender, x, x + this._metrics.width);
        }
        ctx.restore();
      }
    };
    TextDesignFont.prototype.availableOptions = {
      text: { type: "string" /* STRING */, default: "" },
      fontIdentifier: {
        type: "string" /* STRING */,
        default: "imgly_font_open_sans_bold"
      },
      fontVariation: { type: "object" /* OBJECT */, default: null },
      lineHeight: { type: "number" /* NUMBER */, default: 1 },
      fontSize: { type: "number" /* NUMBER */, default: 22 },
      textColor: { type: "string" /* STRING */, default: "black" },
      strokeStyle: { type: "string" /* STRING */, default: "black" },
      outlineWidth: { type: "number" /* NUMBER */, default: 0 },
      textBaseline: { type: "string" /* STRING */, default: "alphabetic" },
      excludeAccents: { type: "boolean" /* BOOLEAN */, default: false }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-element.js
var TextDesignElement;
var init_text_design_element = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-element.js"() {
    init_core();
    TextDesignElement = class extends configurable_default {
    };
    TextDesignElement.prototype.availableOptions = {
      text: { type: "string" /* STRING */, default: "" },
      frame: { type: "object" /* OBJECT */, default: null },
      font: { type: "object" /* OBJECT */, default: null }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-attributes.js
var TextDesignAttributes;
var init_text_design_attributes = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-attributes.js"() {
    init_core();
    TextDesignAttributes = class extends configurable_default {
    };
    TextDesignAttributes.prototype.availableOptions = {
      tintColor: { type: "color" /* COLOR */, default: color_default.BLACK },
      textColor: { type: "color" /* COLOR */, default: color_default.BLACK },
      alignment: {
        type: "string" /* STRING */,
        default: "left",
        available: ["left", "center", "right"]
      },
      lineSpacing: { type: "number" /* NUMBER */, default: 1 },
      fontIdentifier: {
        type: "string" /* STRING */,
        default: "imgly_font_open_sans_bold"
      }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/default/text-design-row.js
var Rectangle4, TextDesignRow;
var init_text_design_row = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/default/text-design-row.js"() {
    init_core();
    init_size_value();
    init_text_design_attributes();
    ({ Rectangle: Rectangle4 } = math_exports);
    TextDesignRow = class extends configurable_default {
      constructor(options) {
        super(options);
        this.setSize(new SizeValue(this.getWidth(), 0));
        this.serverImageSmoothingFix = false;
      }
      _getFrame() {
        const size = this.getSize();
        return new Rectangle4(0, 0, size.width, size.height);
      }
      _getTextFrame() {
        return this._getFrame();
      }
      _getTextFrameForElement(element) {
        return element.getFrame().clone();
      }
      _calculateLayoutElements() {
        log_default.warn("TextDesignRow is an abstract class.");
      }
      _getLayoutElements() {
        if (this._options.elements.length <= 0) {
          this.layout();
        }
        return this.getElements();
      }
      _fontSize(element) {
        log_default.warn("TextDesignRow#_fontSize not implemented. @TODO: Is it necessary?");
        return 0;
      }
      layout() {
        this.setElements(this._calculateLayoutElements());
        return this;
      }
      textFrame(element, fontSize) {
        return element.getFrame().clone();
      }
      willRender(context) {
      }
      didRender(context) {
      }
      render(context) {
        context.save();
        this._getLayoutElements().forEach((element) => {
          const { text, frame, font } = element.serializeOptions();
          const attributes = this.getAttributes();
          font.draw(context, frame.x, frame.y, {
            textColor: attributes.getTextColor().toRGBA(),
            alignment: attributes.getAlignment()
          });
        });
        context.restore();
      }
    };
    TextDesignRow.prototype.availableOptions = {
      words: { type: "object" /* OBJECT */, default: null },
      width: { type: "number" /* NUMBER */, default: 100 },
      attributes: {
        type: "configurable" /* CONFIGURABLE */,
        default: new TextDesignAttributes()
      },
      shearingAngle: { type: "number" /* NUMBER */, default: 0 },
      elements: { type: "array" /* ARRAY */, default: [] },
      size: { type: "object" /* OBJECT */, default: null }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/blocks/text-design-row-triple.js
var Rectangle5, _TextDesignRowTriple, TextDesignRowTriple;
var init_text_design_row_triple = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/blocks/text-design-row-triple.js"() {
    init_core();
    init_text_design_font();
    init_text_design_element();
    init_text_design_row();
    ({ Rectangle: Rectangle5 } = math_exports);
    _TextDesignRowTriple = class extends TextDesignRow {
      _calculateLayoutElements() {
        if (this.getWords().size() <= 0) {
          return [];
        }
        const {
          orientation,
          width,
          size,
          relativeRowOffset,
          attributes
        } = this.serializeOptions();
        const { fontIdentifier } = attributes;
        const wordGroups = this.getWords().joined(3);
        const lines = orientation === _TextDesignRowTriple.Orientations.Left ? [wordGroups[0], wordGroups[1], wordGroups[2]] : [wordGroups[1], wordGroups[2], wordGroups[0]];
        const dummyFonts = utils_default.Array.range(0, 2).map((i) => new TextDesignFont({
          text: lines[i],
          fontIdentifier,
          fontSize: 60
        }));
        const dummySizes = dummyFonts.map((font) => font.getSizeValue());
        const largestWidthIndex = dummySizes[0].width > dummySizes[1].width ? 0 : 1;
        const smallestWidthIndex = (largestWidthIndex + 1) % 2;
        dummyFonts[smallestWidthIndex].fitWidth(dummySizes[largestWidthIndex].width);
        dummySizes[smallestWidthIndex] = dummyFonts[smallestWidthIndex].getSizeValue();
        const dummyHeight = (dummySizes[smallestWidthIndex].height + dummySizes[largestWidthIndex].height) / (1 - relativeRowOffset);
        const dummySingleRowFont = new TextDesignFont({
          text: lines[2],
          fontIdentifier
        });
        dummySingleRowFont.fitHeight(dummyHeight);
        const dummySingleRowWidth = dummySingleRowFont.getSizeValue().width;
        const dummyDoubleRowWidth = dummySizes[largestWidthIndex].width;
        const scale = width / (dummySingleRowWidth + dummyDoubleRowWidth);
        const singleRowWidth = scale * dummySingleRowWidth;
        const doubleRowWidth = scale * dummyDoubleRowWidth;
        const rowHeight = scale * dummyHeight;
        const offset = relativeRowOffset * rowHeight;
        size.set(width, rowHeight);
        const fonts = utils_default.Array.range(0, 3).map((i) => new TextDesignFont({ text: lines[i], fontIdentifier }));
        fonts[0].fitWidth(doubleRowWidth);
        fonts[1].fitWidth(doubleRowWidth);
        fonts[2].fitWidth(singleRowWidth);
        const doubleRowX = orientation === _TextDesignRowTriple.Orientations.Left ? 0 : singleRowWidth;
        const singleRowX = orientation === _TextDesignRowTriple.Orientations.Left ? doubleRowWidth : 0;
        const xOffsets = [doubleRowX, doubleRowX, singleRowX];
        const yOffsets = [0, fonts[0].getSizeValue().height + offset, 0];
        const frames = fonts.map((font, i) => new Rectangle5(xOffsets[i], yOffsets[i], font.getSizeValue().width, font.getSizeValue().height));
        return fonts.map((font, i) => new TextDesignElement({
          text: lines[i],
          font: fonts[i],
          frame: frames[i]
        }));
      }
    };
    TextDesignRowTriple = _TextDesignRowTriple;
    __publicField(TextDesignRowTriple, "Orientations", {
      Right: "RIGHT",
      Left: "LEFT"
    });
    TextDesignRowTriple.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignRow.prototype.availableOptions), {
      orientation: {
        type: "string" /* STRING */,
        default: TextDesignRowTriple.Orientations.Left,
        available: [
          TextDesignRowTriple.Orientations.Right,
          TextDesignRowTriple.Orientations.Left
        ]
      },
      relativeRowOffset: { type: "number" /* NUMBER */, default: 0.05 }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rectangle-insets.js
var Rectangle6, RectangleInsets;
var init_rectangle_insets = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rectangle-insets.js"() {
    init_core();
    ({ Rectangle: Rectangle6 } = math_exports);
    RectangleInsets = class {
      constructor(top = 0, left = 0, bottom = 0, right = 0) {
        this.top = top;
        this.left = left;
        this.bottom = bottom;
        this.right = right;
      }
      multiply(a) {
        this.top *= a;
        this.left *= a;
        this.bottom *= a;
        this.right *= a;
      }
      toObject() {
        return __spreadValues({}, this);
      }
      equals(r, eps = 0) {
        return Math.abs(r.top - this.top) <= eps && Math.abs(r.left - this.left) <= eps && Math.abs(r.bottom - this.bottom) <= eps && Math.abs(r.right - this.right) <= eps;
      }
      scale(sx = 1, sy) {
        if (sy === void 0) {
          sy = sx;
        }
        this.top *= sy;
        this.bottom *= sy;
        this.left *= sx;
        this.right *= sx;
        return this;
      }
      clone() {
        return new RectangleInsets(this.top, this.left, this.bottom, this.right);
      }
      applyToRectangle(rect) {
        return new Rectangle6(rect.x + this.left, rect.y + this.top, rect.width - this.left - this.right, rect.height - this.top - this.bottom);
      }
      static get ZERO() {
        return new RectangleInsets(0, 0, 0, 0);
      }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/default/text-design-row-single.js
var TextDesignRowSingle;
var init_text_design_row_single = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/default/text-design-row-single.js"() {
    init_core();
    init_text_design_font();
    init_rectangle_insets();
    init_text_design_element();
    init_text_design_row();
    TextDesignRowSingle = class extends TextDesignRow {
      _calculateLayoutElements() {
        const { attributes, imageInsets, size, width } = this.serializeOptions();
        const text = this.getWords().joined(1)[0] || "";
        const { fontIdentifier } = attributes;
        const font = new TextDesignFont({ text, fontIdentifier });
        font.fitWidth(this._getTextFrame().width);
        const height = font.getTextMetrics().height + imageInsets.top + imageInsets.bottom;
        size.height = height;
        const frame = this._getTextFrame();
        const layoutElement = new TextDesignElement({ text, frame, font });
        return [layoutElement];
      }
    };
    TextDesignRowSingle.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignRow.prototype.availableOptions), {
      imageInsets: { type: "object" /* OBJECT */, default: new RectangleInsets() }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/utils/canvas.js
var Rectangle7, Vector226, drawImageRect, fillRect, drawRoundedRect, strokeRect, fillRectPunctuated, buildCapRectangle, drawImageWithCapInsets, drawImageFrame;
var init_canvas = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/utils/canvas.js"() {
    init_core();
    ({ Rectangle: Rectangle7, Vector2: Vector226 } = math_exports);
    drawImageRect = (context, image, srcRect, destRect) => {
      context.drawImage(image, srcRect.x, srcRect.y, srcRect.width, srcRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
    };
    fillRect = (context, rect, color, compositeOperation = "source-over", stroke = false) => {
      context.save();
      context.fillStyle = color.toRGBA();
      context.globalCompositeOperation = compositeOperation;
      context.fillRect(rect.x, rect.y, rect.width, rect.height);
      if (stroke) {
        context.strokeStyle = color.toRGBA();
        context.strokeWith = 1;
        context.strokeRect(rect.x, rect.y, rect.width, rect.height);
      }
      context.restore();
    };
    drawRoundedRect = (context, rect, radius, color, compositeOperation = "source-over", stroke = false) => {
      context.save();
      context.fillStyle = color.toRGBA();
      context.globalCompositeOperation = compositeOperation;
      radius = Math.min(Math.max(radius, 0), Math.min(rect.height, rect.width) * 0.5);
      const left = rect.x;
      const right = rect.x + rect.width;
      const top = rect.y;
      const bottom = rect.y + rect.height;
      context.beginPath();
      context.moveTo(left + radius, top);
      context.arcTo(right, top, right, bottom, radius);
      context.arcTo(right, bottom, left, bottom, radius);
      context.arcTo(left, bottom, left, top, radius);
      context.arcTo(left, top, right, top, radius);
      context.closePath();
      context.fill();
      if (stroke) {
        context.stroke();
      }
      context.restore();
    };
    strokeRect = (context, rect, color, lineWidth = 4) => {
      context.save();
      context.strokeStyle = color.toRGBA();
      context.lineWidth = lineWidth;
      context.strokeRect(rect.x, rect.y, rect.width, rect.height);
      context.restore();
    };
    fillRectPunctuated = (context, rect, color, compositeOperation = "source-over") => {
      context.save();
      const radius = rect.height / 2;
      const centerY = rect.y + radius;
      let centerX = rect.x + radius;
      const endX = rect.x + rect.width;
      context.fillStyle = color.toRGBA();
      context.globalCompositeOperation = compositeOperation;
      while (centerX < endX) {
        context.beginPath();
        context.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        context.fill();
        centerX += radius * 4;
      }
      context.restore();
    };
    buildCapRectangle = (rectangle, capInsets) => {
      const center = capInsets.applyToRectangle(rectangle);
      const { x, y, width, height } = rectangle;
      const corners = [
        Rectangle7.FromDiagonalPoints(new Vector226(0, 0), new Vector226(center.x, center.y)),
        Rectangle7.FromDiagonalPoints(new Vector226(0, center.y + center.height), new Vector226(center.x, height)),
        Rectangle7.FromDiagonalPoints(new Vector226(center.x + center.width, center.y + center.height), new Vector226(width, height)),
        Rectangle7.FromDiagonalPoints(new Vector226(center.x + center.width, 0), new Vector226(width, center.y))
      ].map((r) => r.translate(x, y));
      const bars = [
        Rectangle7.FromDiagonalPoints(new Vector226(center.x, 0), new Vector226(center.x + center.width, center.y)),
        Rectangle7.FromDiagonalPoints(new Vector226(0, center.y), new Vector226(center.x, center.y + center.height)),
        Rectangle7.FromDiagonalPoints(new Vector226(center.x, center.y + center.height), new Vector226(center.x + center.width, height)),
        Rectangle7.FromDiagonalPoints(new Vector226(center.x + center.width, center.y), new Vector226(width, center.y + center.height))
      ].map((r) => r.translate(x, y));
      return { corners, bars, center };
    };
    drawImageWithCapInsets = (context, image, destRect, capInsets) => {
      const imageWidth = image.naturalWidth || image.width;
      const imageHeight = image.naturalHeight || image.height;
      const capSource = buildCapRectangle(new Rectangle7(0, 0, imageWidth, imageHeight), capInsets);
      const capDest = buildCapRectangle(destRect, capInsets);
      drawImageRect(context, image, capSource.center, capDest.center);
      utils_default.Array.zip(capSource.corners, capDest.corners).forEach(([src, dst]) => drawImageRect(context, image, src, dst));
      utils_default.Array.zip(capSource.bars, capDest.bars).forEach(([src, dst]) => drawImageRect(context, image, src, dst));
    };
    drawImageFrame = (context, image, frame, color, compositeMode = "source-atop") => {
      context.save();
      if (color) {
        context.globalAlpha = color.a;
      }
      context.drawImage(image, frame.x, frame.y, frame.width, frame.height);
      if (color) {
        context.globalAlpha = 1;
      }
      if (color) {
        const c = color.clone();
        c.a = 1;
        fillRect(context, frame, c, compositeMode);
      }
      context.restore();
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/masked/text-design-row-masked.js
var TextDesignRowMasked;
var init_text_design_row_masked = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/masked/text-design-row-masked.js"() {
    init_core();
    init_canvas();
    init_rectangle_insets();
    init_text_design_row_single();
    TextDesignRowMasked = class extends TextDesignRowSingle {
      _getTextColor() {
        if (this.getAutoAdjustTextColor() && !this.getIsMasked()) {
          if (this.getBackgroundColor().equals(color_default.WHITE)) {
            return color_default.BLACK;
          }
          return color_default.WHITE;
        }
        return this.getAttributes().getTextColor().clone();
      }
      _getTextFrame() {
        return this.getImageInsets().applyToRectangle(this._getFrame());
      }
      _getTextFrameForElement(element) {
        const frame = super._getTextFrameForElement(element);
        const imageInsets = this.getImageInsets();
        if (this.getIsMasked() || this.getIsUsedInInvertedLayout()) {
          frame.y -= imageInsets.top;
        }
        return frame;
      }
      willRender(context) {
        if (true) {
          if (this.serverImageSmoothingFix) {
            context.imageSmoothingEnabled = true;
          }
        }
        const attributes = this.getAttributes();
        attributes.setTextColor(this._getTextColor());
        const image = this.getImage();
        if (image) {
          const capInsets = this.getCapInsets();
          const frame = this._getFrame();
          if (capInsets && !capInsets.equals(RectangleInsets.ZERO)) {
            drawImageWithCapInsets(context, image, frame, capInsets);
          } else {
            context.drawImage(image, frame.x, frame.y, frame.width, frame.height);
          }
          fillRect(context, frame, this.getBackgroundColor(), "source-atop", true);
        }
        if ((this.getIsMasked() || this.getIsUsedInInvertedLayout()) && image) {
          context.save();
          context.globalCompositeOperation = "destination-out";
        }
      }
      didRender(context) {
        super.didRender(context);
        if (this.getIsMasked() || this.getIsUsedInInvertedLayout()) {
          context.restore();
        }
      }
    };
    TextDesignRowMasked.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignRowSingle.prototype.availableOptions), {
      image: { type: "image" /* IMAGE */, default: null },
      capInsets: { type: "object" /* OBJECT */, default: new RectangleInsets() },
      backgroundColor: { type: "color" /* COLOR */, default: color_default.WHITE },
      autoAdjustTextColor: { type: "boolean" /* BOOLEAN */, default: true },
      isMasked: { type: "boolean" /* BOOLEAN */, default: true },
      isUsedInInvertedLayout: { type: "boolean" /* BOOLEAN */, default: false }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-banderole.js
var TextDesignBanderole;
var init_text_design_banderole = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-banderole.js"() {
    init_core();
    init_rectangle_insets();
    TextDesignBanderole = class extends configurable_default {
      insetsForWidth(width) {
        return this.getRelativeInsets().clone().scale(width);
      }
      static get Small() {
        return new TextDesignBanderole({
          imagePath: "text-design/images/imgly_text_design_asset_banderole_small.png",
          fontIdentifier: "imgly_font_outfit_bold",
          relativeInsets: new RectangleInsets(0.05, 0.2, 0.05, 0.2)
        });
      }
      static get Rectangle() {
        return new TextDesignBanderole({
          imagePath: "text-design/images/imgly_text_design_asset_black_background.png",
          fontIdentifier: "imgly_font_outfit_bold",
          relativeInsets: new RectangleInsets(0.05, 0.05, 0.05, 0.05),
          needsImageSmoothingFix: true
        });
      }
      static get Celebrate1() {
        return new TextDesignBanderole({
          imagePath: "text-design/images/imgly_text_design_asset_celebrate_01.png",
          fontIdentifier: "imgly_font_rasa_500",
          relativeInsets: new RectangleInsets(0.05, 0.2, 0.05, 0.2)
        });
      }
      static get Celebrate2() {
        return new TextDesignBanderole({
          imagePath: "text-design/images/imgly_text_design_asset_celebrate_02.png",
          fontIdentifier: "imgly_font_rasa_500",
          relativeInsets: new RectangleInsets(0.05, 0.2, 0.05, 0.2)
        });
      }
    };
    TextDesignBanderole.prototype.availableOptions = {
      image: { type: "image" /* IMAGE */, default: null },
      imagePath: { type: "string" /* STRING */, default: null },
      relativeInsets: { type: "object" /* OBJECT */, default: new RectangleInsets() },
      fontIdentifier: {
        type: "string" /* STRING */,
        default: "imgly_font_open_sans_bold"
      },
      needsImageSmoothingFix: { type: "boolean" /* BOOLEAN */, default: false }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-layout-data.js
var TextDesignLayoutData;
var init_text_design_layout_data = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-layout-data.js"() {
    init_core();
    init_rectangle_insets();
    init_size_value();
    TextDesignLayoutData = class extends configurable_default {
      getSize() {
        const rows = this.getRows();
        const width = this.getWidth();
        const lineCount = rows.length - 1;
        let height = rows.reduce((acc, row) => acc + row.getSize().height, 0);
        height += (lineCount + 1) * this.getRelativeLineSpacing() * width;
        const insets = this.getRelativeInsets().clone().scale(width);
        height += insets.top + insets.bottom;
        return new SizeValue(width, height);
      }
    };
    TextDesignLayoutData.prototype.availableOptions = {
      text: { type: "string" /* STRING */, default: "" },
      lines: { type: "array" /* ARRAY */, default: [] },
      relativeInsets: { type: "object" /* OBJECT */, default: new RectangleInsets() },
      relativeLineSpacing: { type: "number" /* NUMBER */, default: 0 },
      rows: { type: "object" /* OBJECT */, default: [] },
      background: { type: "object" /* OBJECT */, default: null },
      width: { type: "number" /* NUMBER */, default: 0 }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/text/words.js
var Words;
var init_words = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/text/words.js"() {
    init_core();
    Words = class {
      constructor(text) {
        this.words = [];
        if (text) {
          this.splitIntoWords(text);
        }
      }
      splitIntoWords(text) {
        this.words = text.match(/\S+/g) || [];
        return [...this.words];
      }
      get() {
        return [...this.words];
      }
      getWord(index) {
        return this.words[index];
      }
      set(words) {
        this.words = [...words];
        return this;
      }
      slice(start, end) {
        return Words.fromWords(this.words.slice(start, end));
      }
      getLowerCase() {
        return this.words.map((w) => w.toLowerCase());
      }
      getUpperCase() {
        return this.words.map((w) => w.toUpperCase());
      }
      size() {
        return this.words.length;
      }
      countNumberOfCharacters() {
        return this.words.reduce((acc, s) => acc + s.length, 0);
      }
      joined(numberOfLines) {
        const numberOfWords = this.size();
        const wordsPerLine = Math.floor(numberOfWords / numberOfLines);
        const extraWords = numberOfWords % numberOfLines;
        let lineStartPos = 0;
        let lineEndPos = 0;
        return utils_default.Array.range(0, numberOfLines).map((i) => {
          lineStartPos = lineEndPos;
          const numOfWordsInLine = wordsPerLine + (i < extraWords ? 1 : 0);
          lineEndPos = Math.min(lineStartPos + numOfWordsInLine, numberOfWords);
          return utils_default.Array.range(lineStartPos, lineEndPos).reduce((line, j) => line + (j === lineStartPos ? "" : " ") + this.words[j], "");
        });
      }
      static fromWords(words) {
        const result = new Words();
        result.words = [...words];
        return result;
      }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design.js
var MAXIMUM_NUMBER_OF_TRIES, MIN_LINE_COUNT_OF_RANDOM, RANDOM_ADDITIONAL_LINE_PERCENTAGE, TextDesign;
var init_text_design = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design.js"() {
    init_core();
    init_randomizer();
    init_rectangle_insets();
    init_text_design_row_single();
    init_text_design_attributes();
    init_text_design_layout_data();
    init_words();
    MAXIMUM_NUMBER_OF_TRIES = 10;
    MIN_LINE_COUNT_OF_RANDOM = 4;
    RANDOM_ADDITIONAL_LINE_PERCENTAGE = 0.4;
    TextDesign = class extends configurable_default {
      constructor(options) {
        super(options);
        this._relativeInsets = new RectangleInsets();
        this._background = null;
        this._fontRandomizer = new Randomizer(0);
        this._lineNumberRandomizer = new Randomizer(0);
        this._wordsPerLineRandomizer = new Randomizer(0);
        this._seedPool = [
          this._fontRandomizer,
          this._lineNumberRandomizer,
          this._wordsPerLineRandomizer
        ];
      }
      seed(value) {
        this._seedPool.forEach((s) => s.seed(value));
      }
      getImagePaths() {
        return [];
      }
      onImagesLoaded() {
      }
      getMaximumNumberOfTries() {
        return MAXIMUM_NUMBER_OF_TRIES;
      }
      getMinLineCountOfRandom() {
        return MIN_LINE_COUNT_OF_RANDOM;
      }
      getRandomAdditionalLinePercentage() {
        return RANDOM_ADDITIONAL_LINE_PERCENTAGE;
      }
      _fontForRow(index, words) {
        return this._fontRandomizer.pickNext(this.getFontIdentifiers());
      }
      _modifiedText(text) {
        return text.replace("\n", " ").replace("	", " ");
      }
      _minimumNumberOfLines(words) {
        return Math.ceil(Math.sqrt(words.size()));
      }
      _maximumNumberOfLines(words) {
        return words.size();
      }
      _calculatedNumberOfLines(words) {
        let lineCount = this._minimumNumberOfLines(words);
        if (words.size() >= this.getMinLineCountOfRandom()) {
          const max = Math.floor(Math.max(1, lineCount * this.getRandomAdditionalLinePercentage()));
          lineCount += this._lineNumberRandomizer.nextInRange(0, max);
        }
        return Math.min(lineCount, this._maximumNumberOfLines(words));
      }
      _randomizedNumberOfWordsPerLine(numberOfLines, numberOfWords) {
        if (numberOfLines > numberOfWords) {
          log_default.warn("TextDesign#_randomizedNumberOfWordsPerLine: Invalid number of lines");
          return numberOfWords;
        }
        const wordsPerLine = utils_default.Array.repeat(1, numberOfLines);
        utils_default.Array.range(numberOfLines, numberOfWords).forEach((_) => {
          const index = this._wordsPerLineRandomizer.nextInRange(0, numberOfLines - 1);
          wordsPerLine[index] += 1;
        });
        return wordsPerLine;
      }
      _textLines(text) {
        const words = new Words(text);
        const numberOfLines = this._calculatedNumberOfLines(words);
        const numberOfWordsPerLine = this._randomizedNumberOfWordsPerLine(numberOfLines, words.size());
        return numberOfWordsPerLine.reduce((acc, numOfWordsInLine) => ({
          index: acc.index + numOfWordsInLine,
          lines: [
            ...acc.lines,
            words.slice(acc.index, Math.min(acc.index + numOfWordsInLine, words.size()))
          ]
        }), { index: 0, lines: [] }).lines;
      }
      _validTextLines(text) {
        let textLines = this._textLines(text);
        let indexOfLineWithLassThan3Chars = 0;
        do {
          indexOfLineWithLassThan3Chars = utils_default.Array.findIndex(textLines, (words) => words.countNumberOfCharacters() < 3);
          if (indexOfLineWithLassThan3Chars >= 0) {
            const lineBefore = textLines[indexOfLineWithLassThan3Chars - 1];
            const lineAfter = textLines[indexOfLineWithLassThan3Chars + 1];
            const charCountOfLineBefore = lineBefore ? lineBefore.countNumberOfCharacters() : Number.MAX_SAFE_INTEGER;
            const charCountOfLineAfter = lineAfter ? lineAfter.countNumberOfCharacters() : Number.MAX_SAFE_INTEGER;
            if (charCountOfLineBefore < charCountOfLineAfter && lineBefore) {
              lineBefore.words = [
                ...lineBefore.words,
                ...textLines[indexOfLineWithLassThan3Chars].words
              ];
              textLines = [
                ...textLines.slice(0, indexOfLineWithLassThan3Chars),
                ...textLines.slice(indexOfLineWithLassThan3Chars + 1)
              ];
            } else if (lineAfter) {
              lineAfter.words = [
                ...textLines[indexOfLineWithLassThan3Chars].words,
                ...lineAfter.words
              ];
              textLines = [
                ...textLines.slice(0, indexOfLineWithLassThan3Chars),
                ...textLines.slice(indexOfLineWithLassThan3Chars + 1)
              ];
            }
          }
        } while (indexOfLineWithLassThan3Chars > -1 && textLines.length > 1);
        return textLines;
      }
      _modifiedLines(lines) {
        return lines;
      }
      _getBackground() {
        return this._background;
      }
      generateLayoutData(text, width) {
        const updatedText = this._modifiedText(text);
        const lines = this._modifiedLines(this._validTextLines(updatedText));
        const insetWidth = width * (1 - this._relativeInsets.left - this._relativeInsets.right);
        const rows = this._layoutRows(lines, insetWidth);
        return new TextDesignLayoutData({
          text: updatedText,
          relativeInsets: this._relativeInsets.clone(),
          relativeLineSpacing: this.getRelativeLineSpacing(),
          background: this._background || this._getBackground(),
          lines,
          rows,
          width
        });
      }
      _layoutRows(lines, width) {
        return lines.map((line, index) => this._randomLayoutRow(line, index, width, new TextDesignAttributes({
          fontIdentifier: this._fontForRow(index, line)
        })).layout());
      }
      _randomLayoutRow(words, index, width, attributes) {
        return new TextDesignRowSingle({ words, width, attributes });
      }
    };
    __publicField(TextDesign, "defaultFontIdentifiers", []);
    __publicField(TextDesign, "identifier", "textdesign");
    TextDesign.prototype.availableOptions = {
      fontIdentifiers: { type: "array" /* ARRAY */, default: [] },
      relativeLineSpacing: { type: "number" /* NUMBER */, default: 0 }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks.js
var TextDesignBlocks;
var init_text_design_blocks = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks.js"() {
    init_core();
    init_randomizer();
    init_text_design_row_triple();
    init_text_design_row_single();
    init_text_design_row_masked();
    init_text_design_attributes();
    init_text_design_banderole();
    init_text_design_asset_manager();
    init_text_design();
    TextDesignBlocks = class extends TextDesign {
      constructor(...args) {
        super(...args);
        __publicField(this, "getImagePaths", () => {
          const banderoles = this.getBanderoles();
          return banderoles && banderoles.map((b) => b.getImagePath()) || [];
        });
        __publicField(this, "onImagesLoaded", () => {
          const banderoles = this.getBanderoles();
          if (banderoles) {
            banderoles.forEach((b) => {
              const image = AssetManager.getImage(b.getImagePath());
              if (!image) {
                log_default.warn(`TextDesignBlocks#onImagesLoaded: Image not found '${b.getImagePath()}'`);
                return;
              }
              b.setImage(image);
            });
          }
        });
        this._rowTypeLessThan3WordsRandomizer = new Randomizer(0);
        this._rowTypeMoreThan3WordsRandomizer = new Randomizer(0);
        this._banderolesRandomizer = new Randomizer(0);
        this._seedPool = [
          ...this._seedPool,
          this._rowTypeLessThan3WordsRandomizer,
          this._rowTypeMoreThan3WordsRandomizer,
          this._banderolesRandomizer
        ];
      }
      _modifiedText(text) {
        return super._modifiedText(text).toUpperCase();
      }
      generateLayoutData(text, width) {
        this._options.hasMaskedText = false;
        return super.generateLayoutData(text, width);
      }
      _randomLayoutRow(words, index, width, attributes) {
        if (words.size() < 3) {
          const isMasked = this._rowTypeLessThan3WordsRandomizer.nextInRange(0, 2) === 0;
          return this._layoutRow(words, width, attributes, isMasked);
        }
        const randomValue = this._rowTypeMoreThan3WordsRandomizer.nextInRange(0, 3);
        switch (randomValue) {
          case 0:
            return new TextDesignRowTriple({
              words,
              width,
              attributes,
              orientation: TextDesignRowTriple.Orientations.Left
            });
          case 1:
            return new TextDesignRowTriple({
              words,
              width,
              attributes,
              orientation: TextDesignRowTriple.Orientations.Right
            });
          case 2:
            return this._layoutRow(words, width, attributes, true);
          case 3:
            return new TextDesignRowSingle({ words, width, attributes });
          default:
            throw new Error(`TextDesignBlocks#_randomLayoutRow: Invalid randomValue generated: ${randomValue}.`);
        }
      }
      _layoutRow(words, width, attributes, isMasked) {
        if (this.getHasMaskedText()) {
          isMasked = false;
        }
        if (isMasked) {
          this.setHasMaskedText(true);
          const banderole = this._banderolesRandomizer.pickNext(this.getBanderoles());
          const row = new TextDesignRowMasked({
            words,
            width,
            attributes: new TextDesignAttributes({
              alignment: "left",
              fontIdentifier: banderole.getFontIdentifier()
            }),
            image: banderole.getImage(),
            imageInsets: banderole.insetsForWidth(width),
            capInsets: null,
            backgroundColor: color_default.WHITE
          });
          if (banderole.getNeedsImageSmoothingFix()) {
            row.serverImageSmoothingFix = true;
          }
          return row;
        }
        return new TextDesignRowSingle({ words, width, attributes });
      }
    };
    __publicField(TextDesignBlocks, "defaultFontIdentifiers", ["imgly_font_outfit_bold"]);
    __publicField(TextDesignBlocks, "identifier", "imgly_text_design_blocks");
    __publicField(TextDesignBlocks, "defaultBanderoles", [
      TextDesignBanderole.Rectangle,
      TextDesignBanderole.Small
    ]);
    TextDesignBlocks.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesign.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignBlocks.defaultFontIdentifiers
      },
      relativeLineSpacing: { type: "number" /* NUMBER */, default: 0.025 / 3 },
      hasMaskedText: { type: "boolean" /* BOOLEAN */, default: false },
      banderoles: {
        type: "array" /* ARRAY */,
        default: TextDesignBlocks.defaultBanderoles
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-condensed.js
var TextDesignBlocksCondensed;
var init_text_design_blocks_condensed = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-condensed.js"() {
    init_core();
    init_text_design_row_single();
    init_text_design_blocks();
    TextDesignBlocksCondensed = class extends TextDesignBlocks {
      constructor(...args) {
        super(...args);
        this._exclusiveFont = null;
      }
      generateLayoutData(text, width) {
        this._exclusiveFont = this._fontRandomizer.pickNext(this.getFontIdentifiers());
        return super.generateLayoutData(text, width);
      }
      _fontForRow(index, words) {
        return this._exclusiveFont || super._fontForRow(index, words);
      }
      _layoutRow(words, width, attributes, isMasked) {
        return new TextDesignRowSingle({ words, width, attributes });
      }
    };
    __publicField(TextDesignBlocksCondensed, "defaultFontIdentifiers", [
      "imgly_font_ostrich_sans_heavy",
      "imgly_font_ostrich_sans_bold",
      "imgly_font_ostrich_sans_black"
    ]);
    __publicField(TextDesignBlocksCondensed, "identifier", "imgly_text_design_blocks_condensed");
    TextDesignBlocksCondensed.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignBlocks.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignBlocksCondensed.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/shearing/text-design-row-form.js
var Rectangle8, _TextDesignRowForm, TextDesignRowForm;
var init_text_design_row_form = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/shearing/text-design-row-form.js"() {
    init_core();
    init_canvas();
    init_size_value();
    init_text_design_element();
    init_text_design_row();
    ({ Rectangle: Rectangle8 } = math_exports);
    _TextDesignRowForm = class extends TextDesignRow {
      constructor(...args) {
        super(...args);
        this.setSize(new SizeValue(this.getWidth(), this.getHeight()));
      }
      _calculateLayoutElements() {
        return [new TextDesignElement({ frame: this._getTextFrame() })];
      }
      render(context) {
        const frame = this._getFrame();
        const type = this.getType();
        const attributes = this.getAttributes();
        const color = attributes.getTextColor();
        const rectHeight = frame.height / 3;
        let firstRect = new Rectangle8(frame.x, frame.y, frame.width, rectHeight);
        let secondRect = new Rectangle8(frame.x, frame.y + rectHeight * 2, frame.width, rectHeight);
        switch (type) {
          case _TextDesignRowForm.FormType.Rect:
            fillRect(context, frame, color);
            break;
          case _TextDesignRowForm.FormType.DoubleRect:
            fillRect(context, firstRect, color);
            fillRect(context, secondRect, color);
            break;
          case _TextDesignRowForm.FormType.DoubleRectFirstPunctuated:
            fillRectPunctuated(context, firstRect, color);
            fillRect(context, secondRect, color);
            break;
          case _TextDesignRowForm.FormType.DoubleRectSecondPunctuated:
            fillRect(context, firstRect, color);
            fillRectPunctuated(context, secondRect, color);
            break;
          case _TextDesignRowForm.FormType.LongLine: {
            const lineHeight = frame.height / 2;
            const rect = new Rectangle8(frame.x, frame.y, frame.width, lineHeight);
            drawRoundedRect(context, rect, rect.height * 0.5, color);
            break;
          }
          case _TextDesignRowForm.FormType.LongAndShortLine: {
            const firstLineHeight = frame.height * 0.2;
            const secondLineHeight = firstLineHeight * 0.75;
            firstRect = new Rectangle8(frame.x, frame.y + firstLineHeight, frame.width, firstLineHeight);
            const secondRectX = frame.x + frame.width * 0.25;
            const secondRectY = frame.y + frame.height - secondLineHeight;
            secondRect = new Rectangle8(secondRectX, secondRectY, frame.width * 0.5, secondLineHeight);
            drawRoundedRect(context, firstRect, firstRect.height * 0.5, color);
            drawRoundedRect(context, secondRect, secondRect.height * 0.5, color);
            break;
          }
          default:
            break;
        }
      }
    };
    TextDesignRowForm = _TextDesignRowForm;
    __publicField(TextDesignRowForm, "FormType", {
      Rect: "RECT",
      DoubleRect: "DOUBLE_RECT",
      DoubleRectFirstPunctuated: "DOUBLE_RECT_FIRST_PUNCTUATED",
      DoubleRectSecondPunctuated: "DOUBLE_RECT_SECOND_PUNCTUATED",
      LongLine: "LONG_LINE",
      LongAndShortLine: "LONG_AND_SHORT_LINE"
    });
    TextDesignRowForm.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignRow.prototype.availableOptions), {
      height: { type: "number" /* NUMBER */, default: 100 },
      type: {
        type: "string" /* STRING */,
        default: TextDesignRowForm.FormType.Rect,
        available: utils_default.values(TextDesignRowForm.FormType)
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-light.js
var TextDesignBlocksLight;
var init_text_design_blocks_light = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-light.js"() {
    init_core();
    init_text_design_row_single();
    init_text_design_row_form();
    init_text_design_blocks();
    TextDesignBlocksLight = class extends TextDesignBlocks {
      _layoutRow(words, width, attributes, isMasked) {
        return new TextDesignRowSingle({ words, width, attributes });
      }
      _layoutRows(lines, width) {
        const elements = super._layoutRows(lines, width);
        const firstFormHeight = 0.032 * width;
        const lastFormHeight = 0.08 * width;
        const firstRow = new TextDesignRowForm({
          width,
          height: firstFormHeight,
          type: TextDesignRowForm.FormType.LongLine,
          shearingAngle: 0
        }).layout();
        const lastRow = new TextDesignRowForm({
          width,
          height: lastFormHeight,
          type: TextDesignRowForm.FormType.LongAndShortLine,
          shearingAngle: 0
        }).layout();
        return [firstRow, ...elements, lastRow];
      }
    };
    __publicField(TextDesignBlocksLight, "defaultFontIdentifiers", ["imgly_font_sue_ellen_francisco"]);
    __publicField(TextDesignBlocksLight, "identifier", "imgly_text_design_blocks_light");
    TextDesignBlocksLight.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignBlocks.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignBlocksLight.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-light-v3_1_0.js
var TextDesignBlocksLightV310;
var init_text_design_blocks_light_v3_1_0 = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-light-v3_1_0.js"() {
    init_core();
    init_text_design_row_single();
    init_text_design_attributes();
    init_text_design_blocks_light();
    TextDesignBlocksLightV310 = class extends TextDesignBlocksLight {
      _layoutRows(lines, width) {
        return lines.map((line, index) => this._randomLayoutRow(line, index, width, new TextDesignAttributes({
          fontIdentifier: this._fontForRow(index, line)
        })).layout());
      }
      _layoutRow(words, width, attributes, isMasked) {
        return new TextDesignRowSingle({ words, width, attributes });
      }
    };
    __publicField(TextDesignBlocksLightV310, "defaultFontIdentifiers", ["imgly_font_sue_ellen_francisco"]);
    __publicField(TextDesignBlocksLightV310, "identifier", "imgly_text_design_blocks_light-v3_1_0");
    TextDesignBlocksLightV310.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignBlocksLight.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignBlocksLightV310.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/image/text-design-row-image.js
var Rectangle9, _TextDesignRowImage, TextDesignRowImage;
var init_text_design_row_image = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/image/text-design-row-image.js"() {
    init_core();
    init_text_design_font();
    init_canvas();
    init_size_value();
    init_text_design_element();
    init_text_design_row_single();
    ({ Rectangle: Rectangle9 } = math_exports);
    _TextDesignRowImage = class extends TextDesignRowSingle {
      getImageSize() {
        const leftImage = this.getLeftImage();
        const rightImage = this.getRightImage();
        const words = this.getWords();
        const attributes = this.getAttributes();
        const fontIdentifier = attributes.getFontIdentifier();
        const imageSize = leftImage ? new SizeValue(leftImage.width, leftImage.height) : new SizeValue();
        const text = words.joined(1)[0];
        if (!text) {
          return imageSize;
        }
        const font = new TextDesignFont({ text, fontIdentifier, fontSize: 50 });
        const textSize = font.getSizeValue();
        const imageCount = rightImage ? 2 : 1;
        imageSize.scale(imageCount, 1);
        const newImageSize = imageSize.clone().fitInWidthWithOther(this._getFrame().width, textSize);
        newImageSize.scale(1 / imageCount, 1);
        return newImageSize;
      }
      _getTextFrame() {
        const textFrame = super._getTextFrame().clone();
        const imageSize = this.getImageSize();
        const rightImage = this.getRightImage();
        const imagePosition = this.getImagePosition();
        if (!rightImage) {
          if (imagePosition === _TextDesignRowImage.ImagePosition.Left) {
            textFrame.x += imageSize.width;
          }
        } else {
          textFrame.x += imageSize.width;
          textFrame.width -= 2 * imageSize.width;
        }
        return textFrame;
      }
      _calculateLayoutElements() {
        const elements = super._calculateLayoutElements();
        const frame = this._getFrame();
        const rightImage = this.getRightImage();
        const imageSize = this.getImageSize();
        const imagePosition = this.getImagePosition();
        const textFrame = this._getTextFrame();
        const attributes = this.getAttributes();
        const fontIdentifier = attributes.getFontIdentifier();
        const font = new TextDesignFont({ text: "stickerClock", fontIdentifier });
        font.fitWidth(this._getTextFrame().width);
        const leftImageRect = new Rectangle9().set(frame.x, frame.y, imageSize.width, imageSize.height);
        if (!rightImage && imagePosition === _TextDesignRowImage.ImagePosition.Right) {
          leftImageRect.x += textFrame.width;
        }
        elements.push(new TextDesignElement({
          text: "stickerClock",
          frame: leftImageRect,
          font
        }));
        if (rightImage) {
          const firstElement = elements[0];
          if (firstElement) {
            const rightImageRect = leftImageRect.clone();
            rightImageRect.translate(firstElement.getFrame().width + rightImageRect.width, 0);
            elements.push(new TextDesignElement({
              text: "stickerClock",
              frame: rightImageRect,
              font
            }));
          }
        }
        return elements;
      }
      render(context) {
        const elements = this._getLayoutElements();
        const attributes = this.getAttributes();
        const textColor = attributes.getTextColor();
        const leftImage = this.getLeftImage();
        const rightImage = this.getRightImage();
        const layoutElement = elements[0];
        const secondElement = elements[1];
        const { font } = layoutElement.serializeOptions();
        const textFrame = this._getTextFrameForElement(layoutElement);
        font.draw(context, textFrame.x, textFrame.y, {
          textColor: attributes.getTextColor().toRGBA(),
          alignment: attributes.getAlignment()
        });
        if (leftImage) {
          const dest = secondElement.getFrame();
          context.drawImage(leftImage, dest.x, dest.y, dest.width, dest.height);
          fillRect(context, dest, textColor, "source-atop");
        }
        if (elements.length > 2) {
          const rightElement = elements[2];
          const rightElementFrame = rightElement.getFrame().clone();
          context.drawImage(rightImage, rightElementFrame.x, rightElementFrame.y, rightElementFrame.width, rightElementFrame.height);
          fillRect(context, rightElementFrame, textColor, "source-atop");
        }
      }
    };
    TextDesignRowImage = _TextDesignRowImage;
    __publicField(TextDesignRowImage, "ImagePosition", {
      Left: "LEFT",
      right: "RIGHT"
    });
    TextDesignRowImage.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignRowSingle.prototype.availableOptions), {
      leftImage: { type: "image" /* IMAGE */, default: null },
      rightImage: { type: "image" /* IMAGE */, default: null },
      imagePosition: {
        type: "string" /* STRING */,
        default: TextDesignRowImage.ImagePosition.Left,
        available: [
          TextDesignRowImage.ImagePosition.Left,
          TextDesignRowImage.ImagePosition.Right
        ]
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-celebrate.js
var _TextDesignCelebrate, TextDesignCelebrate;
var init_text_design_celebrate = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-celebrate.js"() {
    init_core();
    init_text_design_row_single();
    init_text_design_row_image();
    init_text_design_banderole();
    init_words();
    init_text_design_blocks();
    _TextDesignCelebrate = class extends TextDesignBlocks {
      _fontForRow(index, words) {
        const fonts = this.getFontIdentifiers();
        return fonts[index % fonts.length];
      }
      _minimumNumberOfLines(words) {
        return Math.max(Math.floor(super._minimumNumberOfLines(words) * 0.7), 1);
      }
      _maximumNumberOfLines(words) {
        return Math.max(Math.floor(words.countNumberOfCharacters() / 5), 1);
      }
      _randomLayoutRow(words, index, width, attributes) {
        return this._createSingleRow(_TextDesignCelebrate.RowType.Single, words, width, attributes);
      }
      _createSingleRow(rowType, words, width, attributes) {
        const fontIdentifier = attributes.getFontIdentifier();
        const updatedWords = fontIdentifier === "imgly_font_allison_regular" || fontIdentifier === "imgly_font_handycheera_regular" ? new Words().set(words.getLowerCase()) : words;
        switch (rowType) {
          case _TextDesignCelebrate.RowType.Single:
            return new TextDesignRowSingle({
              words: updatedWords,
              width,
              attributes
            });
          case _TextDesignCelebrate.RowType.SingleImage:
            return new TextDesignRowImage({
              words: updatedWords,
              width,
              attributes
            });
          default:
            log_default.warn(`TextDesignCelebrate#_createSingleRow: Invalid row type '${rowType}'`);
            return null;
        }
      }
    };
    TextDesignCelebrate = _TextDesignCelebrate;
    __publicField(TextDesignCelebrate, "defaultFontIdentifiers", [
      "imgly_font_handycheera_regular",
      "imgly_font_rasa_regular"
    ]);
    __publicField(TextDesignCelebrate, "defaultBanderoles", [
      TextDesignBanderole.Celebrate1,
      TextDesignBanderole.Celebrate2
    ]);
    __publicField(TextDesignCelebrate, "identifier", "imgly_text_design_celebrate");
    __publicField(TextDesignCelebrate, "RowType", {
      Single: "SINGLE",
      SingleImage: "SINGLE_IMAGE"
    });
    TextDesignCelebrate.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignBlocks.prototype.availableOptions), {
      relativeLineSpacing: { type: "number" /* NUMBER */, default: 0.01875 },
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignCelebrate.defaultFontIdentifiers
      },
      banderoles: {
        type: "array" /* ARRAY */,
        default: TextDesignCelebrate.defaultBanderoles
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/image/text-design-row-single-image.js
var TextDesignRowSingleImage;
var init_text_design_row_single_image = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/image/text-design-row-single-image.js"() {
    init_core();
    init_text_design_font();
    init_words();
    init_canvas();
    init_size_value();
    init_text_design_attributes();
    init_text_design_element();
    init_text_design_row();
    TextDesignRowSingleImage = class extends TextDesignRow {
      constructor(...args) {
        super(...args);
        this.setSize(new SizeValue(this.getWidth(), this.getHeight()));
      }
      _getImageFrame() {
        const imageRect = this._getTextFrame().clone();
        const image = this.getImage();
        if (this.getDrawingModeAspectFit() && image) {
          const ratio = Math.min(imageRect.width / image.width, imageRect.height / image.height);
          const newWidth = image.width * ratio;
          const newHeight = image.height * ratio;
          imageRect.x += (imageRect.width - newWidth) / 2;
          imageRect.y += (imageRect.height - newHeight) / 2;
          imageRect.width = newWidth;
          imageRect.height = newHeight;
        }
        return imageRect;
      }
      _calculateLayoutElements() {
        return [
          new TextDesignElement({
            text: "",
            frame: this._getImageFrame(),
            font: new TextDesignFont()
          })
        ];
      }
      render(context) {
        const image = this.getImage();
        const imageFrame = this._getImageFrame();
        const attributes = this.getAttributes();
        const textColor = attributes.getTextColor();
        drawImageFrame(context, image, imageFrame, textColor);
      }
    };
    __publicField(TextDesignRowSingleImage, "RowImages", {
      decorative1: "text-design/images/imgly_text_design_asset_decorative_01.png",
      decorative2: "text-design/images/imgly_text_design_asset_decorative_02.png",
      decorative3: "text-design/images/imgly_text_design_asset_decorative_05.png",
      decorative4: "text-design/images/imgly_text_design_asset_decorative_06.png",
      celebrate1: "text-design/images/imgly_text_design_asset_celebrate_03.png",
      celebrate2: "text-design/images/imgly_text_design_asset_celebrate_04.png",
      celebrate3: "text-design/images/imgly_text_design_asset_celebrate_05.png"
    });
    TextDesignRowSingleImage.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignRow.prototype.availableOptions), {
      words: { type: "object" /* OBJECT */, default: new Words() },
      height: { type: "number" /* NUMBER */, default: 0 },
      image: { type: "image" /* IMAGE */, default: null },
      imagePath: {
        type: "string" /* STRING */,
        default: TextDesignRowSingleImage.RowImages.decorative1
      },
      drawingModeAspectFit: { type: "boolean" /* BOOLEAN */, default: false },
      attributes: {
        type: "configurable" /* CONFIGURABLE */,
        default: new TextDesignAttributes()
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-celebrate-simple.js
var TextDesignCelebrateSimple;
var init_text_design_celebrate_simple = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-celebrate-simple.js"() {
    init_core();
    init_randomizer();
    init_text_design_row_single();
    init_text_design_row_image();
    init_text_design_row_single_image();
    init_text_design_banderole();
    init_text_design_asset_manager();
    init_words();
    init_text_design_blocks();
    init_text_design_celebrate();
    TextDesignCelebrateSimple = class extends TextDesignCelebrate {
      constructor(...args) {
        super(...args);
        __publicField(this, "getImagePaths", () => {
          const banderoles = this.getBanderoles();
          return [
            ...banderoles && banderoles.map((b) => b.getImagePath()) || [],
            ...this._celebrateTypes
          ];
        });
        __publicField(this, "onImagesLoaded", () => {
          const banderoles = this.getBanderoles();
          if (banderoles) {
            banderoles.forEach((b) => {
              const image = AssetManager.getImage(b.getImagePath());
              if (!image) {
                log_default.warn(`TextDesignBlocks#onImagesLoaded: Image not found '${b.getImagePath()}'`);
                return;
              }
              b.setImage(image);
            });
          }
        });
        this._celebrateTypes = [
          TextDesignRowSingleImage.RowImages.celebrate1,
          TextDesignRowSingleImage.RowImages.celebrate2,
          TextDesignRowSingleImage.RowImages.celebrate3
        ];
        this._exclusiveFont = null;
        this._typeRandomizer = new Randomizer(0);
        this._useMaskedRandomizer = new Randomizer(0);
        this._seedPool.push(this._typeRandomizer);
        this._seedPool.push(this._useMaskedRandomizer);
      }
      _fontForRow(index, words) {
        const fonts = this.getFontIdentifiers();
        return fonts[index % (fonts.length - 1)];
      }
      _layoutRows(lines, width) {
        const imagePath = this._typeRandomizer.pickNext(this._celebrateTypes);
        const image = AssetManager.getImage(imagePath);
        if (!image) {
          log_default.warn(`TextDesignCelebrateSimple#_layoutRows: Image not fount '${imagePath}'`);
        }
        const firstRow = new TextDesignRowSingleImage({
          width,
          height: width * 0.5,
          drawingModeAspectFit: true,
          image
        }).layout();
        const rows = super._layoutRows(lines, width);
        return [firstRow, ...rows];
      }
      _randomLayoutRow(words, index, width, attributes) {
        const numberOfCharacters = words.countNumberOfCharacters();
        const maximumNumberOfCharacters = 13;
        const minimumNumberOfCharacters = 4;
        if (numberOfCharacters < minimumNumberOfCharacters) {
          attributes.setFontIdentifier("imgly_font_rasa_regular");
        }
        const isMasked = this._useMaskedRandomizer.nextBool(2, 1);
        if (numberOfCharacters < maximumNumberOfCharacters && isMasked && !this.getHasMaskedText()) {
          return this._layoutRow(words, width, attributes, true);
        }
        return super._randomLayoutRow(words, index, width, attributes);
      }
    };
    __publicField(TextDesignCelebrateSimple, "identifier", "imgly_text_design_celebrate_simple");
    __publicField(TextDesignCelebrateSimple, "defaultFontIdentifiers", [
      "imgly_font_allison_regular",
      "imgly_font_rasa_regular",
      "imgly_font_rasa_500"
    ]);
    TextDesignCelebrateSimple.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignCelebrate.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignCelebrateSimple.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-background.js
var TextDesignBackground;
var init_text_design_background = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-background.js"() {
    init_core();
    TextDesignBackground = class extends configurable_default {
      render(context, size, relativeInsets, color, randomizer) {
        log_default.warn("TextDesignBackground#render: Abstract class");
      }
    };
    TextDesignBackground.prototype.availableOptions = {};
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-equal-width-background.js
var Rectangle10, TextDesignEqualWidthBackground;
var init_text_design_equal_width_background = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-equal-width-background.js"() {
    init_core();
    init_text_design_asset_manager();
    init_canvas();
    init_text_design_background();
    ({ Rectangle: Rectangle10 } = math_exports);
    TextDesignEqualWidthBackground = class extends TextDesignBackground {
      getImagePaths() {
        const {
          topImagePath,
          bottomImagePath,
          leftImagePath,
          rightImagePath
        } = this._options;
        return [
          topImagePath,
          bottomImagePath,
          leftImagePath,
          rightImagePath
        ].filter((path) => path !== "");
      }
      render(context, size, relativeInsets, color, randomizer) {
        const absoluteInsets = relativeInsets.clone().scale(size.width);
        const frame = size.rectangle(0, 0);
        const topImage = AssetManager.getImage(this.getTopImagePath());
        const leftImage = AssetManager.getImage(this.getLeftImagePath());
        const rightImage = AssetManager.getImage(this.getRightImagePath());
        const bottomImage = AssetManager.getImage(this.getBottomImagePath());
        if (topImage) {
          const aspect = topImage.width / topImage.height;
          const destHeight = absoluteInsets.top * this.getTopImageFillRate();
          const destWidth = destHeight * aspect;
          const xCenter = frame.width / 2;
          const xOrigin = xCenter - destWidth / 2;
          const topFrame = new Rectangle10(xOrigin, 0, destWidth, destHeight);
          drawImageFrame(context, topImage, topFrame, color);
        }
        if (bottomImage) {
          const aspect = bottomImage.width / bottomImage.height;
          const destHeight = absoluteInsets.bottom * this.getBottomImageFillRate();
          const destWidth = destHeight * aspect;
          const xCenter = frame.width / 2;
          const xOrigin = xCenter - destWidth / 2;
          const bottomFrame = new Rectangle10(xOrigin, frame.height - destHeight, destWidth, destHeight);
          drawImageFrame(context, bottomImage, bottomFrame, color);
        }
        if (leftImage) {
          const aspect = leftImage.width / leftImage.height;
          const destWidth = absoluteInsets.left * this.getLeftImageFillRate();
          const destHeight = destWidth / aspect;
          const yCenter = frame.height / 2;
          const yOrigin = yCenter - destHeight / 2;
          const leftFrame = new Rectangle10(0, yOrigin, destWidth, destHeight);
          drawImageFrame(context, leftImage, leftFrame, color);
        }
        if (rightImage) {
          const aspect = rightImage.width / rightImage.height;
          const destWidth = absoluteInsets.right * this.getRightImageFillRate();
          const destHeight = destWidth / aspect;
          const yCenter = frame.height / 2;
          const yOrigin = yCenter - destHeight / 2;
          const rightFrame = new Rectangle10(frame.width - destWidth, yOrigin, destWidth, destHeight);
          drawImageFrame(context, rightImage, rightFrame, color);
        }
      }
    };
    TextDesignEqualWidthBackground.prototype.availableOptions = {
      topImagePath: { type: "string" /* STRING */, default: "" },
      leftImagePath: { type: "string" /* STRING */, default: "" },
      bottomImagePath: { type: "string" /* STRING */, default: "" },
      rightImagePath: { type: "string" /* STRING */, default: "" },
      topImageFillRate: { type: "number" /* NUMBER */, default: 1 },
      leftImageFillRate: { type: "number" /* NUMBER */, default: 1 },
      bottomImageFillRate: { type: "number" /* NUMBER */, default: 1 },
      rightImageFillRate: { type: "number" /* NUMBER */, default: 1 }
    };
    TextDesignEqualWidthBackground.Backgrounds = [
      new TextDesignEqualWidthBackground({
        topImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_1.png",
        leftImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_2.png",
        rightImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_2.png",
        bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_3.png",
        topImageFillRate: 0.8,
        leftImageFillRate: 0.6,
        rightImageFillRate: 0.6,
        bottomImageFillRate: 0.8
      }),
      new TextDesignEqualWidthBackground({
        leftImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background2_1.png",
        rightImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background2_1.png",
        bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background2_2.png",
        leftImageFillRate: 0.6,
        rightImageFillRate: 0.6,
        bottomImageFillRate: 0.6
      }),
      new TextDesignEqualWidthBackground({
        topImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background3_1.png",
        bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background3_2.png",
        topImageFillRate: 0.6,
        bottomImageFillRate: 0.6
      }),
      new TextDesignEqualWidthBackground({
        topImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_1.png",
        leftImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_3.png",
        rightImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_3.png",
        bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_2.png",
        topImageFillRate: 0.1,
        leftImageFillRate: 0.6,
        rightImageFillRate: 0.6,
        bottomImageFillRate: 0.6
      })
    ];
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-equal-width.js
var TextDesignEqualWidth;
var init_text_design_equal_width = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-equal-width.js"() {
    init_core();
    init_text_design_equal_width_background();
    init_randomizer();
    init_rectangle_insets();
    init_text_design_row_single();
    init_words();
    init_text_design();
    TextDesignEqualWidth = class extends TextDesign {
      constructor(...args) {
        super(...args);
        this._relativeInsets = new RectangleInsets(0.1, 0.1, 0.1, 0.1);
        this._alreadyContainsARowWithScriptFont = false;
        this._backgroundsRandomizer = new Randomizer(0);
        this._seedPool.push(this._backgroundsRandomizer);
      }
      getImagePaths() {
        return utils_default.Array.flatten(TextDesignEqualWidthBackground.Backgrounds.map((b) => b.getImagePaths()));
      }
      _getBackground() {
        return this._backgroundsRandomizer.pickNext(TextDesignEqualWidthBackground.Backgrounds);
      }
      generateLayoutData(text, width) {
        this._alreadyContainsARowWithScriptFont = false;
        this._background = this._getBackground();
        return super.generateLayoutData(text, width);
      }
      _modifiedText(text) {
        return super._modifiedText(text).toUpperCase();
      }
      _fontForRow(index, words) {
        let fontIdentifier = super._fontForRow(index, words);
        if (fontIdentifier === "imgly_font_petit_formal_script") {
          if (this._alreadyContainsARowWithScriptFont) {
            fontIdentifier = "imgly_font_bungee_inline";
          }
          this._alreadyContainsARowWithScriptFont = true;
        }
        return fontIdentifier;
      }
      _randomLayoutRow(words, index, width, attributes) {
        const lowercase = attributes.getFontIdentifier() === "imgly_font_petit_formal_script";
        return new TextDesignRowSingle({
          words: lowercase ? new Words().set(words.getLowerCase()) : words,
          width,
          attributes
        });
      }
    };
    __publicField(TextDesignEqualWidth, "identifier", "imgly_text_design_equal_width");
    __publicField(TextDesignEqualWidth, "defaultFontIdentifiers", [
      "imgly_font_ultra",
      "imgly_font_bungee_inline",
      "imgly_font_petit_formal_script"
    ]);
    TextDesignEqualWidth.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesign.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignEqualWidth.defaultFontIdentifiers
      },
      relativeLineSpacing: { type: "number" /* NUMBER */, default: 0.025 }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-equal-width-fat.js
var TextDesignEqualWidthFat;
var init_text_design_equal_width_fat = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-equal-width-fat.js"() {
    init_core();
    init_rectangle_insets();
    init_text_design_equal_width();
    TextDesignEqualWidthFat = class extends TextDesignEqualWidth {
      constructor(...args) {
        super(...args);
        this._relativeInsets = new RectangleInsets();
      }
      _getBackground() {
        return null;
      }
    };
    __publicField(TextDesignEqualWidthFat, "defaultFontIdentifiers", ["imgly_font_ultra"]);
    __publicField(TextDesignEqualWidthFat, "identifier", "imgly_text_design_equal_width_fat");
    TextDesignEqualWidthFat.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignEqualWidth.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignEqualWidthFat.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/masked-row-type.js
var RowType;
var init_masked_row_type = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/masked-row-type.js"() {
    init_core();
    init_rectangle_insets();
    RowType = class extends configurable_default {
      insetsForWidth(width) {
        const insets = this.getRelativeInsets().clone();
        return insets.scale(width);
      }
    };
    RowType.prototype.availableOptions = {
      imagePath: { type: "string" /* STRING */, default: "" },
      minimumHeightRatio: { type: "number" /* NUMBER */, default: 0 },
      sizeToFitContent: { type: "boolean" /* BOOLEAN */, default: true },
      capInsets: { type: "object" /* OBJECT */, default: new RectangleInsets() },
      relativeInsets: { type: "object" /* OBJECT */, default: new RectangleInsets() }
    };
    RowType.Box = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_black_background.png",
      relativeInsets: new RectangleInsets(0.1, 0.1, 0.1, 0.1)
    });
    RowType.Badge1 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_badge1.png",
      relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
    });
    RowType.Badge2 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_badge2.png",
      relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
    });
    RowType.Badge3 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_badge3.png",
      relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
    });
    RowType.Badge4 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_badge4.png",
      relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
    });
    RowType.SpeechBubble1 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_speech_bubble_small2.png",
      relativeInsets: new RectangleInsets(0.04, 0.07, 0.12, 0.07),
      capInsets: new RectangleInsets(19 * 3, 57 * 3, 41 * 3, 17 * 3)
    });
    RowType.SpeechBubble2 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_speech_bubble3.png",
      relativeInsets: new RectangleInsets(0.04, 0.07, 0.12, 0.07),
      capInsets: new RectangleInsets(2 * 3, 35 * 3, 29 * 3, 5 * 3)
    });
    RowType.SpeechBubble3 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_speech_bubble_small.png",
      relativeInsets: new RectangleInsets(0.165664675, 0.2, 0.165664675, 0.2),
      minimumHeightRatio: 0.7
    });
    RowType.SpeechBubble4 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_speech_bubble4.png",
      relativeInsets: new RectangleInsets(0.124800224, 0.2, 0.291200523, 0.2),
      minimumHeightRatio: 0.7
    });
    RowType.SpeechBubble5 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_speech_bubble5.png",
      relativeInsets: new RectangleInsets(0.114892823, 0.27, 0.15984926, 0.27)
    });
    RowType.Watercolor1 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_watercolor_01.png",
      minimumHeightRatio: 0.7,
      relativeInsets: new RectangleInsets(0.2, 0.25, 0.2, 0.25)
    });
    RowType.Watercolor2 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_watercolor_02.png",
      minimumHeightRatio: 0.7,
      relativeInsets: new RectangleInsets(0.08, 0.25, 0.3, 0.25)
    });
    RowType.Watercolor3 = new RowType({
      imagePath: "text-design/images/imgly_text_design_asset_watercolor_03.png",
      minimumHeightRatio: 0.7,
      relativeInsets: new RectangleInsets(0.1, 0.2, 0.15, 0.2)
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text/text-splitter.js
var import_split_graphemes, TextSplitter, text_splitter_default;
var init_text_splitter = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text/text-splitter.js"() {
    import_split_graphemes = require("split-graphemes");
    TextSplitter = class {
      constructor(context) {
        this._context = context;
        this._lastFontStyle = {};
      }
      getLines() {
        let lines = [];
        let newLineWords = [];
        const linesCount = this._lines.length;
        for (let l = 0; l < linesCount; l++) {
          const line = this._lines[l];
          const words = this._buildWords(line);
          const wordsCount = words.length;
          for (let w = 0; w < wordsCount; w++) {
            const word = words[w];
            const currentLine = newLineWords.concat(word).join("").replace(/\s+$/i, "");
            const width = this._getWidth(currentLine);
            if (width > this._maxWidth) {
              if (newLineWords.length > 0) {
                lines.push(newLineWords.join(""));
                newLineWords = [word];
              }
              const _word = word.replace(/\s+$/i, "");
              if (this._getWidth(_word) > this._maxWidth) {
                const splitWord = this._splitWord(word);
                lines = lines.concat(splitWord.lines);
                if (splitWord.rest) {
                  newLineWords = [splitWord.rest];
                }
              }
            } else {
              newLineWords.push(word);
            }
          }
          lines.push(newLineWords.join(""));
          newLineWords = [];
        }
        return lines.map((line) => this._trimLine(line, this._context.textAlign));
      }
      _trimLine(line, alignment) {
        return line;
      }
      _buildWords(line) {
        const words = [];
        let word = "";
        const len = line.length;
        for (let i = 0; i < len; i++) {
          const char = line[i];
          word += char;
          if (char === " " || char === "-" || i === len - 1) {
            words.push(word);
            word = "";
          }
        }
        return words;
      }
      _splitWord(raw) {
        const response = {
          lines: [],
          rest: null
        };
        const word = (0, import_split_graphemes.splitGraphemes)(raw);
        const wordLength = word.length;
        let chars = [];
        for (let c = 0; c < wordLength; c++) {
          const char = word[c];
          if (this._getWidth(chars.concat(char).join("")) > this._maxWidth) {
            if (chars.length > 0) {
              response.lines.push(chars.join(""));
            }
            chars = [char];
          } else {
            chars.push(char);
          }
          if (c === wordLength - 1 && chars.length > 0) {
            response.rest = chars.join("");
          }
        }
        return response;
      }
      _fontStyleChanged() {
        if (this._context.font !== this._lastFontStyle) {
          this._lastFontStyle = this._context.font;
          return true;
        }
        return false;
      }
      _getWidth(string) {
        return this._context.measureText(string).width;
      }
      setText(text) {
        this._text = text;
        this._lines = text.split("\n");
      }
      setMaxWidth(maxWidth) {
        this._maxWidth = maxWidth;
      }
    };
    text_splitter_default = TextSplitter;
  }
});

// engine/sdk/operations/sprite-operation/sprites/text/text-renderer.js
var Vector227, TextRenderer, text_renderer_default;
var init_text_renderer = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text/text-renderer.js"() {
    init_core();
    init_text_splitter();
    ({ Vector2: Vector227 } = math_exports);
    TextRenderer = class {
      constructor(text, operation) {
        this._text = text;
        this._operation = operation;
        this._textOptions = {};
        this.rotation = 0;
        this._createCanvas();
        this._createTexture();
      }
      _createCanvas() {
        this._canvas = utils_default.createCanvas();
        this._context = this._canvas.getContext("2d");
        this._textSplitter = new text_splitter_default(this._context);
        this._finalCanvas = utils_default.createCanvas();
        this._finalContext = this._finalCanvas.getContext("2d");
      }
      _createTexture() {
        this._texture = engine_default.Texture.fromCanvas(this._canvas);
        this._finalTexture = engine_default.Texture.fromCanvas(this._finalCanvas);
      }
      _applyTextOptions(textOptions, context) {
        context.font = `${this._text.getFontStyle()} ${this._text.getFontWeight()} ${textOptions.fontSize}px "${this._text.getFontFamily()}"`;
        if (this._text.getTextMetrics()) {
          context.textBaseline = "alphabetic";
        } else {
          context.textBaseline = "top";
        }
        context.textAlign = this._text.getAlignment();
        context.fillStyle = this._text.getColor().toRGBA();
        context.strokeStyle = this._text.getOutlineColor().toRGBA();
        const outlineWidth = this._text.getOutlineWidth();
        if (outlineWidth > 0) {
          context.lineWidth = outlineWidth;
        }
      }
      _buildOutputLines(maxWidth) {
        this._textSplitter.setText(this._text.getText());
        this._textSplitter.setMaxWidth(maxWidth);
        return this._textSplitter.getLines().map((line) => {
          return line.replace(/\s+$/i, "");
        });
      }
      _renderTextLine(text, y, padding) {
        const textAlignment = this._text.getAlignment();
        const drawPosition = new Vector227(0, y);
        switch (textAlignment) {
          case "left":
            drawPosition.x = padding;
            break;
          case "center":
            drawPosition.x = this._canvas.width / 2;
            break;
          case "right":
            drawPosition.x = this._canvas.width - padding;
            break;
        }
        this._context.save();
        this._context.translate(drawPosition.x, drawPosition.y);
        this._context.fillText(text, 0, 0);
        this._context.restore();
        const outlineWidth = this._text.getOutlineWidth();
        if (outlineWidth > 0) {
          this._context.miterLimit = 2;
          this._context.strokeText(text, drawPosition.x, drawPosition.y);
        }
      }
      update(sdk, inputDimensions) {
        const textOptions = this.calculateFontStyles(sdk, inputDimensions);
        if (textOptions) {
          const { dimensions, lines } = this._calculateText(sdk, textOptions, inputDimensions);
          this._renderText(sdk, dimensions, lines, textOptions, inputDimensions);
          this._updateFinalTexture();
        }
      }
      _updateFinalTexture() {
        const { width, height } = this._canvas;
        const { rotation } = this;
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        const finalDimensions = new Vector227(Math.abs(width * cos) + Math.abs(height * sin), Math.abs(width * sin) + Math.abs(height * cos));
        this._finalCanvas.width = finalDimensions.x;
        this._finalCanvas.height = finalDimensions.y;
        this._finalContext.save();
        this._finalContext.translate(this._finalCanvas.width / 2, this._finalCanvas.height / 2);
        this._finalContext.rotate(rotation);
        this._finalContext.drawImage(this._canvas, -width / 2, -height / 2);
        this._finalContext.restore();
      }
      _renderText(sdk, dimensions, lines, textOptions, inputDimensions) {
        this._canvas.width = dimensions.x;
        this._canvas.height = dimensions.y;
        if (this._text.getMaxHeight()) {
          this._canvas.height = Math.min(this._text.getMaxHeight() * inputDimensions.y, this._canvas.height);
        }
        this._context = this._canvas.getContext("2d");
        this._context.fillStyle = this._text.getBackgroundColor().toRGBA();
        this._context.fillRect(0, 0, dimensions.x, dimensions.y);
        this._applyTextOptions(textOptions, this._context);
        const padding = this._padding(inputDimensions);
        const metrics = this._text.getTextMetrics();
        const absoluteFontSize = this._text.getFontSize() * inputDimensions.y;
        const scale = 1 / metrics.unitsPerEm * absoluteFontSize;
        const ascender = metrics.ascender * scale;
        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          this._renderTextLine(line, textOptions.topPadding + textOptions.lineHeight * lineNum + padding + ascender, padding);
        }
      }
      calculateFontStyles(sdk, inputDimensions) {
        const fontFamily = this._text.getFontFamily();
        const fontSize = this._text.getFontSize() * inputDimensions.y;
        const textHeight = this._text.getAbsoluteTextHeight(inputDimensions);
        const lineHeight = textHeight * this._text.getLineHeight();
        const topPadding = textHeight * (this._text.getLineHeight() - 1) / 2;
        const textOptions = { fontFamily, fontSize, lineHeight, topPadding };
        if (this._textOptions.fontFamily !== fontFamily || this._textOptions.fontSize !== fontSize || this._textOptions.lineHeight !== lineHeight) {
          this._textOptions = textOptions;
        }
        return textOptions;
      }
      _calculateText(sdk, textOptions, inputDimensions) {
        const maxWidth = this._text.getMaxWidth() * inputDimensions.x;
        this._applyTextOptions(textOptions, this._context);
        const dimensions = new Vector227();
        let lines = this._text.getText().split("\n");
        if (typeof maxWidth !== "undefined") {
          dimensions.x = maxWidth;
          lines = this._buildOutputLines(maxWidth);
        }
        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          dimensions.x = Math.max(dimensions.x, this._context.measureText(line).width);
        }
        const { lineHeight } = textOptions;
        dimensions.y = lines.length * lineHeight;
        const padding = this._padding(inputDimensions);
        dimensions.y += padding * 2;
        dimensions.x += padding * 2;
        return { dimensions, lines };
      }
      _padding(inputDimensions) {
        const textHeight = this._text.getAbsoluteTextHeight(inputDimensions);
        const relativePadding = 0.2;
        return textHeight * relativePadding;
      }
      getTexture() {
        return this._texture;
      }
      getFinalTexture() {
        return this._finalTexture;
      }
      getDimensions(sdk, inputDimensions) {
        const textOptions = this.calculateFontStyles(sdk, inputDimensions);
        const { dimensions } = this._calculateText(sdk, textOptions, inputDimensions);
        return dimensions;
      }
      dispose() {
        if (this._measurementElement) {
          document.body.removeChild(this._measurementElement);
        }
        if (this._texture) {
          this._texture.dispose();
          this._texture = null;
        }
        if (this._finalTexture) {
          this._finalTexture.dispose();
          this._finalTexture = null;
        }
      }
    };
    text_renderer_default = TextRenderer;
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/text/text-design-font-multiline.js
var Vector228, TextDesignFontMultiline;
var init_text_design_font_multiline = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/text/text-design-font-multiline.js"() {
    init_core();
    init_text_splitter();
    init_size_value();
    init_text_design_asset_manager();
    ({ Vector2: Vector228 } = math_exports);
    TextDesignFontMultiline = class extends configurable_default {
      constructor(options) {
        super(options);
        this._textOptions = {};
        this._createCanvas();
      }
      _createCanvas() {
        this._canvas = utils_default.createCanvas();
        this._context = this._canvas.getContext("2d");
        this._textSplitter = new text_splitter_default(this._context);
        this._finalCanvas = utils_default.createCanvas();
        this._finalContext = this._finalCanvas.getContext("2d");
        this.updateFontVariation();
      }
      setOption(optionName, value, update = true, initial = false) {
        super.setOption(optionName, value, update, initial);
        if (optionName === "fontIdentifier" && !initial) {
          this.updateFontVariation();
        }
      }
      updateFontVariation() {
        const fontVariation = AssetManager.getVariation(this.getFontIdentifier());
        if (!fontVariation) {
          log_default.warn(`TextDesignFont: Unable to find font '${this._fontIdentifier}'`);
        }
        this.setFontVariation(fontVariation);
        return fontVariation;
      }
      _applyTextOptions(options = {}, ctx = this._context) {
        const { fontSize, fontVariation, lineHeight, textColor, alignment } = __spreadValues(__spreadValues({}, this._options), options);
        const {
          fontStyle,
          fontWeight,
          fontFamily
        } = fontVariation.serializeOptions();
        ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px "${fontFamily}"`;
        ctx.fillStyle = textColor;
        ctx.textBaseline = "top";
        ctx.textAlign = alignment || "left";
      }
      _buildOutputLines(maxWidth) {
        this._textSplitter.setText(this.getText());
        this._textSplitter.setMaxWidth(maxWidth);
        return this._textSplitter.getLines();
      }
      _renderTextLine(text, y) {
        const textAlignment = this.getAlignment();
        const drawPosition = new Vector228(0, y);
        switch (textAlignment) {
          case "center":
            drawPosition.x = this._canvas.width / 2;
            break;
          case "right":
            drawPosition.x = this._canvas.width;
            break;
        }
        this._context.fillText(text, drawPosition.x, drawPosition.y);
      }
      update() {
        const textOptions = this.calculateFontStyles();
        if (textOptions) {
          const { dimensions, lines } = this._calculateText(textOptions);
          this._dimensions = dimensions;
          this._renderText(dimensions, lines, textOptions);
        }
      }
      draw(ctx, x = 0, y = 0) {
        this.update();
        ctx.drawImage(this._canvas, x, y, this._dimensions.x, this._dimensions.y);
      }
      _renderText(dimensions, lines, textOptions) {
        this._canvas.width = dimensions.x;
        this._canvas.height = dimensions.y;
        this._context = this._canvas.getContext("2d");
        this._applyTextOptions(textOptions, this._context);
        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          this._renderTextLine(line, textOptions.topPadding + textOptions.lineHeight * lineNum);
        }
      }
      getFontFamily() {
        const variation = this.getFontVariation();
        return variation.getFontFamily();
      }
      calculateFontStyles() {
        const fontFamily = this.getFontFamily();
        const fontSize = this.getFontSize();
        const textHeight = this.getAbsoluteTextHeight();
        const lineHeight = textHeight * this.getLineHeight();
        const topPadding = textHeight * (this.getLineHeight() - 1) / 2;
        const textOptions = {
          fontFamily,
          fontSize,
          textHeight,
          lineHeight,
          topPadding
        };
        this._textOptions = __spreadValues({}, textOptions);
        return textOptions;
      }
      getTextMetrics() {
        const variation = this.getFontVariation();
        return variation.getTextMetrics();
      }
      getAbsoluteTextHeight() {
        const actualFontSize = this.getFontSize();
        const textMetrics = this.getTextMetrics();
        if (textMetrics) {
          const scale = 1 / textMetrics.unitsPerEm * actualFontSize;
          const ascent = textMetrics.ascender * scale;
          const descent = textMetrics.descender * scale;
          return ascent + Math.abs(descent);
        }
        return actualFontSize * this.getLineHeight() * 1.1;
      }
      _calculateText(textOptions) {
        this._applyTextOptions(textOptions, this._context);
        const dimensions = new Vector228();
        let lines = this.getText().split("\n");
        let maxWidth;
        if (typeof maxWidth !== "undefined") {
          dimensions.x = maxWidth;
          lines = this._buildOutputLines(maxWidth);
        } else {
          for (let lineNum = 0; lineNum < lines.length; lineNum++) {
            const line = lines[lineNum];
            dimensions.x = Math.max(dimensions.x, this._context.measureText(line).width);
          }
        }
        const { lineHeight } = textOptions;
        dimensions.y = lines.length * lineHeight;
        return { dimensions, lines };
      }
      getDimensions() {
        const textOptions = this.calculateFontStyles();
        const { dimensions } = this._calculateText(textOptions);
        return dimensions;
      }
      fitMaxHeight() {
        this.update();
        const dimensions = this.getDimensions();
        const lines = this.getText().split("\n");
        const scale = this.getMaxHeight() / dimensions.y;
      }
      fitMaxWidth() {
        const width = this.getDimensions().x;
        const scale = this.getMaxWidth() / width;
        this.setFontSize(this.getFontSize() * scale);
        this._textOptions.fontSize = this.getFontSize();
      }
      fitInFrame(frame) {
        this.setMaxWidth(frame.width);
        this.setMaxHeight(frame.height);
        this.fitMaxWidth();
        this.fitMaxHeight();
      }
      getSize() {
        const dimensions = this.getDimensions();
        return new SizeValue(dimensions.x, dimensions.y);
      }
    };
    TextDesignFontMultiline.prototype.availableOptions = {
      text: { type: "string" /* STRING */, default: "" },
      fontIdentifier: {
        type: "string" /* STRING */,
        default: "imgly_font_open_sans_bold"
      },
      fontVariation: { type: "object" /* OBJECT */, default: null },
      lineHeight: { type: "number" /* NUMBER */, default: 1 },
      fontSize: { type: "number" /* NUMBER */, default: 22 },
      textColor: { type: "string" /* STRING */, default: "black" },
      strokeStyle: { type: "string" /* STRING */, default: "black" },
      outlineWidth: { type: "number" /* NUMBER */, default: 0 },
      textBaseline: { type: "string" /* STRING */, default: "alphabetic" },
      excludeAccents: { type: "boolean" /* BOOLEAN */, default: true },
      maxWidth: { type: "number" /* NUMBER */, default: 100 },
      maxHeight: { type: "number" /* NUMBER */, default: 0 },
      alignment: {
        type: "string" /* STRING */,
        default: "left",
        available: ["left", "center", "right"]
      }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/masked/text-design-row-multiline.js
var TextDesignRowMultiline;
var init_text_design_row_multiline = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/masked/text-design-row-multiline.js"() {
    init_core();
    init_text_renderer();
    init_text_design_font();
    init_text_design_font_multiline();
    init_text_design_element();
    init_text_design_row_masked();
    TextDesignRowMultiline = class extends TextDesignRowMasked {
      _calculateLayoutElements() {
        const words = this.getWords();
        const textFrame = this._getTextFrame();
        const attributes = this.getAttributes();
        const fontIdentifier = attributes.getFontIdentifier();
        const imageInsets = this.getImageInsets();
        const font = new TextDesignFont({ text: words.getWord(0), fontIdentifier });
        font.fitWidth(textFrame.width);
        const element = new TextDesignElement({
          text: words.getWord(0),
          frame: textFrame,
          font
        });
        element.setFrame(this._getTextFrameForElement(element));
        const size = this.getSize();
        if (this.getSizeToFitContent() || size.height <= 1) {
          size.height = imageInsets.top + element.getFrame().height + imageInsets.bottom;
        }
        size.height = Math.max(size.height, this.getMinimumHeight());
        return [element];
      }
      _getTextFrameForElement(element) {
        const words = this.getWords();
        const text = words.getWord(0);
        const attributes = this.getAttributes();
        const fontIdentifier = attributes.getFontIdentifier();
        const imageInsets = this.getImageInsets();
        const insettedRect = this.getImageInsets().applyToRectangle(this._getFrame()).scale(this.getTextScaleFactor());
        const font = new TextDesignFontMultiline({
          text,
          fontIdentifier,
          alignment: attributes.getAlignment(),
          lineHeight: 1
        });
        font.fitInFrame(insettedRect);
        const textSize = font.getSize();
        insettedRect.height = textSize.height;
        let stringHeight = textSize.height * this.getRowScaleFactor();
        if (this.getSizeToFitContent()) {
          stringHeight += imageInsets.top + imageInsets.bottom;
        }
        const frame = this._getFrame();
        const alignment = attributes.getAlignment();
        if (this.getCenteredVertically()) {
          insettedRect.y = frame.height / 2 - stringHeight / 2 + imageInsets.top;
        } else {
          switch (alignment) {
            case "left":
              insettedRect.y = frame.height - stringHeight - imageInsets.bottom;
              break;
            case "center":
              insettedRect.y = frame.height / 2 - stringHeight / 2 + stringHeight * this.getCenterOffset();
              insettedRect.x = (frame.width - insettedRect.width) / 2;
              break;
            case "right":
              insettedRect.x = frame.width - insettedRect.width - imageInsets.right;
              break;
            default:
              break;
          }
        }
        return insettedRect;
      }
      render(context) {
        context.save();
        this._getLayoutElements().forEach((element) => {
          let { text, frame } = element.serializeOptions();
          const attributes = this.getAttributes();
          const fontIdentifier = attributes.getFontIdentifier();
          const fontMultiline = new TextDesignFontMultiline({
            text,
            fontIdentifier,
            alignment: attributes.getAlignment(),
            lineHeight: 1,
            textColor: attributes.getTextColor().toRGBA()
          });
          frame = this._getTextFrameForElement(element);
          fontMultiline.fitInFrame(frame);
          fontMultiline.draw(context, frame.x, frame.y);
        });
        context.restore();
      }
    };
    TextDesignRowMultiline.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignRowMasked.prototype.availableOptions), {
      centerOffset: { type: "number" /* NUMBER */, default: 0 },
      sizeToFitContent: { type: "boolean" /* BOOLEAN */, default: false },
      textScaleFactor: { type: "number" /* NUMBER */, default: 0.95 },
      rowScaleFactor: { type: "number" /* NUMBER */, default: 1 },
      minimumHeight: { type: "number" /* NUMBER */, default: 0 },
      centeredVertically: { type: "boolean" /* BOOLEAN */, default: false }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked.js
var _TextDesignMasked, TextDesignMasked;
var init_text_design_masked = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked.js"() {
    init_core();
    init_masked_row_type();
    init_randomizer();
    init_text_design_row_multiline();
    init_text_design_asset_manager();
    init_words();
    init_text_design();
    _TextDesignMasked = class extends TextDesign {
      constructor(...args) {
        super(...args);
        this._rowType = RowType.Box;
        this._alignmentRandomizer = new Randomizer(0);
        this._isMaskedRandomizer = new Randomizer(0);
        this._seedPool.push(this._alignmentRandomizer);
        this._seedPool.push(this._isMaskedRandomizer);
      }
      getImagePaths() {
        return [RowType.Box.getImagePath()];
      }
      _modifiedText(text) {
        return super._modifiedText(text).toLowerCase();
      }
      _modifiedLines(lines) {
        const words = new Words();
        words.set([
          lines.reduce((acc, line) => `${acc}${acc === "" ? "" : "\n"}${line.joined(1)[0]}`, "")
        ]);
        return [words];
      }
      _layoutRows(lines, width) {
        const rows = super._layoutRows(lines, width);
        const firstRow = rows[0];
        if (firstRow && this.getSquareLayout()) {
          const size = firstRow.getSize();
          size.height = size.width;
        }
        return rows;
      }
      getAlignment() {
        return this._alignmentRandomizer.pickNext(this.constructor.ValidAlignments || _TextDesignMasked.ValidAlignments);
      }
      _randomLayoutRow(words, index, width, attributes) {
        const alignment = this.getAlignment();
        const rowType = this._rowType;
        const image = AssetManager.getImage(rowType.getImagePath());
        attributes.setAlignment(alignment);
        const row = new TextDesignRowMultiline({
          words,
          width,
          attributes,
          image,
          imageInsets: rowType.insetsForWidth(width),
          capInsets: rowType.getCapInsets(),
          backgroundColor: color_default.WHITE,
          centerOffset: 0,
          textScaleFactor: 0.7,
          isMasked: this._isMaskedRandomizer.nextBool()
        });
        if (this._rowType === RowType.Box) {
          row.serverImageSmoothingFix = true;
        }
        const rowSize = row.getSize();
        if (this.getSquareLayout()) {
          rowSize.height = rowSize.width;
        } else {
          rowSize.height = Math.max(rowSize.height, rowSize.width * rowType.getMinimumHeightRatio());
        }
        return row;
      }
    };
    TextDesignMasked = _TextDesignMasked;
    __publicField(TextDesignMasked, "defaultFontIdentifiers", ["imgly_font_lexend_bold"]);
    __publicField(TextDesignMasked, "Alignment", {
      Left: "left",
      Center: "center",
      Right: "right"
    });
    __publicField(TextDesignMasked, "ValidAlignments", [
      _TextDesignMasked.Alignment.Left,
      _TextDesignMasked.Alignment.Center,
      _TextDesignMasked.Alignment.Right
    ]);
    __publicField(TextDesignMasked, "identifier", "imgly_text_design_masked");
    TextDesignMasked.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesign.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignMasked.defaultFontIdentifiers
      },
      squareLayout: { type: "boolean" /* BOOLEAN */, default: true }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-badge.js
var TextDesignMaskedBadge;
var init_text_design_masked_badge = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-badge.js"() {
    init_core();
    init_masked_row_type();
    init_randomizer();
    init_text_design_masked();
    TextDesignMaskedBadge = class extends TextDesignMasked {
      constructor(...args) {
        super(...args);
        this._possibleRowTypes = [
          RowType.Badge1,
          RowType.Badge2,
          RowType.Badge3,
          RowType.Badge4
        ];
        this._rowTypesRandomizer = new Randomizer(0);
        this._isMaskedRandomizer = new Randomizer(0);
        this._seedPool.push(this._rowTypesRandomizer);
        this._seedPool.push(this._isMaskedRandomizer);
      }
      getImagePaths() {
        return this._possibleRowTypes.map((rowType) => rowType.getImagePath());
      }
      _randomLayoutRow(words, index, width, attributes) {
        this._rowType = this._rowTypesRandomizer.pickNext(this._possibleRowTypes);
        attributes.setLineSpacing(0.9);
        const row = super._randomLayoutRow(words, index, width, attributes);
        row.set({ textScaleFactor: 0.9 });
        return row;
      }
    };
    __publicField(TextDesignMaskedBadge, "defaultFontIdentifiers", ["imgly_font_outfit_bold"]);
    __publicField(TextDesignMaskedBadge, "identifier", "imgly_text_design_masked_badge");
    __publicField(TextDesignMaskedBadge, "ValidAlignments", [TextDesignMasked.Alignment.Center]);
    TextDesignMaskedBadge.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignMasked.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignMaskedBadge.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-speech-bubble.js
var TextDesignMaskedSpeechBubble;
var init_text_design_masked_speech_bubble = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-speech-bubble.js"() {
    init_core();
    init_masked_row_type();
    init_randomizer();
    init_text_design_masked();
    TextDesignMaskedSpeechBubble = class extends TextDesignMasked {
      constructor(...args) {
        super(...args);
        this._possibleRowTypes = [RowType.SpeechBubble1, RowType.SpeechBubble3];
        this._rowTypesRandomizer = new Randomizer(0);
        this._isMaskedRandomizer = new Randomizer(0);
        this._seedPool.push(this._rowTypesRandomizer);
        this._seedPool.push(this._isMaskedRandomizer);
      }
      getImagePaths() {
        return this._possibleRowTypes.map((rowType) => rowType.getImagePath());
      }
      _rowTypes(words) {
        return this._possibleRowTypes;
      }
      _randomLayoutRow(words, index, width, attributes) {
        this._rowType = this._rowTypesRandomizer.pickNext(this._rowTypes(words));
        attributes.setLineSpacing(0.9);
        const row = super._randomLayoutRow(words, index, width, attributes);
        row.set({
          textScaleFactor: 1,
          minimumHeight: width * this._rowType.getMinimumHeightRatio(),
          sizeToFitContent: this._rowType.getSizeToFitContent(),
          centeredVertically: true
        });
        return row;
      }
    };
    __publicField(TextDesignMaskedSpeechBubble, "defaultFontIdentifiers", [
      "imgly_font_roboto_black_italic",
      "imgly_font_roboto_light_italic",
      "imgly_font_roboto_black",
      "imgly_font_roboto_light"
    ]);
    __publicField(TextDesignMaskedSpeechBubble, "identifier", "imgly_text_design_masked_speech_bubble");
    TextDesignMaskedSpeechBubble.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignMasked.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignMaskedSpeechBubble.defaultFontIdentifiers
      },
      squareLayout: { type: "boolean" /* BOOLEAN */, default: false },
      alignment: {
        type: "string" /* STRING */,
        default: "left",
        available: TextDesignMasked.ValidAlignments
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-speech-bubble-comic.js
var TextDesignMaskedSpeechBubbleComic;
var init_text_design_masked_speech_bubble_comic = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-speech-bubble-comic.js"() {
    init_core();
    init_masked_row_type();
    init_text_design_masked();
    init_text_design_masked_speech_bubble();
    TextDesignMaskedSpeechBubbleComic = class extends TextDesignMaskedSpeechBubble {
      constructor(...args) {
        super(...args);
        this._possibleRowTypes = [
          RowType.SpeechBubble2,
          RowType.SpeechBubble4,
          RowType.SpeechBubble2,
          RowType.SpeechBubble4,
          RowType.SpeechBubble5
        ];
        this._possibleRowTypesForMin15 = this._possibleRowTypes.slice(0, 2);
        this._possibleRowTypesForMax14 = this._possibleRowTypes.slice(2);
      }
      _rowTypes(words) {
        return words.countNumberOfCharacters() < 15 ? this._possibleRowTypesForMax14 : this._possibleRowTypesForMin15;
      }
    };
    __publicField(TextDesignMaskedSpeechBubbleComic, "defaultFontIdentifiers", ["imgly_font_permanent_marker"]);
    __publicField(TextDesignMaskedSpeechBubbleComic, "identifier", "imgly_text_design_masked_speech_bubble_comic");
    TextDesignMaskedSpeechBubbleComic.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignMaskedSpeechBubble.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignMaskedSpeechBubbleComic.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-multiline.js
var TextDesignMultiline;
var init_text_design_multiline = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-multiline.js"() {
    init_core();
    init_text_design_row_multiline();
    init_text_design_masked();
    TextDesignMultiline = class extends TextDesignMasked {
      _modifiedText(text) {
        return super._modifiedText(text).toUpperCase();
      }
      _randomLayoutRow(words, index, width, attributes) {
        const alignment = this._alignmentRandomizer.pickNext(TextDesignMasked.ValidAlignments);
        attributes.setAlignment(alignment);
        return new TextDesignRowMultiline({
          words,
          width,
          attributes,
          image: null,
          backgroundColor: color_default.WHITE,
          centerOffset: 0,
          sizeToFitContent: true,
          isMasked: false,
          autoAdjustTextColor: false
        });
      }
    };
    __publicField(TextDesignMultiline, "defaultFontIdentifiers", ["imgly_font_abril_fatface_regular"]);
    __publicField(TextDesignMultiline, "identifier", "imgly_text_design_multiline");
    TextDesignMultiline.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignMasked.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignMultiline.defaultFontIdentifiers
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particle.js
var Rectangle11, TextDesignParticle;
var init_text_design_particle = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particle.js"() {
    init_core();
    ({ Rectangle: Rectangle11 } = math_exports);
    TextDesignParticle = class extends configurable_default {
      getContentFrame() {
        const frame = this.getFrame().clone();
        const inset = frame.width * 0.1;
        return frame.insetBy(inset, inset);
      }
      intersects(particle) {
        return this.getFrame().intersects(particle.getFrame());
      }
    };
    TextDesignParticle.prototype.availableOptions = {
      frame: { type: "object" /* OBJECT */, default: new Rectangle11() }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background.js
var Rectangle12, TextDesignParticlesBackground;
var init_text_design_particles_background = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background.js"() {
    init_core();
    init_text_design_asset_manager();
    init_canvas();
    init_text_design_background();
    init_text_design_particle();
    ({ Rectangle: Rectangle12 } = math_exports);
    TextDesignParticlesBackground = class extends TextDesignBackground {
      constructor(...args) {
        super(...args);
        this._MAX_TRIES = 1e3;
        this._PRECISION = 1e3;
      }
      render(context, size, relativeInsets, color, randomizer) {
        const { imagePaths, relativeParticleSize } = this._options;
        if (imagePaths.length <= 0) {
          return;
        }
        const aspect = size.width / size.height;
        const textRect = new Rectangle12(Math.round(relativeInsets.left * this._PRECISION), Math.round(relativeInsets.top * this._PRECISION * aspect), this._PRECISION, this._PRECISION);
        textRect.width -= textRect.x + Math.round(relativeInsets.right * this._PRECISION);
        textRect.height -= textRect.y + Math.round(relativeInsets.bottom * this._PRECISION * aspect);
        const particles = [];
        let count = 0;
        let tryCount = 0;
        while (count < this.getParticleCount() && tryCount < this._MAX_TRIES) {
          const radius = relativeParticleSize / 2;
          const minX = Math.round(radius * this._PRECISION);
          const minY = Math.round(radius * this._PRECISION * aspect);
          const maxX = Math.floor(this._PRECISION) - minX;
          const maxY = Math.floor(this._PRECISION) - minY;
          const randomValueX = randomizer.nextInRange(minX, maxX);
          const randomValueY = randomizer.nextInRange(minY, maxY);
          const frame = new Rectangle12(randomValueX - minX, randomValueY - minY, 2 * minX, 2 * minY);
          if (!frame.intersects(textRect) && !this.hasCollision(particles, frame)) {
            particles.push(new TextDesignParticle({ frame }));
            count += 1;
          }
          tryCount += 1;
        }
        for (let i = 0; i < particles.length; i++) {
          const particle = particles[i];
          const randomImagePath = randomizer.pickNext(imagePaths);
          const randomImage = AssetManager.getImage(randomImagePath);
          const opacity = randomizer.nextInRange(140, 230) / 255;
          const scaleX = size.width / this._PRECISION;
          const scaleY = size.height / this._PRECISION;
          const destination = particle.getContentFrame();
          destination.x *= scaleX;
          destination.y *= scaleY;
          destination.width *= scaleX;
          destination.height *= scaleY;
          const finalColor = color.clone();
          finalColor.a = opacity;
          drawImageFrame(context, randomImage, destination, finalColor, "source-atop");
        }
      }
      hasCollision(particles, rect) {
        for (let i = 0; i < particles.length; i++) {
          if (rect.intersects(particles[i].getFrame())) {
            return true;
          }
        }
        return false;
      }
    };
    TextDesignParticlesBackground.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignBackground.prototype.availableOptions), {
      particleCount: { type: "number" /* NUMBER */, default: 50 },
      relativeParticleSize: { type: "number" /* NUMBER */, default: 0.08 },
      imagePaths: { type: "array" /* ARRAY */, default: [] }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-brush.js
var TextDesignParticlesBackgroundBrush;
var init_text_design_particles_background_brush = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-brush.js"() {
    init_core();
    init_text_design_particles_background();
    TextDesignParticlesBackgroundBrush = class extends TextDesignParticlesBackground {
    };
    __publicField(TextDesignParticlesBackgroundBrush, "Images", [
      "text-design/images/imgly_text_design_particle_brush_01.png",
      "text-design/images/imgly_text_design_particle_brush_02.png",
      "text-design/images/imgly_text_design_particle_brush_03.png",
      "text-design/images/imgly_text_design_particle_brush_04.png",
      "text-design/images/imgly_text_design_particle_brush_05.png",
      "text-design/images/imgly_text_design_particle_brush_06.png",
      "text-design/images/imgly_text_design_particle_brush_07.png",
      "text-design/images/imgly_text_design_particle_brush_08.png",
      "text-design/images/imgly_text_design_particle_brush_09.png",
      "text-design/images/imgly_text_design_particle_brush_10.png"
    ]);
    TextDesignParticlesBackgroundBrush.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignParticlesBackground.prototype.availableOptions), {
      imagePaths: {
        type: "array" /* ARRAY */,
        default: [...TextDesignParticlesBackgroundBrush.Images]
      },
      relativeParticleSize: { type: "number" /* NUMBER */, default: 0.12 }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-circle.js
var TextDesignParticlesBackgroundCircle;
var init_text_design_particles_background_circle = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-circle.js"() {
    init_core();
    init_text_design_particles_background();
    TextDesignParticlesBackgroundCircle = class extends TextDesignParticlesBackground {
    };
    __publicField(TextDesignParticlesBackgroundCircle, "Images", [
      "text-design/images/imgly_text_design_particle_circle_01.png",
      "text-design/images/imgly_text_design_particle_circle_02.png",
      "text-design/images/imgly_text_design_particle_circle_03.png",
      "text-design/images/imgly_text_design_particle_circle_04.png",
      "text-design/images/imgly_text_design_particle_circle_05.png",
      "text-design/images/imgly_text_design_particle_circle_06.png",
      "text-design/images/imgly_text_design_particle_circle_07.png",
      "text-design/images/imgly_text_design_particle_circle_08.png",
      "text-design/images/imgly_text_design_particle_circle_09.png",
      "text-design/images/imgly_text_design_particle_circle_10.png"
    ]);
    TextDesignParticlesBackgroundCircle.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignParticlesBackground.prototype.availableOptions), {
      imagePaths: {
        type: "array" /* ARRAY */,
        default: [...TextDesignParticlesBackgroundCircle.Images]
      },
      relativeParticleSize: { type: "number" /* NUMBER */, default: 0.12 }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-triangle.js
var TextDesignParticlesBackgroundTriangle;
var init_text_design_particles_background_triangle = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-triangle.js"() {
    init_core();
    init_text_design_particles_background();
    TextDesignParticlesBackgroundTriangle = class extends TextDesignParticlesBackground {
    };
    __publicField(TextDesignParticlesBackgroundTriangle, "Images", [
      "text-design/images/imgly_text_design_particle_triangle_01.png",
      "text-design/images/imgly_text_design_particle_triangle_02.png",
      "text-design/images/imgly_text_design_particle_triangle_03.png",
      "text-design/images/imgly_text_design_particle_triangle_04.png",
      "text-design/images/imgly_text_design_particle_triangle_05.png",
      "text-design/images/imgly_text_design_particle_triangle_06.png",
      "text-design/images/imgly_text_design_particle_triangle_07.png",
      "text-design/images/imgly_text_design_particle_triangle_08.png",
      "text-design/images/imgly_text_design_particle_triangle_09.png",
      "text-design/images/imgly_text_design_particle_triangle_10.png"
    ]);
    TextDesignParticlesBackgroundTriangle.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignParticlesBackground.prototype.availableOptions), {
      imagePaths: {
        type: "array" /* ARRAY */,
        default: [...TextDesignParticlesBackgroundTriangle.Images]
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-sunshine.js
var _TextDesignSunshine, TextDesignSunshine;
var init_text_design_sunshine = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-sunshine.js"() {
    init_core();
    init_randomizer();
    init_rectangle_insets();
    init_text_design_row_single();
    init_text_design_row_image();
    init_text_design_row_single_image();
    init_text_design_asset_manager();
    init_words();
    init_text_design();
    _TextDesignSunshine = class extends TextDesign {
      constructor(...args) {
        super(...args);
        this._relativeInsets = new RectangleInsets(0, 0, 0, 0);
        this._INVALID_FONTS_IF_LESS_THEN_5_CHARS = ["imgly_font_montserrat_light"];
        this._INVALID_FONTS_IF_LESS_THEN_4_CHARS = [
          "imgly_font_montserrat_light",
          "imgly_font_cookie_regular"
        ];
        this._lineCount = 0;
        this._decorativeRowCreated = false;
        this._useImageRowRandomizer = new Randomizer(0);
        this._rowTypeRandomizer = new Randomizer(0);
        this._lineDecorativeTypeRandomizer = new Randomizer(0);
        this._seedPool.push(this._useImageRowRandomizer);
        this._seedPool.push(this._rowTypeRandomizer);
        this._seedPool.push(this._lineDecorativeTypeRandomizer);
      }
      getImagePaths() {
        return [
          ..._TextDesignSunshine.DecoratorImages,
          ..._TextDesignSunshine.RowImages
        ];
      }
      _fontForRow(index, words) {
        const numOfCharacters = words.countNumberOfCharacters();
        let fonts = this.getFontIdentifiers();
        if (numOfCharacters < 4) {
          fonts = fonts.filter((font) => this._INVALID_FONTS_IF_LESS_THEN_4_CHARS.indexOf(font) < 0);
        } else if (numOfCharacters < 5) {
          fonts = fonts.filter((font) => this._INVALID_FONTS_IF_LESS_THEN_5_CHARS.indexOf(font) < 0);
        }
        return fonts[index % fonts.length];
      }
      _modifiedText(text) {
        return super._modifiedText(text).toUpperCase();
      }
      _modifiedLines(lines) {
        this._lineCount = lines.length;
        return lines;
      }
      generateLayoutData(text, width) {
        this._decorativeRowCreated = false;
        return super.generateLayoutData(text, width);
      }
      _randomLayoutRow(words, index, width, attributes) {
        const fontIdentifier = attributes.getFontIdentifier();
        let modifiedWords = words;
        switch (fontIdentifier) {
          case "imgly_font_cookie_regular":
            modifiedWords = new Words().set(words.getLowerCase());
            break;
          case "imgly_font_permanent_marker":
            modifiedWords = new Words().set(words.getUpperCase());
            break;
          default:
            break;
        }
        const noDecorations = this.getDecorativeRowsInTheMiddleOnly() && (index === 0 || index === this._lineCount - 1);
        if (this._useImageRowRandomizer.nextBool() || this._decorativeRowCreated || noDecorations) {
          return new TextDesignRowSingle({
            words: modifiedWords,
            width,
            attributes
          });
        }
        this._decorativeRowCreated = true;
        const [leftImage, rightImage] = this._randomDecoratorImages();
        return new TextDesignRowImage({
          words,
          width,
          attributes,
          leftImage,
          rightImage
        });
      }
      _layoutRows(lines, width) {
        const elements = super._layoutRows(lines, width);
        if (!this.getDecorationsVisible()) {
          return elements;
        }
        const formHeight = 0.0625 * width;
        const firstRow = new TextDesignRowSingleImage({
          width,
          height: formHeight,
          image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(_TextDesignSunshine.RowImages))
        }).layout();
        const lastRow = new TextDesignRowSingleImage({
          width,
          height: formHeight,
          image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(_TextDesignSunshine.RowImages))
        }).layout();
        return [firstRow, ...elements, lastRow];
      }
      _randomDecoratorImages() {
        if (this._lineDecorativeTypeRandomizer.nextInRange(0, 1)) {
          return _TextDesignSunshine.DecoratorImages.slice(0, 2).map((path) => AssetManager.getImage(path));
        }
        return _TextDesignSunshine.DecoratorImages.slice(2).map((path) => AssetManager.getImage(path));
      }
    };
    TextDesignSunshine = _TextDesignSunshine;
    __publicField(TextDesignSunshine, "defaultFontIdentifiers", [
      "imgly_font_permanent_marker",
      "imgly_font_cookie_regular",
      "imgly_font_cookie_regular",
      "imgly_font_montserrat_light"
    ]);
    __publicField(TextDesignSunshine, "identifier", "imgly_text_design_sunshine");
    __publicField(TextDesignSunshine, "RowImages", [
      TextDesignRowSingleImage.RowImages.decorative1,
      TextDesignRowSingleImage.RowImages.decorative2,
      TextDesignRowSingleImage.RowImages.decorative3,
      TextDesignRowSingleImage.RowImages.decorative4
    ]);
    __publicField(TextDesignSunshine, "DecoratorImages", [
      "text-design/images/imgly_text_design_asset_decorative_03.png",
      "text-design/images/imgly_text_design_asset_decorative_04.png",
      "text-design/images/imgly_text_design_asset_decorative_07.png",
      "text-design/images/imgly_text_design_asset_decorative_08.png"
    ]);
    TextDesignSunshine.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesign.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignSunshine.defaultFontIdentifiers
      },
      relativeLineSpacing: { type: "number" /* NUMBER */, default: 0.025 / 3 * 4 },
      decorationsVisible: { type: "boolean" /* BOOLEAN */, default: true },
      decorativeRowsInTheMiddleOnly: { type: "boolean" /* BOOLEAN */, default: false }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-particles.js
var _TextDesignParticles, TextDesignParticles;
var init_text_design_particles = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-particles.js"() {
    init_core();
    init_text_design_particles_background_brush();
    init_text_design_particles_background_circle();
    init_text_design_particles_background_triangle();
    init_randomizer();
    init_rectangle_insets();
    init_text_design_asset_manager();
    init_text_design_sunshine();
    _TextDesignParticles = class extends TextDesignSunshine {
      constructor(...args) {
        super(...args);
        this._relativeInsets = new RectangleInsets(0.3, 0.3, 0.3, 0.3);
        this._backgroundRandomizer = new Randomizer(0);
        this._decoTypeRandomizer = new Randomizer(0);
        this._seedPool.push(this._backgroundRandomizer);
        this._seedPool.push(this._decoTypeRandomizer);
      }
      getImagePaths() {
        return [
          ...TextDesignSunshine.RowImages,
          ...utils_default.Array.flatten(_TextDesignParticles.Backgrounds.map((b) => b.getImagePaths())),
          ..._TextDesignParticles.DecoratorImages
        ];
      }
      _getBackground() {
        return this._backgroundRandomizer.pickNext(_TextDesignParticles.Backgrounds);
      }
      _randomDecoratorImages() {
        switch (this._decoTypeRandomizer.nextInRange(0, 2)) {
          case 0:
            return _TextDesignParticles.DecoratorImages.slice(0, 2).map((path) => AssetManager.getImage(path));
          case 1:
          case 2:
            return _TextDesignParticles.DecoratorImages.slice(2).map((path) => AssetManager.getImage(path));
          default:
            log_default.warn("TextDesignParticles#_randomDecoratorImages: Number generated not in valid range.");
            return _TextDesignParticles.DecoratorImages.slice(2).map((path) => AssetManager.getImage(path));
        }
      }
    };
    TextDesignParticles = _TextDesignParticles;
    __publicField(TextDesignParticles, "defaultFontIdentifiers", [
      "imgly_font_permanent_marker",
      "imgly_font_cookie_regular",
      "imgly_font_cookie_regular",
      "imgly_font_montserrat_light"
    ]);
    __publicField(TextDesignParticles, "identifier", "imgly_text_design_particles");
    __publicField(TextDesignParticles, "Backgrounds", [
      new TextDesignParticlesBackgroundBrush(),
      new TextDesignParticlesBackgroundCircle(),
      new TextDesignParticlesBackgroundTriangle()
    ]);
    __publicField(TextDesignParticles, "DecoratorImages", [
      "text-design/images/imgly_text_design_particle_holder_01.png",
      "text-design/images/imgly_text_design_particle_holder_02.png",
      "text-design/images/imgly_text_design_particle_holder_03.png",
      "text-design/images/imgly_text_design_particle_holder_04.png"
    ]);
    TextDesignParticles.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignSunshine.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignParticles.defaultFontIdentifiers
      },
      decorationsVisible: { type: "boolean" /* BOOLEAN */, default: false },
      decorativeRowsInTheMiddleOnly: { type: "boolean" /* BOOLEAN */, default: true }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-rotated.js
var TextDesignRotated;
var init_text_design_rotated = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-rotated.js"() {
    init_core();
    init_randomizer();
    init_rectangle_insets();
    init_text_design_row_form();
    init_text_design();
    TextDesignRotated = class extends TextDesign {
      constructor(...args) {
        super(...args);
        this._relativeInsets = new RectangleInsets(0.1, 0, 0, 0);
        this._rowTypeRandomizer = new Randomizer(0);
        this._seedPool.push(this._rowTypeRandomizer);
      }
      _modifiedText(text) {
        return super._modifiedText(text).toUpperCase();
      }
      _randomLayoutRow(words, index, width, attributes) {
        const row = super._randomLayoutRow(words, index, width, attributes);
        row.setShearingAngle(this.getShearingAngle());
        return row;
      }
      _layoutRows(lines, width) {
        const elements = super._layoutRows(lines, width);
        const types = utils_default.values(TextDesignRowForm.FormType);
        const formHeight = 30;
        const firstRow = new TextDesignRowForm({
          width,
          height: formHeight,
          type: this._rowTypeRandomizer.pickNext(types),
          shearingAngle: this.getShearingAngle()
        }).layout();
        const lastRow = new TextDesignRowForm({
          width,
          height: formHeight,
          type: this._rowTypeRandomizer.pickNext(types),
          shearingAngle: this.getShearingAngle()
        }).layout();
        return [firstRow, ...elements, lastRow];
      }
    };
    __publicField(TextDesignRotated, "defaultFontIdentifiers", ["imgly_font_outfit_bold"]);
    __publicField(TextDesignRotated, "identifier", "imgly_text_design_rotated");
    TextDesignRotated.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesign.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignRotated.defaultFontIdentifiers
      },
      relativeLineSpacing: { type: "number" /* NUMBER */, default: 0.025 / 3 },
      shearingAngle: { type: "number" /* NUMBER */, default: -0.1 }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-sunshine-v3_1_0.js
var TextDesignSunshineV310;
var init_text_design_sunshine_v3_1_0 = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-sunshine-v3_1_0.js"() {
    init_rectangle_insets();
    init_text_design_row_single_image();
    init_text_design_asset_manager();
    init_text_design_sunshine();
    TextDesignSunshineV310 = class extends TextDesignSunshine {
      constructor(...args) {
        super(...args);
        this._relativeInsets = new RectangleInsets(0, 0.3, 0, 0.3);
      }
      _layoutRows(lines, width) {
        const elements = super._layoutRows(lines, width);
        if (!this.getDecorationsVisible()) {
          return elements;
        }
        const formHeight = 25;
        const firstRow = new TextDesignRowSingleImage({
          width,
          height: formHeight,
          image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(TextDesignSunshine.RowImages))
        }).layout();
        const lastRow = new TextDesignRowSingleImage({
          width,
          height: formHeight,
          image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(TextDesignSunshine.RowImages))
        }).layout();
        return [firstRow, ...elements, lastRow];
      }
    };
    __publicField(TextDesignSunshineV310, "identifier", "imgly_text_design_sunshine-v3_1_0");
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-watercolor.js
var TextDesignWatercolor;
var init_text_design_watercolor = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-watercolor.js"() {
    init_core();
    init_masked_row_type();
    init_text_design_masked();
    init_text_design_masked_speech_bubble();
    TextDesignWatercolor = class extends TextDesignMaskedSpeechBubble {
      constructor(...args) {
        super(...args);
        this._possibleRowTypes = [
          RowType.Watercolor1,
          RowType.Watercolor2,
          RowType.Watercolor3
        ];
      }
    };
    __publicField(TextDesignWatercolor, "defaultFontIdentifiers", [
      "imgly_font_permanent_marker",
      "imgly_font_cookie_regular",
      "imgly_font_cookie_regular"
    ]);
    __publicField(TextDesignWatercolor, "identifier", "imgly_text_design_watercolor");
    TextDesignWatercolor.prototype.availableOptions = __spreadProps(__spreadValues({}, TextDesignMaskedSpeechBubble.prototype.availableOptions), {
      fontIdentifiers: {
        type: "array" /* ARRAY */,
        default: TextDesignWatercolor.defaultFontIdentifiers
      },
      alignment: {
        type: "string" /* STRING */,
        default: TextDesignMasked.Alignment.Center,
        available: TextDesignMasked.ValidAlignments
      }
    });
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/text-design-renderer.js
var Rectangle13, REFERENCE_WIDTH, TextDesignRenderer;
var init_text_design_renderer = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design/text-design-renderer.js"() {
    init_core();
    init_randomizer();
    init_text_design_row_masked();
    init_text_design_row_multiline();
    init_size_value();
    init_canvas();
    ({ Rectangle: Rectangle13 } = math_exports);
    REFERENCE_WIDTH = 1e3;
    TextDesignRenderer = class {
      constructor() {
        this._layoutData = null;
        this._layout = null;
        this._text = "";
        this._seed = 0;
        this._debugMode = false;
        this.randomizer = new Randomizer();
      }
      createLayout(layout, text, seed) {
        this._layout = layout;
        this._text = text;
        this._seed = seed;
        layout.seed(seed);
        this._layoutData = layout.generateLayoutData(text, REFERENCE_WIDTH);
      }
      calculateAspect() {
        if (!this._layoutData) {
          log_default.warn("TextDesignRenderer#calculateAspect: No layout data");
          return 1;
        }
        return this._layoutData.getSize().aspect();
      }
      draw(context, destinationSize, color, isInverted) {
        const layoutData = this._layoutData;
        if (this._layoutData) {
          const renderSize = new SizeValue(REFERENCE_WIDTH, REFERENCE_WIDTH / destinationSize.aspect());
          const scale = destinationSize.width / REFERENCE_WIDTH;
          const insets = layoutData.getRelativeInsets().clone().scale(renderSize.width);
          const lineSpacing = layoutData.getRelativeLineSpacing() * renderSize.width;
          let yOrigin = insets.top;
          context.save();
          this.randomizer.seed(this._seed);
          const background = layoutData.getBackground();
          if (background) {
            background.render(context, destinationSize, layoutData.getRelativeInsets(), isInverted ? color_default.WHITE : color, this.randomizer);
          }
          context.scale(scale, scale);
          layoutData.getRows().forEach((row) => {
            context.save();
            const attributes = row.getAttributes();
            context.transform(1, row.getShearingAngle(), 0, 1, insets.left, yOrigin);
            attributes.setTextColor(isInverted ? color_default.WHITE : color.clone());
            attributes.setTintColor(isInverted ? color_default.WHITE : color.clone());
            if (row instanceof TextDesignRowMasked || row instanceof TextDesignRowMultiline) {
              row.setBackgroundColor(isInverted ? color_default.WHITE : color.clone());
              row.setIsUsedInInvertedLayout(isInverted);
            }
            if (this._debugMode) {
              row._debugMode = true;
            }
            row.willRender(context);
            row.render(context);
            row.didRender(context);
            if (this._debugMode) {
              const frame = row._getFrame();
              const textFrame = row._getTextFrame();
              strokeRect(context, frame, color_default.GREEN);
              strokeRect(context, textFrame, color_default.BLUE);
              row._getLayoutElements().forEach((element) => {
                const frame2 = element.getFrame();
                const textFrame2 = row._getTextFrameForElement(element);
                strokeRect(context, frame2, new color_default(1, 1, 0));
                strokeRect(context, textFrame2, new color_default(0, 1, 1));
              });
            }
            yOrigin += row.getSize().height + lineSpacing;
            context.restore();
          });
          if (this._debugMode) {
            strokeRect(context, new Rectangle13(0, 0, renderSize.width, renderSize.height), color_default.RED);
          }
          context.restore();
        }
      }
    };
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design-sprite.js
var Vector229, TextDesignSprite, text_design_sprite_default;
var init_text_design_sprite = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-design-sprite.js"() {
    init_core();
    init_sprite2();
    init_text_design_blocks();
    init_text_design_blocks_condensed();
    init_text_design_blocks_light();
    init_text_design_blocks_light_v3_1_0();
    init_text_design_celebrate();
    init_text_design_celebrate_simple();
    init_text_design_equal_width();
    init_text_design_equal_width_fat();
    init_text_design_masked();
    init_text_design_masked_badge();
    init_text_design_masked_speech_bubble();
    init_text_design_masked_speech_bubble_comic();
    init_text_design_multiline();
    init_text_design_particles();
    init_text_design_rotated();
    init_text_design_sunshine();
    init_text_design_sunshine_v3_1_0();
    init_text_design_watercolor();
    init_randomizer();
    init_size_value();
    init_text_design_asset_manager();
    init_text_design_renderer();
    ({ Vector2: Vector229 } = math_exports);
    TextDesignSprite = class extends sprite_default {
      constructor(operation, options) {
        super(operation, options);
        this._isDisposed = false;
        this._renderer = new TextDesignRenderer();
        this._canvas = utils_default.createCanvas();
        this._context = this._canvas.getContext("2d");
        this._texture = engine_default.Texture.fromCanvas(this._canvas);
        this._sprite.setTexture(this._texture);
        this._aspect = 1;
        this._isLayoutDirty = true;
        if (this.getSeed() < 0) {
          this.setSeed(Randomizer.TimeSeed());
        }
      }
      seed(value) {
        this.setSeed(value || Randomizer.TimeSeed());
        this._isLayoutDirty = true;
      }
      _updateLayout() {
        const layout = this.getLayout();
        if (!layout) {
          return null;
        }
        this._renderer.createLayout(layout, this.getText(), this.getSeed());
        this._aspect = this._renderer.calculateAspect();
        this._isLayoutDirty = false;
        return true;
      }
      applyTransform(transformChange) {
        super.applyTransform(transformChange);
        const newOptions = {};
        if (this._options.dimensions) {
          newOptions.width = transformChange.applyToRelativeSize(this.getWidth());
        }
        this.set(newOptions, false);
      }
      applyFlip(direction) {
        super.applyFlip(direction);
        let { rotation } = this._options;
        switch (direction) {
          case "horizontal":
            rotation += (Math.PI - rotation) * 2;
            this.setRotation(rotation);
            break;
          case "vertical":
            rotation += (Math.PI / 2 - rotation) * 2;
            this.setRotation(rotation);
            break;
        }
      }
      update(sdk, inputDimensions) {
        const contentNeedUpdate = this._isLayoutDirty;
        if (this._isDisposed || contentNeedUpdate && !this._updateLayout()) {
          return;
        }
        const width = this.getWidth() * inputDimensions.min() / sdk.getTextureScale();
        const height = width / this._aspect;
        const spriteDimensions = new Vector229(width, height);
        const renderDimensions = new Vector229(Math.round(width * 2), Math.round(height * 2)).clamp(new Vector229(1, 1), new Vector229(Infinity, Infinity));
        const renderer = sdk.getRenderer();
        const maxDimensions = renderer.getMaxDimensions() || Infinity;
        if (renderDimensions.x > maxDimensions) {
          renderDimensions.x = maxDimensions;
          renderDimensions.y = Math.round(renderDimensions.x / this._aspect);
        }
        if (renderDimensions.y > maxDimensions) {
          renderDimensions.y = maxDimensions;
          renderDimensions.x = Math.round(renderDimensions.y * this._aspect);
        }
        const sizeChanged = utils_default.ensureCanvasDimensions(this._canvas, renderDimensions);
        if (contentNeedUpdate || sizeChanged) {
          this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
          this._renderer.draw(this._context, new SizeValue(renderDimensions.x, renderDimensions.y), this.getColor(), this.getInverted());
          this.setDimensions(spriteDimensions);
          this._texture.getBaseTexture().update();
          if (renderer.isOfType("webgl" /* WEBGL */)) {
            renderer.updateTexture(this._texture.getBaseTexture());
          }
        }
        super.update(sdk, inputDimensions);
        this._applyFlip();
      }
      _applyFlip() {
        const scale = this._sprite.getScale();
        const { flipHorizontally, flipVertically } = this._options;
        if (flipHorizontally && scale.x > 0 || !flipHorizontally && scale.x < 0) {
          scale.x *= -1;
        }
        if (flipVertically && scale.y > 0 || !flipVertically && scale.y < 0) {
          scale.y *= -1;
        }
        this._sprite.setScale(scale);
      }
      _optionEquals(optionName, value) {
        if (optionName === "layout") {
          const { layout } = this._options;
          if (!layout && value || !value && layout) {
            return false;
          }
          if (!value.constructor || !layout.constructor) {
            return false;
          }
          if (layout.constructor.identifier !== value.constructor.identifier) {
            return false;
          }
          return true;
        }
        return super._optionEquals(optionName, value);
      }
      serializeOptions(keys, toObject = false) {
        if (keys && this.getPadding() < 0) {
          const index = keys.indexOf("padding");
          if (index > -1) {
            keys.splice(index, 1);
          }
        }
        const options = super.serializeOptions(keys, toObject);
        if (!keys)
          options.type = "textdesign";
        return options;
      }
      _getTexture() {
        return this._texture;
      }
      canBeFlippedHorizontally() {
        return false;
      }
      canBeDuplicated() {
        return true;
      }
      canMaskCanvas() {
        return true;
      }
      canAdjustPadding() {
        return true;
      }
      dispose() {
        this._isDisposed = true;
        this._texture.dispose();
        this._sprite.dispose();
      }
    };
    TextDesignSprite.Layouts = {
      TextDesignBlocks,
      TextDesignBlocksCondensed,
      TextDesignBlocksLight,
      TextDesignCelebrate,
      TextDesignCelebrateSimple,
      TextDesignEqualWidth,
      TextDesignEqualWidthFat,
      TextDesignMasked,
      TextDesignMaskedBadge,
      TextDesignMaskedSpeechBubble,
      TextDesignMaskedSpeechBubbleComic,
      TextDesignMultiline,
      TextDesignWatercolor,
      TextDesignSunshine,
      TextDesignParticles,
      TextDesignRotated
    };
    TextDesignSprite.LegacyLayouts = {
      TextDesignBlocksLightV310,
      TextDesignSunshineV310
    };
    TextDesignSprite.AssetManager = AssetManager;
    TextDesignSprite.prototype.availableOptions = {
      id: { type: "string" /* STRING */, default: () => utils_default.getUUID() },
      position: { type: "vector2" /* VECTOR2 */, default: new Vector229(0.5, 0.5) },
      dimensions: { type: "vector2" /* VECTOR2 */, default: Vector229.NULL },
      anchor: { type: "vector2" /* VECTOR2 */, default: new Vector229(0, 0) },
      pivot: { type: "vector2" /* VECTOR2 */, default: new Vector229(0.5, 0.5) },
      rotation: { type: "number" /* NUMBER */, default: 0 },
      flipHorizontally: { type: "boolean" /* BOOLEAN */, default: false },
      flipVertically: { type: "boolean" /* BOOLEAN */, default: false },
      layout: {
        type: "object" /* OBJECT */,
        default: null,
        setter(layout) {
          this._isLayoutDirty = true;
          return layout;
        }
      },
      text: {
        type: "string" /* STRING */,
        default: "",
        setter(text) {
          this._isLayoutDirty = true;
          return text;
        }
      },
      color: {
        type: "color" /* COLOR */,
        default: color_default.BLACK,
        setter(color) {
          this._isLayoutDirty = true;
          return color;
        }
      },
      padding: { type: "number" /* NUMBER */, default: 0.01, minValue: 0.01 },
      width: {
        type: "number" /* NUMBER */,
        default: 0.8
      },
      inverted: {
        type: "boolean" /* BOOLEAN */,
        default: false,
        setter(value) {
          this._isLayoutDirty = true;
          return value;
        }
      },
      seed: { type: "number" /* NUMBER */, default: -1 }
    };
    text_design_sprite_default = TextDesignSprite;
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-sprite.js
var Vector230, TextSprite, text_sprite_default;
var init_text_sprite = __esm({
  "engine/sdk/operations/sprite-operation/sprites/text-sprite.js"() {
    init_core();
    init_sprite2();
    init_text_renderer();
    ({ Vector2: Vector230 } = math_exports);
    TextSprite = class extends sprite_default {
      constructor(...args) {
        super(...args);
        this._textRenderer = new text_renderer_default(this, this._operation);
        this._textRenderer.rotation = this.getRotation();
        this._sprite.setTexture(this._textRenderer.getFinalTexture());
        this._hitTestSprite.setTexture(this._textRenderer.getTexture());
      }
      serializeOptions(keys, toObject = false) {
        const options = super.serializeOptions(keys, toObject);
        if (!keys)
          options.type = "text";
        return options;
      }
      getDOMStyle(sdk, inputDimensions) {
        const actualFontSize = this.getFontSize() * inputDimensions.y;
        return {
          fontWeight: this._options.fontWeight,
          fontSize: `${actualFontSize}px`,
          fontStyle: this._options.fontStyle,
          fontFamily: this._options.fontFamily,
          lineHeight: `${this.getAbsoluteTextHeight(inputDimensions) * this.getLineHeight()}px`,
          color: this._options.color.toRGBA(),
          backgroundColor: this._options.backgroundColor.toRGBA(),
          textAlign: this._options.alignment
        };
      }
      getAbsoluteTextHeight(inputDimensions) {
        const actualFontSize = this.getFontSize() * inputDimensions.y;
        const textMetrics = this.getTextMetrics();
        if (textMetrics) {
          const scale = 1 / textMetrics.unitsPerEm * actualFontSize;
          const ascent = textMetrics.ascender * scale;
          const descent = textMetrics.descender * scale;
          return ascent + Math.abs(descent);
        }
        return actualFontSize * this.getLineHeight() * 1.1;
      }
      getDimensions(sdk, inputDimensions) {
        return this._textRenderer.getDimensions(sdk, inputDimensions);
      }
      applyFlip(direction) {
        super.applyFlip(direction);
        let { rotation } = this._options;
        switch (direction) {
          case "horizontal":
            rotation += (Math.PI - rotation) * 2;
            this.setRotation(rotation);
            break;
          case "vertical":
            rotation += (Math.PI / 2 - rotation) * 2;
            this.setRotation(rotation);
            break;
        }
      }
      applyTransform(transformChange) {
        super.applyTransform(transformChange);
        this.set({
          fontSize: transformChange.scaleSize(this.getFontSize(), "y"),
          maxWidth: transformChange.scaleSize(this.getMaxWidth(), "x")
        }, false);
      }
      applyRotation(degrees) {
        super.applyRotation(degrees);
        const actualDegrees = (degrees + 360) % 360;
        const inputDimensions = this._operation.getInputDimensions();
        if (actualDegrees === 90 || actualDegrees === 270) {
          this.setMaxWidth(this.getMaxWidth() / inputDimensions.x * inputDimensions.y);
          this.setFontSize(this.getFontSize() / inputDimensions.y * inputDimensions.x);
        }
      }
      setOption(key, value) {
        const { flipHorizontally, flipVertically } = this._options;
        if (key === "rotation") {
          let rotation = value;
          if (flipHorizontally) {
            rotation = Math.PI * 2 - rotation;
          }
          if (flipVertically) {
            rotation = Math.PI * 2 - rotation;
          }
          this._options.rotation = rotation;
          if (this._textRenderer) {
            this._textRenderer.rotation = rotation;
          }
          this._rotation = rotation;
          this.emit("update");
          return;
        }
        super.setOption(key, value);
      }
      getOption(key) {
        if (key === "rotation") {
          return this._rotation;
        }
        return super.getOption(key);
      }
      getHitTestDisplayObject() {
        return this._hitTestSprite;
      }
      update(sdk, inputDimensions) {
        this._sprite.setVisible(this._options.visible);
        if (!this._options.visible)
          return;
        this._textRenderer.update(sdk, inputDimensions);
        const textTexture = this._textRenderer.getFinalTexture();
        const baseTexture = textTexture.getBaseTexture();
        baseTexture.update();
        const renderer = sdk.getRenderer();
        if (renderer.isOfType("webgl" /* WEBGL */)) {
          renderer.updateTexture(textTexture.getBaseTexture());
        }
        super.update(sdk, inputDimensions);
        this._sprite.setRotation(0);
        this._textRenderer.getTexture().getBaseTexture().update();
        this._hitTestSprite.setRotation(this._rotation);
        this._hitTestSprite.updateTransform();
        this._applyFlip();
      }
      _applyFlip() {
        const scale = this._sprite.getScale();
        const { flipHorizontally, flipVertically } = this._options;
        if (flipHorizontally && scale.x > 0 || !flipHorizontally && scale.x < 0) {
          scale.x *= -1;
          this.setRotation(this._rotation);
        }
        if (flipVertically && scale.y > 0 || !flipVertically && scale.y < 0) {
          scale.y *= -1;
          this.setRotation(this._rotation);
        }
        this._sprite.setScale(scale);
      }
      _getTexture() {
        return this._textRenderer.getFinalTexture();
      }
      dispose() {
        super.dispose();
        this._textRenderer.dispose();
        this._hitTestSprite.dispose();
        this._sprite.dispose();
      }
      canBeFlippedHorizontally() {
        return false;
      }
      canAdjustPadding() {
        return false;
      }
    };
    TextSprite.prototype.availableOptions = {
      id: { type: "string" /* STRING */, default: () => utils_default.getUUID() },
      fontSize: { type: "number" /* NUMBER */, default: 0.1 },
      characterSpacing: { type: "number" /* NUMBER */, default: 0 },
      lineHeight: { type: "number" /* NUMBER */, default: 1.1 },
      fontIdentifier: { type: "string" /* STRING */ },
      fontFamily: { type: "string" /* STRING */, default: "Times New Roman" },
      fontWeight: { type: "*" /* ALL */, default: "normal" },
      fontStyle: { type: "string" /* STRING */, default: "normal" },
      textMetrics: { type: "object" /* OBJECT */, default: null },
      outlineWidth: { type: "number" /* NUMBER */, default: 0 },
      outlineColor: { type: "color" /* COLOR */, default: color_default.BLACK },
      alignment: {
        type: "string" /* STRING */,
        default: "left",
        available: ["left", "center", "right"]
      },
      verticalAlignment: {
        type: "string" /* STRING */,
        default: "top",
        available: ["top", "center", "bottom"]
      },
      color: { type: "color" /* COLOR */, default: new color_default(1, 0, 0, 1) },
      backgroundColor: { type: "color" /* COLOR */, default: color_default.TRANSPARENT },
      position: { type: "vector2" /* VECTOR2 */, default: new Vector230(0.5, 0.5) },
      anchor: { type: "vector2" /* VECTOR2 */, default: new Vector230(0, 0) },
      pivot: { type: "vector2" /* VECTOR2 */, default: new Vector230(0.5, 0.5) },
      rotation: { type: "number" /* NUMBER */, default: 0 },
      text: { type: "string" /* STRING */, required: true },
      maxWidth: { type: "number" /* NUMBER */, default: 0.5 },
      maxHeight: { type: "number" /* NUMBER */, default: 0 },
      visible: { type: "boolean" /* BOOLEAN */, default: true },
      flipHorizontally: { type: "boolean" /* BOOLEAN */, default: false },
      flipVertically: { type: "boolean" /* BOOLEAN */, default: false }
    };
    TextSprite.type = "text";
    text_sprite_default = TextSprite;
  }
});

// engine/sdk/operations/sprite-operation/index.js
var Vector231, SpriteOperation, sprite_operation_default;
var init_sprite_operation = __esm({
  "engine/sdk/operations/sprite-operation/index.js"() {
    init_core();
    init_sprite2();
    init_brush_sprite();
    init_sticker_sprite();
    init_text_design_sprite();
    init_text_sprite();
    ({ Vector2: Vector231 } = math_exports);
    SpriteOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this.setSmoothDownscaling(this._sdk.getOptions().smoothDownscaling);
        this._onSpriteUpdate = this._onSpriteUpdate.bind(this);
        this._maskCanvas = utils_default.createCanvas();
        const sprites = this._options.sprites.slice();
        sprites.forEach((sprite) => {
          this.removeSprite(sprite);
          this.addSprite(sprite);
        });
      }
      getSpritesOfType(Klass) {
        return this._options.sprites.filter((sprite) => sprite instanceof Klass);
      }
      rotate(degrees) {
        this._options.sprites.forEach((sprite) => {
          sprite.applyRotation(degrees);
        });
      }
      flip(direction) {
        this._options.sprites.forEach((sprite) => {
          sprite.applyFlip(direction);
        });
      }
      _onSpriteUpdate(sprite, options) {
        this.emit("update", this);
        this.setDirty(true);
      }
      _applyRotation(operation, options) {
        this._options.sprites.forEach((sprite) => sprite.applyRotation(operation, options));
      }
      transform(transformChange) {
        this._options.sprites.forEach((sprite) => sprite.applyTransform(transformChange));
      }
      scale(scale) {
        this._options.sprites.forEach((sprite) => sprite.applyScale(scale));
      }
      serializeOption(optionName, toObject = false) {
        if (optionName === "sprites") {
          return this._options.sprites.map((sprite) => {
            return sprite.serializeOptions(void 0, toObject);
          });
        }
        return super.serializeOption(optionName, toObject);
      }
      createSticker(options) {
        return new sticker_sprite_default(this, options);
      }
      createText(options) {
        return new text_sprite_default(this, options);
      }
      createBrush(options) {
        return new brush_sprite_default(this, options);
      }
      createTextDesign(options) {
        return new text_design_sprite_default(this, options);
      }
      addSprite(sprite) {
        this._options.sprites.push(sprite);
        const smoothDownscaling = this.getSmoothDownscaling();
        if (sprite.setSmoothDownscaling)
          sprite.setSmoothDownscaling(smoothDownscaling);
        this._container.addChild(sprite.getDisplayObject());
        this.setDirty(true);
        sprite.on("update", this._onSpriteUpdate);
        this.emit("update", this, this._options.sprites);
      }
      removeSprite(sprite) {
        const { sprites } = this._options;
        const index = sprites.indexOf(sprite);
        if (index !== -1) {
          sprite.off("update", this._onSpriteUpdate);
          this._container.removeChild(sprite.getDisplayObject());
          sprites.splice(index, 1);
          this.setDirty(true);
          return true;
        }
        return false;
      }
      _getOrientatedStageSize() {
        const frame = this._sdk.getSprite().getTexture().getFrame();
        const orientationOperation = this._sdk.getOperationsStack().getByIdentifier("orientation");
        if (orientationOperation) {
          const rotation = orientationOperation ? orientationOperation.getRotation() : 0;
          const hasSwappedSize = rotation === 270 || rotation === 90;
          return hasSwappedSize ? new Vector231(frame.height, frame.width) : new Vector231(frame.width, frame.height);
        }
        const outputOperation = this._sdk.getOperationsStack().getByIdentifier("output");
        if (outputOperation) {
          return outputOperation.getOutputResolution();
        }
        return new Vector231(frame.width, frame.height);
      }
      _render(inputTexture) {
        const container = this._container;
        const { sprites } = this._options;
        const inputDimensions = inputTexture.getDimensions().clone().floor();
        let currentContainer = new engine_default.Container();
        currentContainer.addChild(this._sprite);
        return Promise.all(sprites.map((s) => s.validateSettings())).then(() => {
          sprites.forEach((sprite) => sprite.update(this._sdk, inputDimensions));
        }).then(() => {
          this._renderTexture.clear();
          sprites.forEach((sprite) => {
            if (sprite.getInverted && sprite.getInverted()) {
              this._renderTexture.render(currentContainer);
              this._renderTexture.render(this._renderMaskedSprite(sprite.getDisplayObject(), sprite.getColor ? sprite.getColor() : color_default.WHITE, sprite.getPadding ? sprite.getPadding() : -1));
              currentContainer = new engine_default.Container();
            } else {
              currentContainer.addChild(sprite.getDisplayObject());
            }
          });
          this._renderTexture.render(currentContainer);
          container.addChild(this._sprite);
          sprites.forEach((s) => container.addChild(s.getDisplayObject()));
        });
      }
      _renderMaskedSprite(displayObject, color, padding) {
        const canvas = this._maskCanvas;
        const worldTransform = displayObject.getWorldTransform();
        const canvasSize = this._getOrientatedStageSize();
        utils_default.ensureCanvasDimensions(canvas, canvasSize);
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.fillStyle = color.toRGBA();
        if (padding < 0) {
          ctx.fillRect(0, 0, canvasSize.x, canvasSize.y);
        } else {
          const spriteWidth = Math.abs(displayObject.getWidth() / displayObject.getScale().x);
          const spriteHeight = Math.abs(displayObject.getHeight() / displayObject.getScale().y);
          const absolutePadding = spriteWidth * padding;
          ctx.transform(worldTransform.a, worldTransform.b, worldTransform.c, worldTransform.d, worldTransform.tx, worldTransform.ty);
          ctx.fillRect(-absolutePadding, -absolutePadding, spriteWidth + absolutePadding * 2, spriteHeight + absolutePadding * 2);
        }
        ctx.restore();
        ctx.save();
        ctx.globalCompositeOperation = "destination-out";
        displayObject._renderCanvas({
          getCurrentRenderTarget: () => {
            return {
              getPixelRatio: () => 1
            };
          },
          beforeDraw: (canvas2) => {
            const centerX = displayObject.getWidth();
            const centerY = displayObject.getHeight();
            const scale = displayObject.getScale();
            const isFlippedHorizontal = scale.x < 0;
            const isFlippedVertically = scale.y < 0;
            canvas2.translate(centerX, centerY);
            canvas2.scale(isFlippedHorizontal ? -1 : 1, isFlippedVertically ? -1 : 1);
            canvas2.translate(-centerX, -centerY);
          },
          getContext: () => ctx
        });
        ctx.restore();
        const container = new engine_default.Container();
        const newSprite = new engine_default.Sprite(engine_default.Texture.fromCanvas(canvas));
        container.addChild(newSprite);
        return container;
      }
      takeSpriteToFront(sprite) {
        const { sprites } = this._options;
        const spriteIndex = sprites.indexOf(sprite);
        if (spriteIndex === -1)
          return;
        utils_default.moveArrayItem(sprites, spriteIndex, sprites.length - 1);
        const displayObject = sprite.getDisplayObject();
        this._container.removeChild(displayObject);
        this._container.addChild(displayObject);
        this.setDirty(true);
      }
      getSpritesAtPosition(position, inputDimensions) {
        const intersectingSprites = [];
        this._options.sprites.forEach((s) => s.update(this._sdk, inputDimensions));
        const outputSprite = this._sdk.getSprite();
        const actualPosition = outputSprite.getWorldTransform().applyInverseToVector(position);
        const { width, height } = outputSprite.getTexture().getFrame();
        const anchorOffset = outputSprite.getAnchor().clone().multiply(-width, -height);
        actualPosition.subtract(anchorOffset);
        const sprites = this._options.sprites.slice(0).reverse();
        for (let i = 0, c = sprites.length; i < c; i++) {
          const sprite = sprites[i];
          if (sprite.getHitTestDisplayObject().isAtPosition(actualPosition)) {
            intersectingSprites.push(sprite);
          }
        }
        return intersectingSprites;
      }
      setDirtyForRenderer(dirty, renderer, dimensionsChanged) {
        super.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
        this._options.sprites.forEach((sprite) => {
          sprite.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
        });
      }
      dispose() {
        super.dispose();
        this._options.sprites.forEach((sprite) => {
          sprite.dispose();
        });
      }
    };
    SpriteOperation.StickerSprite = sticker_sprite_default;
    SpriteOperation.TextSprite = text_sprite_default;
    SpriteOperation.BrushSprite = brush_sprite_default;
    SpriteOperation.TextDesignSprite = text_design_sprite_default;
    SpriteOperation.identifier = "sprite";
    SpriteOperation.prototype.availableOptions = {
      sprites: {
        type: "array" /* ARRAY */,
        default: [],
        setter(sprites, initial) {
          sprites = sprites.map((sprite, i) => {
            if (sprite instanceof sprite_default) {
              return sprite;
            }
            const spriteData = __spreadValues({}, sprite);
            delete spriteData.type;
            switch (sprite.type) {
              case "text":
                return new text_sprite_default(this, spriteData);
              case "sticker":
                return new sticker_sprite_default(this, spriteData);
              case "brush":
                return new brush_sprite_default(this, spriteData);
              case "textdesign":
                return new text_design_sprite_default(this, spriteData);
              default: {
                log_default.error(this.constructor.name, `Invalid sprite type: ${sprite.type}`);
                return null;
              }
            }
          });
          if (!initial) {
            if (this._options.sprites) {
              const spritesToRemove = this._options.sprites.slice();
              spritesToRemove.forEach((sprite) => {
                sprite.dispose();
                this.removeSprite(sprite);
              });
            }
            sprites.forEach((sprite) => {
              this.addSprite(sprite);
            });
          }
          return sprites;
        }
      },
      smoothDownscaling: { type: "boolean" /* BOOLEAN */, default: false }
    };
    exports_default.Operations.SpriteOperation = SpriteOperation;
    sprite_operation_default = SpriteOperation;
  }
});

// engine/sdk/operations/transform-operation/transform-change.js
var Vector232, TransformChange, transform_change_default;
var init_transform_change = __esm({
  "engine/sdk/operations/transform-operation/transform-change.js"() {
    init_core();
    ({ Vector2: Vector232 } = math_exports);
    TransformChange = class {
      constructor(operation, options) {
        this._options = options;
        this._oldOptions = {
          start: operation.getStart().clone(),
          end: operation.getEnd().clone(),
          rotation: operation.getRotation(),
          textureScale: operation.getTextureScale()
        };
        this._inputDimensions = operation.getInputDimensions(false);
        this._rotationDelta = options.rotation - operation.getRotation();
        this._deltaCos = Math.cos(this._rotationDelta);
        this._deltaSin = Math.sin(this._rotationDelta);
        this._oldAbsoluteSize = this._oldOptions.end.clone().subtract(this._oldOptions.start).multiply(this._inputDimensions);
        this._newAbsoluteSize = options.end.clone().subtract(options.start).multiply(this._inputDimensions);
        this._absoluteStartDiff = this._oldOptions.start.clone().subtract(options.start).multiply(this._inputDimensions);
        this._scaleRatio = operation.calculateScale(options.rotation) / operation.calculateScale();
        this._sizeFactor = this._newAbsoluteSize.clone().divide(this._oldAbsoluteSize);
        this._textureScaleFactor = this._options.textureScale / operation.getTextureScale();
      }
      applyToRelativePoint(point) {
        const oldStart = this._oldOptions.start;
        const oldEnd = this._oldOptions.end;
        const cropCenter = oldStart.clone().add(oldEnd.clone().subtract(oldStart).divide(2));
        const pixelCropCenter = cropCenter.multiply(this._inputDimensions);
        const pointPixelDistanceToCropCenter = point.clone().multiply(this._oldAbsoluteSize).subtract(this._oldAbsoluteSize.clone().divide(2));
        const pointPixelPositionOnImage = pixelCropCenter.clone().add(pointPixelDistanceToCropCenter);
        const pointPixelDistanceToImageCenter = pointPixelPositionOnImage.clone().subtract(this._inputDimensions.clone().divide(2));
        const rotatedPointPixelDistanceToImageCenter = new Vector232(pointPixelDistanceToImageCenter.x * this._deltaCos - pointPixelDistanceToImageCenter.y * this._deltaSin, pointPixelDistanceToImageCenter.x * this._deltaSin + pointPixelDistanceToImageCenter.y * this._deltaCos);
        const rotatedPointPixelPositionOnImage = this._inputDimensions.clone().divide(2).add(rotatedPointPixelDistanceToImageCenter);
        const newAbsoluteStart = this._options.start.clone().multiply(this._inputDimensions);
        return rotatedPointPixelPositionOnImage.clone().subtract(newAbsoluteStart).divide(this._newAbsoluteSize);
      }
      applyToRelativeSize(size) {
        return size * this._oldAbsoluteSize.min() / this._newAbsoluteSize.min();
      }
      applyToDimensions(dimensions) {
        dimensions = dimensions.clone().multiply(this._scaleRatio);
        if (this._options.textureScale) {
          dimensions.multiply(this._textureScaleFactor);
        }
        return dimensions;
      }
      scaleSize(size, side = "y") {
        return size / this._sizeFactor[side];
      }
      applyToRotation(rotation) {
        return (rotation + this._rotationDelta) % (Math.PI * 2);
      }
      invert() {
        const newStart = this._options.start.clone();
        const newEnd = this._options.end.clone();
        const newInputDimensions = this._inputDimensions;
        const invRotationDelta = -this._rotationDelta;
        const invDeltaCos = Math.cos(invRotationDelta);
        const invDeltaSin = Math.sin(invRotationDelta);
        const newAbsoluteSize = this._oldAbsoluteSize;
        const oldAbsoluteSize = this._newAbsoluteSize;
        const invAbsoluteStartDiff = newStart.clone().subtract(newEnd).multiply(newInputDimensions);
        const invScaleRatio = 1 / this._scaleRatio;
        const invSizeFactor = new Vector232(1 / this._sizeFactor.x, 1 / this._sizeFactor.y);
        const invTextureScaleFactor = 1 / this._textureScaleFactor;
        const newOptions = this._oldOptions;
        this._oldOptions = this._options;
        this._options = newOptions;
        this._inputDimensions = newInputDimensions;
        this._rotationDelta = invRotationDelta;
        this._deltaCos = invDeltaCos;
        this._deltaSin = invDeltaSin;
        this._oldAbsoluteSize = oldAbsoluteSize;
        this._newAbsoluteSize = newAbsoluteSize;
        this._absoluteStartDiff = invAbsoluteStartDiff;
        this._scaleRatio = invScaleRatio;
        this._sizeFactor = invSizeFactor;
        this._textureScaleFactor = invTextureScaleFactor;
        return this;
      }
    };
    transform_change_default = TransformChange;
  }
});

// engine/sdk/operations/transform-operation/index.js
var Vector233, TransformOperation, transform_operation_default;
var init_transform_operation = __esm({
  "engine/sdk/operations/transform-operation/index.js"() {
    init_core();
    init_transform_change();
    ({ Vector2: Vector233 } = math_exports);
    TransformOperation = class extends operation_default {
      _render(inputTexture) {
        this._sprite.setRotation(0);
        const inputDimensions = inputTexture.getDimensions();
        const { start, end, rotation, textureScale } = this._options;
        const size = end.clone().subtract(start);
        const offset = size.clone().divide(2);
        const middle = start.clone().add(offset);
        const scale = this.calculateScale();
        const finalScale = scale * textureScale;
        const outputMiddle = inputDimensions.clone().multiply(finalScale).multiply(offset);
        this._sprite.setAnchor(middle);
        this._sprite.setRotation(rotation);
        this._sprite.setScale(finalScale, finalScale);
        this._sprite.setPosition(outputMiddle);
        this._renderTexture.render(this._container);
        return Promise.resolve();
      }
      calculateScale(rotation = this._options.rotation) {
        const inputDimensions = this.getInputDimensions(false);
        const rotatedDimensions = new Vector233(Math.abs(inputDimensions.x * Math.cos(rotation)) + Math.abs(inputDimensions.y * Math.sin(rotation)), Math.abs(inputDimensions.x * Math.sin(rotation)) + Math.abs(inputDimensions.y * Math.cos(rotation)));
        const distanceToCorner = inputDimensions.clone().subtract(rotatedDimensions.clone()).divide(2).abs();
        let scale = 1;
        if (distanceToCorner.y > distanceToCorner.x) {
          scale = distanceToCorner.y * 2 / inputDimensions.y + 1;
        } else {
          scale = distanceToCorner.x * 2 / inputDimensions.x + 1;
        }
        return scale;
      }
      getNewDimensions(inputDimensions) {
        const { start, end, textureScale } = this._options;
        const scale = this.calculateScale();
        const newDimensions = inputDimensions.clone().multiply(textureScale * scale).multiply(end.clone().subtract(start));
        return newDimensions.round();
      }
      flip(direction) {
        const { start, end } = this._options;
        const tmpStart = start.clone();
        if (direction === "horizontal") {
          start.set(1 - end.x, start.y);
          end.set(1 - tmpStart.x, end.y);
        } else if (direction === "vertical") {
          start.set(start.x, 1 - end.y);
          end.set(end.x, 1 - tmpStart.y);
        }
      }
      rotate(degrees) {
        const { start, end } = this._options;
        const degreesDifference = (degrees + 360) % 360;
        const steps = Math.floor(degreesDifference / 90);
        for (let i = 0; i < steps; i++) {
          const tempStart = start.clone();
          start.set(1 - end.y, tempStart.x);
          end.set(1 - tempStart.y, end.x);
        }
      }
      _onBeforeExport() {
        this._wasEnabledBeforeExport = this.getEnabled();
        this.setEnabled(true);
      }
      _onAfterExport() {
        this.setEnabled(this._wasEnabledBeforeExport, true);
      }
    };
    TransformOperation.identifier = "transform";
    TransformOperation.prototype.availableOptions = {
      start: { type: "vector2" /* VECTOR2 */, default: new Vector233(0, 0) },
      end: { type: "vector2" /* VECTOR2 */, default: new Vector233(1, 1) },
      textureScale: { type: "number" /* NUMBER */, default: 1 },
      rotation: { type: "number" /* NUMBER */, default: 0 }
    };
    TransformOperation.TransformChange = transform_change_default;
    exports_default.Operations.TransformOperation = TransformOperation;
    transform_operation_default = TransformOperation;
  }
});

// engine/sdk/operations/watermark-operation/index.ts
var WatermarkOperation, watermark_operation_default;
var init_watermark_operation = __esm({
  "engine/sdk/operations/watermark-operation/index.ts"() {
    init_globals3();
    init_core();
    init_globals2();
    WatermarkOperation = class extends operation_default {
      constructor(...args) {
        super(...args);
        this._watermarkImage = null;
        this._watermarkTexture = null;
        this._loadWatermarkImage = () => {
          if (!this._watermarkImage) {
            if (!(this._options.watermarkURI instanceof window.Image)) {
              const crossOrigin = {
                value: this._options.crossOrigin,
                cors: true
              };
              return image_loader_default.loadImage(this._options.watermarkURI, crossOrigin).then((image) => {
                this._watermarkImage = image;
              });
            }
            this._watermarkImage = this._options.watermarkURI;
          }
          return Promise.resolve();
        };
        this._setWatermarkalignment = (dimensions, textureDimensions) => {
          const inset = Math.min(textureDimensions.x, textureDimensions.y) * utils_default.clamp(this._options.inset, 0, 1);
          switch (this._options.alignment) {
            case "center":
              this._watermarkSprite.setPosition(new Vector2(textureDimensions.x - dimensions.x, textureDimensions.y - dimensions.y).divide(2));
              break;
            case "top-left":
              this._watermarkSprite.setPosition(new Vector2(inset, inset));
              break;
            case "top-right":
              this._watermarkSprite.setPosition(new Vector2(textureDimensions.x - dimensions.x - inset, inset));
              break;
            case "bottom-left":
              this._watermarkSprite.setPosition(new Vector2(inset, textureDimensions.y - dimensions.y - inset));
              break;
            case "bottom-right":
              this._watermarkSprite.setPosition(new Vector2(textureDimensions.x - dimensions.x - inset, textureDimensions.y - dimensions.y - inset));
              break;
            default:
              this._watermarkSprite.setPosition(new Vector2(0, 0));
              break;
          }
        };
        this._watermarkSprite = new engine_default.Sprite();
        this._watermarkSprite.setAnchor(0, 0);
        this._container.addChild(this._watermarkSprite);
      }
      _render(inputTexture) {
        const { alpha, size } = this._options;
        return this._loadWatermarkImage().then(() => {
          if (this._watermarkImage) {
            if (!this._watermarkTexture) {
              this._watermarkTexture = engine_default.Texture.fromImage(this._watermarkImage);
              this._watermarkSprite.setTexture(this._watermarkTexture);
            }
            const textureDimensions = inputTexture.getDimensions();
            const { width, height } = this._watermarkImage;
            const dimensions = utils_default.resizeVectorToFit(new Vector2(width, height), textureDimensions.clone().multiply(utils_default.clamp(size, 0, 1)));
            this._setWatermarkalignment(dimensions, textureDimensions);
            this._watermarkSprite.setWidth(dimensions.x);
            this._watermarkSprite.setHeight(dimensions.y);
            this._watermarkSprite.setAlpha(alpha);
            if (this._renderTexture) {
              this._renderTexture.render(this._container);
            }
          }
          return Promise.resolve();
        });
      }
      dispose() {
        super.dispose();
        this._watermarkSprite.dispose();
      }
    };
    WatermarkOperation.identifier = "watermark";
    WatermarkOperation.prototype.availableOptions = {
      watermarkURI: { type: "string" /* STRING */, required: true },
      alignment: { type: "string" /* STRING */, default: "top-right" },
      inset: { type: "number" /* NUMBER */, default: "0.05" },
      size: { type: "number" /* NUMBER */, default: "0.2" },
      alpha: { type: "number" /* NUMBER */, default: 1 },
      crossOrigin: { type: "string" /* STRING */, default: "anonymous" }
    };
    exports_default.Operations.WatermarkOperation = WatermarkOperation;
    watermark_operation_default = WatermarkOperation;
  }
});

// engine/sdk/operations/index.js
var Operations;
var init_operations2 = __esm({
  "engine/sdk/operations/index.js"() {
    init_core();
    init_adjustments_operation();
    init_blur_operation();
    init_filter_operation();
    init_flip_operation();
    init_frame_operation();
    init_license_watermark_operation();
    init_linear_focus_operation();
    init_mirrored_focus_operation();
    init_orientation_operation();
    init_output_operation();
    init_overlay_operation();
    init_radial_focus_operation();
    init_selective_blur_operation();
    init_sprite_operation();
    init_transform_operation();
    init_watermark_operation();
    Operations = [
      adjustments_operation_default,
      blur_operation_default,
      filter_operation_default,
      frame_operation_default,
      license_watermark_operation_default,
      linear_focus_operation_default,
      mirrored_focus_operation_default,
      orientation_operation_default,
      overlay_operation_default,
      radial_focus_operation_default,
      selective_blur_operation_default,
      sprite_operation_default,
      transform_operation_default,
      watermark_operation_default,
      output_operation_default,
      flip_operation_default
    ];
    exports_default.AllOperations = Operations;
  }
});

// engine/sdk/index.js
var init_sdk2 = __esm({
  "engine/sdk/index.js"() {
    init_operations2();
    init_exports();
    init_exports();
  }
});

// engine/headless/lib/constants/defaults/fonts.js
var fonts_default;
var init_fonts = __esm({
  "engine/headless/lib/constants/defaults/fonts.js"() {
    fonts_default = [
      {
        fontFamily: "Open Sans",
        variations: [
          {
            identifier: "imgly_font_open_sans_bold",
            fontWeight: "bold",
            provider: "file",
            filePath: "fonts/imgly_font_open_sans_bold.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2189,
              descender: -600
            }
          }
        ]
      },
      {
        fontFamily: "Aleo",
        variations: [
          {
            identifier: "imgly_font_aleo_bold",
            fontWeight: "bold",
            provider: "file",
            filePath: "fonts/imgly_font_aleo_bold.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 805,
              descender: -195
            }
          }
        ]
      },
      {
        fontFamily: "Amatic SC",
        variations: [
          {
            identifier: "imgly_font_amaticsc",
            fontWeight: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_amaticsc.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1016,
              descender: -245
            }
          }
        ]
      },
      {
        fontFamily: "Archivo",
        variations: [
          {
            identifier: "imgly_font_archivo_black",
            fontWeight: "normal",
            filePath: "fonts/imgly_font_archivo_black.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 878,
              descender: -210
            }
          }
        ]
      },
      {
        fontFamily: "Bungee Inline",
        variations: [
          {
            identifier: "imgly_font_bungee_inline",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_bungee_inline.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 860,
              descender: -140
            }
          }
        ]
      },
      {
        fontFamily: "Carter",
        variations: [
          {
            identifier: "imgly_font_carter_one",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_carter_one.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2264,
              descender: -890
            }
          }
        ]
      },
      {
        fontFamily: "Codystar",
        variations: [
          {
            identifier: "imgly_font_codystar",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_codystar.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1024,
              ascender: 953,
              descender: -255
            }
          }
        ]
      },
      {
        fontFamily: "Fira Sans",
        variations: [
          {
            identifier: "imgly_font_fira_sans_regular",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_fira_sans_regular.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 935,
              descender: -265
            }
          }
        ]
      },
      {
        fontFamily: "Krona One",
        variations: [
          {
            identifier: "imgly_font_krona_one",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_krona_one.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2030,
              descender: -530
            }
          }
        ]
      },
      {
        fontFamily: "Kumar One Outline",
        variations: [
          {
            identifier: "imgly_font_kumar_one_outline",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_kumar_one_outline.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1137,
              descender: -642
            }
          }
        ]
      },
      {
        fontFamily: "Lobster",
        variations: [
          {
            identifier: "imgly_font_lobster",
            fontWeight: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_lobster.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1e3,
              descender: -250
            }
          }
        ]
      },
      {
        fontFamily: "Molle",
        variations: [
          {
            identifier: "imgly_font_molle",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_molle.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1852,
              descender: -701
            }
          }
        ]
      },
      {
        fontFamily: "Monoton",
        variations: [
          {
            identifier: "imgly_font_monoton",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_monoton.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2366,
              descender: -822
            }
          }
        ]
      },
      {
        fontFamily: "Nixie One",
        variations: [
          {
            identifier: "imgly_font_nixie_one",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_nixie_one.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 926,
              descender: -210
            }
          }
        ]
      },
      {
        fontFamily: "Notable",
        variations: [
          {
            identifier: "imgly_font_notable",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_notable.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1143,
              descender: -157
            }
          }
        ]
      },
      {
        fontFamily: "Ostrich",
        variations: [
          {
            identifier: "imgly_font_ostrich_sans_black",
            fontWeight: 800,
            provider: "file",
            filePath: "fonts/imgly_font_ostrich_sans_black.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 950,
              descender: -250
            }
          },
          {
            identifier: "imgly_font_ostrich_sans_bold",
            fontWeight: "bold",
            provider: "file",
            filePath: "fonts/imgly_font_ostrich_sans_bold.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 950,
              descender: -250
            }
          }
        ]
      },
      {
        fontFamily: "Oswald SemiBold",
        variations: [
          {
            identifier: "imgly_font_oswald_semi_bold",
            fontWeight: 600,
            fontStyle: "normal",
            filePath: "fonts/imgly_font_oswald_semi_bold.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1193,
              descender: -289
            }
          }
        ]
      },
      {
        fontFamily: "Palanquin Dark SemiBold",
        variations: [
          {
            identifier: "imgly_font_palanquin_dark_semi_bold",
            fontWeight: "bold",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_palanquin_dark_semi_bold.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1320,
              descender: -491
            }
          }
        ]
      },
      {
        fontFamily: "Poppins",
        variations: [
          {
            identifier: "imgly_font_poppins",
            fontWeight: "bold",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_poppins.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1050,
              descender: -350
            }
          }
        ]
      },
      {
        fontFamily: "Permanent Marker",
        variations: [
          {
            identifier: "imgly_font_permanent_marker",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_permanent_marker.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1024,
              ascender: 1136,
              descender: -325
            }
          }
        ]
      },
      {
        fontFamily: "Roboto Black",
        variations: [
          {
            identifier: "imgly_font_roboto_black_italic",
            fontWeight: "normal",
            fontStyle: "italic",
            filePath: "fonts/imgly_font_roboto_black_italic.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1900,
              descender: -500
            }
          }
        ]
      },
      {
        fontFamily: "Roboto Light",
        variations: [
          {
            identifier: "imgly_font_roboto_light_italic",
            fontWeight: "normal",
            fontStyle: "italic",
            filePath: "fonts/imgly_font_roboto_light_italic.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1900,
              descender: -500
            }
          }
        ]
      },
      {
        fontFamily: "Sancreek",
        variations: [
          {
            identifier: "imgly_font_sancreek",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_sancreek.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2104,
              descender: -738
            }
          }
        ]
      },
      {
        fontFamily: "Stint Ultra Expanded",
        variations: [
          {
            identifier: "imgly_font_stint_ultra_expanded",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_stint_ultra_expanded.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1853,
              descender: -483
            }
          }
        ]
      },
      {
        fontFamily: "Trashhand",
        variations: [
          {
            identifier: "imgly_font_trash_hand",
            fontWeight: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_trash_hand.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 759,
              descender: -304
            }
          }
        ]
      },
      {
        fontFamily: "VT323",
        variations: [
          {
            identifier: "imgly_font_vt323",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_vt323.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 800,
              descender: -200
            }
          }
        ]
      },
      {
        fontFamily: "Yeseva One",
        variations: [
          {
            identifier: "imgly_font_yeseva_one",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_yeseva_one.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 915,
              descender: -240
            }
          }
        ]
      },
      {
        fontFamily: "Lexend",
        variations: [
          {
            identifier: "imgly_font_lexend_bold",
            fontWeight: "bold",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_lexend_bold.ttf",
            default: true,
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1e3,
              descender: -250
            }
          }
        ]
      },
      {
        fontFamily: "Outfit",
        variations: [
          {
            identifier: "imgly_font_outfit_bold",
            fontWeight: "bold",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_outfit_bold.ttf",
            default: true,
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1e3,
              descender: -260
            }
          }
        ]
      }
    ];
  }
});

// engine/headless/lib/constants/defaults/text-design-fonts.js
var text_design_fonts_default;
var init_text_design_fonts = __esm({
  "engine/headless/lib/constants/defaults/text-design-fonts.js"() {
    text_design_fonts_default = [
      {
        fontFamily: "Open Sans",
        variations: [
          {
            identifier: "imgly_font_open_sans_bold",
            fontWeight: "bold",
            provider: "file",
            filePath: "fonts/imgly_font_open_sans_bold.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2189,
              descender: -600
            }
          }
        ]
      },
      {
        fontFamily: "Abril Fatface",
        variations: [
          {
            identifier: "imgly_font_abril_fatface_regular",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_abril_fatface_regular.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1058,
              descender: -291
            }
          }
        ]
      },
      {
        fontFamily: "Bungee Inline",
        variations: [
          {
            identifier: "imgly_font_bungee_inline",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_bungee_inline.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 860,
              descender: -140
            }
          }
        ]
      },
      {
        fontFamily: "Handycheera",
        variations: [
          {
            identifier: "imgly_font_handycheera_regular",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_handycheera_regular.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2199,
              descender: -808
            }
          }
        ]
      },
      {
        fontFamily: "Montserrat Light",
        variations: [
          {
            identifier: "imgly_font_montserrat_light",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_montserrat_light.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 968,
              descender: -251
            }
          }
        ]
      },
      {
        fontFamily: "Ostrich",
        variations: [
          {
            identifier: "imgly_font_ostrich_sans_black",
            fontWeight: 800,
            provider: "file",
            filePath: "fonts/imgly_font_ostrich_sans_black.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 950,
              descender: -250
            }
          },
          {
            identifier: "imgly_font_ostrich_sans_bold",
            fontWeight: "bold",
            provider: "file",
            filePath: "fonts/imgly_font_ostrich_sans_bold.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 950,
              descender: -250
            }
          },
          {
            identifier: "imgly_font_ostrich_sans_heavy",
            fontWeight: 900,
            provider: "file",
            filePath: "fonts/imgly_font_ostrich_sans_heavy.woff",
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 674,
              descender: 0
            }
          }
        ]
      },
      {
        fontFamily: "Permanent Marker",
        variations: [
          {
            identifier: "imgly_font_permanent_marker",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_permanent_marker.woff",
            textMetrics: {
              unitsPerEm: 1024,
              ascender: 1136,
              descender: -325
            }
          }
        ]
      },
      {
        fontFamily: "Petit Formal Script",
        variations: [
          {
            identifier: "imgly_font_petit_formal_script",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_petit_formal_script.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2033,
              descender: -527
            }
          }
        ]
      },
      {
        fontFamily: "Rasa",
        variations: [
          {
            identifier: "imgly_font_rasa_regular",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_rasa_regular.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 2750,
              ascender: 2300,
              descender: -1050
            }
          },
          {
            identifier: "imgly_font_rasa_500",
            fontWeight: 500,
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_rasa_500.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 2750,
              ascender: 2300,
              descender: -1050
            }
          }
        ]
      },
      {
        fontFamily: "Roboto Black",
        variations: [
          {
            identifier: "imgly_font_roboto_black",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_roboto_black.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1900,
              descender: -500
            }
          },
          {
            identifier: "imgly_font_roboto_black_italic",
            fontWeight: "normal",
            fontStyle: "italic",
            filePath: "fonts/imgly_font_roboto_black_italic.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1900,
              descender: -500
            }
          }
        ]
      },
      {
        fontFamily: "Roboto Light",
        variations: [
          {
            identifier: "imgly_font_roboto_light",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_roboto_light.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1900,
              descender: -500
            }
          },
          {
            identifier: "imgly_font_roboto_light_italic",
            fontWeight: "normal",
            fontStyle: "italic",
            filePath: "fonts/imgly_font_roboto_light_italic.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 1900,
              descender: -500
            }
          }
        ]
      },
      {
        fontFamily: "Sue Ellen Francisco",
        variations: [
          {
            identifier: "imgly_font_sue_ellen_francisco",
            fontWeight: "normal",
            fontStyle: "normal",
            filePath: "fonts/imgly_font_sue_ellen_francisco.woff",
            provider: "file",
            textMetrics: {
              unitsPerEm: 1024,
              ascender: 1362,
              descender: -634
            }
          }
        ]
      },
      {
        fontFamily: "Ultra",
        variations: [
          {
            identifier: "imgly_font_ultra",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_ultra.woff",
            default: true,
            textMetrics: {
              unitsPerEm: 2048,
              ascender: 2066,
              descender: -561
            }
          }
        ]
      },
      {
        fontFamily: "Allison",
        variations: [
          {
            identifier: "imgly_font_allison_regular",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_allison_regular.ttf",
            default: true,
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 890,
              descender: -380
            }
          }
        ]
      },
      {
        fontFamily: "Cookie",
        variations: [
          {
            identifier: "imgly_font_cookie_regular",
            fontWeight: "normal",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_cookie_regular.ttf",
            default: true,
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 789,
              descender: -320
            }
          }
        ]
      },
      {
        fontFamily: "Lexend",
        variations: [
          {
            identifier: "imgly_font_lexend_bold",
            fontWeight: "bold",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_lexend_bold.ttf",
            default: true,
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1e3,
              descender: -250
            }
          }
        ]
      },
      {
        fontFamily: "Outfit",
        variations: [
          {
            identifier: "imgly_font_outfit_bold",
            fontWeight: "bold",
            fontStyle: "normal",
            provider: "file",
            filePath: "fonts/imgly_font_outfit_bold.ttf",
            default: true,
            textMetrics: {
              unitsPerEm: 1e3,
              ascender: 1e3,
              descender: -260
            }
          }
        ]
      }
    ];
  }
});

// engine/headless/lib/constants/defaults/transform-ratio-categories.js
var transform_ratio_categories_default;
var init_transform_ratio_categories = __esm({
  "engine/headless/lib/constants/defaults/transform-ratio-categories.js"() {
    transform_ratio_categories_default = [
      {
        identifier: "imgly_transforms_common",
        defaultName: "Common Ratios",
        ratios: [
          {
            identifier: "imgly_transform_common_custom",
            defaultName: "Custom",
            ratio: "*",
            selected: true
          },
          {
            identifier: "imgly_transform_common_square",
            defaultName: "Square",
            ratio: 1
          },
          {
            identifier: "imgly_transform_common_4-3",
            defaultName: "4:3",
            ratio: 4 / 3
          },
          {
            identifier: "imgly_transform_common_16-9",
            defaultName: "16:9",
            ratio: 16 / 9
          }
        ]
      },
      {
        identifier: "imgly_transforms_facebook",
        defaultName: "Facebook",
        ratios: [
          {
            identifier: "imgly_transform_facebook_profile",
            defaultName: "Profile Pic",
            dimensions: { x: 300, y: 300 },
            forceDimensions: false,
            lockDimensions: true
          },
          {
            identifier: "imgly_transform_facebook_ad",
            defaultName: "Ad",
            dimensions: { x: 1200, y: 627 }
          },
          {
            identifier: "imgly_transform_facebook_post",
            defaultName: "Post",
            dimensions: { x: 940, y: 788 }
          },
          {
            identifier: "imgly_transform_facebook_cover",
            defaultName: "Cover",
            dimensions: { x: 851, y: 315 }
          }
        ]
      }
    ];
  }
});

// engine/headless/lib/constants/defaults/index.js
var BRUSHES, defaults_default;
var init_defaults = __esm({
  "engine/headless/lib/constants/defaults/index.js"() {
    init_sdk2();
    init_fonts();
    init_text_design_fonts();
    init_transform_ratio_categories();
    BRUSHES = [];
    if (typeof exports_default.Operations.SpriteOperation !== "undefined") {
      BRUSHES.push(exports_default.Operations.SpriteOperation.BrushSprite.Brushes.RadialBrush);
    }
    defaults_default = {
      TRANSFORM_RATIO_CATEGORIES: transform_ratio_categories_default,
      FONTS: fonts_default,
      TEXT_DESIGN_FONTS: text_design_fonts_default,
      BRUSHES
    };
  }
});

// engine/headless/lib/constants/events.js
var Events3, events_default;
var init_events = __esm({
  "engine/headless/lib/constants/events.js"() {
    init_constants2();
    Events3 = __spreadProps(__spreadValues({}, Events), {
      LOAD: "load",
      SAVE: "save",
      EDITOR_RESIZE: "editor:resize",
      ZOOM: "editor:zoom",
      ZOOM_CHANGED: "editor:zoom_changed",
      HISTORY_REDO: "history:redo",
      HISTORY_BEFORE_REDO: "history:before-redo",
      TEXT_SCALED: "editor:text:scaled",
      TRANSFORM_RESIZE: "transform:resize",
      TRANSFORM_AFTER_EDIT: "transform:after-edit",
      ADDED_STICKER: "sticker:added-sticker",
      SPRITES_DESELECTED: "editor:sprite:deselected-all",
      CANVAS_FOCUS: "canvas:focus"
    });
    events_default = Events3;
  }
});

// engine/headless/lib/constants/index.js
var constants_default3;
var init_constants4 = __esm({
  "engine/headless/lib/constants/index.js"() {
    init_defaults();
    init_events();
    constants_default3 = {
      EVENTS: events_default,
      DEFAULTS: defaults_default
    };
  }
});

// engine/headless/lib/browser.js
function getIEVersion() {
  const { userAgent, appVersion } = navigator;
  if (appVersion.indexOf("MSIE") !== -1) {
    return appVersion.match(/MSIE\s+?([0-9]+)/i)[1];
  }
  if (userAgent.indexOf("Trident") !== -1) {
    return userAgent.match(/rv:([0-9]+)/i)[1];
  }
  return false;
}
var browser_default;
var init_browser = __esm({
  "engine/headless/lib/browser.js"() {
    browser_default = {
      getIEVersion
    };
  }
});

// engine/headless/lib/utils.js
var SDKUtils, Vector234, UIUtils, utils_default2;
var init_utils2 = __esm({
  "engine/headless/lib/utils.js"() {
    init_sdk2();
    init_json_loader();
    init_log();
    init_cleanUpCanvasMemory();
    init_browser();
    SDKUtils = exports_default.Utils;
    ({ Vector2: Vector234 } = exports_default.Math);
    UIUtils = {
      getInnerDimensionsForElement(element) {
        const size = new Vector234(element.offsetWidth, element.offsetHeight);
        const computedStyle = window.getComputedStyle(element, null);
        size.x -= parseInt(computedStyle.getPropertyValue("padding-left"), 10);
        size.x -= parseInt(computedStyle.getPropertyValue("padding-right"), 10);
        size.y -= parseInt(computedStyle.getPropertyValue("padding-top"), 10);
        size.y -= parseInt(computedStyle.getPropertyValue("padding-bottom"), 10);
        return size;
      },
      getEventPosition(e) {
        let x = e.clientX;
        let y = e.clientY;
        if (e.type.indexOf("touch") !== -1) {
          if (!e.touches.length)
            return;
          x = e.touches[0].clientX;
          y = e.touches[0].clientY;
        }
        return new Vector234(x, y);
      },
      createTransparentPatternCanvas() {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 10;
        canvas.height = 10;
        context.fillStyle = "white";
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = "#cccccc";
        context.fillRect(0, 0, canvas.width / 2, canvas.height / 2);
        context.fillRect(canvas.width / 2, canvas.height / 2, canvas.width, canvas.height);
        return canvas;
      },
      supportsMSBlob() {
        const canvas = document.createElement("canvas");
        const supported = typeof canvas.msToBlob !== "undefined";
        cleanUpCanvasMemory(canvas);
        return supported;
      },
      translate(phrases, key, interpolationOptions = {}) {
        let response = this.fetch(phrases, key);
        if (!response) {
          log_default.info("Utils#translate", `Unable to translate \`${key}\``);
          return null;
        }
        for (const key2 in interpolationOptions) {
          response = response.replace(`\${${key2}}`, interpolationOptions[key2]);
        }
        return response;
      },
      fetch(object, path, defaultValue) {
        path = path.replace(/\[(\w+)]/g, ".$1");
        path = path.replace(/^\./, "");
        const pathSegments = path.split(".");
        for (let i = 0; i < pathSegments.length; i++) {
          const segment = pathSegments[i];
          object = object[segment];
          if (!object) {
            break;
          }
        }
        if (typeof object === "undefined") {
          return false;
        }
        return object;
      },
      isMobile() {
        const a = navigator.userAgent || navigator.vendor || window.opera;
        return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
      },
      select(items, selectedItems, selector = null) {
        if (!selector)
          selector = (i) => i;
        const newItems = [];
        selectedItems.forEach((selectedItem) => {
          items.forEach((item) => {
            const itemIdentifier = selector(item);
            if (itemIdentifier === selectedItem) {
              newItems.push(item);
            }
          });
        });
        return newItems;
      },
      getJSONP(url) {
        const loader = new JSONLoader(url);
        return loader.load();
      },
      cloneCategories(categories, itemsProperty) {
        return categories.map((category) => {
          category = SDKUtils.clone(category);
          category[itemsProperty] = category[itemsProperty].slice(0);
          return category;
        });
      },
      mergeCategories(categories, newCategories, itemsProperty) {
        categories = this.cloneCategories(categories, itemsProperty);
        let existingCategory = null;
        newCategories.forEach((newCategory) => {
          categories.forEach((category) => {
            if (newCategory.identifier === category.identifier) {
              existingCategory = category;
            }
          });
          if (!existingCategory) {
            categories.push(newCategory);
          } else {
            existingCategory[itemsProperty] = existingCategory[itemsProperty].concat(newCategory[itemsProperty]);
          }
        });
        return categories;
      },
      wrapFiltersInCategories(categories, itemsProperty) {
        return categories.map((item) => {
          let category = item;
          if (!(itemsProperty in category)) {
            category = {
              identifier: `imgly_filters_wrapped-${item.identifier}`,
              displayFlat: true,
              [itemsProperty]: [item]
            };
          }
          return category;
        });
      },
      getStyleObject(el) {
        const styleProperties = window.getComputedStyle(el);
        const styleObject = {};
        for (const property in styleProperties) {
          const value = styleProperties.getPropertyValue(property);
          const camelizedAttr = property.replace(/-([a-z])/g, (a, b) => b.toUpperCase());
          if (value !== "") {
            styleObject[camelizedAttr] = value;
          }
        }
        return styleObject;
      },
      styleElement(element, styles) {
        for (const prop in styles) {
          element.style[prop] = styles[prop];
        }
      },
      debounce(fn, wait, immediate) {
        let timeout;
        return function(...args) {
          const later = () => {
            timeout = null;
            if (!immediate)
              fn.apply(this, args);
          };
          const callNow = immediate && !timeout;
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
          if (callNow)
            fn.apply(this, args);
        };
      },
      getScrollbarWidth() {
        const outer = document.createElement("div");
        outer.style.visibility = "hidden";
        outer.style.width = "100px";
        outer.style.msOverflowStyle = "scrollbar";
        document.body.appendChild(outer);
        const widthNoScroll = outer.offsetWidth;
        outer.style.overflow = "scroll";
        const inner = document.createElement("div");
        inner.style.width = "100%";
        outer.appendChild(inner);
        const widthWithScroll = inner.offsetWidth;
        outer.parentNode.removeChild(outer);
        return widthNoScroll - widthWithScroll;
      },
      findIntegerFraction(ratio, maxIterations = 100) {
        let bestDelta = Number.MAX_VALUE;
        let bestX = 0;
        let bestY = 0;
        let x = 1;
        let y = 1;
        for (let iterations = 0; iterations < maxIterations; iterations++) {
          const delta = x / y - ratio;
          if (delta < 0) {
            x++;
          } else if (delta > 0) {
            y++;
          } else {
            return new Vector234(x, y);
          }
          const newDelta = Math.abs(x / y - ratio);
          if (newDelta < bestDelta) {
            bestDelta = newDelta;
            bestX = x;
            bestY = y;
          }
        }
        return new Vector234(bestX, bestY);
      },
      toFixed(number, decimals = 2) {
        const fixed = number.toFixed(decimals);
        return parseFloat(fixed);
      },
      capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      },
      flipObject(obj) {
        const newObj = {};
        for (const key in obj) {
          newObj[obj[key]] = key;
        }
        return newObj;
      },
      Browser: browser_default
    };
    utils_default2 = UIUtils;
  }
});

// engine/headless/globals.js
var Base643, Color3, ColorMatrix8, EventEmitter3, EXIF2, OptionType6, SDKUtils2, RenderType3, ImageFormat3, SDK, UniformType6, Vector235, Rectangle14, Range2, now3;
var init_globals3 = __esm({
  "engine/headless/globals.js"() {
    init_sdk2();
    init_constants2();
    init_image_loader();
    init_log();
    init_constants4();
    init_utils2();
    ({ Base64: Base643 } = exports_default);
    ({ Color: Color3 } = exports_default);
    ({ ColorMatrix: ColorMatrix8 } = exports_default.Math);
    ({ EventEmitter: EventEmitter3 } = exports_default);
    ({ EXIF: EXIF2 } = exports_default);
    ({ OptionType: OptionType6 } = exports_default);
    SDKUtils2 = exports_default.Utils;
    ({ RenderType: RenderType3 } = exports_default);
    ({ ImageFormat: ImageFormat3 } = exports_default);
    SDK = exports_default;
    ({ UniformType: UniformType6 } = exports_default);
    ({ Vector2: Vector235 } = exports_default.Math);
    ({ Rectangle: Rectangle14 } = exports_default.Math);
    ({ Range: Range2 } = exports_default.Math);
    now3 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();
  }
});

// engine/shared/assets/asset-library.js
var AssetLibrary, asset_library_default;
var init_asset_library = __esm({
  "engine/shared/assets/asset-library.js"() {
    AssetLibrary = class {
      constructor() {
        this._assetsByGroupId = {};
      }
      addAsset(groupID, asset, atBeginning = false) {
        if (!this._assetsByGroupId[groupID]) {
          this._assetsByGroupId[groupID] = [asset];
        } else if (atBeginning) {
          this._assetsByGroupId[groupID].unshift(asset);
        } else {
          this._assetsByGroupId[groupID].push(asset);
        }
      }
      setAssets(groupID, assets) {
        this._assetsByGroupId[groupID] = assets;
      }
      getAssets(groupID) {
        this._assetsByGroupId[groupID] = this._assetsByGroupId[groupID] || [];
        return this._assetsByGroupId[groupID];
      }
    };
    asset_library_default = AssetLibrary;
  }
});

// engine/shared/assets/font.js
var Font;
var init_font = __esm({
  "engine/shared/assets/font.js"() {
    init_sdk2();
    Font = class extends configurable_default {
    };
    Font.prototype.availableOptions = {
      fontFamily: { type: "string" /* STRING */, required: true },
      variations: { type: "array" /* ARRAY */, required: true }
    };
  }
});

// engine/shared/assets/font-variation.js
var FONT_WEIGHTS, FontVariation;
var init_font_variation = __esm({
  "engine/shared/assets/font-variation.js"() {
    init_sdk2();
    FONT_WEIGHTS = {
      100: "Extra Light",
      200: "Light",
      300: "Book",
      400: "Regular",
      500: "Medium",
      600: "Semibold",
      700: "Bold",
      800: "Black",
      900: "Extra Black",
      bold: "Bold",
      normal: "Regular"
    };
    FontVariation = class extends configurable_default {
      getLabel() {
        let label = FONT_WEIGHTS[this._options.fontWeight];
        switch (this._options.fontStyle) {
          case "italic":
            label += " Italic";
            break;
        }
        return label;
      }
    };
    FontVariation.prototype.availableOptions = {
      identifier: { type: "string" /* STRING */, required: true },
      fontFamily: { type: "string" /* STRING */, required: true },
      fontWeight: { type: "*" /* ALL */, default: 400 },
      fontStyle: { type: "string" /* STRING */, default: "normal" },
      textMetrics: { type: "object" /* OBJECT */, default: null },
      provider: { type: "string" /* STRING */, available: ["google", "file"] },
      filePath: { type: "string" /* STRING */ },
      default: { type: "boolean" /* BOOLEAN */, default: false },
      font: { type: "object" /* OBJECT */ }
    };
  }
});

// engine/shared/utils/legacyFontHandler.js
var legacyFontIdentifierMap, legacyFontHandler;
var init_legacyFontHandler = __esm({
  "engine/shared/utils/legacyFontHandler.js"() {
    legacyFontIdentifierMap = {
      imgly_font_bernier_regular: "imgly_font_sancreek",
      imgly_font_cheque_regular: "imgly_font_kumar_one_outline",
      imgly_font_gagalin_regular: "imgly_font_permanent_marker",
      imgly_font_hagin_caps_thin: "imgly_font_nixie_one",
      imgly_font_intro_inline: "imgly_font_bungee_inline",
      imgly_font_nexa_script: "imgly_font_molle",
      imgly_font_panton_blackitalic_caps: "imgly_font_roboto_black_italic",
      imgly_font_panton_lightitalic_caps: "imgly_font_roboto_light_italic",
      imgly_font_perfograma: "imgly_font_codystar",
      imgly_font_panton_black_caps: "imgly_font_roboto_black",
      imgly_font_panton_light_caps: "imgly_font_roboto_light",
      imgly_font_summer_font_light: "imgly_font_sue_ellen_francisco",
      imgly_font_wolesbro: "imgly_font_cookie_regular",
      imgly_font_campton_bold: "imgly_font_outfit_bold",
      imgly_font_galano_grotesque_bold: "imgly_font_lexend_bold",
      imgly_font_amberlight: "imgly_font_allison_regular)"
    };
    legacyFontHandler = (fontId, displayWarning = false) => {
      if (legacyFontIdentifierMap[fontId]) {
        if (displayWarning) {
          console.warn(`Font ${fontId} was deprecated. Please use ${legacyFontIdentifierMap[fontId]} instead.`);
        }
        return legacyFontIdentifierMap[fontId];
      }
      return fontId;
    };
  }
});

// engine/shared/managers/font-manager.js
var FontManager;
var init_font_manager = __esm({
  "engine/shared/managers/font-manager.js"() {
    init_globals3();
    init_font();
    init_font_variation();
    init_log();
    init_legacyFontHandler();
    FontManager = class {
      constructor(ui, options) {
        this._ui = ui;
        this._options = options;
        this._fonts = [];
        this._variationsByIdentifier = {};
        this._fontsByFontFamily = {};
        this._initFonts();
      }
      _initFonts() {
        const {
          fonts: additionalFonts,
          replaceFonts,
          availableVariations,
          isTextDesign
        } = this._options;
        let customAssetsAllowed = true;
        if (false) {
          customAssetsAllowed = this._ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
        }
        if (additionalFonts && customAssetsAllowed) {
          additionalFonts.forEach(({ variations }, index) => {
            if (variations) {
              variations.forEach((variation, variationIndex) => {
                if (legacyFontIdentifierMap[variation.identifier]) {
                  const correctedIdentifier = legacyFontHandler(variation.identifier, true);
                  additionalFonts[index].variations[variationIndex].identifier = correctedIdentifier;
                  const { fontFamily } = constants_default3.DEFAULTS.FONTS.find((family) => family.variations.some((font) => font.identifier === correctedIdentifier));
                  additionalFonts[index].fontFamily = fontFamily;
                }
              });
            }
          });
        }
        let fonts = isTextDesign ? constants_default3.DEFAULTS.TEXT_DESIGN_FONTS : constants_default3.DEFAULTS.FONTS;
        if (customAssetsAllowed) {
          if (replaceFonts) {
            fonts = additionalFonts;
          } else {
            fonts = fonts.concat(additionalFonts || []);
          }
        }
        let defaultVariation;
        fonts = fonts.map((font) => {
          const { fontFamily } = font;
          let { variations } = font;
          if (customAssetsAllowed && availableVariations) {
            variations = variations.filter((variation) => availableVariations.indexOf(variation.identifier) !== -1);
          }
          if (variations.length === 0)
            return null;
          const fontInstance = new Font({
            fontFamily
          });
          variations = variations.map((variation) => {
            const variationInstance = new FontVariation(variation);
            variationInstance.setFontFamily(fontFamily);
            variationInstance.setFont(fontInstance);
            if (variation.default && !defaultVariation) {
              defaultVariation = variationInstance;
            }
            if (variationInstance.getTextMetrics() == null) {
              log_default.warn(`Missing font metrics for ${variationInstance.getIdentifier()}. The SDK will fall back to basic font rendering, which may lead to layout issues. Please provide font metrics for your custom fonts. See https://docs.photoeditorsdk.com/guides/html5/ for more details.`);
            }
            this._variationsByIdentifier[variationInstance.getIdentifier()] = variationInstance;
            return variationInstance;
          });
          fontInstance.setVariations(variations);
          this._fontsByFontFamily[fontFamily] = fontInstance;
          return fontInstance;
        }).filter((f) => f);
        if (!defaultVariation) {
          [defaultVariation] = fonts[0].getVariations();
        }
        this._defaultVariation = defaultVariation;
        this._fonts = fonts;
      }
      getFonts() {
        return this._fonts;
      }
      getFontByFontFamily(fontFamily) {
        return this._fontsByFontFamily[fontFamily];
      }
      getVariationByIdentifier(identifier) {
        return this._variationsByIdentifier[legacyFontHandler(identifier)];
      }
      getVariationsByIdentifier() {
        return __spreadValues({}, this._variationsByIdentifier);
      }
      getDefaultVariation() {
        return this._defaultVariation;
      }
    };
  }
});

// engine/headless/lib/font-loader/font-ruler.js
var FONT_SIZE, CHARACTERS, FontRuler;
var init_font_ruler = __esm({
  "engine/headless/lib/font-loader/font-ruler.js"() {
    init_font_variation();
    FONT_SIZE = 30;
    CHARACTERS = "abcdefghijklmnopqrstuvwxzy";
    FontRuler = class {
      constructor(fontVariation) {
        this._fontVariation = fontVariation || new FontVariation({
          fontFamily: "Times New Roman",
          fontWeight: "normal",
          fontStyle: "normal"
        });
        this._createRuler();
      }
      _createRuler() {
        this._ruler = document.createElement("div");
        this._ruler.innerText = CHARACTERS;
        document.body.appendChild(this._ruler);
        this._setRulerStyle();
      }
      _setRulerStyle() {
        this._ruler.style.cssText = `
      position: absolute;
      top: -9999px;
      left: -9999px;
      opacity: 0;
      display: inline-block;
      font: ${this._fontVariation.getFontStyle()} ${this._fontVariation.getFontWeight()} ${FONT_SIZE}px ${this._fontVariation.getFontFamily()};
    `;
      }
      setFontVariation(fontVariation) {
        this._fontVariation = fontVariation;
        this._setRulerStyle();
      }
      getWidth() {
        return !this._ruler ? -1 : this._ruler.offsetWidth;
      }
      dispose() {
        if (this._ruler) {
          this._ruler.parentNode.removeChild(this._ruler);
          this._ruler = null;
        }
      }
    };
  }
});

// engine/headless/lib/font-loader/font-observer.js
var now5, OBSERVE_INTERVAL, OBSERVE_TIMEOUT, FontObserver;
var init_font_observer = __esm({
  "engine/headless/lib/font-loader/font-observer.js"() {
    init_font_ruler();
    now5 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();
    OBSERVE_INTERVAL = 50;
    OBSERVE_TIMEOUT = 5e3;
    FontObserver = class {
      constructor(fontVariation) {
        this._fontVariation = fontVariation;
        this._defaultFontRuler = new FontRuler();
        this._customFontRuler = new FontRuler(this._fontVariation);
      }
      observe() {
        const startedAt = now5();
        return new Promise((resolve, reject) => {
          const interval = window.setInterval(() => {
            const changed = this._defaultFontRuler.getWidth() !== this._customFontRuler.getWidth();
            if (changed) {
              window.clearInterval(interval);
              return resolve();
            }
            if (now5() - startedAt >= OBSERVE_TIMEOUT) {
              const error = new Error(`Failed to load font ${this._fontVariation.getFontFamily()}.`);
              error.font = this._fontVariation;
              return reject(error);
            }
          }, OBSERVE_INTERVAL);
        });
      }
      dispose() {
        this._defaultFontRuler.dispose();
        this._customFontRuler.dispose();
      }
    };
  }
});

// engine/headless/lib/font-loader/loaders/base-font-loader.js
var BaseFontLoader;
var init_base_font_loader = __esm({
  "engine/headless/lib/font-loader/loaders/base-font-loader.js"() {
    init_sdk2();
    init_font_observer();
    BaseFontLoader = class {
      constructor(ui) {
        this._ui = ui;
        this._fonts = [];
        this._observers = [];
      }
      add(variation) {
        this._fonts.push(variation);
      }
      load() {
        if (this._fonts.length === 0) {
          return Promise.resolve();
        }
        this._observers = [];
        this._fonts.forEach((variation) => {
          this._observers.push(new FontObserver(variation));
        });
        return utils_default.executePromises(this._observers.map((observer) => observer.observe()));
      }
      dispose() {
        this._observers.forEach((observer) => observer.dispose());
      }
    };
  }
});

// engine/headless/lib/font-loader/loaders/file-font-loader.js
var FileFontLoader;
var init_file_font_loader = __esm({
  "engine/headless/lib/font-loader/loaders/file-font-loader.js"() {
    init_base_font_loader();
    FileFontLoader = class extends BaseFontLoader {
      load() {
        return Promise.resolve();
      }
    };
  }
});

// engine/headless/lib/font-loader/loaders/google-font-loader.js
var FONT_STYLES, GoogleFontLoader;
var init_google_font_loader = __esm({
  "engine/headless/lib/font-loader/loaders/google-font-loader.js"() {
    init_base_font_loader();
    FONT_STYLES = {
      italic: "i"
    };
    GoogleFontLoader = class extends BaseFontLoader {
      load() {
        if (this._fonts.length) {
          this._addStylesheetTag();
        }
        return super.load();
      }
      _addStylesheetTag() {
        const families = this._getFamiliesString();
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = `https://fonts.googleapis.com/css?family=${families}`;
        const head = document.getElementsByTagName("head")[0];
        head.appendChild(link);
      }
      _getFamiliesString() {
        const families = {};
        this._fonts.forEach((font) => {
          const fontFamily = font.getFontFamily();
          const fontStyle = font.getFontStyle();
          const fontWeight = font.getFontWeight();
          families[fontFamily] = families[fontFamily] || [];
          if (typeof fontWeight !== "undefined") {
            families[fontFamily].push(`${fontWeight}${FONT_STYLES[fontStyle] || ""}`);
          } else {
            families[fontFamily].push(400);
          }
        });
        const familyStrings = [];
        for (const name in families) {
          const variants = families[name];
          const variantsString = variants.length ? `:${variants.join(",")}` : "";
          const nameString = name.replace(" ", "+") + variantsString;
          familyStrings.push(nameString);
        }
        return familyStrings.join("|");
      }
    };
  }
});

// engine/headless/lib/font-loader/index.js
var FontLoader;
var init_font_loader = __esm({
  "engine/headless/lib/font-loader/index.js"() {
    init_file_font_loader();
    init_google_font_loader();
    FontLoader = class {
      constructor(ui, fonts) {
        this._ui = ui;
        this._fonts = fonts;
        this._loadedFonts = [];
      }
      setFonts(fonts) {
        this._fonts = fonts;
      }
      needsToLoad() {
        for (let i = 0; i < this._fonts.length; i++) {
          let provider;
          this._fonts[i].getVariations().forEach((variation) => {
            provider = provider || variation.getProvider();
          });
          if (!provider)
            continue;
          return true;
        }
      }
      fontLoaded(font) {
        const identifier = font.getFontFamily();
        return this._loadedFonts.indexOf(identifier) !== -1;
      }
      setFontLoaded(font) {
        if (!this.fontLoaded(font)) {
          const identifier = font.getFontFamily();
          this._loadedFonts.push(identifier);
        }
      }
      load() {
        const fonts = this._fonts;
        const loaders = {
          google: new GoogleFontLoader(this._ui),
          file: new FileFontLoader(this._ui)
        };
        const disposeLoaders = () => {
          for (const identifier in loaders) {
            const loader = loaders[identifier];
            loader.dispose();
          }
        };
        fonts.filter((font) => !this.fontLoaded(font)).forEach((font) => {
          font.getVariations().forEach((variation) => {
            const provider = variation.getProvider();
            if (!provider)
              return;
            const loader = loaders[provider];
            loader.add(variation);
          });
        });
        const promises = [];
        for (const name in loaders) {
          promises.push(loaders[name].load());
        }
        return Promise.all(promises).then(() => {
          disposeLoaders();
          fonts.forEach((font) => {
            this.setFontLoaded(font);
          });
        }).catch((e) => {
          disposeLoaders();
          throw e;
        });
      }
    };
  }
});

// engine/shared/managers/brush-manager.js
var BrushManager;
var init_brush_manager = __esm({
  "engine/shared/managers/brush-manager.js"() {
    init_globals3();
    BrushManager = class {
      constructor(ui, options) {
        this._ui = ui;
        this._options = options;
        this._brushes = [];
        this._brushesById = {};
        this._addBrushes(constants_default3.DEFAULTS.BRUSHES);
        const { brushes: brushes2, replaceBrushes, availableBrushes } = this._options;
        if (this._options.brushes) {
          this._addBrushes(brushes2, replaceBrushes);
        }
        if (availableBrushes) {
          this._brushes = this._brushes.filter((brush) => availableBrushes.indexOf(brush.identifier) !== -1);
        }
      }
      _addBrushes(brushes2, replaceBrushes) {
        if (replaceBrushes) {
          this._brushes = [];
          this._brushesById = {};
        }
        brushes2.forEach((brush) => {
          this._brushes.push(brush);
          this._brushesById[brush.identifier] = brush;
        });
      }
      getBrushByIdentifier(identifier) {
        return this._brushesById[identifier];
      }
      getBrushes() {
        return this._brushes;
      }
      getFirstBrush() {
        return this._brushes[0];
      }
    };
  }
});

// engine/shared/managers/filter-manager.js
var _FilterManager, FilterManager;
var init_filter_manager = __esm({
  "engine/shared/managers/filter-manager.js"() {
    init_globals3();
    _FilterManager = class {
      constructor(ui, options, isPreloading = false) {
        this._ui = ui;
        this._options = options;
        this._categoriesById = {};
        this._filtersByIdentifier = {
          identity: SDK.Operations.FilterOperation.Filters.IdentityFilter
        };
        this._categories = utils_default2.wrapFiltersInCategories(constants_default.DEFAULTS.FILTERS.slice(0), _FilterManager.CATEGORY_ITEMS_PROPERTY);
        this._customAssetsAllowed = isPreloading || ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
        if (this._customAssetsAllowed && this._options.categories) {
          this._options.categories = utils_default2.wrapFiltersInCategories(this._options.categories, _FilterManager.CATEGORY_ITEMS_PROPERTY);
        }
        this._initCategories();
      }
      instantiateFilterWithIdentifier(identifier) {
        const crossOrigin = { value: this._ui._options.crossOrigin, cors: true };
        const Filter3 = this.getFilterByIdentifier(identifier);
        if (!Filter3) {
          return Promise.reject(new Error(`Unknown filter with identifier \`${identifier}\`!`));
        }
        if (!(Filter3.prototype instanceof SDK.Operations.FilterOperation.Filter)) {
          const {
            lutImage,
            resolution,
            horizontalTileCount,
            verticalTileCount
          } = Filter3;
          let { lightColor, darkColor } = Filter3;
          if (lightColor && darkColor) {
            lightColor = Color3.fromHex(lightColor);
            darkColor = Color3.fromHex(darkColor);
            return Promise.resolve(new SDK.Operations.FilterOperation.Filters.DuoToneFilter({
              lightColor,
              darkColor
            }));
          }
          let preloadedImage;
          if (this._ui.getPreloader) {
            preloadedImage = this._ui.getPreloader().getAsset(lutImage);
          }
          let loadPromise;
          if (preloadedImage) {
            loadPromise = Promise.resolve(preloadedImage);
          } else {
            loadPromise = image_loader_default.loadImage(this._ui.getAssetPath(lutImage), crossOrigin);
          }
          return loadPromise.then(() => {
            return image_loader_default.loadImage(this._ui.getAssetPath(lutImage), crossOrigin).then((image) => {
              return new SDK.Operations.FilterOperation.Filters.ThreeDLUTFilter({
                image,
                resolution,
                horizontalTileCount,
                verticalTileCount
              });
            });
          });
        }
        return Promise.resolve(new Filter3());
      }
      _initCategories() {
        if (this._customAssetsAllowed && this._options.categories) {
          if (this._options.replaceCategories) {
            this._categories = utils_default2.wrapFiltersInCategories(this._options.categories, _FilterManager.CATEGORY_ITEMS_PROPERTY);
          } else {
            this._categories = utils_default2.mergeCategories(this._categories, this._options.categories, _FilterManager.CATEGORY_ITEMS_PROPERTY);
          }
        }
        if (this._customAssetsAllowed && this._options.availableFilters) {
          const newCategories = [];
          this._categories.forEach((category) => {
            const filters = category.filters.filter((f) => this._options.availableFilters.indexOf(f.identifier) !== -1);
            if (filters.length > 0) {
              newCategories.push({
                identifier: category.identifier,
                defaultName: category.defaultName,
                filters
              });
            }
          });
          this._categories = newCategories;
        }
        const allCategory = {
          identifier: "all",
          defaultName: "All",
          visible: false,
          filters: this._categories.length <= 0 ? [] : this._categories.map((c) => c.filters).reduce((a, b) => a.concat(b))
        };
        this._categories.unshift(allCategory);
        this._categoriesById.all = allCategory;
        this._categories.forEach((c) => {
          this._categoriesById[c.identifier] = c;
        });
        allCategory.filters.forEach((filter) => {
          this._filtersByIdentifier[filter.identifier] = filter;
        });
      }
      getFiltersForCategory(categoryIdentifier) {
        if (!this._categoriesById[categoryIdentifier]) {
          throw new Error(`Unknown filter category '${categoryIdentifier}'`);
        }
        return this._categoriesById[categoryIdentifier].filters;
      }
      getItemsByCategory(categoryIdentifier) {
        return this.getFiltersForCategory(categoryIdentifier);
      }
      getFilterByIdentifier(identifier) {
        return this._filtersByIdentifier[identifier];
      }
      getCategories() {
        return this._categories;
      }
      getCategoryByIdentifier(identifier) {
        return this._categoriesById[identifier];
      }
    };
    FilterManager = _FilterManager;
    __publicField(FilterManager, "CATEGORY_ITEMS_PROPERTY", "filters");
  }
});

// engine/shared/managers/sticker-manager.js
var CUSTOM_CATEGORY_ID, StickerManager;
var init_sticker_manager = __esm({
  "engine/shared/managers/sticker-manager.js"() {
    init_globals3();
    init_sdk2();
    init_asset_library();
    init_constants2();
    init_json_loader();
    CUSTOM_CATEGORY_ID = "imgly_sticker_custom";
    StickerManager = class {
      constructor(ui, options, dynamicAssetsLibrary) {
        this._ui = ui;
        this._options = options;
        this._dynamicAssetsLibrary = dynamicAssetsLibrary || this._ui.getEditor().getDynamicAssetsLibrary() || new asset_library_default();
        this._categoriesById = {};
        this._categories = [];
        this._stickersById = {};
        this._customStickerCanvas = utils_default.createCanvas();
        this.reload();
      }
      reload() {
        this._categoriesById = {};
        this._categories = [];
        this._stickersById = {};
        const customAssetsAllowed = this._ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
        this._addCategories(constants_default.DEFAULTS.STICKER_CATEGORIES);
        const { categories, replaceCategories } = this._options;
        if (customAssetsAllowed && this._options.categories) {
          this._addCategories(categories, replaceCategories);
        } else {
          this._updateCategoriesMap();
          this._updateAllCategory();
        }
        if (customAssetsAllowed) {
          const customStickers = this._dynamicAssetsLibrary.getAssets("sticker");
          if (customStickers.length > 0) {
            const customCategory = this._createCustomStickerCategory(customStickers);
            this._addCategories([customCategory], false, true);
          }
        }
      }
      loadExternal(url) {
        const loader = new JSONLoader(url);
        return loader.load().then((result) => {
          this._addCategories(result.categories, this._options.replaceCategories);
        });
      }
      _addCategories(categories, replace = false, insertAtBeginning = false) {
        if (replace) {
          this._categories = categories.slice(0);
        } else if (insertAtBeginning) {
          this._categories = this._mergeCategories(categories, this._categories);
        } else {
          this._categories = this._mergeCategories(this._categories, categories);
        }
        this._updateCategoriesMap();
        this._updateAllCategory();
      }
      _mergeCategories(categories, newCategories) {
        categories = utils_default2.cloneCategories(categories, "stickers");
        for (const newCategory of newCategories) {
          let duplicateCategory = false;
          for (const existingCategory of categories) {
            if (newCategory.identifier === existingCategory.identifier) {
              for (const newSticker of newCategory.stickers) {
                let duplicateSticker = false;
                for (const existingSticker of existingCategory.stickers) {
                  if (newSticker.identifier === existingSticker.identifier) {
                    Object.assign(existingSticker, newSticker);
                    duplicateSticker = true;
                    break;
                  }
                }
                if (!duplicateSticker) {
                  existingCategory.stickers.push(newSticker);
                }
              }
              duplicateCategory = true;
              break;
            }
          }
          if (!duplicateCategory) {
            categories.push(newCategory);
          }
        }
        return categories;
      }
      _updateCategoriesMap() {
        this._categoriesById = {};
        this._categories.forEach((c) => {
          this._categoriesById[c.identifier] = c;
        });
        this._categories.forEach((c) => {
          c.stickers.forEach((s) => {
            this._stickersById[s.identifier] = s;
          });
        });
        if (typeof this._options.availableStickers !== "undefined" && this._options.availableStickers !== null) {
          this._categories.forEach((category) => {
            if (category.identifier !== CUSTOM_CATEGORY_ID) {
              category.stickers = category.stickers.filter((sticker) => this._options.availableStickers.indexOf(sticker.identifier) !== -1);
            }
          });
          this._categories = this._categories.filter((category) => category.stickers.length > 0);
        }
        this._updateAllCategory();
      }
      _updateAllCategory() {
        this._allCategory = {
          identifier: "all",
          defaultName: "All",
          stickers: this._categories.map((c) => c.stickers).reduce((a, b) => a.concat(b), [])
        };
        this._categoriesById.all = this._allCategory;
      }
      renderStickerThumbnailFromImage(image) {
        const canvas = this._customStickerCanvas;
        const context = canvas.getContext("2d");
        context.save();
        const thumbWidth = 62;
        const scale = thumbWidth / image.width;
        const thumbHeight = scale * image.height;
        canvas.width = thumbWidth;
        canvas.height = thumbWidth;
        context.clearRect(0, 0, image.width, image.height);
        context.translate(0, 0.5 * (canvas.height - thumbHeight));
        context.scale(scale, scale);
        context.drawImage(image, 0, 0);
        const thumbURL = canvas.toDataURL("image/png");
        context.restore();
        return {
          data: thumbURL,
          width: thumbWidth,
          height: thumbHeight
        };
      }
      addCustomStickerFromImage(image, name, tintMode = "none") {
        const needsResize = (image2) => {
          const sdk2 = this._ui.getEditor().getSDK();
          const renderer = sdk2.getRenderer();
          const dimensions = new Vector235(image2.width, image2.height);
          const maxPixels = this._ui.getEditor().getMaxMegapixels() * 1e6;
          let maxDimensions = renderer.getMaxDimensions();
          const exceedsMaxPixels = dimensions.x * dimensions.y > maxPixels;
          const exceedsMaxDimensions = maxDimensions !== null && (dimensions.x > maxDimensions || dimensions.y > maxDimensions);
          if (exceedsMaxPixels) {
            const ratioHV = image2.width / image2.height;
            const ratioVH = image2.height / image2.width;
            maxDimensions = new Vector235(Math.sqrt(maxPixels * ratioHV), Math.sqrt(maxPixels * ratioVH)).floor().max();
          }
          const safeDimensions2 = dimensions.clone();
          if (exceedsMaxPixels || exceedsMaxDimensions) {
            if (dimensions.x / dimensions.y > 1) {
              safeDimensions2.x = maxDimensions;
              safeDimensions2.y = maxDimensions / dimensions.x * dimensions.y;
            } else {
              safeDimensions2.x = maxDimensions / dimensions.y * dimensions.x;
              safeDimensions2.y = maxDimensions;
            }
          }
          return safeDimensions2;
        };
        const scaledSizeWithLongerSide = (imageSize, maxDimension) => {
          const aspect = imageSize.x / imageSize.y;
          if (aspect > 1) {
            return new Vector235(maxDimension, maxDimension / aspect);
          }
          return new Vector235(maxDimension * aspect, maxDimension);
        };
        const isSVG = image.src.substring(0, 14) === "data:image/svg";
        const sdk = this._ui.getEditor().getSDK();
        image = sdk.correctExifOrientation(image);
        const svgSize = scaledSizeWithLongerSide(new Vector235(image.width, image.height), 2048);
        const safeDimensions = isSVG ? svgSize : needsResize(image);
        const canvas = this._customStickerCanvas;
        const context = canvas.getContext("2d");
        context.save();
        const thumb = this.renderStickerThumbnailFromImage(image);
        if (isSVG) {
          if (image.width > image.height) {
            canvas.width = 2048;
            canvas.height = 2048 / image.width * image.height;
          } else {
            canvas.height = 2048;
            canvas.width = 2048 / image.height * image.width;
          }
          image.width = canvas.width;
          image.height = canvas.height;
        } else {
          canvas.width = safeDimensions.x;
          canvas.height = safeDimensions.y;
          context.scale(safeDimensions.x / image.width, safeDimensions.y / image.height);
        }
        context.drawImage(image, 0, 0, image.width, image.height);
        const baseURL = canvas.toDataURL();
        context.restore();
        const sticker = {
          identifier: utils_default.generateUUID(),
          defaultName: name || "",
          tintMode,
          images: {
            mediaThumb: {
              uris: [thumb.data],
              rawData: true,
              width: thumb.width,
              height: thumb.height
            },
            mediaBase: {
              uris: isSVG ? [baseURL, image.src] : [baseURL],
              rawData: true,
              isSVG,
              width: safeDimensions.x,
              height: safeDimensions.y
            }
          }
        };
        const assetsLibrary = this._dynamicAssetsLibrary;
        assetsLibrary.addAsset("sticker", sticker, true);
        const customStickers = assetsLibrary.getAssets("sticker");
        if (customStickers.length === 1) {
          const customCategory = this._createCustomStickerCategory(customStickers);
          this._addCategories([customCategory], false, true);
        } else {
          this.getCategory(CUSTOM_CATEGORY_ID).stickers = customStickers;
          this._updateAllCategory();
        }
        this._updateCategoriesMap();
      }
      _createCustomStickerCategory(stickers) {
        return {
          identifier: CUSTOM_CATEGORY_ID,
          defaultName: "Custom",
          metaData: {
            backgroundImage: stickers[stickers.length - 1].images.mediaBase.uris[0],
            rawData: true
          },
          stickers
        };
      }
      getStickersForCategory(categoryName) {
        if (!this._categoriesById[categoryName]) {
          throw new Error(`Unknown sticker category '${categoryName}'`);
        }
        return this._categoriesById[categoryName].stickers;
      }
      getStickerByIdentifier(identifier) {
        return this._stickersById[identifier];
      }
      getCategories(includeAllCategory = false) {
        if (includeAllCategory) {
          return [this._allCategory].concat(this._categories);
        }
        return this._categories;
      }
      getCategory(id) {
        return this._categoriesById[id];
      }
      static getURLForSticker(sticker, size = "base") {
        const { images } = sticker;
        const media = size === "base" ? images.mediaBase || images.mediaThumb : images.mediaThumb;
        const uris = media.uris || [media.uri];
        if (false) {
          if (!utils_default2.Browser.getIEVersion()) {
            const svgs = uris.filter((f) => /\.svg$/i.test(f));
            return svgs.length ? svgs[0] : uris[0];
          }
        }
        const notSvgs = uris.filter((f) => !/\.svg$/i.test(f));
        return notSvgs.length ? notSvgs[0] : uris[0];
      }
    };
  }
});

// engine/shared/serialization/1.0.0/deserializer.js
var import_p_map2, Brush2, v100Deserializer;
var init_deserializer = __esm({
  "engine/shared/serialization/1.0.0/deserializer.js"() {
    init_globals3();
    init_font_loader();
    init_brush_manager();
    init_filter_manager();
    init_font_manager();
    init_sticker_manager();
    import_p_map2 = __toESM(require("p-map"));
    if (typeof SDK.Operations.SpriteOperation !== "undefined") {
      Brush2 = SDK.Operations.SpriteOperation.BrushSprite;
    }
    v100Deserializer = class {
      constructor(editor, data) {
        this._editor = editor;
        this._ui = this._editor.getUI();
        this._data = data;
        this._filterManager = new FilterManager(this._ui, this._getOptions("filter"));
        this._stickerManager = new StickerManager(this._ui, this._getOptions("sticker"));
        this._brushManager = new BrushManager(this._ui, this._getOptions("brush"));
        this._fontManager = new FontManager(this._ui, this._getOptions("text"));
      }
      _getOptions(control) {
        const { controls } = this._editor;
        let defaultOptions = {};
        if (controls && controls.get(control)) {
          defaultOptions = controls.get(control).defaultOptions;
        }
        const editorOptions = this._editor.getOptions();
        return SDKUtils2.deepDefaults({}, editorOptions.editor.controlsOptions[control] || {}, defaultOptions);
      }
      deserialize() {
        return this._validateVersion().then(() => this._deserializeInputImage()).then(() => this._deserializeOperations());
      }
      _validateVersion() {
        if (this._data.version !== this.constructor.version) {
          return Promise.reject(new Error(`Invalid version ${this._data.version}, expected ${this.constructor.version}`));
        }
        return Promise.resolve();
      }
      _deserializeInputImage() {
        return new Promise((resolve, reject) => {
          const { data, type } = this._data.inputImage;
          if (data && type) {
            const image = new window.Image();
            image.addEventListener("load", () => {
              this._editor.setImage(image);
              resolve();
            });
            image.src = `data:${type};base64,${data}`;
          } else {
            resolve();
          }
        });
      }
      _deserializeOperations() {
        return __async(this, null, function* () {
          const { operations } = this._data;
          return (0, import_p_map2.default)(operations, (operation) => __async(this, null, function* () {
            return this._deserializeOperation(operation);
          }));
        });
      }
      _deserializeOperation(operation) {
        switch (operation.type) {
          case "crop":
            return this._deserializeCropOperation(operation);
          case "orientation":
            return this._deserializeOrientationOperation(operation);
          case "filter":
            return this._deserializeFilterOperation(operation);
          case "adjustments":
            return this._deserializeAdjustmentsOperation(operation);
          case "sprite":
            return this._deserializeSpriteOperation(operation);
          case "focus":
            return this._deserializeFocusOperation(operation);
        }
      }
      _deserializeCropOperation(operation) {
        const { options } = operation;
        let { rotation } = options;
        const start = Vector235.fromObject(options.start);
        const end = Vector235.fromObject(options.end);
        if (rotation > Math.PI) {
          rotation -= Math.PI * 2;
        }
        const cropOptions = { start, end };
        if (typeof rotation !== "undefined") {
          cropOptions.rotation = rotation;
        }
        const transformOperation = this._editor.operations.getOrCreate("transform");
        this._editor.broadcastTransform(transformOperation, cropOptions);
        transformOperation.set(cropOptions);
        return Promise.resolve(transformOperation);
      }
      _deserializeOrientationOperation(operation) {
        const { options } = operation;
        const orientationOperation = this._editor.operations.getOrCreate("orientation");
        if (!orientationOperation)
          return Promise.resolve();
        orientationOperation.set(options);
        return Promise.resolve(orientationOperation);
      }
      _deserializeFilterOperation(operation) {
        const { options } = operation;
        if (!this._filterManager.getFilterByIdentifier(options.name)) {
          log_default.warn("Deserializer", `Unknown filter \`${options.name}\``);
          return Promise.resolve();
        }
        return this._filterManager.instantiateFilterWithIdentifier(options.name).then((filter) => {
          const filterOperation = this._editor.operations.getOrCreate("filter");
          filterOperation.set({
            identifier: options.name,
            filter,
            intensity: options.intensity
          });
          return filterOperation;
        });
      }
      _deserializeAdjustmentsOperation(operation) {
        const { AdjustmentsOperation: AdjustmentsOperation2 } = SDK.Operations;
        const { options } = operation;
        const knownOptions = [
          "brightness",
          "saturation",
          "contrast",
          "exposure",
          "shadows",
          "highlights",
          "clarity"
        ];
        const operationOptions = {};
        knownOptions.forEach((optionName) => {
          if (typeof options[optionName] === "undefined")
            return;
          const {
            minValue,
            midValue,
            maxValue
          } = AdjustmentsOperation2.prototype.availableOptions[optionName];
          let value = options[optionName];
          value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
          operationOptions[optionName] = value;
        });
        return Promise.resolve(this._editor.operations.getOrCreate("adjustments", operationOptions));
      }
      _deserializeSpriteOperation(operation) {
        const { options } = operation;
        const spriteOperation = this._editor.operations.getOrCreate("sprite");
        if (!spriteOperation)
          return Promise.resolve();
        const promises = options.sprites.map((sprite) => {
          return this._deserializeSprite(spriteOperation, sprite);
        }).filter((p) => p);
        return Promise.all(promises).then((sprites) => {
          spriteOperation.setSprites(sprites.filter((s) => s));
          return spriteOperation;
        });
      }
      _deserializeSprite(spriteOperation, sprite) {
        switch (sprite.type) {
          case "sticker":
            return this._deserializeSticker(spriteOperation, sprite);
          case "text":
            return this._deserializeText(spriteOperation, sprite);
          case "brush":
            return this._deserializeBrush(spriteOperation, sprite);
          case "textdesign":
            return this._deserializeTextDesign && this._deserializeTextDesign(spriteOperation, sprite);
        }
      }
      _deserializeSticker(operation, sprite) {
        const { SpriteOperation: SpriteOperation2 } = SDK.Operations;
        const { options } = sprite;
        const sticker = this._stickerManager.getStickerByIdentifier(options.name);
        const url = this._stickerManager.getURLForSticker(sticker);
        if (!sticker) {
          log_default.warn("Deserializer", `Unknown sticker '${options.name}'. Skipping sprite.`);
          return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
          const image = new window.Image();
          image.addEventListener("load", () => {
            const adjustments = SpriteOperation2.StickerSprite.prototype.availableOptions.adjustments.structure;
            const { rotation, flipHorizontally, flipVertically } = options;
            const stickerOptions = {
              identifier: options.name,
              image,
              position: Vector235.fromObject(options.position),
              dimensions: Vector235.fromObject(options.dimensions),
              rotation,
              flipHorizontally,
              flipVertically,
              adjustments: {}
            };
            if (typeof options.adjustments !== "undefined") {
              ["brightness", "contrast", "saturation"].forEach((option) => {
                if (typeof options.adjustments[option] !== "undefined") {
                  stickerOptions.adjustments[option] = options.adjustments[option] + adjustments[option].default;
                }
              });
            }
            resolve(operation.createSticker(stickerOptions));
          });
          image.crossOrigin = this._editor.getCrossOrigin();
          image.src = this._editor.getUI().getAssetPath(url);
        });
      }
      _deserializeText(operation, text) {
        const { options } = text;
        const {
          fontSize,
          lineHeight,
          fontFamily,
          fontWeight,
          alignment,
          rotation,
          maxWidth,
          color,
          backgroundColor
        } = options;
        const fontLoader = new FontLoader(this._ui);
        let font = this._fontManager.getFontByFontFamily(fontFamily);
        if (!font)
          font = this._fontManager.getDefaultFont();
        fontLoader.setFonts([font]);
        return fontLoader.load().then(() => {
          const sprite = operation.createText({
            fontSize,
            lineHeight,
            fontFamily,
            fontWeight,
            alignment,
            rotation,
            maxWidth,
            text: options.text,
            color: Color3.fromArray(color),
            backgroundColor: Color3.fromArray(backgroundColor),
            position: Vector235.fromObject(options.position)
          });
          sprite._edited = true;
          return sprite;
        });
      }
      _deserializeBrush(operation, brush) {
        const { options } = brush;
        const { paths } = options;
        const brushSprite = operation.createBrush();
        paths.forEach((path) => {
          this._deserializeBrushPath(brushSprite, path);
        });
        return Promise.resolve(brushSprite);
      }
      _deserializeBrushPath(brushSprite, path) {
        const { points } = path;
        const brushInstance = this._createBrushForPath(path);
        const pathObject = brushSprite.createPath(brushInstance);
        pathObject.setClosed(true);
        points.forEach((point) => {
          pathObject.addControlPoint(Vector235.fromObject(point));
        });
      }
      _createBrushForPath(path) {
        const { color, size } = path;
        const colorObject = Color3.fromArray(color);
        const brushOptions = {
          color: colorObject,
          size
        };
        const rawBrush = this._brushManager.getFirstBrush();
        if (rawBrush.prototype && rawBrush.prototype instanceof Brush2) {
          const BrushClass2 = rawBrush;
          return new BrushClass2(brushOptions);
        }
        const _brush = __spreadValues({}, rawBrush);
        delete _brush.image;
        class BrushClass extends Brush2 {
        }
        BrushClass.identifier = rawBrush.identifier;
        return new BrushClass(__spreadValues(__spreadValues({}, _brush), brushOptions));
      }
      _deserializeFocusOperation(operation) {
        const { options } = operation.options;
        switch (operation.options.type) {
          case "radial": {
            const { position, radius, gradientRadius, blurRadius } = options;
            return Promise.resolve(this._editor.operations.getOrCreate("radial-focus", {
              position: Vector235.fromObject(position),
              radius,
              gradientRadius,
              blurRadius
            }));
          }
          case "linear": {
            const { start, end, size, gradientSize, blurRadius } = options;
            return Promise.resolve(this._editor.operations.getOrCreate("mirrored-focus", {
              start: Vector235.fromObject(start),
              end: Vector235.fromObject(end),
              size,
              gradientSize,
              blurRadius
            }));
          }
        }
      }
      _getInputDimensionsForOperation(operation) {
        let operationFound = false;
        let inputDimensions = this._editor.getInputDimensions();
        this._editor.operations.getStack().forEach((op) => {
          if (op === operation)
            operationFound = true;
          if (operationFound)
            return;
          inputDimensions = op.getNewDimensions(inputDimensions);
        });
        return inputDimensions;
      }
    };
    v100Deserializer.version = "1.0.0";
  }
});

// engine/shared/serialization/1.0.0/serializer.js
var TWICE_PI, v100Serializer;
var init_serializer = __esm({
  "engine/shared/serialization/1.0.0/serializer.js"() {
    init_globals3();
    TWICE_PI = Math.PI * 2;
    v100Serializer = class {
      constructor(editor) {
        this._editor = editor;
        this._serializeOperations = this._serializeOperations.bind(this);
      }
      serialize(options = {}) {
        this._options = __spreadProps(__spreadValues({}, options), { image: true });
        const data = {
          version: this.constructor.version
        };
        return this._serializeInputImage(data).then(this._serializeOperations);
      }
      _serializeInputImage(data) {
        const image = this._editor.getImage();
        const { width, height } = image;
        if (!this._options.image) {
          data.inputImage = { width, height };
          return Promise.resolve(data);
        }
        const canvas = SDKUtils2.createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0);
        const dataUrl = canvas.toDataURL(ImageFormat3.PNG);
        data.inputImage = {
          type: ImageFormat3.PNG,
          data: dataUrl.replace(/^data:image\/(.*?);base64,/, ""),
          width,
          height
        };
        return Promise.resolve(data);
      }
      _serializeOperations(data) {
        const operations = [];
        const stack = this._editor.operations.getStack();
        stack.forEach((operation) => {
          const data2 = this._serializeOperation(operation, operations);
          if (data2) {
            operations.push(data2);
          }
        });
        data.operations = operations.filter((o) => o);
        return Promise.resolve(data);
      }
      _serializeOperation(operation, operations) {
        switch (operation.constructor.identifier) {
          case "transform":
            return this._serializeTransformOperation(operation);
          case "orientation":
            return this._serializeOrientationOperation(operation);
          case "filter":
            return this._serializeFilterOperation(operation);
          case "adjustments":
            return this._serializeAdjustmentsOperation(operation);
          case "sprite":
            return this._serializeSpriteOperation(operation, operations);
          case "radial-focus":
            return this._serializeRadialFocusOperation(operation);
          case "mirrored-focus":
            return this._serializeLinearFocusOperation(operation);
          default:
            log_default.warn(`Unable to serialize operation of type ${operation.constructor.identifier}`);
        }
      }
      _serializeTransformOperation(operation) {
        const options = operation.serializeOptions(["start", "end", "rotation"], true);
        options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
        return {
          type: "crop",
          options
        };
      }
      _serializeOrientationOperation(operation) {
        return {
          type: "orientation",
          options: operation.serializeOptions(["flipVertically", "flipHorizontally", "rotation"], true)
        };
      }
      _serializeFilterOperation(operation) {
        if (operation.getIdentifier() === "identity")
          return null;
        return {
          type: "filter",
          options: {
            intensity: operation.getIntensity(),
            name: operation.getIdentifier()
          }
        };
      }
      _serializeAdjustmentsOperation(operation) {
        const { availableOptions } = operation;
        const optionNames = [
          "brightness",
          "saturation",
          "contrast",
          "exposure",
          "shadows",
          "highlights",
          "clarity"
        ];
        const options = {};
        optionNames.forEach((optionName) => {
          const option = availableOptions[optionName];
          const value = operation.getOption(optionName);
          const { minValue, midValue, maxValue } = option;
          options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
        });
        return {
          type: "adjustments",
          options
        };
      }
      _serializeSpriteOperation(operation, operations) {
        const spriteOperations = operations.filter((o) => o.type === "sprite");
        let spriteOperation;
        let returnOperation = true;
        if (spriteOperations.length) {
          spriteOperation = spriteOperations.pop();
          returnOperation = false;
        } else {
          spriteOperation = {
            type: "sprite",
            options: {
              sprites: []
            }
          };
        }
        operation.getSprites().forEach((sprite) => {
          let spriteItem = null;
          if (sprite instanceof operation.constructor.StickerSprite) {
            spriteItem = this._serializeSticker(operation, sprite);
          } else if (sprite instanceof operation.constructor.TextSprite) {
            spriteItem = this._serializeText(operation, sprite);
          } else if (sprite instanceof operation.constructor.BrushSprite) {
            spriteItem = this._serializeBrush(operation, sprite);
          } else if (sprite instanceof operation.constructor.TextDesignSprite) {
            spriteItem = this._serializeTextDesign && this._serializeTextDesign(operation, sprite);
          }
          if (spriteItem) {
            spriteOperation.options.sprites.push(spriteItem);
          }
        });
        if (returnOperation) {
          return spriteOperation;
        }
      }
      _serializeSticker(operation, sprite) {
        const adjustments = sprite.getAdjustments();
        const options = sprite.serializeOptions([
          "identifier",
          "position",
          "dimensions",
          "flipVertically",
          "flipHorizontally",
          "rotation"
        ], true);
        options.name = options.identifier;
        delete options.identifier;
        options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
        const adjustmentsOptions = adjustments.availableOptions;
        options.adjustments = {
          brightness: adjustments.getBrightness() - adjustmentsOptions.brightness.default,
          saturation: adjustments.getSaturation() - adjustmentsOptions.saturation.default,
          contrast: adjustments.getContrast() - adjustmentsOptions.contrast.default
        };
        return {
          type: "sticker",
          options
        };
      }
      _serializeText(operation, sprite) {
        const options = sprite.serializeOptions([
          "fontSize",
          "lineHeight",
          "fontFamily",
          "fontWeight",
          "alignment",
          "color",
          "backgroundColor",
          "position",
          "rotation",
          "text",
          "maxWidth"
        ], true);
        options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
        return {
          type: "text",
          options
        };
      }
      _serializeBrush(operation, sprite) {
        return {
          type: "brush",
          options: {
            paths: sprite.getPaths().map((path) => this._serializePath(path))
          }
        };
      }
      _serializePath(path) {
        const options = path.getBrush().serializeOptions(["color", "size"], true);
        options.points = path.getControlPoints().map((point) => point.getPosition().toObject());
        return options;
      }
      _serializeRadialFocusOperation(operation) {
        return {
          type: "focus",
          options: {
            type: "radial",
            options: operation.serializeOptions(["position", "radius", "gradientRadius", "blurRadius"], true)
          }
        };
      }
      _serializeLinearFocusOperation(operation) {
        return {
          type: "focus",
          options: {
            type: "linear",
            options: operation.serializeOptions(["start", "end", "blurRadius", "size", "gradientSize"], true)
          }
        };
      }
      _getInputDimensionsForOperation(operation) {
        let operationFound = false;
        let inputDimensions = this._editor.getInputDimensions();
        this._editor.operations.getStack().forEach((op) => {
          if (op === operation)
            operationFound = true;
          if (operationFound)
            return;
          inputDimensions = op.getNewDimensions(inputDimensions);
        });
        return inputDimensions;
      }
    };
    v100Serializer.version = "1.0.0";
  }
});

// engine/shared/serialization/1.0.0/index.js
var __exports = {};
__export(__exports, {
  default: () => Serialization
});
var Serialization;
var init__ = __esm({
  "engine/shared/serialization/1.0.0/index.js"() {
    init_deserializer();
    init_serializer();
    Serialization = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v100Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v100Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization.version = "1.0.0";
  }
});

// engine/shared/serialization/1.0.1/deserializer.js
var v101Deserializer;
var init_deserializer2 = __esm({
  "engine/shared/serialization/1.0.1/deserializer.js"() {
    init_globals3();
    init_deserializer();
    v101Deserializer = class extends v100Deserializer {
      _deserializeOperation(operation) {
        if (operation.type === "selective-blur") {
          return this._deserializeSelectiveBlurOperation(operation);
        }
        return super._deserializeOperation(operation);
      }
      _deserializeCropOperation(operation) {
        const { options } = operation;
        let { rotation } = options;
        const start = Vector235.fromObject(options.start);
        const end = Vector235.fromObject(options.end);
        const dimensions = options.dimensions ? Vector235.fromObject(options.dimensions) : null;
        if (end.x - start.x <= 0 || end.y - start.y <= 0) {
          throw new Error(`A crop should not result in negative or zero dimensions - start: ${start} - end: ${end}`);
        }
        if (rotation > Math.PI) {
          rotation -= Math.PI * 2;
        }
        const cropOptions = {
          start,
          end
        };
        if (typeof rotation !== "undefined")
          cropOptions.rotation = rotation;
        const transformOperation = this._editor.operations.getOrCreate("transform");
        if (!transformOperation)
          return Promise.resolve();
        this._editor.broadcastTransform(transformOperation, cropOptions);
        transformOperation.set(cropOptions);
        if (dimensions) {
          const size = end.clone().subtract(start);
          const transformDimensions = transformOperation.getInputDimensions(false).multiply(size);
          transformOperation.setTextureScale(dimensions.x / transformDimensions.x);
        }
        return Promise.resolve(transformOperation);
      }
    };
    v101Deserializer.version = "1.0.1";
  }
});

// engine/shared/serialization/1.0.1/serializer.js
var TWICE_PI2, v101Serializer;
var init_serializer2 = __esm({
  "engine/shared/serialization/1.0.1/serializer.js"() {
    init_serializer();
    TWICE_PI2 = Math.PI * 2;
    v101Serializer = class extends v100Serializer {
      _serializeTransformOperation(operation) {
        const options = operation.serializeOptions(["start", "end", "rotation", "textureScale"], true);
        options.rotation = (options.rotation + TWICE_PI2) % TWICE_PI2;
        if (options.textureScale !== 1) {
          options.dimensions = operation.getNewDimensions(operation.getInputDimensions(false));
        }
        delete options.textureScale;
        return {
          type: "crop",
          options
        };
      }
    };
    v101Serializer.version = "1.0.1";
  }
});

// engine/shared/serialization/1.0.1/index.js
var __exports2 = {};
__export(__exports2, {
  default: () => Serialization2
});
var Serialization2;
var init__2 = __esm({
  "engine/shared/serialization/1.0.1/index.js"() {
    init_deserializer2();
    init_serializer2();
    Serialization2 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v101Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v101Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization2.version = "1.0.1";
  }
});

// engine/headless/lib/frame.js
var OptionType8, Frame;
var init_frame = __esm({
  "engine/headless/lib/frame.js"() {
    init_image_loader();
    init_globals3();
    ({ OptionType: OptionType8 } = SDK);
    Frame = class extends SDK.Configurable {
      constructor(ui, options = {}) {
        super(options);
        this._loaded = false;
        this._loading = false;
        this._ui = ui;
        this._frame = SDK.Utils.deepClone(this._options);
      }
      load() {
        if (this._loaded)
          return Promise.resolve();
        if (this._loading)
          return Promise.reject(new Error("Called Frame#load while it's already loading"));
        this._loading = true;
        const { imageGroups } = this._frame;
        const promises = [];
        ["top", "left", "right", "bottom"].forEach((groupName) => {
          if (!(groupName in imageGroups))
            return;
          const group = imageGroups[groupName];
          ["start", "mid", "end"].forEach((partName) => {
            if (!(partName in group))
              return;
            promises.push(this._loadPart(groupName, partName));
          });
        });
        return Promise.all(promises).then(() => {
          this._loaded = true;
          this._loading = false;
        }).catch((e) => {
          this._loaded = false;
          this._loading = false;
        });
      }
      _loadPart(groupName, partName) {
        const { imageGroups } = this._frame;
        const part = imageGroups[groupName][partName];
        let imageUrl = part;
        if (typeof part !== "string" && "image" in part) {
          imageUrl = part.image;
        }
        return image_loader_default.load(this._ui.getAssetPath(imageUrl)).then((image) => {
          if (typeof part !== "string") {
            this._frame.imageGroups[groupName][partName].image = image;
          } else {
            this._frame.imageGroups[groupName][partName] = image;
          }
          return image;
        });
      }
      getFrame() {
        return this._frame;
      }
    };
    Frame.prototype.availableOptions = {
      identifier: { type: OptionType8.STRING, required: true },
      defaultName: { type: OptionType8.STRING },
      thumbnail: { type: OptionType8.STRING },
      tintable: { type: OptionType8.BOOLEAN, default: false },
      layoutMode: {
        type: OptionType8.STRING,
        default: "horizontal-inside",
        available: ["horizontal-inside", "vertical-inside"]
      },
      imageGroups: { type: OptionType8.OBJECT, required: true }
    };
  }
});

// engine/shared/managers/frame-manager.js
var FrameManager;
var init_frame_manager = __esm({
  "engine/shared/managers/frame-manager.js"() {
    init_globals3();
    FrameManager = class {
      constructor(ui, options) {
        this._ui = ui;
        this._options = options;
        this._categoriesById = {};
        this._categories = [];
        this._framesById = {};
        this._addCategories(constants_default.DEFAULTS.FRAME_CATEGORIES);
        this._customAssetsAllowed = ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
        const { categories, replaceCategories } = this._options;
        if (this._customAssetsAllowed && this._options.categories) {
          this._addCategories(categories, replaceCategories);
        } else {
          this._updateAllCategory();
        }
      }
      _addCategories(categories, replace = false) {
        if (replace) {
          this._categories = categories.slice(0);
        } else {
          this._categories = utils_default2.mergeCategories(this._categories, categories, "frames");
        }
        this._categoriesById = {};
        this._categories.forEach((c) => {
          this._categoriesById[c.identifier] = c;
        });
        const { availableFrames } = this._options;
        if (this._customAssetsAllowed && availableFrames) {
          this._categories.forEach((c) => {
            c.frames = c.frames.filter((f) => availableFrames.indexOf(f.identifier) !== -1);
          });
        }
        this._categories.forEach((c) => {
          c.frames.forEach((s) => {
            this._framesById[s.identifier] = s;
          });
        });
        this._updateAllCategory();
      }
      _updateAllCategory() {
        this._allCategory = {
          identifier: "all",
          defaultName: "All",
          frames: this._categories.map((c) => c.frames).reduce((a, b) => a.concat(b), [])
        };
        this._categoriesById.all = this._allCategory;
      }
      getFramesForCategory(categoryName) {
        if (!this._categoriesById[categoryName]) {
          throw new Error(`Unknown frame category '${categoryName}'`);
        }
        return this._categoriesById[categoryName].frames;
      }
      getFrameByIdentifier(identifier) {
        return this._framesById[identifier];
      }
      getCategories() {
        return this._categories;
      }
      getCategory(id) {
        return this._categoriesById[id];
      }
    };
  }
});

// engine/shared/managers/overlay-manager.js
var OverlayManager;
var init_overlay_manager = __esm({
  "engine/shared/managers/overlay-manager.js"() {
    init_globals3();
    OverlayManager = class {
      constructor(ui, options) {
        this._ui = ui;
        this._options = options;
        this._overlays = constants_default.DEFAULTS.OVERLAYS.slice(0);
        this._overlaysByIdentifier = {};
        const customAssetsAllowed = ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
        if (customAssetsAllowed && options.overlays) {
          if (options.replaceOverlays) {
            this._overlays = options.overlays;
          } else {
            this._overlays = this._overlays.concat(options.overlays);
          }
        }
        if (customAssetsAllowed && options.availableOverlays) {
          this._overlays = this._overlays.filter((o) => options.availableOverlays.indexOf(o.identifier) !== -1);
        }
        this._overlays.forEach((overlay) => {
          this._overlaysByIdentifier[overlay.identifier] = overlay;
        });
      }
      getOverlays() {
        return this._overlays;
      }
      getOverlayByIdentifier(identifier) {
        return this._overlaysByIdentifier[identifier];
      }
    };
  }
});

// engine/shared/serialization/2.0.0/blend-modes.js
var OverlayFilter3, blend_modes_default;
var init_blend_modes = __esm({
  "engine/shared/serialization/2.0.0/blend-modes.js"() {
    init_globals3();
    ({ OverlayFilter: OverlayFilter3 } = SDK.Engine.Filters);
    blend_modes_default = {
      [OverlayFilter3.BLEND_MODES.NORMAL]: "normal",
      [OverlayFilter3.BLEND_MODES.OVERLAY]: "overlay",
      [OverlayFilter3.BLEND_MODES.HARD_LIGHT]: "hard light",
      [OverlayFilter3.BLEND_MODES.SOFT_LIGHT]: "soft light",
      [OverlayFilter3.BLEND_MODES.MULTIPLY]: "multiply",
      [OverlayFilter3.BLEND_MODES.DARKEN]: "darken",
      [OverlayFilter3.BLEND_MODES.LIGHTEN]: "lighten",
      [OverlayFilter3.BLEND_MODES.SCREEN]: "screen",
      [OverlayFilter3.BLEND_MODES.COLOR_BURN]: "color burn"
    };
  }
});

// engine/shared/serialization/2.0.0/deserializer.js
var blendModeByName, v200Deserializer;
var init_deserializer3 = __esm({
  "engine/shared/serialization/2.0.0/deserializer.js"() {
    init_globals3();
    init_font_loader();
    init_frame();
    init_image_loader();
    init_frame_manager();
    init_overlay_manager();
    init_sticker_manager();
    init_deserializer2();
    init_blend_modes();
    blendModeByName = SDKUtils2.flipObject(blend_modes_default);
    v200Deserializer = class extends v101Deserializer {
      constructor(...args) {
        super(...args);
        this._frameManager = new FrameManager(this._ui, this._getOptions("frame"));
        const overlayOptions = this._getOptions("overlay");
        if (overlayOptions) {
          this._overlayManager = new OverlayManager(this._ui, overlayOptions);
        }
      }
      _deserializeSprite(spriteOperation, sprite) {
        if (sprite.type === "frame") {
          return this._deserializeFrame(spriteOperation, sprite);
        }
        if (sprite.type === "overlay") {
          return this._deserializeOverlay(spriteOperation, sprite);
        }
        return super._deserializeSprite(spriteOperation, sprite);
      }
      _deserializeOperation(operation) {
        if (operation.type === "transform") {
          return this._deserializeTransformOperation(operation);
        }
        return super._deserializeOperation(operation);
      }
      _deserializeOrientationOperation(operationData) {
        if (this._data.meta && this._data.meta.platform !== "html5") {
          return super._deserializeOrientationOperation(operationData);
        }
        const {
          rotation,
          flipHorizontally,
          flipVertically
        } = operationData.options;
        let shouldFlip = rotation === 90 && !flipHorizontally && !flipVertically;
        shouldFlip |= rotation === 90 && flipHorizontally && flipVertically;
        shouldFlip |= rotation === 270 && !flipHorizontally && !flipVertically;
        shouldFlip |= rotation === 270 && flipHorizontally && flipVertically;
        if (shouldFlip) {
          operationData.options.flipHorizontally = !operationData.options.flipHorizontally;
          operationData.options.flipVertically = !operationData.options.flipVertically;
        }
        return super._deserializeOrientationOperation(operationData);
      }
      _deserializeTransformOperation(operationData) {
        return super._deserializeCropOperation(operationData).then((operation) => {
          if (!operation)
            return;
          const orientationData = SDKUtils2.Array.find(this._data.operations, (op) => op.type === "orientation");
          if (orientationData) {
            const { options } = orientationData;
            let { rotation, flipHorizontally, flipVertically } = options;
            if (rotation === 90 || rotation === 270) {
              if (!flipHorizontally && flipVertically || flipHorizontally && !flipVertically) {
                flipHorizontally = !flipHorizontally;
                flipVertically = !flipVertically;
              }
            }
            operation.rotate(options.rotation);
            if (flipHorizontally) {
              operation.flip("horizontal");
              operation.setRotation(operation.getRotation() * -1);
            }
            if (flipVertically) {
              operation.flip("vertical");
              operation.setRotation(operation.getRotation() * -1);
            }
          }
          return operation;
        });
      }
      _deserializeFrame(spriteOperation, frame) {
        const { identifier } = frame.options;
        const frameData = this._frameManager.getFrameByIdentifier(identifier);
        if (!frameData) {
          log_default.warn("Deserializer", `Unknown frame \`${identifier}\`. Skipping frame.`);
          return Promise.resolve();
        }
        const frameInstance = new Frame(this._ui, frameData);
        return frameInstance.load().then(() => {
          this._editor.operations.getOrCreate("frame", {
            frame: frameInstance.getFrame()
          });
        });
      }
      _deserializeOverlay(spriteOperation, overlay) {
        const { blendMode, intensity, identifier } = overlay.options;
        const overlayData = this._overlayManager.getOverlayByIdentifier(identifier);
        if (!overlayData) {
          log_default.warn("Deserializer", `Unknown overlay \`${identifier}\`. Skipping overlay.`);
          return Promise.resolve();
        }
        const overlayPath = this._editor.getUI().getAssetPath(overlayData.image);
        return image_loader_default.load(overlayPath).then((image) => {
          this._editor.operations.getOrCreate("overlay", {
            alpha: intensity,
            identifier,
            blendMode: parseInt(blendModeByName[blendMode || overlayData.blendMode], 10),
            image
          });
        });
      }
      _createBrushForPath(path) {
        const brush = super._createBrushForPath(path);
        if (typeof path.hardness !== "undefined" && brush.hasOption("hardness")) {
          brush.setHardness(path.hardness);
        }
        return brush;
      }
      _deserializeSticker(operation, sprite) {
        const { SpriteOperation: SpriteOperation2 } = SDK.Operations;
        const { options } = sprite;
        const sticker = this._stickerManager.getStickerByIdentifier(options.identifier);
        const url = StickerManager.getURLForSticker(sticker, "base");
        if (!sticker) {
          log_default.warn("Deserializer", `Unknown sticker \`${options.identifier}\`. Skipping sprite.`);
          return Promise.resolve();
        }
        const inputDimensions = operation.getInputDimensions(false);
        return new Promise((resolve, reject) => {
          const image = new window.Image();
          image.addEventListener("load", () => {
            const adjustments = SpriteOperation2.StickerSprite.prototype.availableOptions.adjustments.structure;
            const { rotation, flipHorizontally, flipVertically } = options;
            const stickerOptions = {
              identifier: options.identifier,
              image,
              position: Vector235.fromObject(options.position),
              dimensions: Vector235.fromObject(options.dimensions).multiply(inputDimensions.min()),
              rotation,
              flipHorizontally,
              flipVertically,
              adjustments: {}
            };
            if (typeof options.adjustments !== "undefined") {
              ["brightness", "contrast", "saturation"].forEach((option) => {
                if (typeof options.adjustments[option] !== "undefined") {
                  stickerOptions.adjustments[option] = options.adjustments[option] + adjustments[option].default;
                }
              });
            }
            if (typeof options.tintColor !== "undefined" && typeof sticker.tintMode !== "undefined") {
              stickerOptions.tintColor = Color3.fromArray(options.tintColor);
              stickerOptions.tintMode = sticker.tintMode;
            }
            resolve(operation.createSticker(stickerOptions));
          });
          image.crossOrigin = this._editor.getCrossOrigin();
          image.src = this._editor.getUI().getAssetPath(url);
        });
      }
      _deserializeFilterOperation(operation) {
        const { options } = operation;
        if (!this._filterManager.getFilterByIdentifier(options.identifier)) {
          log_default.warn("Deserializer", `Unknown filter \`${options.identifier}\``);
          return Promise.resolve();
        }
        return this._filterManager.instantiateFilterWithIdentifier(options.identifier).then((filter) => {
          const filterOperation = this._editor.operations.getOrCreate("filter");
          if (!filterOperation)
            return;
          filterOperation.set({
            identifier: options.identifier,
            filter,
            intensity: options.intensity
          });
          return filterOperation;
        });
      }
      _deserializeFocusOperation(operation) {
        const { options, type } = operation.options;
        if (type !== "radial")
          return super._deserializeFocusOperation(operation);
        const image = this._editor.getImage();
        const imageAspect = image.width / image.height;
        const { start, end, gradientRadius, blurRadius } = options;
        const radius = Vector235.fromObject(end).subtract(Vector235.fromObject(start)).multiply(imageAspect, 1).len();
        return Promise.resolve(this._editor.operations.getOrCreate("radial-focus", {
          position: Vector235.fromObject(start),
          radius,
          gradientRadius,
          blurRadius
        }));
      }
      _deserializeText(operation, text) {
        const { options } = text;
        const {
          fontSize,
          lineHeight,
          fontIdentifier,
          alignment,
          rotation,
          maxWidth,
          color,
          backgroundColor
        } = options;
        const fontLoader = new FontLoader(this._ui);
        let variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
        if (!variation) {
          variation = this._fontManager.getDefaultFont();
        } else {
          fontLoader.setFonts([variation.getFont()]);
        }
        return fontLoader.load().then(() => {
          const inputDimensions = operation.getInputDimensions(false);
          const fixedMaxWidth = maxWidth * inputDimensions.min() / inputDimensions.x;
          const sprite = operation.createText({
            fontSize,
            lineHeight,
            fontFamily: variation.getFontFamily(),
            fontWeight: variation.getFontWeight(),
            fontIdentifier: variation.getIdentifier(),
            alignment,
            rotation,
            maxWidth: fixedMaxWidth,
            text: options.text,
            color: Color3.fromArray(color),
            backgroundColor: Color3.fromArray(backgroundColor),
            position: Vector235.fromObject(options.position)
          });
          sprite._edited = true;
          return sprite;
        });
      }
    };
    v200Deserializer.version = "2.0.0";
  }
});

// engine/shared/serialization/2.0.0/serializer.js
var v200Serializer;
var init_serializer3 = __esm({
  "engine/shared/serialization/2.0.0/serializer.js"() {
    init_serializer2();
    init_blend_modes();
    v200Serializer = class extends v101Serializer {
      _serializeSticker(operation, sprite) {
        const inputDimensions = operation.getInputDimensions(false);
        const response = super._serializeSticker(operation, sprite);
        if (sprite.getTintMode() !== "none") {
          response.options.tintColor = sprite.serializeOption("tintColor", true);
        }
        response.options.dimensions = sprite.getDimensions().clone().divide(inputDimensions.min()).toObject();
        response.options.identifier = response.options.name;
        delete response.options.name;
        return response;
      }
      _serializePath(path) {
        const response = super._serializePath(path);
        const brush = path.getBrush();
        if (brush.hasOption("hardness")) {
          response.hardness = brush.getOption("hardness");
        }
        return response;
      }
      _serializeOperation(operation, operations) {
        if (operation.constructor.identifier === "frame") {
          this._serializeFrameOperation(operation, operations);
          return null;
        }
        if (operation.constructor.identifier === "overlay") {
          this._serializeOverlayOperation(operation, operations);
          return null;
        }
        return super._serializeOperation(operation, operations);
      }
      _serializeFrameOperation(operation, operations) {
        const spriteOperations = operations.filter((o) => o.type === "sprite");
        let spriteOperation;
        if (spriteOperations.length) {
          spriteOperation = spriteOperations.pop();
        } else {
          spriteOperation = {
            type: "sprite",
            options: {
              sprites: []
            }
          };
          operations.push(spriteOperation);
        }
        spriteOperation.options.sprites.push({
          type: "frame",
          options: this._getFrameOptions(operation)
        });
      }
      _serializeOverlayOperation(operation, operations) {
        if (!operation.getIdentifier())
          return;
        const spriteOperations = operations.filter((o) => o.type === "sprite");
        let spriteOperation;
        if (spriteOperations.length) {
          spriteOperation = spriteOperations.pop();
        } else {
          spriteOperation = {
            type: "sprite",
            options: {
              sprites: []
            }
          };
          operations.push(spriteOperation);
        }
        spriteOperation.options.sprites.push({
          type: "overlay",
          options: {
            identifier: operation.getIdentifier(),
            intensity: operation.getAlpha(),
            blendMode: blend_modes_default[operation.getBlendMode()]
          }
        });
      }
      _getFrameOptions(operation) {
        return {
          identifier: operation.getFrame().identifier
        };
      }
      _serializeOrientationOperation(operation) {
        const response = super._serializeOrientationOperation(operation);
        if (response.options.rotation === 90 || response.options.rotation === 270) {
          response.options.flipHorizontally = !response.options.flipHorizontally;
          response.options.flipVertically = !response.options.flipVertically;
        }
        return response;
      }
      _serializeTransformOperation(operation) {
        const { operations } = this._editor;
        if (operations.exists("orientation")) {
          operation = operation.clone();
          const orientationOperation = operations.get("orientation");
          operation.rotate(-orientationOperation.getRotation());
          if (orientationOperation.getFlipVertically()) {
            operation.flip("vertical");
            operation.setRotation(operation.getRotation() * -1);
          }
          if (orientationOperation.getFlipHorizontally()) {
            operation.flip("horizontal");
            operation.setRotation(operation.getRotation() * -1);
          }
        }
        const response = super._serializeTransformOperation(operation);
        response.type = "transform";
        return response;
      }
      _serializeText(operation, sprite) {
        const response = super._serializeText(operation, sprite);
        const inputDimensions = operation.getInputDimensions(false);
        response.options.fontIdentifier = sprite.getFontIdentifier();
        response.options.maxWidth = response.options.maxWidth * inputDimensions.x / inputDimensions.min();
        delete response.options.fontFamily;
        return response;
      }
      _serializeFilterOperation(operation) {
        const response = super._serializeFilterOperation(operation);
        if (!response)
          return null;
        response.options.identifier = response.options.name;
        delete response.options.name;
        return response;
      }
      _serializeRadialFocusOperation(operation) {
        const response = super._serializeRadialFocusOperation(operation);
        const focusOptions = response.options.options;
        focusOptions.start = focusOptions.position;
        delete focusOptions.position;
        focusOptions.end = {
          x: focusOptions.start.x + focusOptions.radius,
          y: focusOptions.start.y
        };
        delete focusOptions.radius;
        return response;
      }
    };
    v200Serializer.version = "2.0.0";
  }
});

// engine/shared/serialization/2.0.0/index.js
var __exports3 = {};
__export(__exports3, {
  default: () => Serialization3
});
var Serialization3;
var init__3 = __esm({
  "engine/shared/serialization/2.0.0/index.js"() {
    init_deserializer3();
    init_serializer3();
    Serialization3 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v200Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v200Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization3.version = "2.0.0";
  }
});

// engine/shared/managers/text-design-manager.js
var TextDesignManager;
var init_text_design_manager = __esm({
  "engine/shared/managers/text-design-manager.js"() {
    init_globals3();
    TextDesignManager = class {
      constructor(ui, options = {}) {
        this._ui = ui;
        this._options = options;
        this._defaultLayouts = SDK.Operations.SpriteOperation.TextDesignSprite.Layouts;
        this._legacyLayouts = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts;
        this._layouts = [];
        this._init();
      }
      _init() {
        const { availableLayouts } = this._options;
        const allLayouts = __spreadValues(__spreadValues({}, this._defaultLayouts), this._legacyLayouts);
        this._layouts = Object.keys(allLayouts).map((k) => ({
          identifier: allLayouts[k].identifier,
          layout: allLayouts[k]
        }));
        if (availableLayouts) {
          availableLayouts.push(...Object.values(this._legacyLayouts).map((i) => i.identifier));
          this._layouts = this._layouts.filter((item) => availableLayouts.indexOf(item.identifier) >= 0);
        }
      }
      getLayoutByIdentifier(identifier) {
        const item = SDKUtils2.Array.find(this._layouts, (l) => l.identifier === identifier);
        return item && item.layout;
      }
      getLayouts() {
        return [...this._layouts];
      }
      getDefaultLayout() {
        return this.getLayouts()[0];
      }
    };
  }
});

// engine/shared/serialization/3.0.0/deserializer.js
var Brush3, v300Deserializer;
var init_deserializer4 = __esm({
  "engine/shared/serialization/3.0.0/deserializer.js"() {
    init_globals3();
    init_image_loader();
    init_font_manager();
    init_sticker_manager();
    init_text_design_manager();
    init_deserializer3();
    if (typeof SDK.Operations.SpriteOperation !== "undefined") {
      Brush3 = SDK.Operations.SpriteOperation.BrushSprite.Brush;
    }
    v300Deserializer = class extends v200Deserializer {
      _deserializeSticker(operation, sprite) {
        const { SpriteOperation: SpriteOperation2 } = SDK.Operations;
        const { options } = sprite;
        const sticker = this._stickerManager.getStickerByIdentifier(options.identifier);
        if (!sticker) {
          log_default.warn("Deserializer", `Unknown sticker \`${options.identifier}\`. Skipping sprite.`);
          return Promise.resolve();
        }
        const { mediaBase } = sticker.images;
        const url = StickerManager.getURLForSticker(sticker, "base");
        const resolvedUrl = mediaBase.rawData ? mediaBase.uris[0] : this._editor.getUI().getAssetPath(url);
        const inputDimensions = operation.getInputDimensions(false);
        return image_loader_default.load(resolvedUrl).then((image) => {
          const adjustments = SpriteOperation2.StickerSprite.prototype.availableOptions.adjustments.structure;
          const { rotation, flipHorizontally, flipVertically } = options;
          const stickerOptions = {
            identifier: options.identifier,
            image,
            position: Vector235.fromObject(options.position),
            dimensions: Vector235.fromObject(options.dimensions).multiply(inputDimensions.min()),
            rotation: rotation || 0,
            flipHorizontally,
            flipVertically,
            resizeMode: sticker.resizeMode || "keepAspect",
            adjustments: {}
          };
          if (typeof options.adjustments !== "undefined") {
            ["brightness", "contrast", "saturation"].forEach((option) => {
              if (typeof options.adjustments[option] !== "undefined") {
                stickerOptions.adjustments[option] = options.adjustments[option] + adjustments[option].default;
              }
            });
          }
          if (typeof options.tintMode !== "undefined" && typeof options.tintColor !== "undefined") {
            stickerOptions.tintColor = Color3.fromArray(options.tintColor.rgba);
            stickerOptions.tintMode = options.tintMode;
          } else if (typeof options.tintColor !== "undefined" && typeof sticker.tintMode !== "undefined") {
            stickerOptions.tintColor = Color3.fromArray(options.tintColor.rgba);
            stickerOptions.tintMode = sticker.tintMode;
          }
          if (typeof options.alpha !== "undefined") {
            stickerOptions.alpha = options.alpha;
          }
          return operation.createSticker(stickerOptions);
        });
      }
      _deserializeTransformOperation(operationData) {
        return super._deserializeTransformOperation(operationData).then((operation) => {
          if (!operation)
            return;
          operation._ratio = null;
          return operation;
        });
      }
      _deserializeInputImage() {
        let { data, type, uri } = this._data.image;
        if (data && type) {
          uri = `data:${type};base64,${data}`;
        }
        if (uri) {
          return image_loader_default.load(uri).then((image) => {
            this._editor.setImage(image);
          });
        }
        return Promise.resolve();
      }
      _deserializeAdjustmentsOperation(operationData) {
        const { AdjustmentsOperation: AdjustmentsOperation2 } = SDK.Operations;
        return super._deserializeAdjustmentsOperation(operationData).then((operation) => {
          if (!operation)
            return null;
          const { options } = operationData;
          const knownOptions = ["gamma", "whites", "blacks", "temperature"];
          const operationOptions = {};
          knownOptions.forEach((optionName) => {
            if (typeof options[optionName] === "undefined")
              return;
            const {
              minValue,
              midValue,
              maxValue
            } = AdjustmentsOperation2.prototype.availableOptions[optionName];
            let value = options[optionName];
            value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
            operationOptions[optionName] = value;
          });
          operation.set(operationOptions);
          return operation;
        });
      }
      _deserializeFocusOperation(operationData) {
        const { options } = operationData.options;
        switch (operationData.options.type) {
          case "radial":
            return super._deserializeFocusOperation(operationData);
          case "linear": {
            const { start, end, blurRadius } = options;
            return Promise.resolve(this._editor.operations.getOrCreate("linear-focus", {
              controlPoint1: Vector235.fromObject(start),
              controlPoint2: Vector235.fromObject(end),
              blurRadius
            }));
          }
          case "mirrored": {
            const { start, end, size, gradientSize, blurRadius } = options;
            return Promise.resolve(this._editor.operations.getOrCreate("mirrored-focus", {
              start: Vector235.fromObject(start),
              end: Vector235.fromObject(end),
              size,
              gradientSize,
              blurRadius
            }));
          }
          case "gaussian": {
            const { blurRadius } = options;
            return Promise.resolve(this._editor.operations.getOrCreate("blur", {
              blurRadius
            }));
          }
        }
      }
      _deserializeText(operation, text) {
        const { options } = text;
        const {
          fontSize,
          lineHeight,
          fontIdentifier,
          alignment,
          rotation,
          maxWidth,
          color,
          backgroundColor
        } = options;
        const fontLoader = this._ui.getFontLoader();
        let variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
        if (!variation) {
          variation = this._fontManager.getDefaultVariation();
        } else {
          fontLoader.setFonts([variation.getFont()]);
        }
        return fontLoader.load().then(() => {
          const inputDimensions = operation.getInputDimensions(false);
          const fixedMaxWidth = maxWidth * inputDimensions.min() / inputDimensions.x;
          const sprite = operation.createText({
            fontSize,
            lineHeight,
            fontFamily: variation.getFontFamily(),
            fontWeight: variation.getFontWeight(),
            fontIdentifier: variation.getIdentifier(),
            textMetrics: variation.getTextMetrics(),
            alignment,
            rotation,
            maxWidth: fixedMaxWidth,
            text: options.text,
            color: Color3.fromArray(color.rgba),
            backgroundColor: Color3.fromArray(backgroundColor.rgba),
            position: Vector235.fromObject(options.position)
          });
          sprite._edited = true;
          return sprite;
        });
      }
      _createBrushForPath(path) {
        const { identifier, color, size, hardness } = path.brush;
        const colorObject = Color3.fromArray(color.rgba);
        const brushOptions = {
          color: colorObject,
          size
        };
        if (typeof hardness !== "undefined") {
          brushOptions.hardness = hardness;
        }
        let rawBrush = this._brushManager.getBrushByIdentifier(identifier);
        if (!rawBrush) {
          rawBrush = this._brushManager.getFirstBrush();
        }
        if (rawBrush.prototype && rawBrush.prototype instanceof Brush3) {
          const BrushClass2 = rawBrush;
          return new BrushClass2(brushOptions);
        }
        const _brush = __spreadValues({}, rawBrush);
        delete _brush.image;
        class BrushClass extends Brush3 {
        }
        BrushClass.identifier = rawBrush.identifier;
        return new BrushClass(__spreadValues(__spreadValues({}, _brush), brushOptions));
      }
      _deserializeFrame(spriteOperation, frame) {
        return super._deserializeFrame(spriteOperation, frame).then(() => {
          const frameOperation = this._editor.operations.get("frame");
          const { size, alpha, tintColor } = frame.options;
          const options = {};
          if (typeof size !== "undefined") {
            options.scale = size;
          }
          if (typeof alpha !== "undefined") {
            options.alpha = alpha;
          }
          if (typeof tintColor !== "undefined") {
            options.tintColor = Color3.fromArray(tintColor.rgba);
          }
          frameOperation.set(options);
        });
      }
      _deserializeTextDesign(operation, sprite) {
        const { options } = sprite;
        const {
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color,
          width,
          seed,
          inverted
        } = options;
        let { identifier } = options;
        if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignBlocksLight.identifier) {
          identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignBlocksLightV310.identifier;
        } else if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignSunshine.identifier) {
          identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignSunshineV310.identifier;
        }
        const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
        const fontManager = new FontManager(this._ui, {
          fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
          replaceFonts: true
        });
        const { AssetManager: AssetManager2 } = operation.constructor.TextDesignSprite;
        const fontLoader = this._ui.getFontLoader();
        const Layout = textDesignManager.getLayoutByIdentifier(identifier);
        const layout = new Layout();
        fontLoader.setFonts(fontManager.getFonts());
        AssetManager2.setFonts(__spreadValues(__spreadValues({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
        return fontLoader.load().then(() => {
          const images = layout.getImagePaths().map((path) => ({
            path,
            fullPath: this._ui.getAssetPath(path),
            image: null
          }));
          return AssetManager2.loadImages(images).then(() => {
            layout.onImagesLoaded();
            return operation.createTextDesign({
              position,
              rotation,
              flipHorizontally,
              flipVertically,
              text,
              color: Color3.fromArray(color.rgba),
              width,
              seed,
              inverted,
              layout
            });
          });
        });
      }
    };
    v300Deserializer.version = "3.0.0";
  }
});

// engine/shared/assets/transform-ratio.js
var TransformRatio;
var init_transform_ratio = __esm({
  "engine/shared/assets/transform-ratio.js"() {
    init_sdk2();
    TransformRatio = class extends configurable_default {
    };
    TransformRatio.prototype.availableOptions = {
      identifier: { type: "string" /* STRING */, required: true },
      defaultName: { type: "string" /* STRING */, required: true },
      ratio: { type: "*" /* ALL */, required: false, default: null },
      selected: { type: "boolean" /* BOOLEAN */, required: false },
      dimensions: { type: "vector2" /* VECTOR2 */, required: false },
      lockDimensions: { type: "boolean" /* BOOLEAN */, required: false, default: null },
      forceDimensions: { type: "boolean" /* BOOLEAN */, required: false, default: null }
    };
  }
});

// engine/shared/serialization/3.0.0/serializer.js
var v300Serializer;
var init_serializer4 = __esm({
  "engine/shared/serialization/3.0.0/serializer.js"() {
    init_globals3();
    init_transform_ratio();
    init_serializer3();
    v300Serializer = class extends v200Serializer {
      serialize(options = {}) {
        return super.serialize(options).then((data) => {
          data.meta = {
            platform: "html5",
            version: this._editor.getSDK().version,
            createdAt: SDKUtils2.ISODateString(new Date())
          };
          data.image = data.inputImage;
          delete data.inputImage;
          return data;
        });
      }
      _serializeSticker(operation, sprite) {
        const response = super._serializeSticker(operation, sprite);
        response.options.alpha = sprite.getAlpha();
        if (response.options.tintColor) {
          response.options.tintColor = {
            rgba: response.options.tintColor
          };
        }
        return response;
      }
      _serializeText(operation, sprite) {
        const response = super._serializeText(operation, sprite);
        response.options.color = {
          rgba: response.options.color
        };
        response.options.backgroundColor = {
          rgba: response.options.backgroundColor
        };
        response.options.flipHorizontally = false;
        response.options.flipVertically = false;
        delete response.options.fontWeight;
        return response;
      }
      _serializePath(path) {
        const response = super._serializePath(path);
        delete response.hardness;
        delete response.size;
        delete response.color;
        const brush = path.getBrush();
        response.brush = brush.serializeOptions(["identifier", "size", "color"], true);
        if (typeof response.brush.identifier === "undefined") {
          delete response.brush.identifier;
        }
        response.brush.color = {
          rgba: response.brush.color
        };
        const hardness = brush.getOption("hardness");
        if (hardness !== "undefined") {
          response.brush.hardness = hardness;
        }
        return response;
      }
      _serializeFrameOperation(operation, operations) {
        super._serializeFrameOperation(operation, operations);
        const spriteOperations = operations.filter((o) => o.type === "sprite");
        let spriteOperation;
        if (spriteOperations.length) {
          spriteOperation = spriteOperations.pop();
          const frame = spriteOperation.options.sprites.filter((s) => s.type === "frame")[0];
          const tintColor = operation.getTintColor();
          if (!tintColor.equals(new Color3(1, 1, 1, 0))) {
            frame.options.tintColor = {
              rgba: operation.serializeOption("tintColor", true)
            };
          }
          const options = operation.serializeOptions(["scale", "alpha"], true);
          frame.options = __spreadValues(__spreadValues({}, frame.options), options);
          frame.options.size = frame.options.scale;
          delete frame.options.scale;
        }
      }
      _serializeTransformOperation(operation) {
        const response = super._serializeTransformOperation(operation);
        if (operation._ratio) {
          let identifier;
          if (operation._ratio instanceof TransformRatio) {
            identifier = operation._ratio.getIdentifier();
          } else {
            identifier = operation._ratio.identifier;
          }
          response.options.meta = {
            identifier
          };
        }
        delete response.options.scale;
        return response;
      }
      _serializeAdjustmentsOperation(operation) {
        const response = super._serializeAdjustmentsOperation(operation);
        const optionNames = ["gamma", "whites", "blacks", "temperature"];
        const { availableOptions } = operation;
        const options = {};
        optionNames.forEach((optionName) => {
          const option = availableOptions[optionName];
          const value = operation.getOption(optionName);
          const { minValue, midValue, maxValue } = option;
          options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
        });
        response.options = __spreadValues(__spreadValues({}, response.options), options);
        return response;
      }
      _serializeOperation(operation, operations) {
        switch (operation.constructor.identifier) {
          case "mirrored-focus":
            return this._serializeMirroredFocusOperation(operation);
          case "linear-focus":
            return this._serializeLinearFocusOperation(operation);
          case "blur":
            return this._serializeBlurOperation(operation);
          default:
            return super._serializeOperation(operation, operations);
        }
      }
      _serializeMirroredFocusOperation(operation) {
        return {
          type: "focus",
          options: {
            type: "mirrored",
            options: operation.serializeOptions(["start", "end", "blurRadius", "size", "gradientSize"], true)
          }
        };
      }
      _serializeLinearFocusOperation(operation) {
        const options = operation.serializeOptions(["controlPoint1", "controlPoint2", "blurRadius"], true);
        options.start = options.controlPoint1;
        delete options.controlPoint1;
        options.end = options.controlPoint2;
        delete options.controlPoint2;
        return {
          type: "focus",
          options: {
            type: "linear",
            options
          }
        };
      }
      _serializeBlurOperation(operation) {
        return {
          type: "focus",
          options: {
            type: "gaussian",
            options: operation.serializeOptions(["blurRadius"], true)
          }
        };
      }
    };
    v300Serializer.version = "3.0.0";
  }
});

// engine/shared/serialization/3.0.0/index.js
var __exports4 = {};
__export(__exports4, {
  default: () => Serialization4
});
var Serialization4;
var init__4 = __esm({
  "engine/shared/serialization/3.0.0/index.js"() {
    init_deserializer4();
    init_serializer4();
    Serialization4 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v300Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v300Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization4.version = "3.0.0";
  }
});

// engine/shared/serialization/3.1.0/deserializer.js
var v310Deserializer;
var init_deserializer5 = __esm({
  "engine/shared/serialization/3.1.0/deserializer.js"() {
    init_globals3();
    init_font_manager();
    init_text_design_manager();
    init_deserializer4();
    v310Deserializer = class extends v300Deserializer {
      _deserializeTextDesign(operation, sprite) {
        const { options } = sprite;
        const {
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color,
          width,
          seed,
          inverted
        } = options;
        let { identifier } = options;
        if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignBlocksLight.identifier) {
          identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignBlocksLightV310.identifier;
        } else if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignSunshine.identifier) {
          identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignSunshineV310.identifier;
        }
        const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
        const fontManager = new FontManager(this._ui, {
          fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
          replaceFonts: true
        });
        const { AssetManager: AssetManager2 } = operation.constructor.TextDesignSprite;
        const fontLoader = this._ui.getFontLoader();
        const Layout = textDesignManager.getLayoutByIdentifier(identifier);
        const layout = new Layout();
        fontLoader.setFonts(fontManager.getFonts());
        AssetManager2.setFonts(__spreadValues(__spreadValues({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
        return fontLoader.load().then(() => {
          const images = layout.getImagePaths().map((path) => ({
            path,
            fullPath: this._ui.getAssetPath(path),
            image: null
          }));
          return AssetManager2.loadImages(images).then(() => {
            layout.onImagesLoaded();
            return operation.createTextDesign({
              position,
              rotation,
              flipHorizontally,
              flipVertically,
              text,
              color: Color3.fromArray(color.rgba),
              width,
              seed,
              inverted,
              layout
            });
          });
        });
      }
    };
    v310Deserializer.version = "3.1.0";
  }
});

// engine/shared/serialization/3.1.0/serializer.js
var v310Serializer;
var init_serializer5 = __esm({
  "engine/shared/serialization/3.1.0/serializer.js"() {
    init_globals3();
    init_serializer4();
    v310Serializer = class extends v300Serializer {
      _serializeTextDesign(operation, sprite) {
        const options = sprite.serializeOptions([
          "position",
          "rotation",
          "flipHorizontally",
          "flipVertically",
          "text",
          "color",
          "width",
          "seed",
          "inverted"
        ], true);
        options.color = {
          rgba: options.color
        };
        const layout = sprite.getLayout();
        if (layout) {
          options.identifier = layout.constructor.identifier;
        }
        return {
          type: "textdesign",
          options
        };
      }
    };
    v310Serializer.version = "3.1.0";
  }
});

// engine/shared/serialization/3.1.0/index.js
var __exports5 = {};
__export(__exports5, {
  default: () => Serialization5
});
var Serialization5;
var init__5 = __esm({
  "engine/shared/serialization/3.1.0/index.js"() {
    init_deserializer5();
    init_serializer5();
    Serialization5 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v310Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v310Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization5.version = "3.1.0";
  }
});

// engine/shared/serialization/3.2.0/deserializer.js
var v320Deserializer;
var init_deserializer6 = __esm({
  "engine/shared/serialization/3.2.0/deserializer.js"() {
    init_globals3();
    init_font_manager();
    init_text_design_manager();
    init_deserializer5();
    v320Deserializer = class extends v310Deserializer {
      _deserializeTextDesign(operation, sprite) {
        const { options } = sprite;
        const {
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color,
          width,
          seed,
          inverted
        } = options;
        let { identifier } = options;
        if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignBlocksLight.identifier) {
          identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignBlocksLightV310.identifier;
        } else if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignSunshine.identifier) {
          identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignSunshineV310.identifier;
        }
        const padding = "padding" in options ? options.padding / width : -1;
        const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
        const fontManager = new FontManager(this._ui, {
          fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
          replaceFonts: true
        });
        const { AssetManager: AssetManager2 } = operation.constructor.TextDesignSprite;
        const fontLoader = this._ui.getFontLoader();
        const Layout = textDesignManager.getLayoutByIdentifier(identifier);
        const layout = new Layout();
        fontLoader.setFonts(fontManager.getFonts());
        AssetManager2.setFonts(__spreadValues(__spreadValues({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
        return fontLoader.load().then(() => {
          const images = layout.getImagePaths().map((path) => ({
            path,
            fullPath: this._ui.getAssetPath(path),
            image: null
          }));
          return AssetManager2.loadImages(images).then(() => {
            layout.onImagesLoaded();
            return operation.createTextDesign({
              position,
              rotation,
              flipHorizontally,
              flipVertically,
              text,
              color: Color3.fromArray(color.rgba),
              width,
              seed,
              inverted,
              layout,
              padding
            });
          });
        });
      }
    };
    v320Deserializer.version = "3.2.0";
  }
});

// engine/shared/serialization/3.2.0/serializer.js
var v320Serializer;
var init_serializer6 = __esm({
  "engine/shared/serialization/3.2.0/serializer.js"() {
    init_serializer5();
    v320Serializer = class extends v310Serializer {
      _serializeTextDesign(operation, sprite) {
        const options = sprite.serializeOptions([
          "position",
          "rotation",
          "flipHorizontally",
          "flipVertically",
          "text",
          "color",
          "width",
          "seed",
          "inverted",
          "padding"
        ], true);
        options.color = {
          rgba: options.color
        };
        const layout = sprite.getLayout();
        if (layout) {
          options.identifier = layout.constructor.identifier;
        }
        options.padding *= options.width;
        return {
          type: "textdesign",
          options
        };
      }
    };
    v320Serializer.version = "3.2.0";
  }
});

// engine/shared/serialization/3.2.0/index.js
var __exports6 = {};
__export(__exports6, {
  default: () => Serialization6
});
var Serialization6;
var init__6 = __esm({
  "engine/shared/serialization/3.2.0/index.js"() {
    init_deserializer6();
    init_serializer6();
    Serialization6 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v320Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v320Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization6.version = "3.2.0";
  }
});

// engine/shared/serialization/3.4.0/deserializer.js
var v340Deserializer;
var init_deserializer7 = __esm({
  "engine/shared/serialization/3.4.0/deserializer.js"() {
    init_deserializer6();
    v340Deserializer = class extends v320Deserializer {
      _deserializeOperation(operation) {
        return super._deserializeOperation(operation);
      }
      _deserializeOrientationOperation(operation) {
        const { options } = operation;
        const orientationOperation = this._editor.operations.getOrCreate("orientation");
        if (!orientationOperation)
          return Promise.resolve();
        orientationOperation.set(options);
        return Promise.resolve(orientationOperation);
      }
    };
    v340Deserializer.version = "3.4.0";
  }
});

// engine/shared/serialization/3.4.0/serializer.js
var v340Serializer;
var init_serializer7 = __esm({
  "engine/shared/serialization/3.4.0/serializer.js"() {
    init_blend_modes();
    init_serializer6();
    v340Serializer = class extends v320Serializer {
      _serializeOperation(operation, operations) {
        switch (operation.constructor.identifier) {
          case "artfilter":
            return this._serializeStyle(operation);
          default:
            return super._serializeOperation(operation, operations);
        }
      }
      _serializeOrientationOperation(operation) {
        return {
          type: "orientation",
          options: operation.serializeOptions(["flipVertically", "flipHorizontally", "rotation"], true)
        };
      }
      _serializeStyle(operation) {
        const { identifier, intensity, blendMode } = operation.getOptions();
        const {
          tileEdgeLength,
          overlappingFactor
        } = operation.getStyleTransferModel().getOptions();
        return {
          type: "artFilter",
          options: {
            identifier,
            intensity,
            blendMode: blend_modes_default[blendMode],
            tileEdgeLength,
            overlappingFactor
          }
        };
      }
    };
    v340Serializer.version = "3.4.0";
  }
});

// engine/shared/serialization/3.4.0/index.js
var __exports7 = {};
__export(__exports7, {
  default: () => Serialization7
});
var Serialization7;
var init__7 = __esm({
  "engine/shared/serialization/3.4.0/index.js"() {
    init_deserializer7();
    init_serializer7();
    Serialization7 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v340Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v340Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization7.version = "3.4.0";
  }
});

// engine/shared/serialization/3.5.0/deserializer.js
var v350Deserializer;
var init_deserializer8 = __esm({
  "engine/shared/serialization/3.5.0/deserializer.js"() {
    init_globals3();
    init_font_manager();
    init_text_design_manager();
    init_deserializer7();
    v350Deserializer = class extends v340Deserializer {
      _deserializeTextDesign(operation, sprite) {
        const { options } = sprite;
        const {
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color,
          width,
          seed,
          inverted,
          identifier
        } = options;
        const padding = "padding" in options ? options.padding / width : -1;
        const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
        const fontManager = new FontManager(this._ui, {
          fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
          replaceFonts: true
        });
        const { AssetManager: AssetManager2 } = operation.constructor.TextDesignSprite;
        const fontLoader = this._ui.getFontLoader();
        const Layout = textDesignManager.getLayoutByIdentifier(identifier);
        const layout = new Layout();
        fontLoader.setFonts(fontManager.getFonts());
        AssetManager2.setFonts(__spreadValues(__spreadValues({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
        return fontLoader.load().then(() => {
          const images = layout.getImagePaths().map((path) => ({
            path,
            fullPath: this._ui.getAssetPath(path),
            image: null
          }));
          return AssetManager2.loadImages(images).then(() => {
            layout.onImagesLoaded();
            return operation.createTextDesign({
              position,
              rotation,
              flipHorizontally,
              flipVertically,
              text,
              color: Color3.fromArray(color.rgba),
              width,
              seed,
              inverted,
              layout,
              padding
            });
          });
        });
      }
    };
    v350Deserializer.version = "3.5.0";
  }
});

// engine/shared/serialization/3.5.0/serializer.js
var v350Serializer;
var init_serializer8 = __esm({
  "engine/shared/serialization/3.5.0/serializer.js"() {
    init_serializer7();
    v350Serializer = class extends v340Serializer {
    };
    v350Serializer.version = "3.5.0";
  }
});

// engine/shared/serialization/3.5.0/index.js
var __exports8 = {};
__export(__exports8, {
  default: () => Serialization8
});
var Serialization8;
var init__8 = __esm({
  "engine/shared/serialization/3.5.0/index.js"() {
    init_deserializer8();
    init_serializer8();
    Serialization8 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v350Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v350Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization8.version = "3.5.0";
  }
});

// engine/shared/serialization/3.6.0/deserializer.js
var v360Deserializer;
var init_deserializer9 = __esm({
  "engine/shared/serialization/3.6.0/deserializer.js"() {
    init_globals3();
    init_deserializer8();
    v360Deserializer = class extends v350Deserializer {
      _deserializeAdjustmentsOperation(operationData) {
        const { AdjustmentsOperation: AdjustmentsOperation2 } = SDK.Operations;
        return super._deserializeAdjustmentsOperation(operationData).then((operation) => {
          if (!operation)
            return null;
          const { options } = operationData;
          const optionName = "sharpness";
          const operationOptions = {};
          if (typeof options[optionName] === "undefined")
            return;
          const {
            minValue,
            midValue,
            maxValue
          } = AdjustmentsOperation2.prototype.availableOptions[optionName];
          let value = options[optionName];
          value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
          operationOptions[optionName] = value;
          operation.set(operationOptions);
          return operation;
        });
      }
    };
    v360Deserializer.version = "3.6.0";
  }
});

// engine/shared/serialization/3.6.0/serializer.js
var v360Serializer;
var init_serializer9 = __esm({
  "engine/shared/serialization/3.6.0/serializer.js"() {
    init_serializer8();
    v360Serializer = class extends v350Serializer {
      _serializeAdjustmentsOperation(operation) {
        const response = super._serializeAdjustmentsOperation(operation);
        const optionName = "sharpness";
        const { availableOptions } = operation;
        const options = {};
        const option = availableOptions[optionName];
        const value = operation.getOption(optionName);
        const { minValue, midValue, maxValue } = option;
        options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
        response.options = __spreadValues(__spreadValues({}, response.options), options);
        return response;
      }
    };
    v360Serializer.version = "3.6.0";
  }
});

// engine/shared/serialization/3.6.0/index.js
var __exports9 = {};
__export(__exports9, {
  default: () => Serialization9
});
var Serialization9;
var init__9 = __esm({
  "engine/shared/serialization/3.6.0/index.js"() {
    init_deserializer9();
    init_serializer9();
    Serialization9 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v360Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v360Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization9.version = "3.6.0";
  }
});

// engine/shared/serialization/3.7.0/deserializer.js
var v370Deserializer;
var init_deserializer10 = __esm({
  "engine/shared/serialization/3.7.0/deserializer.js"() {
    init_sdk2();
    init_deserializer9();
    v370Deserializer = class extends v360Deserializer {
      deserialize() {
        return this._validateVersion().then(() => this._deserializeAssetLibrary()).then(() => this._deserializeInputImage()).then(() => this._deserializeOperations());
      }
      _deserializeAssetLibrary() {
        return new Promise((resolve, reject) => {
          const data = this._data;
          if (!data.assetLibrary) {
            resolve();
            return;
          }
          const { assets } = data.assetLibrary;
          const promises = [];
          for (const assetType in assets) {
            promises.push(this._deserializeCustomAssets(assetType, assets[assetType]));
          }
          return Promise.all(promises).then(() => {
            resolve();
          }).catch((err) => {
            console.error(err);
            reject(err);
          });
        });
      }
      _deserializeCustomAssets(type, data) {
        switch (type) {
          case "stickers":
            return this._deserializeCustomStickerAssets(data);
          default:
            return Promise.reject(new Error(`Unknown asset type: ${type}`));
        }
      }
      _deserializeCustomStickerAssets(serializedStickers) {
        let defaultTintMode = "none";
        const editorOptions = this._editor.getOptions().editor;
        if (editorOptions && editorOptions.controlsOptions && editorOptions.controlsOptions.sticker) {
          defaultTintMode = editorOptions.controlsOptions.sticker.customStickerTintMode || "none";
        }
        const promises = serializedStickers.map((serializedSticker) => {
          return new Promise((resolve, reject) => {
            const { identifier, raster } = serializedSticker;
            const isSVG = serializedSticker.svg !== void 0;
            let rasterBase64 = `data:${raster.type};base64,${raster.data}`;
            let image = new image_default();
            image.onload = () => {
              const sdk = this._editor.getSDK();
              image = sdk.correctExifOrientation(image);
              if (image.toDataURL) {
                rasterBase64 = image.toDataURL();
              }
              let thumb = { data: "", width: 1, height: 1 };
              if (false) {
                thumb = this._stickerManager.renderStickerThumbnailFromImage(image);
              }
              const customSticker = {
                identifier,
                defaultName: serializedSticker.name || "",
                tintMode: defaultTintMode,
                images: {
                  mediaBase: {
                    uris: [rasterBase64],
                    rawData: true,
                    isSVG,
                    width: image.width,
                    height: image.height
                  },
                  mediaThumb: {
                    uris: [thumb.data],
                    rawData: true,
                    width: thumb.width,
                    height: thumb.height
                  }
                }
              };
              if (isSVG) {
                const svgBase64 = `data:image/svg+xml;base64,${serializedSticker.svg.data}`;
                customSticker.images.mediaBase.uris.push(svgBase64);
              }
              resolve(customSticker);
            };
            image.onerror = () => {
              reject(new Error(`Invalid base64 data: ${rasterBase64}`));
            };
            image.src = rasterBase64;
          });
        });
        return Promise.all(promises).then((stickers) => {
          const assetsLibrary = this._editor.getDynamicAssetsLibrary();
          assetsLibrary.setAssets("sticker", stickers);
          this._stickerManager.reload();
        });
      }
    };
    v370Deserializer.version = "3.7.0";
  }
});

// engine/shared/serialization/3.7.0/serializer.js
var v370Serializer;
var init_serializer10 = __esm({
  "engine/shared/serialization/3.7.0/serializer.js"() {
    init_serializer9();
    v370Serializer = class extends v360Serializer {
      serialize(options = {}) {
        return super.serialize(options).then((data) => {
          return this._serializeAssetLibrary(data).then((data2) => {
            return data2;
          });
        });
      }
      _serializeAssetLibrary(data) {
        if (!this._editor.getDynamicAssetsLibrary) {
          return Promise.resolve(data);
        }
        const assetLibrary = this._editor.getDynamicAssetsLibrary();
        const serializedStickers = this._serializeCustomStickerAssets(data, assetLibrary);
        if (serializedStickers.length === 0) {
          return Promise.resolve(data);
        }
        data.assetLibrary = {
          assets: {
            stickers: serializedStickers
          }
        };
        return Promise.resolve(data);
      }
      _serializeCustomStickerAssets(data, assetLibrary) {
        const customStickers = assetLibrary.getAssets("sticker");
        if (customStickers.length === 0) {
          return [];
        }
        const usedStickerIDs = data.operations.filter((operation) => {
          return operation.type === "sprite";
        }).flatMap((operation) => operation.options.sprites).filter((sprite) => sprite.type === "sticker").map((sprite) => sprite.options.identifier);
        const usedIDMap = {};
        usedStickerIDs.forEach((id) => {
          usedIDMap[id] = true;
        });
        const usedCustomStickers = customStickers.filter((sticker) => {
          return usedIDMap[sticker.identifier];
        });
        return usedCustomStickers.map((sticker) => {
          const { identifier, defaultName: name, images } = sticker;
          const data2 = images.mediaBase.uris[0];
          const { isSVG } = images.mediaBase;
          const regex = /^data:(image\/(jpeg|png));base64,(.*)$/g;
          const matches = regex.exec(data2);
          const rasterType = matches[1];
          const onlyBase64 = matches[3];
          const serialized = {
            identifier,
            name,
            raster: {
              type: rasterType,
              data: onlyBase64
            }
          };
          if (name) {
            serialized.name = name;
          }
          if (isSVG) {
            serialized.svg = {
              data: images.mediaBase.uris[1].replace(/^data:image\/svg\+xml;base64,/g, "")
            };
          }
          return serialized;
        });
      }
    };
    v370Serializer.version = "3.7.0";
  }
});

// engine/shared/serialization/3.7.0/index.js
var __exports10 = {};
__export(__exports10, {
  default: () => Serialization10
});
var Serialization10;
var init__10 = __esm({
  "engine/shared/serialization/3.7.0/index.js"() {
    init_deserializer10();
    init_serializer10();
    Serialization10 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v370Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v370Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization10.version = "3.7.0";
  }
});

// engine/shared/serialization/3.8.0/deserializer.js
var v380Deserializer;
var init_deserializer11 = __esm({
  "engine/shared/serialization/3.8.0/deserializer.js"() {
    init_deserializer10();
    v380Deserializer = class extends v370Deserializer {
    };
    v380Deserializer.version = "3.8.0";
  }
});

// engine/shared/serialization/3.8.0/serializer.js
var v380Serializer;
var init_serializer11 = __esm({
  "engine/shared/serialization/3.8.0/serializer.js"() {
    init_serializer10();
    v380Serializer = class extends v370Serializer {
      _serializeSticker(operation, sprite) {
        const response = super._serializeSticker(operation, sprite);
        response.options.tintMode = sprite.getTintMode();
        return response;
      }
    };
    v380Serializer.version = "3.8.0";
  }
});

// engine/shared/serialization/3.8.0/index.js
var __exports11 = {};
__export(__exports11, {
  default: () => Serialization11
});
var Serialization11;
var init__11 = __esm({
  "engine/shared/serialization/3.8.0/index.js"() {
    init_deserializer11();
    init_serializer11();
    Serialization11 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v380Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v380Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization11.version = "3.8.0";
  }
});

// engine/shared/serialization/3.9.0/deserializer.js
var v390Deserializer;
var init_deserializer12 = __esm({
  "engine/shared/serialization/3.9.0/deserializer.js"() {
    init_globals3();
    init_deserializer11();
    v390Deserializer = class extends v380Deserializer {
      _deserializeTransformOperation(operationData) {
        return super._deserializeCropOperation(operationData).then((operation) => {
          if (!operation)
            return;
          const orientationData = SDKUtils2.Array.find(this._data.operations, (op) => op.type === "orientation");
          if (orientationData) {
            const { options } = orientationData;
            operation.rotate(options.rotation);
            if (options.flipHorizontally) {
              operation.flip("horizontal");
              operation.setRotation(operation.getRotation() * -1);
            }
            if (options.flipVertically) {
              operation.flip("vertical");
              operation.setRotation(operation.getRotation() * -1);
            }
          }
          operation._ratio = null;
          return operation;
        });
      }
      _deserializeText(operation, text) {
        const { options } = text;
        const {
          fontSize,
          lineHeight,
          fontIdentifier,
          alignment,
          rotation,
          maxWidth,
          color,
          backgroundColor
        } = options;
        const fontLoader = this._ui.getFontLoader();
        let variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
        if (!variation) {
          variation = this._fontManager.getDefaultVariation();
        } else {
          fontLoader.setFonts([variation.getFont()]);
        }
        return fontLoader.load().then(() => {
          const inputDimensions = operation.getInputDimensions(false);
          const minSide = inputDimensions.min();
          const width = inputDimensions.x;
          const height = inputDimensions.y;
          const internalMaxWidth = maxWidth * minSide / width;
          const internalFont = fontSize * minSide / height;
          const sprite = operation.createText({
            fontSize: internalFont,
            lineHeight,
            fontFamily: variation.getFontFamily(),
            fontWeight: variation.getFontWeight(),
            fontIdentifier: variation.getIdentifier(),
            textMetrics: variation.getTextMetrics(),
            alignment,
            rotation,
            maxWidth: internalMaxWidth,
            text: options.text,
            color: Color3.fromArray(color.rgba),
            backgroundColor: Color3.fromArray(backgroundColor.rgba),
            position: Vector235.fromObject(options.position)
          });
          sprite._edited = true;
          return sprite;
        });
      }
    };
    v390Deserializer.version = "3.9.0";
  }
});

// engine/shared/serialization/3.9.0/serializer.js
var TWICE_PI3, v390Serializer;
var init_serializer12 = __esm({
  "engine/shared/serialization/3.9.0/serializer.js"() {
    init_transform_ratio();
    init_serializer11();
    TWICE_PI3 = Math.PI * 2;
    v390Serializer = class extends v380Serializer {
      _serializeTransformOperation(operation) {
        const { operations } = this._editor;
        if (operations.exists("orientation")) {
          operation = operation.clone();
          const orientationOperation = operations.get("orientation");
          if (orientationOperation.getFlipVertically()) {
            operation.flip("vertical");
            operation.setRotation(operation.getRotation() * -1);
          }
          if (orientationOperation.getFlipHorizontally()) {
            operation.flip("horizontal");
            operation.setRotation(operation.getRotation() * -1);
          }
          operation.rotate(-orientationOperation.getRotation());
        }
        const options = operation.serializeOptions(["start", "end", "rotation", "textureScale"], true);
        options.rotation = (options.rotation + TWICE_PI3) % TWICE_PI3;
        if (options.textureScale !== 1) {
          options.dimensions = operation.getNewDimensions(operation.getInputDimensions(false));
        }
        delete options.textureScale;
        const response = { type: "transform", options };
        if (operation._ratio) {
          let identifier;
          if (operation._ratio instanceof TransformRatio) {
            identifier = operation._ratio.getIdentifier();
          } else {
            identifier = operation._ratio.identifier;
          }
          response.options.meta = {
            identifier
          };
        }
        delete response.options.scale;
        return response;
      }
      _serializeText(operation, sprite) {
        const inputDimensions = operation.getInputDimensions(false);
        const response = super._serializeText(operation, sprite);
        response.options.fontSize = response.options.fontSize * inputDimensions.y / inputDimensions.min();
        return response;
      }
    };
    v390Serializer.version = "3.9.0";
  }
});

// engine/shared/serialization/3.9.0/index.js
var __exports12 = {};
__export(__exports12, {
  default: () => Serialization12
});
var Serialization12;
var init__12 = __esm({
  "engine/shared/serialization/3.9.0/index.js"() {
    init_deserializer12();
    init_serializer12();
    Serialization12 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v390Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v390Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization12.version = "3.9.0";
  }
});

// engine/shared/serialization/3.12.0/deserializer.js
var v3120Deserializer;
var init_deserializer13 = __esm({
  "engine/shared/serialization/3.12.0/deserializer.js"() {
    init_deserializer12();
    v3120Deserializer = class extends v390Deserializer {
    };
    v3120Deserializer.version = "3.12.0";
  }
});

// engine/shared/serialization/3.12.0/serializer.js
var v3120Serializer;
var init_serializer13 = __esm({
  "engine/shared/serialization/3.12.0/serializer.js"() {
    init_serializer12();
    v3120Serializer = class extends v390Serializer {
      _serializeCustomStickerAssets(data, assetLibrary) {
        const customStickers = assetLibrary.getAssets("sticker");
        if (customStickers.length === 0) {
          return [];
        }
        const usedStickerIDs = data.operations.filter((operation) => {
          return operation.type === "sprite";
        }).flatMap((operation) => operation.options.sprites).filter((sprite) => sprite.type === "sticker").map((sprite) => sprite.options.identifier);
        const usedIDMap = {};
        usedStickerIDs.forEach((id) => {
          usedIDMap[id] = true;
        });
        const usedCustomStickers = customStickers.filter((sticker) => {
          return usedIDMap[sticker.identifier];
        });
        return usedCustomStickers.map((sticker) => {
          const { identifier, defaultName: name, images } = sticker;
          const data2 = images.mediaBase.uris[0];
          const { isSVG } = images.mediaBase;
          const regex = /^data:(image\/(jpeg|png|gif));base64,(.*)$/g;
          const matches = regex.exec(data2);
          const rasterType = matches[1];
          const onlyBase64 = matches[3];
          const serialized = {
            identifier,
            name,
            raster: {
              type: rasterType,
              data: onlyBase64
            }
          };
          if (name) {
            serialized.name = name;
          }
          if (isSVG) {
            serialized.svg = {
              data: images.mediaBase.uris[1].replace(/^data:image\/svg\+xml;base64,/g, "")
            };
          }
          return serialized;
        });
      }
    };
    v3120Serializer.version = "3.12.0";
  }
});

// engine/shared/serialization/3.12.0/index.js
var __exports13 = {};
__export(__exports13, {
  default: () => Serialization13
});
var Serialization13;
var init__13 = __esm({
  "engine/shared/serialization/3.12.0/index.js"() {
    init_deserializer13();
    init_serializer13();
    Serialization13 = class {
      constructor(editor) {
        this._editor = editor;
      }
      serialize(...args) {
        const serializer = new v3120Serializer(this._editor);
        return serializer.serialize(...args);
      }
      deserialize(data) {
        const deserializer = new v3120Deserializer(this._editor, data);
        return deserializer.deserialize();
      }
    };
    Serialization13.version = "3.12.0";
  }
});

// engine/server/index.js
var server_exports = {};
__export(server_exports, {
  default: () => server_default
});
init_globals3();
init_json_loader();

// engine/server/lib/editor.js
init_asset_library();

// engine/shared/exporter.js
init_globals3();

// engine/shared/downloader/file-downloader.js
init_globals3();
var FileDownloader = class {
  static downloadDataURL(data, baseName = "photoeditorsdk-export") {
    const url = this.createBlobURLFromDataURL(data);
    const extension = this.getExtensionFromDataURL(data);
    const link = document.createElement("a");
    link.download = `${baseName}.${extension}`;
    link.href = url;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
  static downloadMSBlob(data, baseName = "photoeditorsdk-export") {
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(data, `${baseName}.png`);
    }
  }
  static getExtensionFromDataURL(data) {
    const mimeString = data.split(",")[0].split(":")[1].split(";")[0];
    return mimeString.split("/").pop();
  }
  static createBlobURLFromDataURL(data) {
    if (!window.Blob || !window.URL || !ArrayBuffer || !Uint8Array) {
      return data;
    }
    const rawData = Base643.decode(data.split(",")[1]);
    const mimeString = data.split(",")[0].split(":")[1].split(";")[0];
    const arrayBuffer = new ArrayBuffer(rawData.length);
    const intArray = new Uint8Array(arrayBuffer);
    for (let i = 0; i < rawData.length; i++) {
      intArray[i] = rawData[i];
    }
    const blob = new window.Blob([arrayBuffer], {
      type: mimeString
    });
    return window.URL.createObjectURL(blob);
  }
};

// engine/shared/exporter.js
var Exporter = class {
  constructor(sdk, options, download) {
    this._sdk = sdk;
    this._options = options;
    this._download = download;
  }
  export() {
    const renderType = this._getRenderType();
    return this._sdk.export(renderType, this._options.format, this._options.quality).then((data) => {
      if (this._download) {
        this._downloadData(renderType, data);
      }
      return data;
    });
  }
  _downloadData(renderType, data) {
    switch (renderType) {
      case RenderType3.DATAURL:
        FileDownloader.downloadDataURL(data, this._options.fileBasename);
        break;
      case RenderType3.MSBLOB:
        FileDownloader.downloadMSBlob(data, this._options.fileBasename);
        break;
    }
  }
  _getRenderType() {
    const options = this._options;
    if (options.type !== RenderType3.IMAGE || !this._download) {
      return options.type;
    }
    if (utils_default2.supportsMSBlob()) {
      return RenderType3.MSBLOB;
    }
    return RenderType3.DATAURL;
  }
};

// engine/server/lib/editor.js
init_font_manager();
init_cleanUpCanvasMemory();

// engine/server/globals.js
init_sdk2();
init_constants2();
init_image_loader();
init_log();

// engine/server/lib/constants/index.js
init_sdk2();

// packages/shared/assets/font/metadata.ts
var metadata = [
  {
    identifier: "imgly_font_open_sans_bold",
    fontFamily: "Open Sans",
    fontWeight: "bold",
    fontURI: "./fonts/imgly_font_open_sans_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2189,
      descender: -600
    }
  },
  {
    identifier: "imgly_font_aleo_bold",
    fontFamily: "Aleo",
    fontWeight: "bold",
    fontURI: "./fonts/imgly_font_aleo_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 805,
      descender: -195
    }
  },
  {
    identifier: "imgly_font_amaticsc",
    fontFamily: "Amatic SC",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_amaticsc.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1016,
      descender: -245
    }
  },
  {
    identifier: "imgly_font_archivo_black",
    fontFamily: "Archivo",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_archivo_black.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 878,
      descender: -210
    }
  },
  {
    identifier: "imgly_font_bungee_inline",
    fontFamily: "Bungee Inline",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_bungee_inline.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 860,
      descender: -140
    }
  },
  {
    identifier: "imgly_font_fira_sans_regular",
    fontFamily: "Fira Sans",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_fira_sans_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 935,
      descender: -265
    }
  },
  {
    identifier: "imgly_font_carter_one",
    fontFamily: "Carter One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_carter_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2264,
      descender: -890
    }
  },
  {
    identifier: "imgly_font_codystar",
    fontFamily: "Codystar",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_codystar.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1024,
      ascender: 953,
      descender: -255
    }
  },
  {
    identifier: "imgly_font_krona_one",
    fontFamily: "Krona One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_krona_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2030,
      descender: -530
    }
  },
  {
    identifier: "imgly_font_kumar_one_outline",
    fontFamily: "Kumar One Outline",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_kumar_one_outline.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1137,
      descender: -642
    }
  },
  {
    identifier: "imgly_font_lobster",
    fontFamily: "Lobster",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_lobster.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1e3,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_molle",
    fontFamily: "Molle",
    fontWeight: "normal",
    fontStyle: "italic",
    fontURI: "./fonts/imgly_font_molle.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1852,
      descender: -701
    }
  },
  {
    identifier: "imgly_font_monoton",
    fontFamily: "Monoton",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_monoton.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2366,
      descender: -822
    }
  },
  {
    identifier: "imgly_font_nixie_one",
    fontFamily: "Nixie One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_nixie_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 926,
      descender: -210
    }
  },
  {
    identifier: "imgly_font_notable",
    fontFamily: "Notable",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_notable.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1143,
      descender: -157
    }
  },
  {
    identifier: "imgly_font_ostrich_sans_black",
    fontFamily: "Ostrich",
    fontWeight: 800,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ostrich_sans_black.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 950,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_ostrich_sans_bold",
    fontFamily: "Ostrich",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ostrich_sans_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 950,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_oswald_semi_bold",
    fontFamily: "Oswald SemiBold",
    googleFamily: "Oswald",
    fontWeight: 600,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_oswald_semi_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1193,
      descender: -289
    }
  },
  {
    identifier: "imgly_font_palanquin_dark_semi_bold",
    fontFamily: "Palanquin Dark SemiBold",
    googleFamily: "Palanquin Dark",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_palanquin_dark_semi_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1320,
      descender: -491
    }
  },
  {
    identifier: "imgly_font_poppins",
    fontFamily: "Poppins",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_poppins.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1050,
      descender: -350
    }
  },
  {
    identifier: "imgly_font_permanent_marker",
    fontFamily: "Permanent Marker",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_permanent_marker.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1024,
      ascender: 1136,
      descender: -325
    }
  },
  {
    identifier: "imgly_font_roboto_black_italic",
    fontFamily: "Roboto Black",
    fontWeight: "bold",
    fontStyle: "italic",
    googleFamily: "Roboto",
    fontURI: "./fonts/imgly_font_roboto_black_italic.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_roboto_light_italic",
    fontFamily: "Roboto Light",
    googleFamily: "Roboto",
    fontWeight: 300,
    fontStyle: "italic",
    fontURI: "./fonts/imgly_font_roboto_light_italic.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_sancreek",
    fontFamily: "Sancreek",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_sancreek.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2104,
      descender: -738
    }
  },
  {
    identifier: "imgly_font_stint_ultra_expanded",
    fontFamily: "Stint Ultra Expanded",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_stint_ultra_expanded.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1853,
      descender: -483
    }
  },
  {
    identifier: "imgly_font_trash_hand",
    fontFamily: "Trash Hand",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_trash_hand.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 759,
      descender: -304
    }
  },
  {
    identifier: "imgly_font_vt323",
    fontFamily: "VT323",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_vt323.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 800,
      descender: -200
    }
  },
  {
    identifier: "imgly_font_yeseva_one",
    fontFamily: "Yeseva One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_yeseva_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 915,
      descender: -240
    }
  },
  {
    identifier: "imgly_font_abril_fatface_regular",
    fontFamily: "Abril Fatface",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_abril_fatface_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1058,
      descender: -291
    }
  },
  {
    identifier: "imgly_font_montserrat_light",
    fontFamily: "Montserrat Light",
    googleFamily: "Montserrat",
    fontWeight: 300,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_montserrat_light.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 968,
      descender: -251
    }
  },
  {
    identifier: "imgly_font_handycheera_regular",
    fontFamily: "Handycheera",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_handycheera_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2199,
      descender: -808
    }
  },
  {
    identifier: "imgly_font_ostrich_sans_heavy",
    fontFamily: "Ostrich",
    fontWeight: 900,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ostrich_sans_heavy.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 674,
      descender: 0
    }
  },
  {
    identifier: "imgly_font_petit_formal_script",
    fontFamily: "Petit Formal Script",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_petit_formal_script.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2033,
      descender: -527
    }
  },
  {
    identifier: "imgly_font_rasa_500",
    fontFamily: "Rasa",
    fontWeight: 500,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_rasa_500.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2750,
      ascender: 2300,
      descender: -1050
    }
  },
  {
    identifier: "imgly_font_rasa_regular",
    fontFamily: "Rasa",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_rasa_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2750,
      ascender: 2300,
      descender: -1050
    }
  },
  {
    identifier: "imgly_font_roboto_black",
    fontFamily: "Roboto Black",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_roboto_black.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_roboto_light",
    fontFamily: "Roboto Light",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_roboto_light.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_sue_ellen_francisco",
    fontFamily: "Sue Ellen Francisco",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_sue_ellen_francisco.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1024,
      ascender: 1362,
      descender: -634
    }
  },
  {
    identifier: "imgly_font_ultra",
    fontFamily: "Ultra",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ultra.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2066,
      descender: -561
    }
  },
  {
    identifier: "imgly_font_allison_regular",
    fontFamily: "Allison",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_allison_regular.ttf",
    format: "truetype",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 890,
      descender: -380
    }
  },
  {
    identifier: "imgly_font_cookie_regular",
    fontFamily: "Cookie",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_cookie_regular.ttf",
    format: "truetype",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 789,
      descender: -320
    }
  },
  {
    identifier: "imgly_font_lexend_bold",
    fontFamily: "Lexend",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_lexend_bold.ttf",
    format: "truetype",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1e3,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_outfit_bold",
    fontFamily: "Outfit",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_outfit_bold.ttf",
    format: "truetype",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1e3,
      descender: -260
    }
  }
];
var metadata_default = metadata;

// engine/server/lib/constants/index.js
var brushes = [];
if (typeof exports_default.Operations.SpriteOperation !== "undefined") {
  brushes.push(exports_default.Operations.SpriteOperation.BrushSprite.Brushes.RadialBrush);
}
var constants_default4 = {
  EVENTS: {
    EXPORT: "export",
    OPERATION_CREATED: "operation:created",
    OPERATION_UPDATED: "operation:updated",
    OPERATION_REMOVED: "operation:removed"
  },
  DEFAULTS: {
    TRANSFORM_RATIO_CATEGORIES: [
      {
        identifier: "imgly_transforms_common",
        defaultName: "Common Ratios",
        ratios: [
          {
            identifier: "imgly_transform_common_custom",
            defaultName: "Custom",
            ratio: "*",
            selected: true
          },
          {
            identifier: "imgly_transform_common_square",
            defaultName: "Square",
            ratio: 1
          },
          {
            identifier: "imgly_transform_common_4-3",
            defaultName: "4:3",
            ratio: 4 / 3
          },
          {
            identifier: "imgly_transform_common_16-9",
            defaultName: "16:9",
            ratio: 16 / 9
          }
        ]
      },
      {
        identifier: "imgly_transforms_facebook",
        defaultName: "Facebook",
        ratios: [
          {
            identifier: "imgly_transform_facebook_profile",
            defaultName: "Profile Pic",
            ratio: 1 / 1
          },
          {
            identifier: "imgly_transform_facebook_ad",
            defaultName: "Ad",
            dimensions: new exports_default.Math.Vector2(1200, 627)
          },
          {
            identifier: "imgly_transform_facebook_post",
            defaultName: "Post",
            dimensions: new exports_default.Math.Vector2(940, 788)
          },
          {
            identifier: "imgly_transform_facebook_cover",
            defaultName: "Cover",
            dimensions: new exports_default.Math.Vector2(851, 315)
          }
        ]
      }
    ],
    FONTS: metadata_default,
    BRUSHES: brushes,
    TEXT_DESIGN_FONTS: metadata_default
  }
};

// engine/server/lib/utils.js
init_sdk2();
init_json_loader();
init_log();
init_cleanUpCanvasMemory();
var { Utils: SDKUtils3 } = exports_default;
var { Vector2: Vector236 } = exports_default.Math;

// engine/server/globals.js
var { Base64: Base644 } = exports_default;
var { Color: Color4 } = exports_default;
var { ColorMatrix: ColorMatrix9 } = exports_default.Math;
var { EventEmitter: EventEmitter4 } = exports_default;
var { EXIF: EXIF3 } = exports_default;
var { OptionType: OptionType7 } = exports_default;
var { Promise: Promise2 } = exports_default;
var SDKUtils4 = exports_default.Utils;
var { RenderType: RenderType4 } = exports_default;
var { ImageFormat: ImageFormat4 } = exports_default;
var SDK2 = exports_default;
var { UniformType: UniformType7 } = exports_default;
var { Vector2: Vector237 } = exports_default.Math;
var { Rectangle: Rectangle15 } = exports_default.Math;
var { Range: Range3 } = exports_default.Math;
var now4 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();

// engine/server/lib/editor/operations.js
var EditorOperations = class {
  constructor(editor, sdk, mediator) {
    this._editor = editor;
    this._sdk = sdk;
    this._mediator = mediator;
    this._available = this._sdk.getOperations();
    this._map = {};
    this._stack = this._sdk.getOperationsStack();
    this._preferredOrder = this._editor.getOptions().editor.operationsOrder;
    this._fixStack();
  }
  exists(identifier) {
    return !!this._map[identifier];
  }
  add(operation) {
    const { identifier } = operation.constructor;
    operation.on("update", () => {
      this._mediator.emit(constants_default4.EVENTS.OPERATION_UPDATED, operation);
    });
    const index = this._preferredOrder.indexOf(identifier);
    if (index === -1) {
      throw new Error(`EditorOperations#add: \`${identifier}\` does not appear in \`operationsOrder\``);
    }
    this._stack.set(index, operation);
    this._map[identifier] = operation;
    this._mediator.emit(constants_default4.EVENTS.OPERATION_CREATED, operation);
  }
  remove(operation, broadcast = true) {
    const identifier = typeof operation === "object" ? operation.constructor.identifier : operation;
    const stack = this._stack.getStack();
    operation = this.get(identifier);
    delete this._map[identifier];
    const index = stack.map((op) => op.constructor.identifier).indexOf(identifier);
    if (index !== -1) {
      this._stack.removeAt(index);
      for (let i = index + 1; i < stack.length; i++) {
        const operation2 = stack[i];
        if (!operation2)
          continue;
        operation2.setDirty(true);
      }
      if (broadcast) {
        this._mediator.emit(constants_default4.EVENTS.OPERATION_REMOVED, operation);
      }
    }
  }
  get(identifier) {
    return this._map[identifier];
  }
  getOrCreate(identifier, options = {}) {
    if (this._map[identifier]) {
      const operation2 = this._map[identifier];
      operation2.set(options, false);
      return operation2;
    }
    const Operation2 = this._available[identifier];
    const operation = new Operation2(this._sdk, options);
    this.add(operation);
    return operation;
  }
  getStack() {
    return this._stack;
  }
  reset() {
    for (const key in this._map) {
      const operation = this._map[key];
      operation.dispose();
    }
    this._map = {};
  }
  _fixStack() {
    const stack = this._stack.getStack().slice();
    this._stack.clear();
    stack.forEach((s) => {
      this.add(s);
    });
  }
};

// engine/server/lib/image-resizer.js
var ImageResizer = class {
  constructor(image, maxPixels, maxDimensions) {
    this._image = image;
    this._maxPixels = maxPixels;
    this._maxDimensions = maxDimensions;
  }
  needsResize() {
    const dimensions = new Vector237(this._image.width, this._image.height);
    const pixels = dimensions.x * dimensions.y;
    const exceedsMaxPixels = this._maxPixels !== null && pixels > this._maxPixels;
    const exceedsMaxDimensions = this._maxDimensions !== null && (dimensions.x > this._maxDimensions || dimensions.y > this._maxDimensions);
    return exceedsMaxPixels || exceedsMaxDimensions;
  }
  resize() {
    let reason = null;
    let canvas = null;
    const maxDimensions = this._maxDimensions;
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        const initialDimensions = new Vector237(this._image.width, this._image.height);
        const dimensions = initialDimensions.clone();
        if (this._maxPixels !== null && dimensions.x * dimensions.y > this._maxPixels) {
          dimensions.copy(this._getDimensionsByMaxPixels());
          reason = "maxMegaPixels";
        }
        if (maxDimensions !== null && (dimensions.x > maxDimensions || dimensions.y > maxDimensions)) {
          const scale = Math.min(maxDimensions / dimensions.x, maxDimensions / dimensions.y);
          dimensions.multiply(scale);
          reason = "maxDimensions";
        }
        dimensions.floor();
        canvas = this._createResizedImageCanvas(dimensions);
        resolve({ canvas, dimensions, reason });
      }, 1e3);
    });
  }
  _createResizedImageCanvas(dimensions, imageDimensions = dimensions) {
    const image = this._image;
    const canvas = SDKUtils4.createCanvas();
    canvas.width = dimensions.x;
    canvas.height = dimensions.y;
    const offset = dimensions.clone().subtract(imageDimensions).divide(2);
    const context = canvas.getContext("2d");
    context.drawImage(image, 0, 0, image.width, image.height, offset.x, offset.y, imageDimensions.x, imageDimensions.y);
    return canvas;
  }
  _getDimensionsByMaxPixels() {
    const image = this._image;
    const maxPixels = this._maxPixels;
    const ratioHV = image.width / image.height;
    const ratioVH = image.height / image.width;
    return new Vector237(Math.sqrt(maxPixels * ratioHV), Math.sqrt(maxPixels * ratioVH)).floor();
  }
};

// engine/server/lib/editor.js
var Editor = class extends EventEmitter4 {
  constructor(ui, options, mediator, shallow = false) {
    super();
    this._ui = ui;
    this._options = options;
    this._mediator = mediator;
    this._shallow = shallow;
    this._initFonts();
    if (!shallow) {
      this._initSDK();
      this.operations = new EditorOperations(this, this._sdk, this._mediator);
      this._initSerializers();
    }
    this._dynamicAssetsLibrary = new asset_library_default();
  }
  _initFonts() {
    const options = __spreadProps(__spreadValues({}, this._options.editor.controlsOptions.text), {
      additionalFonts: [],
      replaceFonts: false,
      availableVariations: null
    });
    this._fontManager = new FontManager(this._ui, options);
    const fonts = this._fontManager.getFonts();
    const fontLoader = this._ui.getFontLoader();
    fontLoader.setFonts(fonts);
    fontLoader.load();
  }
  setImage(image = this._options.editor.image, resetEditor = true) {
    if (resetEditor) {
      this.reset();
    }
    let exif = null;
    exif = this._sdk.parseExif(image);
    this._setImage(image, exif);
  }
  _initSDK() {
    const {
      logLevel,
      displayWelcomeMessage,
      debug,
      license,
      crossOrigin
    } = this._options;
    const {
      smoothDownscaling,
      smoothUpscaling,
      preferredRenderer,
      pixelRatio,
      transparent,
      clearColor,
      watermark: watermark2
    } = this._options.editor;
    let clearColorInstance;
    if (Array.isArray(clearColor)) {
      clearColorInstance = Color4.fromArray(clearColor);
    } else if (typeof clearColor === "string") {
      clearColorInstance = Color4.fromHex(clearColor);
    } else if (clearColor instanceof Color4) {
      clearColorInstance = clearColor.clone();
    }
    const rendererOptions = {
      logLevel,
      debug,
      displayWelcomeMessage,
      pixelRatio,
      smoothDownscaling,
      smoothUpscaling,
      transparent,
      crossOrigin,
      clearColor: clearColorInstance,
      license,
      watermark: watermark2
    };
    this._sdk = new SDK2(preferredRenderer, rendererOptions);
  }
  getMaxMegapixels() {
    const { maxMegaPixels } = this._options.editor;
    return maxMegaPixels;
  }
  getCrossOrigin() {
    return SDKUtils4.getCrossOriginValue(this._options.crossOrigin || "anonymous");
  }
  getOutputDimensions(incorporateSpriteScale = false) {
    return this._sdk.getOutputDimensions(incorporateSpriteScale);
  }
  getOutputTextureDimensions(incorporateSpriteScale = false) {
    return this._sdk.getOutputTextureDimensions(incorporateSpriteScale);
  }
  getFinalDimensions(incorporateSpriteScale = false) {
    return this._sdk.getFinalDimensions(incorporateSpriteScale);
  }
  _setImage(image = this._options.editor.image, exif = null) {
    this._sdk.setAllOperationsToDirty();
    this._options.editor.image = image;
    this._sdk.setImage(image, exif);
  }
  _ensureImageIsResized() {
    const inputImage = this._sdk.getImage();
    const renderer = this._sdk.getRenderer();
    const maxMegaPixels = this.getMaxMegapixels();
    const maxPixels = maxMegaPixels ? maxMegaPixels * 1e6 : null;
    const maxDimensions = renderer.getMaxDimensions();
    const imageResizer = new ImageResizer(inputImage, maxPixels, maxDimensions);
    if (!this._resizedImage && imageResizer.needsResize()) {
      return imageResizer.resize().then(({ canvas, dimensions, reason }) => {
        this._resizedImage = canvas;
        this._sdk.setImage(canvas);
        return canvas;
      });
    }
    return Promise.resolve(inputImage);
  }
  export(download = false, options = {}) {
    if (this._watermarkOperation) {
      this._watermarkOperation.setEnabled(false);
    }
    this._sdk.setAllOperationsToDirty();
    return this._ensureImageIsResized().then((image) => {
      const exportOptions = __spreadValues(__spreadValues({}, this._options.editor.export), options);
      const exporter = new Exporter(this._sdk, exportOptions, false);
      return exporter.export().then((output) => {
        this.emit("export", output);
        this._mediator.emit(constants_default4.EVENTS.EXPORT, output, this);
        if (this._watermarkOperation) {
          this._watermarkOperation.setEnabled(true);
          this._sdk.render();
        }
        this._sdk.setAllOperationsToDirty();
        return output;
      });
    });
  }
  broadcastTransform(transformOperation, options) {
    const transformChange = new SDK2.Operations.TransformOperation.TransformChange(transformOperation, options);
    const transformableOperations = [
      "sprite",
      "selective-blur",
      "radial-focus",
      "mirrored-focus",
      "linear-focus",
      "blur"
    ];
    transformableOperations.forEach((identifier) => {
      const operation = this.operations.get(identifier);
      if (!operation) {
        return;
      }
      operation.transform(transformChange);
    });
  }
  broadcastFlip(direction) {
    const flippableOperations = [
      "mirrored-focus",
      "radial-focus",
      "linear-focus",
      "sprite",
      "selective-blur"
    ];
    flippableOperations.forEach((identifier) => {
      const operation = this.operations.get(identifier);
      if (!operation) {
        return;
      }
      operation.flip(direction);
    });
  }
  broadcastRotate(degrees) {
    const flippableOperations = [
      "transform",
      "mirrored-focus",
      "linear-focus",
      "radial-focus",
      "sprite",
      "selective-blur"
    ];
    flippableOperations.forEach((identifier) => {
      const operation = this.operations.get(identifier);
      if (!operation) {
        return;
      }
      operation.rotate(degrees);
    });
  }
  _initSerializers() {
    this._serializers = {
      "1.0.0": (init__(), __toCommonJS(__exports)).default,
      "1.0.1": (init__2(), __toCommonJS(__exports2)).default,
      "2.0.0": (init__3(), __toCommonJS(__exports3)).default,
      "3.0.0": (init__4(), __toCommonJS(__exports4)).default,
      "3.1.0": (init__5(), __toCommonJS(__exports5)).default,
      "3.2.0": (init__6(), __toCommonJS(__exports6)).default,
      "3.4.0": (init__7(), __toCommonJS(__exports7)).default,
      "3.5.0": (init__8(), __toCommonJS(__exports8)).default,
      "3.6.0": (init__9(), __toCommonJS(__exports9)).default,
      "3.7.0": (init__10(), __toCommonJS(__exports10)).default,
      "3.8.0": (init__11(), __toCommonJS(__exports11)).default,
      "3.9.0": (init__12(), __toCommonJS(__exports12)).default,
      "3.12.0": (init__13(), __toCommonJS(__exports13)).default
    };
  }
  serialize(options = {}, version = "3.12.0") {
    const Serializer = this._serializers[version];
    if (!Serializer) {
      return Promise.reject(new Error(`No serializer for version ${version} found.`));
    }
    const serializer = new Serializer(this);
    return serializer.serialize(options);
  }
  deserialize(data) {
    const Serializer = this._serializers[data.version];
    if (!Serializer) {
      return Promise.reject(new Error(`No serializer for version ${data.version} found.`));
    }
    const serializer = new Serializer(this);
    return serializer.deserialize(data);
  }
  reset() {
    this._sdk.reset();
    this.operations.reset();
  }
  dispose() {
    this.stop();
    if (this._resizedImage) {
      cleanUpCanvasMemory(this._resizedImage);
    }
    this._sdk.dispose();
  }
  getRenderer() {
    return this._sdk.getRenderer();
  }
  getSDK() {
    return this._sdk;
  }
  getInputDimensions() {
    return this._sdk.getInputDimensions();
  }
  getImage() {
    return this._options.editor.image;
  }
  getOptions() {
    return this._options;
  }
  getUI() {
    return this._ui;
  }
  getMediator() {
    return this._mediator;
  }
  getDynamicAssetsLibrary() {
    return this._dynamicAssetsLibrary;
  }
};
var editor_default = Editor;

// engine/server/lib/font-loader/index.js
init_globals3();

// engine/server/lib/font-loader/loaders/file-fonts-loader.js
var import_canvas9 = require("canvas");

// engine/server/lib/font-loader/loaders/base-font-loader.js
var BaseFontLoader2 = class {
  constructor(ui) {
    this._ui = ui;
    this._fonts = [];
  }
  add(variation) {
    this._fonts.push(variation);
  }
  load() {
    return Promise.resolve();
  }
  dispose() {
  }
};

// engine/server/lib/font-loader/loaders/file-fonts-loader.js
var FileFontLoader2 = class extends BaseFontLoader2 {
  load() {
    this._fonts.forEach((variation) => {
      const fontPath = this._ui.getAssetPath(variation.getFilePath(), false, true);
      (0, import_canvas9.registerFont)(fontPath, {
        family: variation.getFont().getFontFamily(),
        weight: variation.getFontWeight(),
        style: variation.getFontStyle()
      });
    });
    return super.load();
  }
};

// engine/server/lib/font-loader/index.js
var FontLoader2 = class {
  constructor(ui, fonts) {
    this._ui = ui;
    this._fonts = fonts;
    this._loadedFonts = [];
  }
  setFonts(fonts) {
    this._fonts = fonts;
  }
  needsToLoad() {
    for (let i = 0; i < this._fonts.length; i++) {
      let provider;
      this._fonts[i].getVariations().forEach((variation) => {
        provider = provider || variation.getProvider();
      });
      if (!provider)
        continue;
      return true;
    }
  }
  fontLoaded(font) {
    const identifier = font.getFontFamily();
    return this._loadedFonts.indexOf(identifier) !== -1;
  }
  setFontLoaded(font) {
    if (!this.fontLoaded(font)) {
      const identifier = font.getFontFamily();
      this._loadedFonts.push(identifier);
    }
  }
  load() {
    const fonts = this._fonts;
    const loaders = {
      file: new FileFontLoader2(this._ui)
    };
    const disposeLoaders = () => {
      for (const identifier in loaders) {
        const loader = loaders[identifier];
        loader.dispose();
      }
    };
    fonts.filter((font) => !this.fontLoaded(font)).forEach((font) => {
      font.getVariations().forEach((variation) => {
        const provider = variation.getProvider();
        if (!provider)
          return;
        const loader = loaders[provider];
        if (!loader)
          return log_default.warn(`No font loader for provider \`${provider}\` found.`);
        loader.add(variation);
      });
    });
    const promises = [];
    for (const name in loaders) {
      promises.push(loaders[name].load());
    }
    return Promise.all(promises).then(() => {
      disposeLoaders();
      fonts.forEach((font) => {
        this.setFontLoaded(font);
      });
    }).catch((e) => {
      disposeLoaders();
      throw e;
    });
  }
};

// engine/server/index.js
var bd3 = (str) => SDKUtils2.byteArrayToString(Base643.decode(str));
var Server = class extends EventEmitter3 {
  constructor(options = {}) {
    super();
    this._mediator = new EventEmitter3();
    this._fontLoader = new FontLoader2(this);
    this._options = options;
    this._initOptions();
    this._initEvents();
    this._disposed = false;
    this._editor = new editor_default(this, this._options, this._mediator);
    if (this._options.editor.image) {
      this._editor.setImage(this._options.editor.image);
    }
    log_default.setLevel(this._options.logLevel);
    this._v();
  }
  export(...args) {
    return this._editor.export(...args);
  }
  serialize(...args) {
    return this._editor.serialize(...args);
  }
  deserialize(data) {
    return this._editor.deserialize(data);
  }
  getEditor() {
    return this._editor;
  }
  _initOptions() {
    this._options = SDKUtils2.defaults(this._options, {
      logLevel: "warn",
      crossOrigin: "Anonymous",
      editor: {},
      assets: {},
      responsive: false,
      preloader: true
    });
    this._options.editor = SDKUtils2.defaults(this._options.editor || {}, {
      preferredRenderer: "webgl",
      displayResizeMessage: true,
      controlsOptions: {},
      operationsOrder: [
        "exif-orientation",
        "orientation",
        "transform",
        "filter",
        "adjustments",
        "radial-focus",
        "mirrored-focus",
        "linear-focus",
        "blur",
        "selective-blur",
        "overlay",
        "sprite",
        "frame"
      ],
      maxMegaPixels: null
    });
    this._options.editor.export = SDKUtils2.defaults(this._options.editor.export || {}, {
      format: "image/png",
      type: RenderType3.IMAGE,
      download: true,
      fileBasename: "photoeditorsdk-export",
      quality: 0.8
    });
    this._options.assets = SDKUtils2.defaults(this._options.assets || {}, {
      baseUrl: process.cwd(),
      resolver: null
    });
  }
  _v() {
    if (!this[bd3("X29wdGlvbnM=")][bd3("bGljZW5zZQ==")]) {
      log_default.error(bd3("TGljZW5zaW5n"), bd3("Tm8gYGxpY2Vuc2VgIG9wdGlvbiBnaXZlbg=="));
      log_default.error(bd3("TGljZW5zaW5n"), bd3("SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIGxpY2Vuc2UgeWV0LCBwbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAaW1nLmx5IHRvIG9idGFpbiBhIGxpY2Vuc2Ugb3IgbG9nIGluIHRvIHlvdXIgY3VzdG9tZXIgZGFzaGJvYXJkLg=="));
      return false;
    }
    return true;
  }
  _initEvents() {
    this._mediator.pipeEvents(this);
  }
  _disposeEvents() {
    this._mediator.unpipeEvents(this);
  }
  setImage(image) {
    this._editor.setImage(image);
  }
  getAssetPath(asset, uiAsset = false, disableRetina = false) {
    const { baseUrl, resolver } = this._options.assets;
    let path = `${baseUrl}/${asset}`;
    if (asset.match(/(ftp|http|https):\/\//)) {
      path = asset;
    }
    if (uiAsset) {
      if (!disableRetina) {
        const pixelRatio = Math.max(typeof window !== "undefined" && window.devicePixelRatio || 1, 1);
        if (pixelRatio > 1) {
          const regex = /\.[\w?=]+$/;
          asset = asset.replace(regex, (match) => `@2x${match}`);
        }
      }
      path = `${baseUrl}/ui/desktop/${asset}`;
    }
    if (typeof resolver !== "undefined" && resolver !== null) {
      path = resolver(path);
    }
    return path;
  }
  getFontLoader() {
    return this._fontLoader;
  }
  dispose() {
    if (this._disposed) {
      throw new Error("This instance of PhotoEditorSDK is already disposed.");
    }
    this._disposed = true;
    this._disposeEvents();
  }
  render(config) {
    return this.deserialize(config).then(() => this.export());
  }
};
Server.prototype.identifier = "node";
Server.Constants = constants_default3;
Server.Events = constants_default3.EVENTS;
Server.Utils = utils_default2;
Server.JSONLoader = JSONLoader;
Server.SDK = SDK;
var server_default = Server;
module.exports = __toCommonJS(server_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*
 * Based on https://github.com/exif-js/exif-js by Jacob Seidelin
 * Licensed under MIT
 * @license
 */
/*
 * Extracted from MinifyJpeg (Copyright (c) 2014 Hiroaki Matoba, MIT License):
 * https://github.com/hMatoba/MinifyJpeg
 * @license
 */
/*
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
 * MIT license
 * @license
 */
/*!
 *  Secure Hash Algorithm (SHA256)
 *  http://www.webtoolkit.info/
 *
 *  Original code by Angel Marin, Paul Johnston.
 */
/*!
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */
/*!
StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author:   Mario Klingemann
Contact:  mario@quasimondo.com
Website:  http://www.quasimondo.com/StackBlurForCanvas
Twitter:  @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
@license
*/
