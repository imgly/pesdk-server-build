var __defineProperty = Object.defineProperty;
var __hasOwnProperty = Object.prototype.hasOwnProperty;
var __assign = Object.assign;
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __markAsModule = (target) => {
  return __defineProperty(target, "__esModule", {value: true});
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defineProperty(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2) => {
  __markAsModule(target);
  if (typeof module2 === "object" || typeof module2 === "function") {
    for (let key in module2)
      if (!__hasOwnProperty.call(target, key) && key !== "default")
        __defineProperty(target, key, {get: () => module2[key], enumerable: true});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defineProperty({}, "default", {value: module2, enumerable: true}), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (result) => {
      return result.done ? resolve(result.value) : Promise.resolve(result.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports4, module2) => {
  "use strict";
  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
  module2.exports = function(str) {
    if (typeof str !== "string") {
      throw new TypeError("Expected a string");
    }
    return str.replace(matchOperatorsRe, "\\$&");
  };
});

// node_modules/color-convert/node_modules/color-name/index.js
var require_color_name = __commonJS((exports4, module2) => {
  "use strict";
  module2.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  };
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS((exports4, module2) => {
  var cssKeywords = require_color_name();
  var reverseKeywords = {};
  for (var key in cssKeywords) {
    if (cssKeywords.hasOwnProperty(key)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
  }
  var convert = module2.exports = {
    rgb: {channels: 3, labels: "rgb"},
    hsl: {channels: 3, labels: "hsl"},
    hsv: {channels: 3, labels: "hsv"},
    hwb: {channels: 3, labels: "hwb"},
    cmyk: {channels: 4, labels: "cmyk"},
    xyz: {channels: 3, labels: "xyz"},
    lab: {channels: 3, labels: "lab"},
    lch: {channels: 3, labels: "lch"},
    hex: {channels: 1, labels: ["hex"]},
    keyword: {channels: 1, labels: ["keyword"]},
    ansi16: {channels: 1, labels: ["ansi16"]},
    ansi256: {channels: 1, labels: ["ansi256"]},
    hcg: {channels: 3, labels: ["h", "c", "g"]},
    apple: {channels: 3, labels: ["r16", "g16", "b16"]},
    gray: {channels: 1, labels: ["gray"]}
  };
  for (var model in convert) {
    if (convert.hasOwnProperty(model)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      var channels = convert[model].channels;
      var labels = convert[model].labels;
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", {value: channels});
      Object.defineProperty(convert[model], "labels", {value: labels});
    }
  }
  convert.rgb.hsl = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var min = Math.min(r, g, b);
    var max = Math.max(r, g, b);
    var delta = max - min;
    var h;
    var s;
    var l;
    if (max === min) {
      h = 0;
    } else if (r === max) {
      h = (g - b) / delta;
    } else if (g === max) {
      h = 2 + (b - r) / delta;
    } else if (b === max) {
      h = 4 + (r - g) / delta;
    }
    h = Math.min(h * 60, 360);
    if (h < 0) {
      h += 360;
    }
    l = (min + max) / 2;
    if (max === min) {
      s = 0;
    } else if (l <= 0.5) {
      s = delta / (max + min);
    } else {
      s = delta / (2 - max - min);
    }
    return [h, s * 100, l * 100];
  };
  convert.rgb.hsv = function(rgb) {
    var rdif;
    var gdif;
    var bdif;
    var h;
    var s;
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var v = Math.max(r, g, b);
    var diff = v - Math.min(r, g, b);
    var diffc = function(c) {
      return (v - c) / 6 / diff + 1 / 2;
    };
    if (diff === 0) {
      h = s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v) {
        h = bdif - gdif;
      } else if (g === v) {
        h = 1 / 3 + rdif - bdif;
      } else if (b === v) {
        h = 2 / 3 + gdif - rdif;
      }
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  convert.rgb.hwb = function(rgb) {
    var r = rgb[0];
    var g = rgb[1];
    var b = rgb[2];
    var h = convert.rgb.hsl(rgb)[0];
    var w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [h, w * 100, b * 100];
  };
  convert.rgb.cmyk = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var c;
    var m;
    var y;
    var k;
    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  };
  function comparativeDistance(x, y) {
    return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
  }
  convert.rgb.keyword = function(rgb) {
    var reversed = reverseKeywords[rgb];
    if (reversed) {
      return reversed;
    }
    var currentClosestDistance = Infinity;
    var currentClosestKeyword;
    for (var keyword in cssKeywords) {
      if (cssKeywords.hasOwnProperty(keyword)) {
        var value = cssKeywords[keyword];
        var distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
    }
    return currentClosestKeyword;
  };
  convert.keyword.rgb = function(keyword) {
    return cssKeywords[keyword];
  };
  convert.rgb.xyz = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
    var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [x * 100, y * 100, z * 100];
  };
  convert.rgb.lab = function(rgb) {
    var xyz = convert.rgb.xyz(rgb);
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert.hsl.rgb = function(hsl) {
    var h = hsl[0] / 360;
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var t1;
    var t2;
    var t3;
    var rgb;
    var val;
    if (s === 0) {
      val = l * 255;
      return [val, val, val];
    }
    if (l < 0.5) {
      t2 = l * (1 + s);
    } else {
      t2 = l + s - l * s;
    }
    t1 = 2 * l - t2;
    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0) {
        t3++;
      }
      if (t3 > 1) {
        t3--;
      }
      if (6 * t3 < 1) {
        val = t1 + (t2 - t1) * 6 * t3;
      } else if (2 * t3 < 1) {
        val = t2;
      } else if (3 * t3 < 2) {
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      } else {
        val = t1;
      }
      rgb[i] = val * 255;
    }
    return rgb;
  };
  convert.hsl.hsv = function(hsl) {
    var h = hsl[0];
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var smin = s;
    var lmin = Math.max(l, 0.01);
    var sv;
    var v;
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    v = (l + s) / 2;
    sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [h, sv * 100, v * 100];
  };
  convert.hsv.rgb = function(hsv) {
    var h = hsv[0] / 60;
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var hi = Math.floor(h) % 6;
    var f = h - Math.floor(h);
    var p = 255 * v * (1 - s);
    var q = 255 * v * (1 - s * f);
    var t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  };
  convert.hsv.hsl = function(hsv) {
    var h = hsv[0];
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var vmin = Math.max(v, 0.01);
    var lmin;
    var sl;
    var l;
    l = (2 - s) * v;
    lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  };
  convert.hwb.rgb = function(hwb) {
    var h = hwb[0] / 360;
    var wh = hwb[1] / 100;
    var bl = hwb[2] / 100;
    var ratio = wh + bl;
    var i;
    var v;
    var f;
    var n;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);
    var r;
    var g;
    var b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [r * 255, g * 255, b * 255];
  };
  convert.cmyk.rgb = function(cmyk) {
    var c = cmyk[0] / 100;
    var m = cmyk[1] / 100;
    var y = cmyk[2] / 100;
    var k = cmyk[3] / 100;
    var r;
    var g;
    var b;
    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.rgb = function(xyz) {
    var x = xyz[0] / 100;
    var y = xyz[1] / 100;
    var z = xyz[2] / 100;
    var r;
    var g;
    var b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [r * 255, g * 255, b * 255];
  };
  convert.xyz.lab = function(xyz) {
    var x = xyz[0];
    var y = xyz[1];
    var z = xyz[2];
    var l;
    var a;
    var b;
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
    l = 116 * y - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);
    return [l, a, b];
  };
  convert.lab.xyz = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var x;
    var y;
    var z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    var y2 = Math.pow(y, 3);
    var x2 = Math.pow(x, 3);
    var z2 = Math.pow(z, 3);
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [x, y, z];
  };
  convert.lab.lch = function(lab) {
    var l = lab[0];
    var a = lab[1];
    var b = lab[2];
    var hr;
    var h;
    var c;
    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  };
  convert.lch.lab = function(lch) {
    var l = lch[0];
    var c = lch[1];
    var h = lch[2];
    var a;
    var b;
    var hr;
    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  };
  convert.rgb.ansi16 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
    value = Math.round(value / 50);
    if (value === 0) {
      return 30;
    }
    var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2) {
      ansi += 60;
    }
    return ansi;
  };
  convert.hsv.ansi16 = function(args) {
    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
  };
  convert.rgb.ansi256 = function(args) {
    var r = args[0];
    var g = args[1];
    var b = args[2];
    if (r === g && g === b) {
      if (r < 8) {
        return 16;
      }
      if (r > 248) {
        return 231;
      }
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  convert.ansi16.rgb = function(args) {
    var color6 = args % 10;
    if (color6 === 0 || color6 === 7) {
      if (args > 50) {
        color6 += 3.5;
      }
      color6 = color6 / 10.5 * 255;
      return [color6, color6, color6];
    }
    var mult = (~~(args > 50) + 1) * 0.5;
    var r = (color6 & 1) * mult * 255;
    var g = (color6 >> 1 & 1) * mult * 255;
    var b = (color6 >> 2 & 1) * mult * 255;
    return [r, g, b];
  };
  convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      var c = (args - 232) * 10 + 8;
      return [c, c, c];
    }
    args -= 16;
    var rem;
    var r = Math.floor(args / 36) / 5 * 255;
    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    var b = rem % 6 / 5 * 255;
    return [r, g, b];
  };
  convert.rgb.hex = function(args) {
    var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.hex.rgb = function(args) {
    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match) {
      return [0, 0, 0];
    }
    var colorString = match[0];
    if (match[0].length === 3) {
      colorString = colorString.split("").map(function(char) {
        return char + char;
      }).join("");
    }
    var integer = parseInt(colorString, 16);
    var r = integer >> 16 & 255;
    var g = integer >> 8 & 255;
    var b = integer & 255;
    return [r, g, b];
  };
  convert.rgb.hcg = function(rgb) {
    var r = rgb[0] / 255;
    var g = rgb[1] / 255;
    var b = rgb[2] / 255;
    var max = Math.max(Math.max(r, g), b);
    var min = Math.min(Math.min(r, g), b);
    var chroma = max - min;
    var grayscale3;
    var hue;
    if (chroma < 1) {
      grayscale3 = min / (1 - chroma);
    } else {
      grayscale3 = 0;
    }
    if (chroma <= 0) {
      hue = 0;
    } else if (max === r) {
      hue = (g - b) / chroma % 6;
    } else if (max === g) {
      hue = 2 + (b - r) / chroma;
    } else {
      hue = 4 + (r - g) / chroma + 4;
    }
    hue /= 6;
    hue %= 1;
    return [hue * 360, chroma * 100, grayscale3 * 100];
  };
  convert.hsl.hcg = function(hsl) {
    var s = hsl[1] / 100;
    var l = hsl[2] / 100;
    var c = 1;
    var f = 0;
    if (l < 0.5) {
      c = 2 * s * l;
    } else {
      c = 2 * s * (1 - l);
    }
    if (c < 1) {
      f = (l - 0.5 * c) / (1 - c);
    }
    return [hsl[0], c * 100, f * 100];
  };
  convert.hsv.hcg = function(hsv) {
    var s = hsv[1] / 100;
    var v = hsv[2] / 100;
    var c = s * v;
    var f = 0;
    if (c < 1) {
      f = (v - c) / (1 - c);
    }
    return [hsv[0], c * 100, f * 100];
  };
  convert.hcg.rgb = function(hcg) {
    var h = hcg[0] / 360;
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    if (c === 0) {
      return [g * 255, g * 255, g * 255];
    }
    var pure = [0, 0, 0];
    var hi = h % 1 * 6;
    var v = hi % 1;
    var w = 1 - v;
    var mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  convert.hcg.hsv = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    var f = 0;
    if (v > 0) {
      f = c / v;
    }
    return [hcg[0], f * 100, v * 100];
  };
  convert.hcg.hsl = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var l = g * (1 - c) + 0.5 * c;
    var s = 0;
    if (l > 0 && l < 0.5) {
      s = c / (2 * l);
    } else if (l >= 0.5 && l < 1) {
      s = c / (2 * (1 - l));
    }
    return [hcg[0], s * 100, l * 100];
  };
  convert.hcg.hwb = function(hcg) {
    var c = hcg[1] / 100;
    var g = hcg[2] / 100;
    var v = c + g * (1 - c);
    return [hcg[0], (v - c) * 100, (1 - v) * 100];
  };
  convert.hwb.hcg = function(hwb) {
    var w = hwb[1] / 100;
    var b = hwb[2] / 100;
    var v = 1 - b;
    var c = v - w;
    var g = 0;
    if (c < 1) {
      g = (v - c) / (1 - c);
    }
    return [hwb[0], c * 100, g * 100];
  };
  convert.apple.rgb = function(apple) {
    return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
  };
  convert.rgb.apple = function(rgb) {
    return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
  };
  convert.gray.rgb = function(args) {
    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
  };
  convert.gray.hsl = convert.gray.hsv = function(args) {
    return [0, 0, args[0]];
  };
  convert.gray.hwb = function(gray) {
    return [0, 100, gray[0]];
  };
  convert.gray.cmyk = function(gray) {
    return [0, 0, 0, gray[0]];
  };
  convert.gray.lab = function(gray) {
    return [gray[0], 0, 0];
  };
  convert.gray.hex = function(gray) {
    var val = Math.round(gray[0] / 100 * 255) & 255;
    var integer = (val << 16) + (val << 8) + val;
    var string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  convert.rgb.gray = function(rgb) {
    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [val / 255 * 100];
  };
});

// node_modules/color-convert/route.js
var require_route = __commonJS((exports4, module2) => {
  var conversions = require_conversions();
  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);
    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }
    return graph;
  }
  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;
    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);
      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function wrapConversion(toModel, graph) {
    var path2 = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path2.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path2;
    return fn;
  }
  module2.exports = function(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);
    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];
      if (node.parent === null) {
        continue;
      }
      conversion[toModel] = wrapConversion(toModel, graph);
    }
    return conversion;
  };
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS((exports4, module2) => {
  var conversions = require_conversions();
  var route = require_route();
  var convert = {};
  var models = Object.keys(conversions);
  function wrapRaw(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      return fn(args);
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  function wrapRounded(fn) {
    var wrappedFn = function(args) {
      if (args === void 0 || args === null) {
        return args;
      }
      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }
      var result = fn(args);
      if (typeof result === "object") {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }
      return result;
    };
    if ("conversion" in fn) {
      wrappedFn.conversion = fn.conversion;
    }
    return wrappedFn;
  }
  models.forEach(function(fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], "channels", {value: conversions[fromModel].channels});
    Object.defineProperty(convert[fromModel], "labels", {value: conversions[fromModel].labels});
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function(toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  module2.exports = convert;
});

// node_modules/chalk/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS((exports4, module2) => {
  "use strict";
  const colorConvert = require_color_convert();
  const wrapAnsi16 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${code + offset}m`;
  };
  const wrapAnsi256 = (fn, offset) => function() {
    const code = fn.apply(colorConvert, arguments);
    return `[${38 + offset};5;${code}m`;
  };
  const wrapAnsi16m = (fn, offset) => function() {
    const rgb = fn.apply(colorConvert, arguments);
    return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  function assembleStyles() {
    const codes = new Map();
    const styles = {
      modifier: {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    styles.color.grey = styles.color.gray;
    for (const groupName of Object.keys(styles)) {
      const group = styles[groupName];
      for (const styleName of Object.keys(group)) {
        const style = group[styleName];
        styles[styleName] = {
          open: `[${style[0]}m`,
          close: `[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
    }
    const ansi2ansi = (n) => n;
    const rgb2rgb = (r, g, b) => [r, g, b];
    styles.color.close = "[39m";
    styles.bgColor.close = "[49m";
    styles.color.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 0)
    };
    styles.color.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 0)
    };
    styles.color.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 0)
    };
    styles.bgColor.ansi = {
      ansi: wrapAnsi16(ansi2ansi, 10)
    };
    styles.bgColor.ansi256 = {
      ansi256: wrapAnsi256(ansi2ansi, 10)
    };
    styles.bgColor.ansi16m = {
      rgb: wrapAnsi16m(rgb2rgb, 10)
    };
    for (let key of Object.keys(colorConvert)) {
      if (typeof colorConvert[key] !== "object") {
        continue;
      }
      const suite = colorConvert[key];
      if (key === "ansi16") {
        key = "ansi";
      }
      if ("ansi16" in suite) {
        styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
        styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
      }
      if ("ansi256" in suite) {
        styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
        styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
      }
      if ("rgb" in suite) {
        styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
        styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
      }
    }
    return styles;
  }
  Object.defineProperty(module2, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports4, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/chalk/node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports4, module2) => {
  "use strict";
  const os = require("os");
  const hasFlag = require_has_flag();
  const env2 = process.env;
  let forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env2) {
    forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    if (env2.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/chalk/templates.js
var require_templates = __commonJS((exports4, module2) => {
  "use strict";
  const TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  const ESCAPES = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", "\x07"]
  ]);
  function unescape(c) {
    if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }
    return ESCAPES.get(c) || c;
  }
  function parseArguments(name, args) {
    const results = [];
    const chunks = args.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
      } else {
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
    }
    return results;
  }
  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }
    return results;
  }
  function buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles) {
      for (const style of layer.styles) {
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }
    let current = chalk;
    for (const styleName of Object.keys(enabled)) {
      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }
    return current;
  }
  module2.exports = (chalk, tmp) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        const str = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({inverse, styles: parseStyle(style)});
      } else if (close) {
        if (styles.length === 0) {
          throw new Error("Found extraneous } in Chalk template literal");
        }
        chunks.push(buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMsg);
    }
    return chunks.join("");
  };
});

// node_modules/chalk/index.js
var require_chalk = __commonJS((exports4, module2) => {
  "use strict";
  const escapeStringRegexp = require_escape_string_regexp();
  const ansiStyles = require_ansi_styles();
  const stdoutColor = require_supports_color().stdout;
  const template = require_templates();
  const isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");
  const levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];
  const skipModels = new Set(["gray"]);
  const styles = Object.create(null);
  function applyOptions(obj, options) {
    options = options || {};
    const scLevel = stdoutColor ? stdoutColor.level : 0;
    obj.level = options.level === void 0 ? scLevel : options.level;
    obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;
  }
  function Chalk(options) {
    if (!this || !(this instanceof Chalk) || this.template) {
      const chalk = {};
      applyOptions(chalk, options);
      chalk.template = function() {
        const args = [].slice.call(arguments);
        return chalkTag.apply(null, [chalk.template].concat(args));
      };
      Object.setPrototypeOf(chalk, Chalk.prototype);
      Object.setPrototypeOf(chalk.template, chalk);
      chalk.template.constructor = Chalk;
      return chalk.template;
    }
    applyOptions(this, options);
  }
  if (isSimpleWindowsTerm) {
    ansiStyles.blue.open = "[94m";
  }
  for (const key of Object.keys(ansiStyles)) {
    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
    styles[key] = {
      get() {
        const codes = ansiStyles[key];
        return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
      }
    };
  }
  styles.visible = {
    get() {
      return build.call(this, this._styles || [], true, "visible");
    }
  };
  ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), "g");
  for (const model of Object.keys(ansiStyles.color.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    styles[model] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.color.close,
            closeRe: ansiStyles.color.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), "g");
  for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
    if (skipModels.has(model)) {
      continue;
    }
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles[bgModel] = {
      get() {
        const level = this.level;
        return function() {
          const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
          const codes = {
            open,
            close: ansiStyles.bgColor.close,
            closeRe: ansiStyles.bgColor.closeRe
          };
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
        };
      }
    };
  }
  const proto = Object.defineProperties(() => {
  }, styles);
  function build(_styles, _empty, key) {
    const builder = function() {
      return applyStyle.apply(builder, arguments);
    };
    builder._styles = _styles;
    builder._empty = _empty;
    const self = this;
    Object.defineProperty(builder, "level", {
      enumerable: true,
      get() {
        return self.level;
      },
      set(level) {
        self.level = level;
      }
    });
    Object.defineProperty(builder, "enabled", {
      enumerable: true,
      get() {
        return self.enabled;
      },
      set(enabled) {
        self.enabled = enabled;
      }
    });
    builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";
    builder.__proto__ = proto;
    return builder;
  }
  function applyStyle() {
    const args = arguments;
    const argsLen = args.length;
    let str = String(arguments[0]);
    if (argsLen === 0) {
      return "";
    }
    if (argsLen > 1) {
      for (let a = 1; a < argsLen; a++) {
        str += " " + args[a];
      }
    }
    if (!this.enabled || this.level <= 0 || !str) {
      return this._empty ? "" : str;
    }
    const originalDim = ansiStyles.dim.open;
    if (isSimpleWindowsTerm && this.hasGrey) {
      ansiStyles.dim.open = "";
    }
    for (const code of this._styles.slice().reverse()) {
      str = code.open + str.replace(code.closeRe, code.open) + code.close;
      str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`);
    }
    ansiStyles.dim.open = originalDim;
    return str;
  }
  function chalkTag(chalk, strings) {
    if (!Array.isArray(strings)) {
      return [].slice.call(arguments, 1).join(" ");
    }
    const args = [].slice.call(arguments, 2);
    const parts = [strings.raw[0]];
    for (let i = 1; i < strings.length; i++) {
      parts.push(String(args[i - 1]).replace(/[{}\\]/g, "\\$&"));
      parts.push(String(strings.raw[i]));
    }
    return template(chalk, parts.join(""));
  }
  Object.defineProperties(Chalk.prototype, styles);
  module2.exports = Chalk();
  module2.exports.supportsColor = stdoutColor;
  module2.exports.default = module2.exports;
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS((exports4, module2) => {
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      module2.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      module2.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module2.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module2.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  }).call(exports4);
});

// engine/shared/serialization/1.0.0/index.js
var require__ = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v100Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v100Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "1.0.0";
});

// engine/shared/serialization/1.0.1/index.js
var require__2 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v101Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v101Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "1.0.1";
});

// engine/shared/serialization/2.0.0/index.js
var require__3 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v200Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v200Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "2.0.0";
});

// engine/shared/serialization/3.0.0/index.js
var require__4 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v300Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v300Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.0.0";
});

// engine/shared/serialization/3.1.0/index.js
var require__5 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v310Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v310Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.1.0";
});

// engine/shared/serialization/3.2.0/index.js
var require__6 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v320Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v320Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.2.0";
});

// engine/shared/serialization/3.4.0/index.js
var require__7 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v340Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v340Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.4.0";
});

// engine/shared/serialization/3.5.0/index.js
var require__8 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v350Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v350Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.5.0";
});

// engine/shared/serialization/3.6.0/index.js
var require__9 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v360Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v360Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.6.0";
});

// engine/shared/serialization/3.7.0/index.js
var require__10 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v370Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v370Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.7.0";
});

// engine/shared/serialization/3.8.0/index.js
var require__11 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v380Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v380Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.8.0";
});

// engine/shared/serialization/3.9.0/index.js
var require__12 = __commonJS((exports4) => {
  __export(exports4, {
    default: () => Serialization
  });
  class Serialization {
    constructor(editor2) {
      this._editor = editor2;
    }
    serialize(...args) {
      const serializer13 = new v390Serializer(this._editor);
      return serializer13.serialize(...args);
    }
    deserialize(data) {
      const deserializer13 = new v390Deserializer(this._editor, data);
      return deserializer13.deserialize();
    }
  }
  Serialization.version = "3.9.0";
});

// engine/shared/loaders/image-loader.js
const readFileAsync = (filePath) => {
  if (!process.env.REACT_APP_BROWSER) {
    const fs = require("fs");
    return new Promise((resolve, reject) => {
      try {
        fs.readFile(filePath, (err, buffer) => {
          if (err) {
            reject(err);
          } else {
            resolve([filePath, buffer]);
          }
        });
      } catch (err) {
        reject(err);
      }
    });
  }
};
const loadRemoteFile = (url2) => {
  if (!process.env.REACT_APP_BROWSER) {
    const request = require("request");
    return new Promise((resolve, reject) => {
      request.get(url2, {encoding: null}, (err, response, body) => {
        if (err)
          return reject(err);
        if (response.statusCode !== 200) {
          return reject(new Error(`Server responded with status code ${response.statusCode}`));
        }
        resolve([url2, response.body]);
      });
    });
  }
};
var image_loader_default = {
  load(url2, crossOrigin = {cors: true, value: "anonymous"}) {
    const loadPromise = () => {
      if (process.env.REACT_APP_BROWSER) {
        return Promise.resolve([url2, url2]);
      }
      if (!process.env.REACT_APP_BROWSER) {
        if (url2.substr(0, 5) === "data:") {
          return Promise.resolve([url2, url2]);
        }
        if (!url2.match(/^(https?|ftp|file):\/\//)) {
          return readFileAsync(url2);
        }
        return loadRemoteFile(url2);
      }
    };
    return loadPromise().then(([originalSrc, src]) => {
      return this._createAndLoadImage(originalSrc, src, crossOrigin);
    });
  },
  loadImage(src, crossOrigin = {cors: true, value: "anonymous"}) {
    if (process.env.REACT_APP_BROWSER) {
      return this._loadWithoutExif(src, crossOrigin);
    }
    return this.load(src, crossOrigin);
  },
  _loadWithoutExif(src, crossOrigin = {cors: true, value: "anonymous"}) {
    return new Promise((resolve, reject) => {
      const image5 = new window.Image();
      image5.addEventListener("load", () => {
        resolve(image5);
      });
      image5.addEventListener("error", () => {
        reject(new Error(`Failed to load image at ${src}`));
      });
      if (crossOrigin.cors) {
        image5.crossOrigin = crossOrigin.value;
      }
      image5.src = src;
    });
  },
  _createAndLoadImage(originalSrc, src, crossOrigin = {cors: true, value: "anonymous"}) {
    return new Promise((resolve, reject) => {
      if (process.env.REACT_APP_BROWSER) {
        const loadWithoutExif = this._loadWithoutExif(src, crossOrigin).then((img) => resolve(img));
        const loadWithExif = new Promise((resolve2, reject2) => {
          this._loadAsDataURL(src, crossOrigin).then((dataURL) => {
            const image5 = new window.Image();
            image5.addEventListener("load", () => {
              resolve2(image5);
            });
            image5.src = dataURL;
            image5.rawSource = dataURL;
          }).catch((_) => {
            loadWithoutExif.then((img) => resolve2(img));
          });
        });
        if (this._stringEndsWith(src, ".svg")) {
          return loadWithoutExif.then((img) => resolve(img));
        }
        return loadWithExif.then((img) => resolve(img));
      }
      if (!process.env.REACT_APP_BROWSER) {
        const Canvas = require("canvas");
        const image5 = new Canvas.Image();
        image5.src = src;
        image5.rawSource = src;
        image5.filePath = originalSrc;
        resolve(image5);
      }
    });
  },
  _stringEndsWith(srcString, search, length = srcString.length) {
    if (length === void 0 || length > srcString.length) {
      length = srcString.length;
    }
    return srcString.substring(length - search.length, length) === search;
  },
  _loadAsDataURL(url2, crossOrigin = {cors: true, value: "anonymous"}) {
    if (process.env.REACT_APP_BROWSER) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.onload = function() {
          const reader = new FileReader();
          reader.onloadend = function() {
            if (reader.error) {
              reject(reader.error);
            }
            resolve(reader.result);
          };
          reader.readAsDataURL(xhr.response);
        };
        xhr.open("GET", url2);
        xhr.responseType = "blob";
        xhr.withCredentials = crossOrigin.cors && crossOrigin.value === "use-credentials";
        xhr.send();
      });
    }
    return Promise.reject(new Error(`Loading images as data urls is only supported in browser environments.`));
  },
  loadXHR(url2, mime) {
    return new Promise((resolve, reject) => {
      let xhr;
      if (window.XDomainRequest) {
        xhr = new window.XDomainRequest();
        if (mime)
          xhr.overrideMimeType(mime);
        xhr.onload = function() {
          resolve(xhr);
        };
        xhr.onerror = function(e) {
          reject(e);
        };
      } else if (window.XMLHttpRequest) {
        xhr = new window.XMLHttpRequest();
        if (mime)
          xhr.overrideMimeType(mime);
        xhr.onreadystatechange = function(oEvent) {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              resolve(xhr);
            } else {
              reject(new Error(`HTTP Status ${xhr.status}`));
            }
          }
        };
      }
      xhr.open("GET", url2, true);
      xhr.send();
    });
  }
};

// engine/shared/vendor/promise.js
/*!
 * Native Promise Only
 * v0.8.0-a (c) Kyle Simpson
 * MIT License: http://getify.mit-license.org
 */
const promiseFactory = function DEF() {
  "use strict";
  var builtInProp, cycle, scheduling_queue, ToString = Object.prototype.toString, timer = typeof setImmediate != "undefined" ? function timer2(fn) {
    return setImmediate(fn);
  } : setTimeout;
  try {
    Object.defineProperty({}, "x", {});
    builtInProp = function builtInProp2(obj, name, val, config) {
      return Object.defineProperty(obj, name, {
        value: val,
        writable: true,
        configurable: config !== false
      });
    };
  } catch (err) {
    builtInProp = function builtInProp2(obj, name, val) {
      obj[name] = val;
      return obj;
    };
  }
  scheduling_queue = function Queue() {
    var first, last, item;
    function Item(fn, self) {
      this.fn = fn;
      this.self = self;
      this.next = void 0;
    }
    return {
      add: function add(fn, self) {
        item = new Item(fn, self);
        if (last) {
          last.next = item;
        } else {
          first = item;
        }
        last = item;
        item = void 0;
      },
      drain: function drain() {
        var f = first;
        first = last = cycle = void 0;
        while (f) {
          f.fn.call(f.self);
          f = f.next;
        }
      }
    };
  }();
  function schedule(fn, self) {
    scheduling_queue.add(fn, self);
    if (!cycle) {
      cycle = timer(scheduling_queue.drain);
    }
  }
  function isThenable(o) {
    var _then, o_type = typeof o;
    if (o != null && (o_type == "object" || o_type == "function")) {
      _then = o.then;
    }
    return typeof _then == "function" ? _then : false;
  }
  function notify() {
    for (var i = 0; i < this.chain.length; i++) {
      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
    }
    this.chain.length = 0;
  }
  function notifyIsolated(self, cb, chain) {
    var ret, _then;
    try {
      if (cb === false) {
        chain.reject(self.msg);
      } else {
        if (cb === true) {
          ret = self.msg;
        } else {
          ret = cb.call(void 0, self.msg);
        }
        if (ret === chain.promise) {
          chain.reject(TypeError("Promise-chain cycle"));
        } else if (_then = isThenable(ret)) {
          _then.call(ret, chain.resolve, chain.reject);
        } else {
          chain.resolve(ret);
        }
      }
    } catch (err) {
      chain.reject(err);
    }
  }
  function resolve(msg) {
    var _then, self = this;
    if (self.triggered) {
      return;
    }
    self.triggered = true;
    if (self.def) {
      self = self.def;
    }
    try {
      if (_then = isThenable(msg)) {
        schedule(function() {
          var def_wrapper = new MakeDefWrapper(self);
          try {
            _then.call(msg, function $resolve$() {
              resolve.apply(def_wrapper, arguments);
            }, function $reject$() {
              reject.apply(def_wrapper, arguments);
            });
          } catch (err) {
            reject.call(def_wrapper, err);
          }
        });
      } else {
        self.msg = msg;
        self.state = 1;
        if (self.chain.length > 0) {
          schedule(notify, self);
        }
      }
    } catch (err) {
      reject.call(new MakeDefWrapper(self), err);
    }
  }
  function reject(msg) {
    var self = this;
    if (self.triggered) {
      return;
    }
    self.triggered = true;
    if (self.def) {
      self = self.def;
    }
    self.msg = msg;
    self.state = 2;
    if (self.chain.length > 0) {
      schedule(notify, self);
    }
  }
  function iteratePromises(Constructor, arr, resolver, rejecter) {
    for (var idx = 0; idx < arr.length; idx++) {
      (function IIFE(idx2) {
        Constructor.resolve(arr[idx2]).then(function $resolver$(msg) {
          resolver(idx2, msg);
        }, rejecter);
      })(idx);
    }
  }
  function MakeDefWrapper(self) {
    this.def = self;
    this.triggered = false;
  }
  function MakeDef(self) {
    this.promise = self;
    this.state = 0;
    this.triggered = false;
    this.chain = [];
    this.msg = void 0;
  }
  function Promise4(executor) {
    if (typeof executor != "function") {
      throw TypeError("Not a function");
    }
    if (this.__NPO__ !== 0) {
      throw TypeError("Not a promise");
    }
    this.__NPO__ = 1;
    var def = new MakeDef(this);
    this["then"] = function then(success, failure) {
      var o = {
        success: typeof success == "function" ? success : true,
        failure: typeof failure == "function" ? failure : false
      };
      o.promise = new this.constructor(function extractChain(resolve2, reject2) {
        if (typeof resolve2 != "function" || typeof reject2 != "function") {
          throw TypeError("Not a function");
        }
        o.resolve = resolve2;
        o.reject = reject2;
      });
      def.chain.push(o);
      if (def.state !== 0) {
        schedule(notify, def);
      }
      return o.promise;
    };
    this["catch"] = function $catch$(failure) {
      return this.then(void 0, failure);
    };
    try {
      executor.call(void 0, function publicResolve(msg) {
        resolve.call(def, msg);
      }, function publicReject(msg) {
        reject.call(def, msg);
      });
    } catch (err) {
      reject.call(def, err);
    }
  }
  var PromisePrototype = builtInProp({}, "constructor", Promise4, false);
  Promise4.prototype = PromisePrototype;
  builtInProp(PromisePrototype, "__NPO__", 0, false);
  builtInProp(Promise4, "resolve", function Promise$resolve(msg) {
    var Constructor = this;
    if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
      return msg;
    }
    return new Constructor(function executor(resolve2, reject2) {
      if (typeof resolve2 != "function" || typeof reject2 != "function") {
        throw TypeError("Not a function");
      }
      resolve2(msg);
    });
  });
  builtInProp(Promise4, "reject", function Promise$reject(msg) {
    return new this(function executor(resolve2, reject2) {
      if (typeof resolve2 != "function" || typeof reject2 != "function") {
        throw TypeError("Not a function");
      }
      reject2(msg);
    });
  });
  builtInProp(Promise4, "all", function Promise$all(arr) {
    var Constructor = this;
    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }
    if (arr.length === 0) {
      return Constructor.resolve([]);
    }
    return new Constructor(function executor(resolve2, reject2) {
      if (typeof resolve2 != "function" || typeof reject2 != "function") {
        throw TypeError("Not a function");
      }
      var len = arr.length, msgs = Array(len), count = 0;
      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        msgs[idx] = msg;
        if (++count === len) {
          resolve2(msgs);
        }
      }, reject2);
    });
  });
  builtInProp(Promise4, "race", function Promise$race(arr) {
    var Constructor = this;
    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }
    return new Constructor(function executor(resolve2, reject2) {
      if (typeof resolve2 != "function" || typeof reject2 != "function") {
        throw TypeError("Not a function");
      }
      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        resolve2(msg);
      }, reject2);
    });
  });
  return Promise4;
};
var root = typeof global === "undefined" ? window : global;
const _Promise = typeof Promise !== "undefined" ? Promise : promiseFactory();
root.Promise = root.Promise || _Promise;
var promise_default = _Promise;

// engine/shared/loaders/json-loader.js
const url = __toModule(require("url"));
const TIMEOUT = 5e3;
const root2 = typeof window !== "undefined" ? window : global;
class JSONLoader {
  constructor(url2) {
    this._url = url2;
    this._parsedUrl = url.default.parse(this._url, true);
  }
  _isJSONPRequest() {
    const {query} = this._parsedUrl;
    for (const key in query) {
      const value = query[key];
      if (value === "?") {
        return true;
      }
    }
    return false;
  }
  load() {
    if (this._isJSONPRequest()) {
      return this._loadJSONP();
    }
    return this._loadJSON();
  }
  _loadJSON() {
    return new promise_default((resolve, reject) => {
      let xhr;
      if (root2.XDomainRequest) {
        xhr = new root2.XDomainRequest();
        xhr.onload = function() {
          const json = JSON.parse(xhr.responseText);
          resolve(json);
        };
        xhr.onerror = function(e) {
          reject(e);
        };
        xhr.open("GET", this._url, true);
        xhr.send();
      } else if (root2.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function(oEvent) {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              const json = JSON.parse(xhr.responseText);
              resolve(json);
            } else {
              reject(new Error(`HTTP Status ${xhr.status}`));
            }
          }
        };
        xhr.open("GET", this._url, true);
        xhr.send();
      }
    });
  }
  _loadJSONP() {
    let failed = false;
    let succeeded = false;
    const fnName = `pesdk${Math.round(Math.random() * 99999999999999)}`;
    return new promise_default((resolve, reject) => {
      const node = this._createJSONPNode(fnName);
      root2[fnName] = (result) => {
        this._removeJSONPNode(node);
        if (!failed) {
          succeeded = true;
          resolve(result);
        }
      };
      root2.setTimeout(() => {
        if (!succeeded) {
          this._removeJSONPNode(node);
          failed = true;
          reject(new Error("Timeout of 5 seconds exceeded."));
        }
      }, TIMEOUT);
    });
  }
  _createJSONPNode(fnName) {
    const JSONPUrl = this._buildJSONPUrl(fnName);
    const headNode = document.querySelector("head");
    const scriptNode = document.createElement("script");
    scriptNode.src = JSONPUrl;
    headNode.appendChild(scriptNode);
    return scriptNode;
  }
  _removeJSONPNode(node) {
    node.parentNode.removeChild(node);
  }
  _buildJSONPUrl(fnName) {
    const {query} = this._parsedUrl;
    let parameter = null;
    for (const param in query) {
      if (query[param] === "?") {
        parameter = param;
        break;
      }
    }
    delete this._parsedUrl.search;
    query[parameter] = fnName;
    return url.default.format(this._parsedUrl);
  }
}

// engine/shared/loaders/index.js
const loaders_exports = {};
__export(loaders_exports, {
  ImageLoader: () => image_loader_default,
  JSONLoader: () => JSONLoader
});

// engine/sdk/core/lib/array-utils.js
class ArrayUtils {
  static head(arr) {
    return arr[0];
  }
  static tail(arr) {
    return arr.slice(1);
  }
  static last(arr) {
    return arr[arr.length - 1];
  }
  static init(arr) {
    return arr.slice(0, arr.length - 1);
  }
  static remove(arr, func) {
    return arr.filter((v, i, arr2) => !func(v, i, arr2));
  }
  static findIndex(array, func) {
    for (let i = 0; i < array.length; i++) {
      if (func(array[i])) {
        return i;
      }
    }
    return -1;
  }
  static find(array, func) {
    for (let i = 0; i < array.length; i++) {
      if (func(array[i])) {
        return array[i];
      }
    }
    return void 0;
  }
  static flatten(array) {
    return array.reduce(function(flat, toFlatten) {
      return flat.concat(Array.isArray(toFlatten) ? ArrayUtils.flatten(toFlatten) : toFlatten);
    }, []);
  }
  static range(start, end) {
    const arr = [];
    if (end > start) {
      for (let i = start; i < end; i++) {
        arr.push(i);
      }
    }
    return arr;
  }
  static repeat(val, n) {
    const arr = [];
    for (let i = 0; i < n; i++) {
      arr[i] = val;
    }
    return arr;
  }
  static zip(a, b) {
    const len = Math.min(a.length, b.length);
    const arr = [];
    for (let i = 0; i < len; i++) {
      arr[i] = [a[i], b[i]];
    }
    return arr;
  }
}
var array_utils_default = ArrayUtils;

// engine/sdk/core/lib/base64.js
/*
 * Extracted from MinifyJpeg (Copyright (c) 2014 Hiroaki Matoba, MIT License):
 * https://github.com/hMatoba/MinifyJpeg
 * @license
 */
const KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const Base64 = {
  encode(input) {
    let output = "";
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    do {
      chr1 = input[i++];
      chr2 = input[i++];
      chr3 = input[i++];
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
      chr1 = chr2 = chr3 = "";
      enc1 = enc2 = enc3 = enc4 = "";
    } while (i < input.length);
    return output;
  },
  decode(input) {
    let chr1;
    let chr2;
    let chr3;
    let enc1;
    let enc2;
    let enc3;
    let enc4;
    let i = 0;
    const buf = [];
    const base64test = /[^A-Za-z0-9+/=]/g;
    if (base64test.exec(input)) {
      throw new Error("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    do {
      enc1 = KEY_STR.indexOf(input.charAt(i++));
      enc2 = KEY_STR.indexOf(input.charAt(i++));
      enc3 = KEY_STR.indexOf(input.charAt(i++));
      enc4 = KEY_STR.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      buf.push(chr1);
      if (enc3 !== 64) {
        buf.push(chr2);
      }
      if (enc4 !== 64) {
        buf.push(chr3);
      }
      chr1 = chr2 = chr3 = "";
      enc1 = enc2 = enc3 = enc4 = "";
    } while (i < input.length);
    return buf;
  }
};
var base64_default = Base64;

// engine/sdk/core/lib/utils.js
class Utils {
  static isArray(object) {
    return Object.prototype.toString.call(object) === "[object Array]";
  }
  static mapRange(value, fromRange, toRange) {
    return (value - fromRange.getMin()) * toRange.getLength() / fromRange.getLength() + toRange.getMin();
  }
  static isPlainObject(object) {
    if (typeof object !== "object" || !object) {
      return false;
    }
    if (typeof Object.getPrototypeOf === "function") {
      const proto = Object.getPrototypeOf(object);
      return proto === Object.prototype || proto === null;
    }
    return Object.prototype.toString.call(object) === "[object Object]";
  }
  static isMobile() {
    if (typeof navigator === "undefined")
      return false;
    const a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
  }
  static isBrowser() {
    return typeof window !== "undefined";
  }
  static isNode() {
    return typeof window === "undefined" && typeof global !== "undefined";
  }
  static values(object) {
    const values = [];
    for (const key in object) {
      values.push(object[key]);
    }
    return values;
  }
  static generateUUID() {
    let d = new Date().getTime();
    if (process.env.REACT_APP_BROWSER) {
      if (typeof window.performance !== "undefined" && typeof window.performance.now === "function") {
        d += window.performance.now();
      }
    }
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = (d + Math.random() * 16) % 16 | 0;
      d = Math.floor(d / 16);
      return (c === "x" ? r : r & 3 | 8).toString(16);
    });
  }
  static isDOMElement(o) {
    return typeof HTMLElement === "object" ? o instanceof HTMLElement : o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
  }
  static isTouchEvent(e) {
    return e.type.indexOf("touch") !== -1;
  }
  static resizeVectorToFit(vector, max) {
    const scale = Math.min(max.x / vector.x, max.y / vector.y);
    const newSize = vector.clone().multiply(scale);
    return newSize;
  }
  static resizeVectorToFill(vector, container3) {
    const vectorRatio = vector.x / vector.y;
    const containerRatio = container3.x / container3.y;
    if (vectorRatio > containerRatio) {
      return container3.clone().set(container3.y * vectorRatio, container3.y);
    }
    return container3.clone().set(container3.x, container3.x / vectorRatio);
  }
  static isExtendable(val) {
    return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
  }
  static defaults(object, ...sources) {
    const newObject = {};
    for (const key in object) {
      newObject[key] = object[key];
    }
    for (let i = 0; i < sources.length; i++) {
      const source = sources[i];
      for (const key in source) {
        if (typeof newObject[key] === "undefined") {
          newObject[key] = source[key];
        }
      }
    }
    return newObject;
  }
  static deepMerge(dest, ...sources) {
    const _deepMerge = (dest2, source) => {
      if (source === void 0) {
        return _deepMerge(null, dest2);
      }
      if (Array.isArray(source)) {
        return [...source];
      }
      if (!Utils.isPlainObject(source)) {
        return source;
      }
      if (!Utils.isPlainObject(dest2)) {
        return __assign({}, source);
      }
      const result = __assign({}, dest2);
      Object.keys(source).forEach((key) => {
        const value = source[key];
        if (value === void 0) {
          return;
        }
        result[key] = _deepMerge(dest2[key], value);
      });
      return result;
    };
    return sources.reduce(_deepMerge, dest);
  }
  static deepDefaults(object, ...sources) {
    const reversedSources = [...sources].reverse();
    return Utils.deepMerge(...reversedSources, object);
  }
  static deepClone(object) {
    const newObject = {};
    for (const key in object) {
      if (Utils.isExtendable(object[key])) {
        newObject[key] = Utils.deepClone(object[key]);
      } else {
        newObject[key] = object[key];
      }
    }
    return newObject;
  }
  static getDeepProperty(object, path2) {
    if (typeof path2 === "string") {
      return object[path2];
    }
    if (!Array.isArray(path2)) {
      return void 0;
    }
    const callPropName = (object2, propName) => {
      let value;
      try {
        value = propName(object2);
      } catch (e) {
        if (!(e instanceof TypeError)) {
          throw e;
        }
      }
      return value;
    };
    return path2.reduce((object2, propName) => object2 ? typeof propName === "function" ? callPropName(object2, propName) : object2[propName] : null, object);
  }
  static extend(object, ...sources) {
    const newObject = {};
    for (const key in object) {
      newObject[key] = object[key];
    }
    for (let i = 0; i < sources.length; i++) {
      const source = sources[i];
      for (const key in source) {
        newObject[key] = source[key];
      }
    }
    return newObject;
  }
  static clone(object) {
    return this.extend({}, object);
  }
  static createBlobURIFromDataURI(data) {
    const root4 = typeof window === "undefined" ? global : window;
    if (!root4.Blob || !root4.URL || !ArrayBuffer || !Uint8Array) {
      return data;
    }
    const rawData = base64_default.decode(data.split(",")[1]);
    const mimeString = data.split(",")[0].split(":")[1].split(";")[0];
    const arrayBuffer = new ArrayBuffer(rawData.length);
    const intArray = new Uint8Array(arrayBuffer);
    for (let i = 0; i < rawData.length; i++) {
      intArray[i] = rawData[i];
    }
    const blob = new root4.Blob([arrayBuffer], {
      type: mimeString
    });
    return root4.URL.createObjectURL(blob);
  }
  static getUUID() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  static createCanvas() {
    if (!process.env.REACT_APP_BROWSER) {
      const NodeCanvas = require("canvas").Canvas;
      return new NodeCanvas(300, 150);
    }
    if (process.env.REACT_APP_BROWSER) {
      return document.createElement("canvas");
    }
  }
  static convertHtmlImageToRGBACanvas(htmlImage, existingCanvas) {
    const canvas9 = existingCanvas || Utils.createCanvas();
    canvas9.width = htmlImage.width;
    canvas9.height = htmlImage.height;
    const context = canvas9.getContext("2d");
    context.clearRect(0, 0, canvas9.width, canvas9.height);
    context.drawImage(htmlImage, 0, 0, htmlImage.width, htmlImage.height);
    return canvas9;
  }
  static isPowerOfTwo(dimensions) {
    return (dimensions.x & dimensions.x - 1) === 0 && (dimensions.y & dimensions.y - 1) === 0;
  }
  static nextLowestPOT(x) {
    for (let i = 1; i < 32; i <<= 1) {
      x |= x >> i;
    }
    return x - (x >> 1);
  }
  static nextHighestPOT(x) {
    x--;
    for (let i = 1; i < 32; i <<= 1) {
      x |= x >> i;
    }
    return x + 1;
  }
  static moveArrayItem(arr, oldIndex, newIndex) {
    if (newIndex >= arr.length) {
      let k = newIndex - arr.length;
      while (k-- + 1) {
        arr.push(void 0);
      }
    }
    arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
  }
  static ensureCanvasDimensions(canvas9, dimensions) {
    if (canvas9.width !== dimensions.x || canvas9.height !== dimensions.y) {
      canvas9.width = dimensions.x;
      canvas9.height = dimensions.y;
      return true;
    }
    return false;
  }
  static byteArrayToString(byteArray) {
    return byteArray.map((byte) => String.fromCharCode(byte)).join("");
  }
  static clamp(number, min, max) {
    return Math.max(min, Math.min(number, max));
  }
  static wildCardMatch(str, rule) {
    return new RegExp(`^${rule.split("*").join(".*")}$`).test(str);
  }
  static flipObject(obj) {
    const newObj = {};
    for (const key in obj) {
      newObj[obj[key]] = key;
    }
    return newObj;
  }
  static cloneOptions(options) {
    const newOptions = {};
    for (const key in options) {
      let value = options[key];
      if (Array.isArray(value)) {
        value = value.slice();
      } else if (value.clone) {
        value = value.clone();
      }
      newOptions[key] = value;
    }
    return newOptions;
  }
  static ISODateString(date) {
    function pad(n) {
      return n < 10 ? `0${n}` : n;
    }
    return `${date.getUTCFullYear()}-${pad(date.getUTCMonth() + 1)}-${pad(date.getUTCDate())}T${pad(date.getUTCHours())}:${pad(date.getUTCMinutes())}:${pad(date.getUTCSeconds())}Z`;
  }
  static getCrossOriginValue(crossOrigin) {
    if (!crossOrigin) {
      return "anonymous";
    }
    if (crossOrigin === "none") {
      return void 0;
    }
    return crossOrigin;
  }
  static shallowEqual(objA, objB) {
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    const bHasOwnProperty = hasOwnProperty.bind(objB);
    for (let i = 0; i < keysA.length; i++) {
      if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
        return false;
      }
    }
    return true;
  }
  static enableIf(condition, value) {
    return condition ? value : void 0;
  }
  static invariant(condition, message) {
    if (!condition) {
      const error = new Error(message);
      throw error;
    }
  }
  static executePromises(promises) {
    const count = promises.length;
    let counter = 0;
    const values = [];
    const errors = [];
    return new Promise((resolve, reject) => {
      const onFinnish = () => {
        counter++;
        if (counter >= count) {
          if (errors.length <= 0) {
            resolve(values);
          } else {
            reject(errors);
          }
        }
      };
      const onSuccess = (value) => {
        values.push(value);
        onFinnish();
      };
      const onError = (value) => {
        errors.push(value);
        onFinnish();
      };
      promises.forEach((promise8) => {
        promise8.then(onSuccess).catch(onError);
      });
    });
  }
}
Utils.Array = array_utils_default;
var utils_default = Utils;

// engine/shared/log.js
const defaultLevels = [
  {name: "trace", type: "trace", background: "#EEEEEE", color: "#AAAAAA"},
  {name: "info", type: "log", background: "#BDE5F8", color: "#00529B"},
  {name: "warn", type: "warn", background: "#FEEFB3", color: "#9F6000"},
  {name: "error", type: "error", background: "#FFBABA", color: "#D8000C"},
  {name: "log", type: "log", background: "#EEEEEE", color: "#1f4f6b"}
];
const hasConsoleGroups = () => console && console.group && console.groupCollapsed && console.groupEnd;
const hasColorOutput = () => typeof navigator !== "undefined" && navigator.userAgent.match(/Gecko|WebKit/i) && !navigator.userAgent.match(/Trident/);
const getLogStyles = (background, color6) => {
  if (process.env.REACT_APP_BROWSER) {
    return [
      "background: #2D7BFF; line-height: 20px; padding: 4px 0",
      "background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0",
      "background: #2D7BFF; line-height: 20px; padding: 4px 0",
      `background: ${background}; color: ${color6}; line-height: 20px; padding: 4px 0; font-weight: bold`,
      "background: #2B2B2B; color: white; line-height: 20px; padding: 4px 0",
      "background: #2D7BFF; line-height: 20px; padding: 4px 0"
    ];
  }
  if (!process.env.REACT_APP_BROWSER) {
    const chalk = require_chalk();
    return [
      chalk.bgHex("#2D7BFF"),
      chalk.bgHex("#2B2B2B").white,
      chalk.bgHex("#2D7BFF"),
      chalk.bgHex(background).hex(color6).bold,
      chalk.bgHex("#2B2B2B").white,
      chalk.bgHex("#2D7BFF")
    ];
  }
};
class Logger {
  constructor(maxLevel = "warn", levels = defaultLevels) {
    this._levels = [...levels];
    this._maxLevel = this.getLevelIndexByName(maxLevel);
    this._consoleFuncs = {
      trace: (...args) => {
        if (hasConsoleGroups()) {
          console.groupCollapsed(...args);
          console.trace();
          console.groupEnd();
        } else {
          console.trace(...args);
        }
      }
    };
    this._levels.forEach(({name}) => {
      this[name] = (tag, ...args) => {
        this._log(name, tag, ...args);
      };
    });
  }
  getLevelIndexByName(levelName) {
    return utils_default.Array.findIndex(this._levels, (l) => l.name === levelName);
  }
  getLevelObjectByName(levelName) {
    return utils_default.Array.find(this._levels, (l) => l.name === levelName);
  }
  canLog(levelName) {
    const level = this.getLevelIndexByName(levelName);
    if (level < 0) {
      return false;
    }
    return level >= this._maxLevel;
  }
  setLevel(levelName) {
    const level = this.getLevelIndexByName(levelName);
    if (level < 0) {
      return;
    }
    this._maxLevel = level;
  }
  _log(levelName, tag, ...args) {
    const level = this.getLevelObjectByName(levelName);
    if (!level || !this.canLog(levelName)) {
      return;
    }
    const {name, type, background, color: color6} = level;
    const outputs = args.filter((arg) => arg !== void 0).map((arg) => {
      if (arg.toObject) {
        return JSON.parse(JSON.stringify(arg.toObject()));
      }
      return arg;
    });
    const consoleFunc = this._consoleFuncs[type] || console[type] ? (...args2) => console[type](...args2) : (...args2) => console.log(...args2);
    const outputsLen = outputs.length;
    const styles = getLogStyles(background, color6);
    if (process.env.REACT_APP_BROWSER) {
      if (!hasColorOutput()) {
        const outputsLen2 = outputs.length;
        if (outputsLen2 <= 0) {
          consoleFunc(`PhotoEditorSDK | ${tag} `);
          return;
        }
        if (outputsLen2 === 1 && typeof outputs[0] === "string") {
          consoleFunc(`PhotoEditorSDK | ${tag} | ${outputs[0]}`);
          return;
        }
        consoleFunc(`PhotoEditorSDK | ${tag} | `, ...outputs);
        return;
      }
      if (outputsLen <= 0) {
        consoleFunc(`%c  %c PhotoEditorSDK %c  %c ${tag} %c %c  `, ...styles);
        return;
      }
      if (outputsLen === 1 && typeof outputs[0] === "string") {
        consoleFunc(`%c  %c PhotoEditorSDK %c  %c ${tag} %c  ${outputs[0]}  %c  `, ...styles);
        return;
      }
      if (hasConsoleGroups()) {
        console.groupCollapsed(`%c  %c PhotoEditorSDK %c  %c ${tag} %c`, ...utils_default.Array.init(styles));
        consoleFunc(...outputs);
        console.groupEnd();
      } else {
        consoleFunc(`%c  %c PhotoEditorSDK %c  %c ${tag} %c`, ...utils_default.Array.init(styles), ...outputs);
      }
    }
    if (!process.env.REACT_APP_BROWSER) {
      const prefix = `${styles[0](" ")} ${styles[1]("PhotoEditorSDK")} ${styles[2](" ")} ${styles[3](tag)}`;
      const suffix = `${styles[5](" ")} `;
      if (outputsLen <= 0) {
        consoleFunc(`${prefix} ${suffix}`);
        return;
      }
      if (outputsLen === 1 && typeof outputs[0] === "string") {
        consoleFunc(`${prefix} ${styles[4](outputs[0])} ${suffix}`);
        return;
      }
      if (hasConsoleGroups()) {
        console.groupCollapsed(`${prefix} ${suffix}`);
        consoleFunc(...outputs);
        console.groupEnd();
      } else {
        consoleFunc(`${prefix} ${suffix}`, ...outputs);
      }
    }
  }
  image(tag = "", source) {
    if (process.env.REACT_APP_BROWSER) {
      let image5 = new window.Image();
      const onload = () => {
        const {width} = image5;
        const {height} = image5;
        if (tag) {
          console.log(tag);
        }
        console.log(`%c+`, `
        font-size: 1px;
        padding: 0px ${Math.floor(width / 2)}px;
        line-height: ${height}px;
        background: url(${image5.src});
        color: transparent;
        background-repeat: no-repeat;
        background-size: ${width}px ${height}px;`);
      };
      image5.onload = onload;
      if (source instanceof window.HTMLCanvasElement) {
        image5.src = source.toDataURL();
      } else if (source instanceof window.Image) {
        image5 = source;
        onload();
      } else if (typeof source === "string") {
        image5.src = source;
      } else {
        this.log(tag, source);
      }
      return image5;
    }
  }
  texture(tag = "", texture5) {
    if (process.env.REACT_APP_BROWSER) {
      if (!texture5) {
        this.log(tag, "texture: null or undefined");
        return;
      }
      const baseTexture = texture5.getBaseTexture();
      const renderers = baseTexture.getRenderers();
      const glRenderer = utils_default.Array.find(renderers, (r) => r && r.constructor.type === "WebGL");
      const {width, height} = baseTexture.getFrame();
      if (glRenderer) {
        const gl = glRenderer.getContext();
        const glTexture = baseTexture.getGLTextureForRenderer(glRenderer);
        this.logGlTexture(gl, glTexture, width, height, tag);
      } else {
        Log.image(tag, baseTexture.getSource());
      }
    }
  }
  logGlTexture(gl, texture5, width = 150, height = 150, tag) {
    if (process.env.REACT_APP_BROWSER) {
      gl.bindTexture(gl.TEXTURE_2D, texture5);
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture5, 0);
      const data = new Uint8Array(width * height * 4);
      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
      gl.deleteFramebuffer(framebuffer);
      const canvas9 = document.createElement("canvas");
      canvas9.width = width;
      canvas9.height = height;
      const context = canvas9.getContext("2d");
      const imageData = context.createImageData(width, height);
      imageData.data.set(data);
      context.putImageData(imageData, 0, 0);
      return Log.image(tag, canvas9);
    }
  }
}
const Log = new Logger("warn");
var log_default = Log;

// engine/sdk/core/constants.js
const constants_exports = {};
__export(constants_exports, {
  ImageFormat: () => ImageFormat,
  OptionType: () => OptionType,
  RenderType: () => RenderType,
  RendererType: () => RendererType,
  UniformType: () => UniformType
});
const RenderType = {
  IMAGE: "image",
  DATAURL: "data-url",
  BUFFER: "buffer",
  BLOB: "blob",
  MSBLOB: "ms-blob"
};
const ImageFormat = {
  PNG: "image/png",
  JPEG: "image/jpeg",
  RAW: "raw"
};
const OptionType = {
  NUMBER: "number",
  VECTOR2: "vector2",
  COLOR_MATRIX: "color-matrix",
  COLOR: "color",
  ARRAY: "array",
  OBJECT: "object",
  STRING: "string",
  BOOLEAN: "boolean",
  CONFIGURABLE: "configurable",
  IMAGE: "image",
  FUNCTION: "function",
  TEXTURE: "texture",
  ALL: "*"
};
const UniformType = {
  SAMPLER2D: "sampler2d",
  INT: "i",
  INT1: "1i",
  INT2: "2i",
  INT3: "3i",
  INT4: "4i",
  FLOAT: "f",
  FLOAT1: "1f",
  FLOAT2: "2f",
  FLOAT_VECTOR2: "2fv",
  FLOAT3: "3f",
  FLOAT4: "4f",
  MAT3: "mat3",
  MAT3FV: "mat3fv",
  MAT4: "mat4"
};
const RendererType = {
  WEBGL: "webgl",
  CANVAS: "canvas"
};

// engine/sdk/core/lib/color.js
class Color {
  constructor(r, g, b, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  toRGBA() {
    const colors = [
      Math.round(this.r * 255),
      Math.round(this.g * 255),
      Math.round(this.b * 255),
      this.a.toFixed(2)
    ];
    return `rgba(${colors.join(",")})`;
  }
  set(r, g, b, a = this.a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  }
  toRGB() {
    return [
      Math.round(this.r * 255),
      Math.round(this.g * 255),
      Math.round(this.b * 255)
    ];
  }
  toHex() {
    const components = [
      this._componentToHex(Math.round(this.r * 255)),
      this._componentToHex(Math.round(this.g * 255)),
      this._componentToHex(Math.round(this.b * 255))
    ];
    return `#${components.join("")}`;
  }
  toGLColor() {
    return [this.r, this.g, this.b, this.a];
  }
  toArray() {
    return this.toGLColor();
  }
  toRGBGLColor() {
    return [this.r, this.g, this.b];
  }
  toHSV() {
    const max = Math.max(this.r, this.g, this.b);
    const min = Math.min(this.r, this.g, this.b);
    let h;
    let s;
    const v = max;
    const d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case this.r:
          h = (this.g - this.b) / d;
          if (this.g < this.b) {
            h += 6;
          }
          break;
        case this.g:
          h = (this.b - this.r) / d + 2;
          break;
        case this.b:
          h = (this.r - this.g) / d + 4;
          break;
      }
      h /= 6;
    }
    return [h, s, v];
  }
  fromHSV(h, s, v) {
    this.copy(Color.fromHSV(h, s, v));
    return this;
  }
  static fromHSV(h, s, v, a = 1) {
    let [r, g, b] = [];
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;
      case 1:
        r = q;
        g = v;
        b = p;
        break;
      case 2:
        r = p;
        g = v;
        b = t;
        break;
      case 3:
        r = p;
        g = q;
        b = v;
        break;
      case 4:
        r = t;
        g = p;
        b = v;
        break;
      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }
    return new Color(r, g, b, a);
  }
  static fromArray(arr) {
    return new Color(arr[0], arr[1], arr[2], arr[3]);
  }
  static fromHex(hex) {
    const [r, g, b] = hex.match(/[0-9A-fa-f]{1,2}/g);
    return new Color(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1);
  }
  clone() {
    return new Color(this.r, this.g, this.b, this.a);
  }
  add(color6) {
    this.r += color6.r;
    this.g += color6.g;
    this.b += color6.b;
    this.a += color6.a;
    return this;
  }
  minus(color6) {
    this.r -= color6.r;
    this.g -= color6.g;
    this.b -= color6.b;
    this.a -= color6.a;
    return this;
  }
  multiplyScalar(val) {
    this.r *= val;
    this.g *= val;
    this.b *= val;
    this.a *= val;
    return this;
  }
  divideScalar(val) {
    this.r /= val;
    this.g /= val;
    this.b /= val;
    this.a /= val;
    return this;
  }
  clamp(minVal, maxVal) {
    this.r = Math.min(Math.max(this.r, minVal), maxVal);
    this.g = Math.min(Math.max(this.g, minVal), maxVal);
    this.b = Math.min(Math.max(this.b, minVal), maxVal);
    this.a = Math.min(Math.max(this.a, minVal), maxVal);
    return this;
  }
  mix(c, a) {
    this.r = (1 - a) * this.r + a * c.r;
    this.g = (1 - a) * this.g + a * c.g;
    this.b = (1 - a) * this.b + a * c.b;
    this.a = (1 - a) * this.a + a * c.a;
    return this;
  }
  copy(color6) {
    this.r = color6.r;
    this.g = color6.g;
    this.b = color6.b;
    this.a = color6.a;
    return this;
  }
  equals(color6) {
    return this.r === color6.r && this.g === color6.g && this.b === color6.b && this.a === color6.a;
  }
  _componentToHex(component) {
    const hex = component.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }
  toString() {
    return `Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
  }
  static get TRANSPARENT() {
    return new Color(0, 0, 0, 0);
  }
  static get WHITE() {
    return new Color(1, 1, 1, 1);
  }
  static get BLACK() {
    return new Color(0, 0, 0, 1);
  }
  static get RED() {
    return new Color(1, 0, 0, 1);
  }
  static get BLUE() {
    return new Color(0, 0, 1, 1);
  }
  static get GREEN() {
    return new Color(0, 1, 0, 1);
  }
}
var color_default = Color;

// engine/sdk/core/lib/event-emitter.js
const DEFAULT_MAX_LISTENERS = 12;
class EventEmitter {
  constructor() {
    this._maxListeners = DEFAULT_MAX_LISTENERS;
    this._events = {};
    this._pipeDestinations = [];
  }
  pipeEvents(destination) {
    this._pipeDestinations.push(destination);
  }
  unpipeEvents(destination) {
    const i = this._pipeDestinations.indexOf(destination);
    if (i === -1) {
      return;
    }
    this._pipeDestinations.splice(i, 1);
  }
  on(type, listener) {
    if (typeof type === "undefined") {
      throw new Error(`Invalid event type: \`${type}\``);
    }
    if (typeof listener !== "function") {
      throw new TypeError();
    }
    const listeners = this._events[type] || (this._events[type] = []);
    if (listeners.indexOf(listener) !== -1) {
      return this;
    }
    listeners.push(listener);
    if (this._maxListeners && listeners.length > this._maxListeners) {
      log_default.warn("EventEmitter", `Possible memory leak detected, added ${listeners.length} \`${type}\` listeners (current limit is ${this._maxListeners})`);
      if (typeof console !== "undefined") {
        console.trace();
      }
    }
    return this;
  }
  once(type, listener) {
    if (typeof type === "undefined") {
      throw new Error(`Invalid event type: \`${type}\``);
    }
    const eventsInstance = this;
    function onceCallback() {
      eventsInstance.off(type, onceCallback);
      listener.apply(null, arguments);
    }
    return this.on(type, onceCallback);
  }
  off(type, ...args) {
    if (typeof type === "undefined") {
      throw new Error(`Invalid event type: \`${type}\``);
    }
    if (args.length === 0) {
      this._events[type] = null;
      return this;
    }
    const listener = args[0];
    if (typeof listener !== "function") {
      throw new TypeError();
    }
    const listeners = this._events[type];
    if (!listeners || !listeners.length) {
      return this;
    }
    const indexOfListener = listeners.indexOf(listener);
    if (indexOfListener === -1) {
      return this;
    }
    listeners.splice(indexOfListener, 1);
    return this;
  }
  emit(type, ...args) {
    if (typeof type === "undefined") {
      throw new Error(`Invalid event type: \`${type}\``);
    }
    this._pipeDestinations.forEach((dest) => {
      dest.emit(type, ...args);
    });
    const listeners = this._events[type];
    if (!listeners || !listeners.length) {
      return false;
    }
    listeners.slice(0).forEach((fn) => fn.apply(null, args));
    return true;
  }
  setMaxListeners(newMaxListeners) {
    if (parseInt(newMaxListeners, 10) !== newMaxListeners) {
      throw new TypeError();
    }
    this._maxListeners = newMaxListeners;
  }
}
var event_emitter_default = EventEmitter;

// engine/sdk/core/lib/gl-utils.js
var gl_utils_default = {
  checkFramebufferStatus(tag, gl) {
    const fboStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    const possibleStatuses = {
      [gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT]: "Incomplete attachment",
      [gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT]: "Missing attachment",
      [gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS]: "Incomplete dimensions",
      [gl.FRAMEBUFFER_UNSUPPORTED]: "Framebuffer unsupported"
    };
    if (fboStatus !== gl.FRAMEBUFFER_COMPLETE) {
      log_default.warn(tag, `Framebuffer incomplete: ${possibleStatuses[fboStatus]}`);
    }
  },
  determineGPUName(gl) {
    let gpuName = null;
    let canvas9 = null;
    if (!gl) {
      canvas9 = document.createElement("canvas");
      gl = canvas9.getContext("experimental-webgl") || canvas9.getContext("webgl");
    }
    const ext = gl && gl.getExtension("WEBGL_debug_renderer_info");
    if (ext) {
      gpuName = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
      canvas9 && canvas9.remove();
    }
    return gpuName;
  },
  isGPUBlacklisted(gpuname, userAgent = null) {
    return false;
  }
};

// engine/sdk/core/lib/math/vector2.js
class Vector2 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    if (typeof this.x === "undefined") {
      this.x = 0;
    }
    if (typeof this.y === "undefined") {
      this.y = 0;
    }
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
  copy(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  }
  clamp(minimum, maximum) {
    const minimumSet = minimum !== null && typeof minimum !== "undefined";
    const maximumSet = maximum !== null && typeof maximum !== "undefined";
    if (!(minimum instanceof Vector2) && minimumSet) {
      minimum = new Vector2(minimum, minimum);
    }
    if (!(maximum instanceof Vector2) && maximumSet) {
      maximum = new Vector2(maximum, maximum);
    }
    if (minimumSet) {
      this.x = Math.max(minimum.x, this.x);
      this.y = Math.max(minimum.y, this.y);
    }
    if (maximumSet) {
      this.x = Math.min(maximum.x, this.x);
      this.y = Math.min(maximum.y, this.y);
    }
    return this;
  }
  divide(divisor, y) {
    if (divisor instanceof Vector2) {
      this.x /= divisor.x;
      this.y /= divisor.y;
    } else {
      this.x /= divisor;
      this.y /= typeof y === "undefined" ? divisor : y;
    }
    return this;
  }
  subtract(subtrahend, y) {
    if (subtrahend instanceof Vector2) {
      this.x -= subtrahend.x;
      this.y -= subtrahend.y;
    } else {
      this.x -= subtrahend;
      this.y -= typeof y === "undefined" ? subtrahend : y;
    }
    return this;
  }
  multiply(factor, y) {
    if (factor instanceof Vector2) {
      this.x *= factor.x;
      this.y *= factor.y;
    } else {
      this.x *= factor;
      this.y *= typeof y === "undefined" ? factor : y;
    }
    return this;
  }
  add(addend, y) {
    if (addend instanceof Vector2) {
      this.x += addend.x;
      this.y += addend.y;
    } else {
      this.x += addend;
      this.y += typeof y === "undefined" ? addend : y;
    }
    return this;
  }
  dot(vec, y) {
    if (vec instanceof Vector2) {
      return this.x * vec.x + this.y * vec.y;
    }
    return this.x * vec + this.y * (typeof y === "undefined" ? vec : y);
  }
  equals(vec, y) {
    if (vec instanceof Vector2) {
      return vec.x === this.x && vec.y === this.y;
    }
    return vec === this.x && y === this.y;
  }
  flip() {
    const tempX = this.x;
    this.x = this.y;
    this.y = tempX;
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  floor() {
    this.x |= 0;
    this.y |= 0;
    return this;
  }
  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    return this;
  }
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  min() {
    return Math.min(this.x, this.y);
  }
  max() {
    return Math.max(this.x, this.y);
  }
  toObject() {
    return {x: this.x, y: this.y};
  }
  toString() {
    return `Vector2({ x: ${this.x}, y: ${this.y} })`;
  }
  roundDecimal(decimals) {
    this.x = parseFloat(this.x.toFixed(decimals));
    this.y = parseFloat(this.y.toFixed(decimals));
    return this;
  }
  asArray(reverse = false) {
    if (reverse) {
      return [this.y, this.x];
    }
    return [this.x, this.y];
  }
  static fromObject(object) {
    return new Vector2(object.x, object.y);
  }
  static get NULL() {
    return new Vector2(0, 0);
  }
}
var vector2_default = Vector2;

// engine/sdk/core/lib/math/matrix.js
class Matrix {
  constructor() {
    this.reset();
  }
  multiply(matrix4) {
    let a;
    let b;
    let c;
    let d;
    let tx;
    let ty;
    a = this.a * matrix4.a + this.b * matrix4.c;
    b = this.a * matrix4.b + this.b * matrix4.d;
    c = this.c * matrix4.a + this.d * matrix4.c;
    d = this.c * matrix4.b + this.d * matrix4.d;
    tx = this.tx * matrix4.a + this.ty * matrix4.c + matrix4.tx;
    ty = this.tx * matrix4.b + this.ty * matrix4.d + matrix4.ty;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  applyToVector(position) {
    const {x, y} = position;
    position = position.clone();
    position.x = this.a * x + this.c * y + this.tx;
    position.y = this.b * x + this.d * y + this.tx;
    return position;
  }
  applyInverseToVector(position) {
    const determinant = 1 / (this.a * this.d + this.c * -this.b);
    const {x, y} = position;
    position = position.clone();
    position.x = this.d * determinant * x + -this.c * determinant * y + (this.ty * this.c - this.tx * this.d) * determinant;
    position.y = this.a * determinant * y + -this.b * determinant * x + (-this.ty * this.a + this.tx * this.b) * determinant;
    return position;
  }
  rectangleToCoordinates(rectangle3, anchor = new vector2_default(0, 0)) {
    const w0 = rectangle3.width * (1 - anchor.x);
    const w1 = rectangle3.width * -anchor.x;
    const h0 = rectangle3.height * (1 - anchor.y);
    const h1 = rectangle3.height * -anchor.y;
    const positions = [];
    positions.push(new vector2_default(this.a * w1 + this.c * h1 + this.tx, this.d * h1 + this.b * w1 + this.ty));
    positions.push(new vector2_default(this.a * w0 + this.c * h1 + this.tx, this.d * h1 + this.b * w0 + this.ty));
    positions.push(new vector2_default(this.a * w0 + this.c * h0 + this.tx, this.d * h0 + this.b * w0 + this.ty));
    positions.push(new vector2_default(this.a * w1 + this.c * h0 + this.tx, this.d * h0 + this.b * w1 + this.ty));
    return positions;
  }
  reset() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
  }
  toArray() {
    const arr = [this.a, this.b, 0, this.c, this.d, 0, this.tx, this.ty, 1];
    if (typeof Float32Array === "undefined") {
      return arr;
    }
    return new Float32Array(arr);
  }
  toString() {
    return `Matrix({ a: ${this.a}, b: ${this.b}, c: ${this.c}, d: ${this.d}, tx: ${this.tx}, ty: ${this.ty} })`;
  }
  static get IDENTITY() {
    return new Matrix();
  }
}
var matrix_default = Matrix;

// engine/sdk/core/lib/math/rectangle.js
class Rectangle {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  set(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    return this;
  }
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  copy(other) {
    this.x = other.x;
    this.y = other.y;
    this.width = other.width;
    this.height = other.height;
    return this;
  }
  equals(rect, y, width, height) {
    if (rect instanceof Rectangle) {
      return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
    }
    const x = rect;
    return x === this.x && y === this.y && width === this.width && height === this.height;
  }
  translate(tx, ty) {
    if (tx instanceof vector2_default) {
      ty = tx.y;
      tx = tx.x;
    }
    this.x += tx;
    this.y += ty;
    return this;
  }
  scale(sx, sy) {
    if (sx instanceof vector2_default) {
      sy = sx.y;
      sx = sx.x;
    } else if (sy === void 0) {
      sy = sx;
    }
    this.width *= sx;
    this.height *= sy;
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.width = Math.round(this.width);
    this.height = Math.round(this.height);
    return this;
  }
  getPosition() {
    return new vector2_default(this.x, this.y);
  }
  getSize() {
    return new vector2_default(this.width, this.height);
  }
  insetBy(dx, dy) {
    this.x += dx;
    this.y += dy;
    this.width -= 2 * dx;
    this.height -= 2 * dy;
    return this;
  }
  intersects(rect) {
    const p1 = new vector2_default(this.x, this.y);
    const p2 = new vector2_default(this.x + this.width, this.y + this.height);
    const q1 = new vector2_default(rect.x, rect.y);
    const q2 = new vector2_default(rect.x + rect.width, rect.y + rect.height);
    if (q1.x > p2.x || p1.x > q2.x || q2.y < p1.y || p2.y < q1.y) {
      return false;
    }
    return true;
  }
  toString() {
    return `Rectangle({ x: ${this.x}, y: ${this.y}, width: ${this.width}, height: ${this.height} })`;
  }
  static FromDiagonalPoints(p1, p2) {
    let inverted = false;
    if (p2.x - p1.x < 0) {
      inverted = true;
    }
    const topLeft = inverted ? p2 : p1;
    const bottomRight = inverted ? p1 : p2;
    const width = bottomRight.x - topLeft.x;
    const height = bottomRight.y - topLeft.y;
    return new Rectangle(topLeft.x, topLeft.y, width, height);
  }
}
var rectangle_default = Rectangle;

// engine/sdk/core/engine/globals.js
const globals_exports = {};
__export(globals_exports, {
  BATCH_SIZE: () => BATCH_SIZE,
  Color: () => color_default,
  Constants: () => constants_exports,
  EventEmitter: () => event_emitter_default,
  GLUtils: () => gl_utils_default,
  Log: () => log_default,
  Matrix: () => matrix_default,
  Rectangle: () => rectangle_default,
  Utils: () => utils_default,
  VERTEX_BYTE_SIZE: () => VERTEX_BYTE_SIZE,
  VERTEX_SIZE: () => VERTEX_SIZE,
  Vector2: () => vector2_default
});
const BATCH_SIZE = 2e3;
const VERTEX_SIZE = 5;
const VERTEX_BYTE_SIZE = VERTEX_SIZE * 4;

// engine/sdk/core/engine/display/display-object.js
class DisplayObject {
  constructor() {
    this._position = new vector2_default(0, 0);
    this._scale = new vector2_default(1, 1);
    this._pivot = new vector2_default(0, 0);
    this._rotation = 0;
    this._lastRotation = null;
    this._alpha = 1;
    this._visible = true;
    this._worldTransform = new matrix_default();
    this._parent = null;
    this._shaders = [];
    this._boundsNeedUpdate = true;
    this._bounds = new rectangle_default(0, 0, 1, 1);
    this._localBoundsNeedUpdate = true;
    this._localBounds = new rectangle_default(0, 0, 1, 1);
    this._tint = 16777215;
    this._filterRectangle = new rectangle_default(0, 0, 0, 0);
  }
  renderWebGL(renderer) {
    log_default.warn(this.constructor.name, "`renderWebGL` is abstract and not implemented in inherited class");
  }
  renderCanvas(renderer) {
    log_default.warn(this.constructor.name, "`renderCanvas` is abstract and not implemented in inherited class");
  }
  updateTransform() {
    const parentTransform = this._parent ? this._parent.getWorldTransform() : matrix_default.IDENTITY;
    const worldTransform = this._worldTransform;
    const rotationChanged = this._rotation !== this._lastRotation;
    if (rotationChanged) {
      this._sinRotation = Math.sin(this._rotation);
      this._cosRotation = Math.cos(this._rotation);
      this._lastRotation = this._rotation;
    }
    worldTransform.a = this._cosRotation * this._scale.x;
    worldTransform.b = this._sinRotation * this._scale.x;
    worldTransform.c = -this._sinRotation * this._scale.y;
    worldTransform.d = this._cosRotation * this._scale.y;
    worldTransform.tx = this._position.x;
    worldTransform.ty = this._position.y;
    if (this._pivot.x || this._pivot.y) {
      worldTransform.tx -= this._pivot.x * worldTransform.a + this._pivot.y * worldTransform.c;
      worldTransform.ty -= this._pivot.x * worldTransform.b + this._pivot.y * worldTransform.d;
    }
    worldTransform.multiply(parentTransform);
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  addShader(shader4) {
    this._shaders.push(shader4);
  }
  removeShader(shader4) {
    const index = this._shaders.indexOf(shader4);
    if (index !== -1) {
      this._shaders.splice(index, 1);
      return true;
    }
    return false;
  }
  removeShaderAt(index) {
    if (!this._shaders[index]) {
      return false;
    }
    this._shaders.splice(index, 1);
    return true;
  }
  getBounds() {
    return this._bounds.clone();
  }
  getPosition() {
    return this._position;
  }
  setPosition(position, y) {
    if (position instanceof vector2_default) {
      this._position.copy(position);
    } else {
      this._position.set(position, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  getScale() {
    return this._scale;
  }
  setScale(scale, y) {
    if (scale instanceof vector2_default) {
      this._scale.copy(scale);
    } else {
      this._scale.set(scale, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  getPivot() {
    return this._pivot;
  }
  setPivot(pivot, y) {
    if (pivot instanceof vector2_default) {
      this._pivot.copy(pivot);
    } else {
      this._pivot.set(pivot, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  getRotation() {
    return this._rotation;
  }
  setRotation(rotation) {
    this._rotation = rotation;
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  getAlpha() {
    return this._alpha;
  }
  setAlpha(alpha) {
    this._alpha = alpha;
  }
  getWorldAlpha() {
    if (this._parent) {
      return this._parent.getAlpha() * this._alpha;
    }
    return this._alpha;
  }
  getWorldTransform() {
    return this._worldTransform;
  }
  getParent() {
    return this._parent;
  }
  setParent(parent) {
    this._parent = parent;
  }
  getFilterRectangle() {
    return this._filterRectangle;
  }
  setFilterRectangle(rectangle3) {
    this._filterRectangle.copy(rectangle3);
  }
  getTint() {
    return this._tint;
  }
  setTint(tint2) {
    this._tint = tint2;
  }
  isVisible() {
    return this._visible;
  }
  setVisible(visible) {
    this._visible = visible;
  }
}
var display_object_default = DisplayObject;

// engine/sdk/core/engine/display/container.js
class Container extends display_object_default {
  constructor(...args) {
    super(...args);
    this._children = [];
    this._filters = [];
  }
  addFilter(filter40) {
    this._filters.push(filter40);
  }
  removeFilter(filter40) {
    const index = this._filters.indexOf(filter40);
    if (index !== -1) {
      this._filters.splice(index, 1);
      return true;
    }
    return false;
  }
  setFilters(filters) {
    this._filters = filters;
  }
  addChild(child) {
    const originalParent = child.getParent();
    if (originalParent !== null) {
      originalParent.removeChild(child);
    }
    child.setParent(this);
    this._children.push(child);
  }
  prependChild(child) {
    const originalParent = child.getParent();
    if (originalParent !== null) {
      originalParent.removeChild(child);
    }
    child.setParent(this);
    this._children.unshift(child);
  }
  hasChild(child) {
    const index = this._children.indexOf(child);
    return index !== -1;
  }
  removeChild(child) {
    const index = this._children.indexOf(child);
    if (index !== -1) {
      this._children.splice(index, 1);
      child.setParent(null);
    } else {
      log_default.info(this.constructor.name, "Tried to remove a child that does not exist");
    }
  }
  clearChildren() {
    this._children = [];
  }
  renderWebGL(renderer) {
    if (!this._visible) {
      return;
    }
    const filterManager = renderer.getFilterManager();
    if (this._filters && this._filters.length) {
      filterManager.pushFilters(this, this._filters);
    }
    renderer.getCurrentObjectRenderer().start();
    this._renderWebGL(renderer);
    this._children.forEach((child) => {
      child.renderWebGL(renderer);
    });
    renderer.getCurrentObjectRenderer().flush();
    if (this._filters && this._filters.length) {
      filterManager.popFilters();
    }
    renderer.getCurrentObjectRenderer().start();
  }
  _renderWebGL(renderer) {
  }
  renderCanvas(renderer) {
    if (!this._visible) {
      return;
    }
    const filterManager = renderer.getFilterManager();
    if (this._filters && this._filters.length) {
      filterManager.pushFilters(this, this._filters);
    }
    this._renderCanvas(renderer);
    this._children.forEach((child) => {
      child.renderCanvas(renderer);
    });
    if (this._filters && this._filters.length) {
      filterManager.popFilters();
    }
  }
  _renderCanvas(renderer) {
  }
  updateTransform() {
    super.updateTransform();
    this._children.forEach((child) => {
      child.updateTransform();
    });
  }
  getLocalBounds() {
    if (this._localBoundsNeedUpdate) {
      this._localBoundsNeedUpdate = false;
    }
    return this._localBounds.clone();
  }
  getBounds() {
    if (this._boundsNeedUpdate) {
      this._boundsNeedUpdate = false;
    }
    return this._bounds.clone();
  }
  getChildren() {
    return this._children;
  }
  getFilters() {
    return this._filters;
  }
  dispose() {
  }
}
var container_default = Container;

// engine/sdk/operations/shared/vendor/stack-blur.js
"use strict";
/*!
StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author:   Mario Klingemann
Contact:  mario@quasimondo.com
Website:  http://www.quasimondo.com/StackBlurForCanvas
Twitter:  @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
@license
*/
var mul_table = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
];
var shg_table = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function stackBlurCanvasRGBA(imageData, top_x, top_y, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var pixels = imageData.data;
  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
  var div = radius + radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stackEnd;
  var stack = stackStart;
  for (i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1)
      stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;
  yw = yi = 0;
  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];
  for (y = 0; y < height; y++) {
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack = stackStart;
    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    for (i = 1; i < radiusPlus1; i++) {
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++) {
      pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa !== 0) {
        pa = 255 / pa;
        pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
        pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
      r_in_sum += stackIn.r = pixels[p];
      g_in_sum += stackIn.g = pixels[p + 1];
      b_in_sum += stackIn.b = pixels[p + 2];
      a_in_sum += stackIn.a = pixels[p + 3];
      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (x = 0; x < width; x++) {
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    stack = stackStart;
    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    yp = width;
    for (i = 1; i <= radius; i++) {
      yi = yp + x << 2;
      r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
      b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
      a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      stack = stack.next;
      if (i < heightMinus1) {
        yp += width;
      }
    }
    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++) {
      p = yi << 2;
      pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
      if (pa > 0) {
        pa = 255 / pa;
        pixels[p] = r_sum * mul_sum >> shg_sum;
        pixels[p + 1] = g_sum * mul_sum >> shg_sum;
        pixels[p + 2] = b_sum * mul_sum >> shg_sum;
      } else {
        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
      }
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
      r_sum += r_in_sum += stackIn.r = pixels[p];
      g_sum += g_in_sum += stackIn.g = pixels[p + 1];
      b_sum += b_in_sum += stackIn.b = pixels[p + 2];
      a_sum += a_in_sum += stackIn.a = pixels[p + 3];
      stackIn = stackIn.next;
      r_out_sum += pr = stackOut.r;
      g_out_sum += pg = stackOut.g;
      b_out_sum += pb = stackOut.b;
      a_out_sum += pa = stackOut.a;
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
}
function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
}

// engine/sdk/core/lib/image.js
let Image;
if (process.env.REACT_APP_BROWSER) {
  Image = window.Image;
}
if (!process.env.REACT_APP_BROWSER) {
  Image = require("canvas").Image;
}
var image_default = Image;

// engine/sdk/core/lib/math/color-matrix.js
class ColorMatrix {
  constructor(a = 1, b = 0, c = 0, d = 0, e = 0, f = 0, g = 1, h = 0, i = 0, j = 0, k = 0, l = 0, m = 1, n = 0, o = 0, p = 0, q = 0, r = 0, s = 1, t = 0) {
    this.set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t);
  }
  set(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    this.j = j;
    this.k = k;
    this.l = l;
    this.m = m;
    this.n = n;
    this.o = o;
    this.p = p;
    this.q = q;
    this.r = r;
    this.s = s;
    this.t = t;
  }
  reset() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 0;
    this.e = 0;
    this.f = 0;
    this.g = 1;
    this.h = 0;
    this.i = 0;
    this.j = 0;
    this.k = 0;
    this.l = 0;
    this.m = 1;
    this.n = 0;
    this.o = 0;
    this.p = 0;
    this.q = 0;
    this.r = 0;
    this.s = 1;
    this.t = 0;
  }
  apply(color6) {
    const r = this.a * color6.r + this.b * color6.g + this.c * color6.b + this.d * color6.a + this.e;
    const g = this.f * color6.r + this.g * color6.g + this.h * color6.b + this.i * color6.a + this.j;
    const b = this.k * color6.r + this.l * color6.g + this.m * color6.b + this.n * color6.a + this.o;
    const a = this.p * color6.r + this.q * color6.g + this.r * color6.b + this.s * color6.a + this.t;
    return new color_default(r, g, b, a);
  }
  multiply(matrix4) {
    let a;
    let b;
    let c;
    let d;
    let e;
    let f;
    let g;
    let h;
    let i;
    let j;
    let k;
    let l;
    let m;
    let n;
    let o;
    let p;
    let q;
    let r;
    let s;
    let t;
    const A = matrix4;
    const B = this;
    a = A.a * B.a + A.b * B.f + A.c * B.k + A.d * B.p;
    b = A.a * B.b + A.b * B.g + A.c * B.l + A.d * B.q;
    c = A.a * B.c + A.b * B.h + A.c * B.m + A.d * B.r;
    d = A.a * B.d + A.b * B.i + A.c * B.n + A.d * B.s;
    f = A.f * B.a + A.g * B.f + A.h * B.k + A.i * B.p;
    g = A.f * B.b + A.g * B.g + A.h * B.l + A.i * B.q;
    h = A.f * B.c + A.g * B.h + A.h * B.m + A.i * B.r;
    i = A.f * B.d + A.g * B.i + A.h * B.n + A.i * B.s;
    k = A.k * B.a + A.l * B.f + A.m * B.k + A.n * B.p;
    l = A.k * B.b + A.l * B.g + A.m * B.l + A.n * B.q;
    m = A.k * B.c + A.l * B.h + A.m * B.m + A.n * B.r;
    n = A.k * B.d + A.l * B.i + A.m * B.n + A.n * B.s;
    p = A.p * B.a + A.q * B.f + A.r * B.k + A.s * B.p;
    q = A.p * B.b + A.q * B.g + A.r * B.l + A.s * B.q;
    r = A.p * B.c + A.q * B.h + A.r * B.m + A.s * B.r;
    s = A.p * B.d + A.q * B.i + A.r * B.n + A.s * B.s;
    e = A.a * B.e + A.b * B.j + A.c * B.o + A.d * B.t + A.e;
    j = A.f * B.e + A.g * B.j + A.h * B.o + A.i * B.t + A.j;
    o = A.k * B.e + A.l * B.j + A.m * B.o + A.n * B.t + A.o;
    t = A.p * B.e + A.q * B.j + A.r * B.o + A.s * B.t + A.t;
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
    this.g = g;
    this.h = h;
    this.i = i;
    this.j = j;
    this.k = k;
    this.l = l;
    this.m = m;
    this.n = n;
    this.o = o;
    this.p = p;
    this.q = q;
    this.r = r;
    this.s = s;
    this.t = t;
    return this;
  }
  clone() {
    const matrix4 = new ColorMatrix();
    matrix4.set(this.a, this.b, this.c, this.d, this.e, this.f, this.g, this.h, this.i, this.j, this.k, this.l, this.m, this.n, this.o, this.p, this.q, this.r, this.s, this.t);
    return matrix4;
  }
  equals(matrix4) {
    return this.a === matrix4.a && this.b === matrix4.b && this.c === matrix4.c && this.d === matrix4.d && this.e === matrix4.e && this.f === matrix4.f && this.g === matrix4.g && this.h === matrix4.h && this.i === matrix4.i && this.j === matrix4.j && this.k === matrix4.k && this.l === matrix4.l && this.m === matrix4.m && this.n === matrix4.n && this.o === matrix4.o && this.p === matrix4.p && this.q === matrix4.q && this.r === matrix4.r && this.s === matrix4.s && this.t === matrix4.t;
  }
  getOffsets() {
    return [this.e, this.j, this.o, this.t];
  }
  toString() {
    return `ColorMatrix( ${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e},
      ${this.f}, ${this.g}, ${this.h}, ${this.i}, ${this.j},
      ${this.k}, ${this.l}, ${this.m}, ${this.n}, ${this.o},
      ${this.p}, ${this.q}, ${this.r}, ${this.s}, ${this.t} )`;
  }
  toArray() {
    return "abcdefghijklmnopqrst".split("").map((v) => this[v]);
  }
  static get IDENTITY() {
    return new ColorMatrix();
  }
  static createBrightnessMatrix(brightness3) {
    const matrix4 = new ColorMatrix();
    matrix4.e = brightness3;
    matrix4.j = brightness3;
    matrix4.o = brightness3;
    return matrix4;
  }
  static createContrastMatrix(contrast3) {
    const matrix4 = new ColorMatrix();
    const t = (1 - contrast3) / 2;
    matrix4.a = matrix4.g = matrix4.m = contrast3;
    matrix4.e = matrix4.j = matrix4.o = t;
    return matrix4;
  }
  static createSaturationMatrix(saturation3 = 1) {
    const matrix4 = new ColorMatrix();
    const invSat = 1 - saturation3;
    const r = 0.213 * invSat;
    const g = 0.715 * invSat;
    const b = 0.072 * invSat;
    matrix4.a = r + saturation3;
    matrix4.b = g;
    matrix4.c = b;
    matrix4.f = r;
    matrix4.g = g + saturation3;
    matrix4.h = b;
    matrix4.k = r;
    matrix4.l = g;
    matrix4.m = b + saturation3;
    return matrix4;
  }
  static createExposureMatrix(exposure = 0) {
    const scale = Math.pow(2, exposure);
    return new ColorMatrix(scale, 0, 0, 0, 0, 0, scale, 0, 0, 0, 0, 0, scale, 0, 0, 0, 0, 0, 1, 0);
  }
  static createLinearMatrix(slope = 1, intercept = 0) {
    const matrix4 = new ColorMatrix();
    matrix4.a = matrix4.g = matrix4.m = slope;
    matrix4.e = matrix4.j = matrix4.o = intercept;
    return matrix4;
  }
}
var color_matrix_default = ColorMatrix;

// engine/sdk/core/lib/configurable.js
class Configurable extends event_emitter_default {
  constructor(options = {}, additionalAvailableOptions = {}) {
    super();
    this.availableOptions = this.availableOptions || {};
    this.availableOptions = utils_default.extend(this.availableOptions, additionalAvailableOptions);
    this._onConfigurableUpdate = this._onConfigurableUpdate.bind(this);
    this._initOptions(options);
  }
  _buildConfigError(message) {
    let errorMessage = "";
    if (this.constructor.name) {
      errorMessage = `${this.constructor.name}: `;
    }
    errorMessage += message;
    return new Error(errorMessage);
  }
  _onOptionsChange() {
  }
  validateSettings() {
    return new promise_default((resolve, reject) => {
      for (const optionName in this.availableOptions) {
        const optionConfig = this.availableOptions[optionName];
        if (optionConfig.required && typeof this._options[optionName] === "undefined") {
          return reject(this._buildConfigError(`Option \`${optionName}\` is required.`));
        }
      }
      resolve();
    });
  }
  _initOptions(userOptions = {}) {
    this._options = {};
    let optionName;
    let option;
    let capitalized;
    const self = this;
    for (optionName in this.availableOptions) {
      capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
      option = this.availableOptions[optionName];
      if ([
        OptionType.STRING,
        OptionType.NUMBER,
        OptionType.BOOLEAN,
        OptionType.OBJECT,
        OptionType.VECTOR2,
        OptionType.COLOR,
        OptionType.CONFIGURABLE,
        OptionType.COLOR_MATRIX,
        OptionType.ARRAY,
        OptionType.IMAGE,
        OptionType.FUNCTION,
        OptionType.ALL
      ].indexOf(option.type) === -1) {
        throw this._buildConfigError(`Unknown option type: \`${option.type}\``);
      }
      const fn = function Ca(optionName2, option2) {
        self[`set${capitalized}`] = function(value, update, initial) {
          self.setOption(optionName2, value, update, initial);
        };
        self[`get${capitalized}`] = function() {
          return self.getOption(optionName2);
        };
      };
      fn(optionName, option);
      if (option.type === OptionType.CONFIGURABLE) {
        this._options[optionName] = new Configurable(void 0, option.structure || {});
        this._options[optionName].on("update", this._onConfigurableUpdate);
      }
      if (!(optionName in userOptions) || typeof userOptions[optionName] === "undefined") {
        if (typeof option.default !== "undefined") {
          let defaultValue = option.default;
          if (typeof option.default === "function") {
            defaultValue = option.default();
          }
          this[`set${capitalized}`](defaultValue, false, true);
        } else if (option.type !== OptionType.CONFIGURABLE) {
          this._options[optionName] = void 0;
        }
      }
    }
    for (optionName in userOptions) {
      if (typeof this.availableOptions[optionName] === "undefined") {
        throw new Error(`Invalid option: ${optionName}`);
      }
      if (typeof userOptions[optionName] !== "undefined") {
        capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
        this[`set${capitalized}`](userOptions[optionName], false, true);
      }
    }
  }
  set(options, emitUpdate = true) {
    for (const optionName in options) {
      this.setOption(optionName, options[optionName], false);
    }
    this._onOptionsChange();
    if (emitUpdate) {
      this.emit("update", this, options);
    }
  }
  getOption(optionName) {
    return this._options[optionName];
  }
  hasOption(optionName) {
    return !!this.availableOptions[optionName];
  }
  getOptionDefault(optionName) {
    const option = this.availableOptions[optionName];
    if (!option) {
      throw new Error(`Invalid option: ${optionName}`);
    }
    return option.default;
  }
  resetOptions() {
    this.set(this.getDefaultOptions());
  }
  getDefaultOptions() {
    const options = {};
    for (const optionName in this.availableOptions) {
      const defaultValue = this.availableOptions[optionName].default;
      if (typeof defaultValue === "undefined")
        continue;
      options[optionName] = defaultValue;
    }
    return options;
  }
  getOptions() {
    return __assign({}, this._options);
  }
  equals(other) {
    const otherOptions = other.getOptions();
    return this.optionsEqual(otherOptions);
  }
  optionsEqual(options) {
    for (const optionName in options) {
      const value = options[optionName];
      if (!this._optionEquals(optionName, value)) {
        return false;
      }
    }
    return true;
  }
  _optionEquals(optionName, value) {
    const option = this.availableOptions[optionName];
    if (typeof option === "undefined") {
      throw new Error(`Invalid option: ${optionName}`);
    }
    const optionType = this.availableOptions[optionName].type;
    const currentValue = this._options[optionName];
    if (currentValue === value)
      return true;
    if (typeof value === "undefined" || typeof currentValue === "undefined")
      return false;
    switch (optionType) {
      case OptionType.OBJECT:
        if (typeof currentValue.optionsEqual === "function") {
          return currentValue.optionsEqual(value._options);
        }
        return currentValue === value;
      case OptionType.STRING:
      case OptionType.NUMBER:
      case OptionType.BOOLEAN:
      case OptionType.FUNCTION:
      case "*":
        return currentValue === value;
      case OptionType.VECTOR2:
        return currentValue.equals(value);
      case OptionType.COLOR:
      case OptionType.COLOR_MATRIX:
        return value.equals(currentValue);
      case OptionType.CONFIGURABLE:
        return currentValue.optionsEqual(value);
      case OptionType.ARRAY:
        return this._arrayOptionEquals(optionName, value);
      case OptionType.IMAGE:
        return currentValue.src === value.src;
    }
  }
  _arrayOptionEquals(optionName, arr) {
    const thisArr = this._options[optionName];
    if (arr.length !== thisArr.length) {
      return false;
    }
    let equal = true;
    for (let i = 0; i < thisArr.length; i++) {
      const thisValue = thisArr[i];
      const value = arr[i];
      if (thisValue instanceof Configurable) {
        if (typeof value === "undefined" || !thisValue.optionsEqual(value)) {
          equal = false;
          break;
        }
      } else if (value !== thisValue) {
        equal = false;
        break;
      }
    }
    return equal;
  }
  serializeOptions(keys = Object.keys(this._options), toObject = false) {
    const options = {};
    keys.forEach((key) => {
      if (typeof this.availableOptions[key] === "undefined") {
        return log_default.warn(`Trying to serialize a key that does not exist: ${key}`);
      }
      if (this.availableOptions[key].serializable === false)
        return;
      options[key] = this.serializeOption(key, toObject);
    });
    return options;
  }
  serializeOption(optionName, toObject = false) {
    const option = this.availableOptions[optionName];
    const optionType = option.type;
    const value = this._options[optionName];
    if (!value)
      return value;
    if (option.serializable === false) {
      throw new Error(`Option \`${optionName}\` is not serializable.`);
    }
    switch (optionType) {
      case OptionType.STRING:
      case OptionType.NUMBER:
      case OptionType.BOOLEAN:
      case OptionType.OBJECT:
      case OptionType.FUNCTION:
      case OptionType.ALL:
        return value;
      case OptionType.VECTOR2:
        return toObject ? value.toObject() : value.clone();
      case OptionType.COLOR:
      case OptionType.COLOR_MATRIX:
        return toObject ? value.toArray() : value.clone();
      case OptionType.CONFIGURABLE:
        return value.serializeOptions(void 0, toObject);
      case OptionType.ARRAY:
        return value.slice(0);
      case OptionType.IMAGE:
        return toObject ? value.src : value;
    }
  }
  setOption(optionName, value, update = true, initial = false) {
    const optionConfig = this.availableOptions[optionName];
    if (!optionConfig) {
      throw new Error(`Invalid option: ${optionName}`);
    }
    if (typeof optionConfig.setter !== "undefined") {
      value = optionConfig.setter.call(this, value, initial);
    }
    if (typeof optionConfig.validation !== "undefined") {
      optionConfig.validation(value);
    }
    if (value === null || typeof value === "undefined") {
      if (optionConfig.required) {
        throw this._buildConfigError(`Option \`${optionName}\` is required.`);
      }
      this._options[optionName] = value;
    } else {
      switch (optionConfig.type) {
        case OptionType.STRING: {
          if (typeof value !== OptionType.STRING) {
            throw this._buildConfigError(`Option \`${optionName}\` has to be a string.`);
          }
          const {available} = optionConfig;
          if (typeof available !== "undefined" && available.indexOf(value) === -1) {
            throw this._buildConfigError(`Invalid value for \`${optionName}\` (valid values are: ${optionConfig.available.join(", ")})`);
          }
          this._options[optionName] = value;
          break;
        }
        case OptionType.NUMBER:
          if (typeof value !== OptionType.NUMBER) {
            throw this._buildConfigError(`Option \`${optionName}\` has to be a number.`);
          }
          this._options[optionName] = value;
          break;
        case OptionType.BOOLEAN:
          if (typeof value !== OptionType.BOOLEAN) {
            throw this._buildConfigError(`Option \`${optionName}\` has to be a boolean.`);
          }
          this._options[optionName] = value;
          break;
        case OptionType.VECTOR2:
          if (!(value instanceof vector2_default) && !(typeof value === "object" && "x" in value && "y" in value)) {
            throw this._buildConfigError(`Option \`${optionName}\` has to be an instance of Vector2 or an Object holding x and y values.`);
          }
          if (value instanceof vector2_default) {
            this._options[optionName] = value.clone();
          } else {
            this._options[optionName] = vector2_default.fromObject(value);
          }
          break;
        case OptionType.COLOR:
          if (!(value instanceof color_default)) {
            throw this._buildConfigError(`Option \`${optionName}\` has to be an instance of Color.`);
          }
          this._options[optionName] = value;
          break;
        case OptionType.COLOR_MATRIX:
          if (!(value instanceof color_matrix_default)) {
            throw this._buildConfigError(`Option \`${optionName}\` has to be an instance of ColorMatrix.`);
          }
          this._options[optionName] = value.clone();
          break;
        case OptionType.FUNCTION:
          if (typeof value !== "function") {
            throw this._buildConfigError(`Option \`${optionName}\` has to be a function.`);
          }
          this._options[optionName] = value;
          break;
        case OptionType.OBJECT:
        case "*":
          this._options[optionName] = value;
          break;
        case OptionType.IMAGE:
          if (typeof value === "string") {
            const image5 = new image_default();
            image5.crossOrigin = utils_default.getCrossOriginValue(optionConfig.crossOrigin);
            image5.src = value;
            this._options[optionName] = image5;
          } else if (value instanceof image_default || typeof HTMLCanvasElement !== "undefined" && value instanceof HTMLCanvasElement || typeof HTMLImageElement !== "undefined" && value instanceof HTMLImageElement) {
            this._options[optionName] = value;
          } else {
            throw this._buildConfigError(`Option \`${optionName}\` has to be an Image, Canvas or String.`);
          }
          break;
        case OptionType.CONFIGURABLE:
          if (value instanceof Configurable) {
            this._options[optionName] = value;
          } else {
            this._options[optionName].set(value);
          }
          break;
        case OptionType.ARRAY:
          if (!(value instanceof Array)) {
            throw this._buildConfigError(`Option \`${optionName}\` has to be an Array.`);
          }
          this._options[optionName] = value.slice(0);
          break;
        default:
          throw this._buildConfigError(`Unknown option type: \`${optionConfig.type}\``);
      }
    }
    if (update) {
      this._onOptionsChange();
      this.emit("update", this, {[optionName]: value});
    }
  }
  _onConfigurableUpdate(...args) {
    this.emit("update", ...args);
  }
  hasChanges() {
    const defaultOptions = this.getDefaultOptions();
    return !this.optionsEqual(defaultOptions);
  }
}
var configurable_default = Configurable;

// engine/sdk/core/engine/shaders/shader.js
const {Log: Log2, Utils: Utils2} = globals_exports;
class Shader {
  constructor(renderer, vertexSource, fragmentSource, uniforms, attributes) {
    this._renderer = renderer;
    this._vertexSource = vertexSource;
    this._fragmentSource = fragmentSource;
    this._uniforms = uniforms || {};
    this._uniformLocations = {};
    this._attributes = attributes || [];
    this._attributeLocations = {};
    this._onContextChange = this._onContextChange.bind(this);
    this._renderer.on("context", this._onContextChange);
    this._init();
  }
  _init() {
    this._compile();
    const gl = this._renderer.getContext();
    gl.useProgram(this._program);
    this._cacheUniformLocations();
    this._cacheAttributeLocations();
  }
  _onContextChange() {
    this._init();
  }
  setupBuffers(vertexBuffer, indexBuffer) {
    const gl = this._renderer.getContext();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.vertexAttribPointer(this._attributeLocations.a_position, 2, gl.FLOAT, false, VERTEX_BYTE_SIZE, 0);
    gl.vertexAttribPointer(this._attributeLocations.a_texCoord, 2, gl.FLOAT, false, VERTEX_BYTE_SIZE, 2 * 4);
    gl.vertexAttribPointer(this._attributeLocations.a_color, 4, gl.UNSIGNED_BYTE, true, VERTEX_BYTE_SIZE, 4 * 4);
  }
  syncUniforms() {
    Object.keys(this._uniforms).forEach((key) => {
      this.syncUniform(key);
    });
  }
  syncUniform(name) {
    const gl = this._renderer.getContext();
    const uniform = this._uniforms[name];
    const location = this._uniformLocations[name];
    switch (uniform.type) {
      case UniformType.SAMPLER2D:
        gl.uniform1i(location, uniform.value);
        break;
      case UniformType.INT:
      case UniformType.INT1:
        gl.uniform1i(location, uniform.value);
        break;
      case UniformType.INT2:
        gl.uniform2i(location, uniform.value[0], uniform.value[1]);
        break;
      case UniformType.INT3:
        gl.uniform3i(location, uniform.value[0], uniform.value[1], uniform.value[2]);
        break;
      case UniformType.INT4:
        gl.uniform4i(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
        break;
      case UniformType.FLOAT:
      case UniformType.FLOAT1:
        gl.uniform1f(location, uniform.value);
        break;
      case UniformType.FLOAT2:
        gl.uniform2f(location, uniform.value[0], uniform.value[1]);
        break;
      case UniformType.FLOAT3:
        gl.uniform3f(location, uniform.value[0], uniform.value[1], uniform.value[2]);
        break;
      case UniformType.FLOAT4:
        gl.uniform4f(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
        break;
      case UniformType.FLOAT_VECTOR2:
        gl.uniform2fv(location, uniform.value);
        break;
      case UniformType.MAT3:
      case UniformType.MAT3FV:
        gl.uniformMatrix3fv(location, false, uniform.value);
        break;
      case UniformType.MAT4:
        gl.uniformMatrix4fv(location, false, uniform.value);
        break;
      default:
        Log2.warn(this.constructor.name, `Unknown uniform type: ${uniform.type}`);
    }
  }
  _cacheAttributeLocations() {
    const gl = this._renderer.getContext();
    this._attributes.forEach((name) => {
      this._attributeLocations[name] = gl.getAttribLocation(this._program, name);
    });
  }
  _cacheUniformLocations() {
    const gl = this._renderer.getContext();
    const keys = Object.keys(this._uniforms);
    keys.forEach((key) => {
      this._uniformLocations[key] = gl.getUniformLocation(this._program, key);
    });
  }
  _addPrecisionToSource(source) {
    const maxFloatPrecision = this._renderer.getMaxFloatPrecision();
    let precision = "mediump";
    if (Utils2.isMobile() && maxFloatPrecision === "highp") {
      precision = "highp";
    }
    return `precision ${precision} float;
${source}`;
  }
  _compile() {
    const gl = this._renderer.getContext();
    const vertexShader = this._compileShader(gl.VERTEX_SHADER, this._vertexSource);
    this._vertexShader = vertexShader;
    const fragmentSource = this._addPrecisionToSource(this._fragmentSource);
    const fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, fragmentSource);
    this._fragmentShader = fragmentShader;
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      let errorMessage = gl.getProgramInfoLog(program);
      if (gl.isContextLost())
        errorMessage = "WebGL context lost";
      gl.deleteProgram(program);
      Log2.error(this.constructor.name, `WebGL program linking error: ${errorMessage}`);
    } else {
      this._program = program;
    }
  }
  _compileShader(shaderType, shaderSource) {
    const gl = this._renderer.getContext();
    const shader4 = gl.createShader(shaderType);
    gl.shaderSource(shader4, shaderSource);
    gl.compileShader(shader4);
    const compiled = gl.getShaderParameter(shader4, gl.COMPILE_STATUS);
    if (!compiled) {
      let errorMessage = gl.getShaderInfoLog(shader4);
      if (gl.isContextLost())
        errorMessage = "WebGL context lost";
      gl.deleteShader(shader4);
      Log2.error(this.constructor.name, `WebGL shader compilation error: ${errorMessage}`);
    }
    return shader4;
  }
  setUniform(name, value, sync = false) {
    this._uniforms[name].value = value;
    if (sync) {
      this.syncUniform(name);
    }
  }
  setUniforms(uniforms, sync = false) {
    for (const name in uniforms) {
      this._uniforms[name].value = uniforms[name];
      if (sync) {
        this.syncUniform(name);
      }
    }
  }
  getUniforms() {
    return this._uniforms;
  }
  getAttributes() {
    return this._attributes;
  }
  getAttributeLocations() {
    return this._attributeLocations;
  }
  getProgram() {
    return this._program;
  }
  dispose() {
    const gl = this._renderer.getContext();
    gl.deleteProgram(this._program);
    gl.deleteShader(this._vertexShader);
    gl.deleteShader(this._fragmentShader);
    this._uniforms = null;
    this._uniformLocations = null;
    this._attributes = null;
    this._attributeLocations = null;
    this._renderer.off("context", this._onContextChange);
  }
}
var shader_default = Shader;

// engine/sdk/core/engine/shaders/source/texture.frag
var texture_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = texture2D(u_image, v_texCoord) * v_color;\n}\n";

// engine/sdk/core/engine/shaders/source/texture.vert
var texture_default2 = "attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\nuniform mat3 u_projMatrix;\n\nvoid main() {\n  gl_Position = vec4((u_projMatrix * vec3(a_position, 1)).xy, 0, 1);\n  v_texCoord = a_texCoord;\n  v_color = vec4(a_color.rgb * a_color.a, a_color.a);\n}\n";

// engine/sdk/core/engine/shaders/texture-shader.js
const {UniformType: UniformType2} = constants_exports;
class TextureShader extends shader_default {
  constructor(renderer, vertexSource, fragmentSource) {
    vertexSource = vertexSource || TextureShader.defaultVertexSource;
    fragmentSource = fragmentSource || TextureShader.defaultFragmentSource;
    super(renderer, vertexSource, fragmentSource, TextureShader.defaultUniforms, TextureShader.defaultAttributes);
  }
}
TextureShader.defaultVertexSource = texture_default2;
TextureShader.defaultFragmentSource = texture_default;
const matrix2 = new matrix_default();
TextureShader.defaultUniforms = {
  u_image: {
    type: UniformType2.SAMPLER2D,
    value: 0
  },
  u_projMatrix: {
    type: UniformType2.MAT3,
    value: matrix2.toArray()
  }
};
TextureShader.defaultAttributes = ["a_position", "a_texCoord", "a_color"];
var texture_shader_default = TextureShader;

// engine/sdk/core/engine/filters/filter.js
const {OptionType: OptionType2, UniformType: UniformType3, RendererType: RendererType2} = constants_exports;
class Filter extends configurable_default {
  _initOptions(userOptions = {}) {
    this._shaders = [];
    this._availableUniforms = texture_shader_default.defaultUniforms;
    this._attributes = texture_shader_default.defaultAttributes;
    this._vertexSource = texture_shader_default.defaultVertexSource;
    this._fragmentSource = texture_shader_default.defaultFragmentSource;
    this._initUniforms();
    super._initOptions(userOptions);
  }
  _initUniforms() {
    this._uniforms = {};
    for (const name in this._availableUniforms) {
      const uniform = this._availableUniforms[name];
      this._uniforms[name] = {
        type: uniform.type,
        value: uniform.default || null
      };
    }
    for (const optionName in this.availableOptions) {
      const optionConfig = this.availableOptions[optionName];
      if (!optionConfig.uniformType) {
        log_default.trace(this.constructor.name, `Option \`${optionName}\` is missing a \`uniformType\`!`);
      } else {
        this._uniforms[`u_${optionName}`] = {
          type: optionConfig.uniformType,
          value: optionConfig.default || null
        };
      }
    }
  }
  setOption(optionName, value, update = true) {
    super.setOption(optionName, value, update);
    let uniformValue = value;
    const optionConfig = this.availableOptions[optionName];
    if (!optionConfig.uniformType) {
      return;
    }
    const uniformName = `u_${optionName}`;
    switch (optionConfig.type) {
      case OptionType2.COLOR:
        if (optionConfig.uniformType === UniformType3.FLOAT4) {
          uniformValue = value.toGLColor();
        } else if (optionConfig.uniformType === UniformType3.FLOAT3) {
          uniformValue = value.toRGBGLColor();
        }
        break;
      case OptionType2.VECTOR2:
        uniformValue = [value.x, value.y];
        break;
      case OptionType2.COLOR_MATRIX: {
        uniformValue = [
          value.a,
          value.b,
          value.c,
          value.d,
          value.f,
          value.g,
          value.h,
          value.i,
          value.k,
          value.l,
          value.m,
          value.n,
          value.p,
          value.q,
          value.r,
          value.s
        ];
        const vectorValue = [value.e, value.j, value.o, value.t];
        this._uniforms[`${uniformName}_vec`] = {
          value: vectorValue,
          type: UniformType3.FLOAT4
        };
      }
    }
    this.setUniform(uniformName, uniformValue);
  }
  setUniform(name, value, sync = false) {
    this._uniforms[name].value = value;
  }
  setUniforms(uniforms, sync = false) {
    for (const name in uniforms) {
      this._uniforms[name].value = uniforms[name];
      if (sync) {
        this.syncUniform(name);
      }
    }
  }
  syncUniform(name) {
    this._shaders.forEach((shader4) => {
      shader4.syncUniform(name);
    });
  }
  syncUniforms() {
    this._shaders.forEach((shader4) => {
      shader4.syncUniforms();
    });
  }
  getShaderForRenderer(renderer) {
    const gl = renderer.getContext();
    let shader4 = this._shaders[gl.id];
    if (!shader4) {
      shader4 = new shader_default(renderer, this._vertexSource, this._fragmentSource, this._uniforms, this._attributes);
      this._shaders[gl.id] = shader4;
    }
    return shader4;
  }
  apply(renderer, inputTarget, outputTarget, clear = false) {
    if (renderer.isOfType(RendererType2.WEBGL)) {
      this._applyWebGL(renderer, inputTarget, outputTarget, clear);
    } else if (renderer.isOfType(RendererType2.CANVAS)) {
      this._applyCanvas(renderer, inputTarget, outputTarget, clear);
    }
  }
  _applyWebGL(renderer, inputTarget, outputTarget, clear = false) {
    const gl = renderer.getContext();
    const shader4 = this.getShaderForRenderer(renderer);
    renderer.setRenderTarget(outputTarget);
    if (clear) {
      outputTarget.clear();
    }
    renderer.setShader(shader4);
    const projectionMatrix = renderer.getCurrentRenderTarget().getProjectionMatrix().toArray();
    shader4.setUniform("u_projMatrix", projectionMatrix);
    shader4.syncUniforms();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputTarget.getTexture());
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const outputContext = outputTarget.getContext();
    log_default.warn(this.constructor.name, "`_applyCanvas` is not implemented. Just copying image data from `inputTarget` to `outputTarget`.");
    outputContext.clearRect(0, 0, canvas9.width, canvas9.height);
    outputContext.drawImage(canvas9, 0, 0);
  }
  dispose() {
    this._shaders.forEach((shader4) => shader4.dispose());
    this._shaders = [];
  }
  _blurImage(inputTarget, outputTarget, blurIntensity) {
    const blurWidth = 10;
    const inputCanvas = inputTarget.getCanvas();
    const downScale = Math.min(1, blurWidth / (blurIntensity * Math.min(inputCanvas.width, inputCanvas.height)));
    const scaleCanvas = utils_default.createCanvas();
    scaleCanvas.width = Math.round(inputCanvas.width * downScale);
    scaleCanvas.height = Math.round(inputCanvas.height * downScale);
    const scaleContext = scaleCanvas.getContext("2d");
    scaleContext.drawImage(inputCanvas, 0, 0, inputCanvas.width, inputCanvas.height, 0, 0, scaleCanvas.width, scaleCanvas.height);
    const radius = blurIntensity * Math.min(scaleCanvas.width, scaleCanvas.height);
    const blurryImageData = scaleContext.getImageData(0, 0, scaleCanvas.width, scaleCanvas.height);
    stackBlurCanvasRGBA(blurryImageData, 0, 0, scaleCanvas.width, scaleCanvas.height, radius);
    scaleContext.putImageData(blurryImageData, 0, 0);
    outputTarget.getContext().drawImage(scaleCanvas, 0, 0, scaleCanvas.width, scaleCanvas.height, 0, 0, inputCanvas.width, inputCanvas.height);
  }
}
var filter_default = Filter;

// engine/sdk/core/engine/filters/source/unpremultiply.frag
var unpremultiply_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(color.a > 0. ? color.rgb / color.a : vec3(0), color.a);\n}\n";

// engine/sdk/core/engine/filters/unpremultiply-filter.js
class UnpremultiplyFilter extends filter_default {
  constructor() {
    super();
    this._fragmentSource = unpremultiply_default;
  }
}

// engine/sdk/core/engine/filters/source/color-overlay.frag
var color_overlay_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform vec4 u_color;\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(mix(color.rgb, u_color.rgb, u_color.a), color.a) * color.a;\n}\n";

// engine/sdk/core/engine/filters/color-overlay-filter.js
const {OptionType: OptionType3, UniformType: UniformType4} = constants_exports;
class ColorOverlayFilter extends filter_default {
  constructor(...args) {
    super(...args);
    this._fragmentSource = color_overlay_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const {color: color6} = this._options;
    const inputImageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const outputImageData = outputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const pixelCount = canvas9.width * canvas9.height;
    const inputColor = new color_default();
    const outputColor = new color_default();
    for (let i = 0; i < pixelCount * 4; i += 4) {
      inputColor.set(inputImageData.data[i] / 255, inputImageData.data[i + 1] / 255, inputImageData.data[i + 2] / 255, inputImageData.data[i + 3] / 255);
      outputColor.set(outputImageData.data[i] / 255, outputImageData.data[i + 1] / 255, outputImageData.data[i + 2] / 255, outputImageData.data[i + 3] / 255);
      const newR = outputColor.r + inputColor.a * (inputColor.r - outputColor.r);
      outputImageData.data[i] = (newR + inputColor.a * (color6.r - newR)) * 255;
      const newG = outputColor.g + inputColor.a * (inputColor.g - outputColor.g);
      outputImageData.data[i + 1] = (newG + inputColor.a * (color6.g - newG)) * 255;
      const newB = outputColor.b + inputColor.a * (inputColor.b - outputColor.b);
      outputImageData.data[i + 2] = (newB + inputColor.a * (color6.b - newB)) * 255;
    }
    outputContext.putImageData(outputImageData, 0, 0);
  }
}
ColorOverlayFilter.prototype.availableOptions = {
  color: {
    type: OptionType3.COLOR,
    default: color_default.WHITE,
    uniformType: UniformType4.FLOAT4
  }
};
var color_overlay_filter_default = ColorOverlayFilter;

// engine/sdk/core/engine/filters/source/tint.frag
var tint_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform vec4 u_color;\nuniform int u_mode;\n\nvec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  if (u_mode == 0) {\n    gl_FragColor = color * color.a;\n  } else if (u_mode == 1) {\n    gl_FragColor = vec4(mix(color.rgb, u_color.rgb, u_color.a), color.a) * color.a;\n  } else if (u_mode == 2) {\n    float luminance = dot(color.rgb, W);\n    vec3 colorized = vec3(luminance) * u_color.rgb;\n    gl_FragColor = vec4(mix(color.rgb, colorized, u_color.a), color.a) * color.a;\n  }\n}\n";

// engine/sdk/core/engine/filters/tint-filter.js
const {OptionType: OptionType4, UniformType: UniformType5} = constants_exports;
class TintFilter extends filter_default {
  constructor(...args) {
    super(...args);
    this._fragmentSource = tint_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {mode, color: color6} = this._options;
    const {r, g, b, a} = color6;
    const W = [0.2125, 0.7154, 0.0721];
    switch (mode) {
      case TintFilter.MODES.SOLID:
        for (let i = 0; i < canvas9.width * canvas9.height; i++) {
          const index = i * 4;
          imageData.data[index] += (r * 255 - imageData.data[index]) * a;
          imageData.data[index + 1] += (g * 255 - imageData.data[index + 1]) * a;
          imageData.data[index + 2] += (b * 255 - imageData.data[index + 2]) * a;
        }
        break;
      case TintFilter.MODES.COLORIZED:
        for (let i = 0; i < canvas9.width * canvas9.height; i++) {
          const index = i * 4;
          const luminance = imageData.data[index] / 255 * W[0] + imageData.data[index + 1] / 255 * W[1] + imageData.data[index + 2] / 255 * W[2];
          const colorized = new color_default(luminance * r, luminance * g, luminance * b);
          imageData.data[index] += (colorized.r * 255 - imageData.data[index]) * a;
          imageData.data[index + 1] += (colorized.g * 255 - imageData.data[index + 1]) * a;
          imageData.data[index + 2] += (colorized.b * 255 - imageData.data[index + 2]) * a;
        }
        break;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
TintFilter.MODES = {
  NONE: 0,
  SOLID: 1,
  COLORIZED: 2
};
TintFilter.prototype.availableOptions = {
  color: {
    type: OptionType4.COLOR,
    default: color_default.WHITE,
    uniformType: UniformType5.FLOAT4
  },
  mode: {
    type: OptionType4.NUMBER,
    default: TintFilter.MODES.NONE,
    uniformType: UniformType5.INT
  }
};
var tint_filter_default = TintFilter;

// engine/sdk/core/engine/filters/source/overlay.frag
var overlay_default = "uniform sampler2D u_image;\nvarying vec2 v_texCoord;\nuniform sampler2D u_overlayImage;\nuniform int u_blendMode;\nuniform float u_alpha;\n\nconst float EPSILON = 0.000001;\n\nvec4 overlay(vec4 a, vec4 b) {\n    vec3 result = mix(\n          1.0 - 2.0 * (1.0 - a.rgb) * (1.0 - b.rgb),\n          2.0 * a.rgb * b.rgb,\n          vec3(a.r < 0.5, a.g < 0.5, a.b < 0.5)\n      );\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 hardLight(vec4 b, vec4 a) {\n    vec3 result = mix(\n          1.0 - 2.0 * (1.0 - a.rgb) * (1.0 - b.rgb),\n          2.0 * a.rgb * b.rgb,\n          vec3(a.r < 0.5, a.g < 0.5, a.b < 0.5)\n      );\n    return mix(b, vec4(result, b.a), u_alpha * a.a);\n}\n\nvec4 softLight(vec4 a, vec4 b) {\n    vec3 result = mix(\n          2.0 * a.rgb * (1.0 - b.rgb) + (2.0 * b.rgb - 1.0) * sqrt(a.rgb),\n          2.0 * a.rgb * b.rgb + a.rgb * a.rgb * (1.0 - 2.0 * b.rgb),\n          vec3(b.r < 0.5, b.g < 0.5, b.b < 0.5)\n      );\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 multiply(vec4 a, vec4 b) {\n    vec3 result = a.rgb * b.rgb;\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 darken(vec4 a, vec4 b) {\n    vec3 result = min(a.rgb, b.rgb);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 lighten(vec4 a, vec4 b) {\n    vec3 result = max(a.rgb, b.rgb);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 screen(vec4 a, vec4 b) {\n    vec3 result = 1.0 - (1.0 - a.rgb) * (1.0 - b.rgb);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 colorBurn(vec4 a, vec4 b) {\n    vec3 result = clamp(1.0 - (1.0 - a.rgb) / max(b.rgb, EPSILON), 0.0, 1.0);\n    return mix(a, vec4(result, a.a), u_alpha * b.a);\n}\n\nvec4 normal(vec4 a, vec4 b) {\n    return mix(a, vec4(b.rgb, a.a), u_alpha * b.a);\n}\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  vec4 overlayColor = texture2D(u_overlayImage, v_texCoord);\n\n  vec4 resultColor;\n  if (u_blendMode == 0) {\n    resultColor = normal(color, overlayColor);\n  } else if (u_blendMode == 1) {\n    resultColor = overlay(color, overlayColor);\n  } else if (u_blendMode == 2) {\n    resultColor = hardLight(color, overlayColor);\n  } else if (u_blendMode == 3) {\n    resultColor = softLight(color, overlayColor);\n  } else if (u_blendMode == 4) {\n    resultColor = multiply(color, overlayColor);\n  } else if (u_blendMode == 5) {\n    resultColor = darken(color, overlayColor);\n  } else if (u_blendMode == 6) {\n    resultColor = lighten(color, overlayColor);\n  } else if (u_blendMode == 7) {\n    resultColor = screen(color, overlayColor);\n  } else if (u_blendMode == 8) {\n    resultColor = colorBurn(color, overlayColor);\n  }\n  gl_FragColor = vec4(resultColor.rgb * resultColor.a, resultColor.a);\n}\n";

// engine/sdk/core/engine/filters/overlay-filter.js
const {OptionType: OptionType5, UniformType: UniformType6} = constants_exports;
const EPSILON = 1e-6;
class OverlayFilter extends filter_default {
  constructor(...args) {
    super(...args);
    this._fragmentSource = overlay_default;
    this._lastImage = null;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const overlayContext = this._options.overlayTexture.getRenderTarget().getContext();
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const overlayImageData = overlayContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {blendMode, alpha} = this._options;
    const inputColor = new color_default();
    const overlayColor = new color_default();
    const outputColor = new color_default();
    for (let i = 0; i < canvas9.width * canvas9.height * 4; i += 4) {
      inputColor.set(imageData.data[i] / 255, imageData.data[i + 1] / 255, imageData.data[i + 2] / 255, imageData.data[i + 3] / 255);
      overlayColor.set(overlayImageData.data[i] / 255, overlayImageData.data[i + 1] / 255, overlayImageData.data[i + 2] / 255, overlayImageData.data[i + 3] / 255);
      let rA;
      let rB;
      let newR;
      let gA;
      let gB;
      let newG;
      let bA;
      let bB;
      let newB;
      switch (blendMode) {
        case OverlayFilter.BLEND_MODES.NORMAL:
          outputColor.set(inputColor.r + overlayColor.a * alpha * (overlayColor.r - inputColor.r), inputColor.g + overlayColor.a * alpha * (overlayColor.g - inputColor.g), inputColor.b + overlayColor.a * alpha * (overlayColor.b - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.OVERLAY:
          rA = 1 - 2 * (1 - inputColor.r) * (1 - overlayColor.r);
          rB = 2 * inputColor.r * overlayColor.r;
          newR = rA + (inputColor.r < 0.5 ? 1 : 0) * (rB - rA);
          gA = 1 - 2 * (1 - inputColor.g) * (1 - overlayColor.g);
          gB = 2 * inputColor.g * overlayColor.g;
          newG = gA + (inputColor.g < 0.5 ? 1 : 0) * (gB - gA);
          bA = 1 - 2 * (1 - inputColor.b) * (1 - overlayColor.b);
          bB = 2 * inputColor.b * overlayColor.b;
          newB = bA + (inputColor.b < 0.5 ? 1 : 0) * (bB - bA);
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.HARD_LIGHT:
          rA = 1 - 2 * (1 - overlayColor.r) * (1 - inputColor.r);
          rB = 2 * overlayColor.r * inputColor.r;
          newR = rA + (overlayColor.r < 0.5 ? 1 : 0) * (rB - rA);
          gA = 1 - 2 * (1 - overlayColor.g) * (1 - inputColor.g);
          gB = 2 * overlayColor.g * inputColor.g;
          newG = gA + (overlayColor.g < 0.5 ? 1 : 0) * (gB - gA);
          bA = 1 - 2 * (1 - overlayColor.b) * (1 - inputColor.b);
          bB = 2 * overlayColor.b * inputColor.b;
          newB = bA + (overlayColor.b < 0.5 ? 1 : 0) * (bB - bA);
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.SOFT_LIGHT:
          rA = 2 * inputColor.r * (1 - overlayColor.r) + (2 * overlayColor.r - 1) * Math.sqrt(inputColor.r);
          rB = 2 * inputColor.r * overlayColor.r + inputColor.r * inputColor.r * (1 - 2 * overlayColor.r);
          newR = rA + (overlayColor.r < 0.5 ? 1 : 0) * (rB - rA);
          gA = 2 * inputColor.g * (1 - overlayColor.g) + (2 * overlayColor.g - 1) * Math.sqrt(inputColor.g);
          gB = 2 * inputColor.g * overlayColor.g + inputColor.g * inputColor.g * (1 - 2 * overlayColor.g);
          newG = gA + (overlayColor.g < 0.5 ? 1 : 0) * (gB - gA);
          bA = 2 * inputColor.b * (1 - overlayColor.b) + (2 * overlayColor.b - 1) * Math.sqrt(inputColor.b);
          bB = 2 * inputColor.b * overlayColor.b + inputColor.b * inputColor.b * (1 - 2 * overlayColor.b);
          newB = bA + (overlayColor.b < 0.5 ? 1 : 0) * (bB - bA);
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.MULTIPLY:
          newR = inputColor.r * overlayColor.r;
          newG = inputColor.g * overlayColor.g;
          newB = inputColor.b * overlayColor.b;
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.DARKEN:
          newR = Math.min(inputColor.r, overlayColor.r);
          newG = Math.min(inputColor.g, overlayColor.g);
          newB = Math.min(inputColor.b, overlayColor.b);
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.LIGHTEN:
          newR = Math.max(inputColor.r, overlayColor.r);
          newG = Math.max(inputColor.g, overlayColor.g);
          newB = Math.max(inputColor.b, overlayColor.b);
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.SCREEN:
          newR = 1 - (1 - inputColor.r) * (1 - overlayColor.r);
          newG = 1 - (1 - inputColor.g) * (1 - overlayColor.g);
          newB = 1 - (1 - inputColor.b) * (1 - overlayColor.b);
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
        case OverlayFilter.BLEND_MODES.COLOR_BURN:
          newR = Math.max(0, Math.min(1, 1 - (1 - inputColor.r) / Math.max(overlayColor.r, EPSILON)));
          newG = Math.max(0, Math.min(1, 1 - (1 - inputColor.g) / Math.max(overlayColor.g, EPSILON)));
          newB = Math.max(0, Math.min(1, 1 - (1 - inputColor.b) / Math.max(overlayColor.b, EPSILON)));
          outputColor.set(inputColor.r + overlayColor.a * alpha * (newR - inputColor.r), inputColor.g + overlayColor.a * alpha * (newG - inputColor.g), inputColor.b + overlayColor.a * alpha * (newB - inputColor.b), inputColor.a);
          break;
      }
      imageData.data[i] = outputColor.r * 255;
      imageData.data[i + 1] = outputColor.g * 255;
      imageData.data[i + 2] = outputColor.b * 255;
      imageData.data[i + 3] = outputColor.a * 255;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
OverlayFilter.BLEND_MODES = {
  NORMAL: 0,
  OVERLAY: 1,
  HARD_LIGHT: 2,
  SOFT_LIGHT: 3,
  MULTIPLY: 4,
  DARKEN: 5,
  LIGHTEN: 6,
  SCREEN: 7,
  COLOR_BURN: 8
};
OverlayFilter.prototype.availableOptions = {
  blendMode: {
    type: OptionType5.NUMBER,
    default: OverlayFilter.BLEND_MODES.NORMAL,
    uniformType: UniformType6.INT
  },
  overlayImage: {
    type: OptionType5.NUMBER,
    required: true,
    uniformType: UniformType6.SAMPLER2D
  },
  overlayTexture: {type: OptionType5.OBJECT, required: true},
  alpha: {
    type: OptionType5.NUMBER,
    default: 1,
    uniformType: UniformType6.FLOAT
  }
};
var overlay_filter_default = OverlayFilter;

// engine/sdk/core/engine/filters/index.js
const filters_exports = {};
__export(filters_exports, {
  ColorOverlayFilter: () => color_overlay_filter_default,
  OverlayFilter: () => overlay_filter_default,
  TintFilter: () => tint_filter_default,
  UnpremultiplyFilter: () => UnpremultiplyFilter
});

// engine/sdk/core/engine/textures/base-texture.js
class BaseTexture extends event_emitter_default {
  constructor(source) {
    super();
    this.id = BaseTexture.id++;
    this._onSourceLoaded = this._onSourceLoaded.bind(this);
    this._renderers = [];
    this._glTextures = {};
    this._source = source;
    this._dirty = true;
    this._glUnit = 0;
    this._mipMapping = false;
    this._magFilter = BaseTexture.DefaultMagFilter;
    this._minFilter = BaseTexture.DefaultMinFilter;
    this._repeatX = BaseTexture.ClampToEdge;
    this._repeatY = BaseTexture.ClampToEdge;
    this._pixelRatio = 1;
    this._loaded = false;
    this._frame = new rectangle_default(0, 0, 100, 100);
    if (source) {
      this._loadSource();
    }
  }
  resizeTo(dimensions) {
    if (this._frame.width === dimensions.x && this._frame.height === dimensions.y) {
      return;
    }
    this._frame.width = dimensions.x;
    this._frame.height = dimensions.y;
    this._dirty = true;
  }
  _loadSource() {
    const source = this._source;
    const sourceLoaded = source.complete;
    const sourceIsCanvas = source.constructor.name === "Canvas" || source.tagName && source.tagName.toUpperCase() === "CANVAS";
    if (sourceLoaded || sourceIsCanvas) {
      return this._onSourceLoaded();
    }
    source.addEventListener && source.addEventListener("load", this._onSourceLoaded);
  }
  _onSourceLoaded() {
    this._loaded = true;
    this.emit("loaded");
    this.update();
  }
  _updateGLFilters() {
    const sourceDimensions = new vector2_default(this._source.width, this._source.height);
    if (utils_default.isPowerOfTwo(sourceDimensions)) {
      log_default.info(this.constructor.name, "Mip-mapping enabled");
      this._minFilter = BaseTexture.TrilinearFilter;
      this._mipMapping = true;
    } else {
      this._minFilter = BaseTexture.LinearFilter;
      this._mipMapping = false;
    }
  }
  update() {
    if (this._frame.width !== this._source.width || this._frame.height !== this._source.height) {
      this._frame = new rectangle_default(0, 0, this._source.width, this._source.height);
      this._dirty = true;
    }
    this._updateGLFilters();
    this.emit("update");
  }
  getRenderers() {
    return [...this._renderers];
  }
  getGLFilter(gl, minOrMag) {
    switch (minOrMag) {
      case "min":
        return this.constructor.getGLFilter(gl, this._minFilter);
      case "mag":
        return this.constructor.getGLFilter(gl, this._magFilter);
    }
  }
  static getGLFilter(gl, filterEnum) {
    switch (filterEnum) {
      case BaseTexture.LinearFilter:
        return gl.LINEAR;
      case BaseTexture.NearestFilter:
        return gl.NEAREST;
      case BaseTexture.BilinearFilter:
        return gl.LINEAR_MIPMAP_NEAREST;
      case BaseTexture.TrilinearFilter:
        return gl.LINEAR_MIPMAP_LINEAR;
    }
  }
  isLoaded() {
    return this._loaded;
  }
  setLoaded(loaded) {
    this._loaded = loaded;
  }
  getSource() {
    return this._source;
  }
  setSource(source) {
    this._source = source;
  }
  getGLTextureForRenderer(renderer) {
    return this._glTextures[renderer.id];
  }
  setGLTextureForRenderer(texture5, renderer) {
    this._renderers[renderer.id] = renderer;
    this._glTextures[renderer.id] = texture5;
  }
  getFrame() {
    return this._frame;
  }
  setFrame(frame2) {
    this._frame = frame2;
  }
  getDimensions() {
    return new vector2_default(this._frame.width, this._frame.height);
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
  }
  getGLUnit() {
    return this._glUnit;
  }
  setGLUnit(glUnit) {
    this._glUnit = glUnit;
  }
  setMinFilter(minFilter) {
    this._minFilter = minFilter;
  }
  getMinFilter() {
    return this._minFilter;
  }
  setMagFilter(magFilter) {
    this._magFilter = magFilter;
  }
  getMagFilter() {
    return this._magFilter;
  }
  setRepeatX(repeat) {
    this._repeatX = repeat;
  }
  getRepeatX() {
    return this._repeatX;
  }
  setRepeatY(repeat) {
    this._repeatY = repeat;
  }
  getRepeatY() {
    return this._repeatY;
  }
  getGLRepeat(gl, direction) {
    const value = direction === "x" ? this.getRepeatX() : this.getRepeatY();
    switch (value) {
      case BaseTexture.ClampToEdge:
        return gl.CLAMP_TO_EDGE;
      case BaseTexture.Repeat:
        return gl.REPEAT;
      case BaseTexture.MirroredRepeat:
        return gl.MIRRORED_REPEAT;
    }
  }
  isDirty() {
    return this._dirty;
  }
  setDirty(dirty) {
    this._dirty = dirty;
  }
  disposeGLTextures() {
    this._renderers.forEach((renderer) => {
      this.disposeGLTexturesForRenderer(renderer);
    });
  }
  disposeGLTexturesForRenderer(renderer) {
    if (!this._glTextures[renderer.id])
      return;
    const gl = renderer.getContext();
    gl.deleteTexture(this._glTextures[renderer.id]);
    delete this._glTextures[renderer.id];
    if (!this._renderers[renderer.id]) {
      delete this._renderers[renderer.id];
    }
  }
  isMipMappingEnabled() {
    return this._mipMapping;
  }
  setMipMappingEnabled(enabled) {
    this._mipMapping = enabled;
  }
  dispose(renderer = null) {
    this.disposeGLTextures();
    this._source = void 0;
  }
}
BaseTexture.NearestFilter = 0;
BaseTexture.LinearFilter = 1;
BaseTexture.BilinearFilter = 2;
BaseTexture.TrilinearFilter = 3;
BaseTexture.DefaultMagFilter = BaseTexture.NearestFilter;
BaseTexture.DefaultMinFilter = BaseTexture.LinearFilter;
BaseTexture.ClampToEdge = 0;
BaseTexture.Repeat = 1;
BaseTexture.MirroredRepeat = 2;
BaseTexture.id = 0;
var base_texture_default = BaseTexture;

// engine/sdk/core/engine/utils/canvas-render-target.js
class CanvasRenderTarget {
  constructor(width, height, pixelRatio, canvas9, context) {
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this._baseTexture = new base_texture_default();
    this._canvas = canvas9 || this._createCanvas();
    this._context = context || this._canvas.getContext("2d");
    this._baseTexture.setSource(this._canvas);
    this._canvas.width = this._width * this._pixelRatio;
    this._canvas.height = this._height * this._pixelRatio;
    this._filterStack = [
      {
        renderTarget: this,
        filter: []
      }
    ];
  }
  _createCanvas() {
    return utils_default.createCanvas();
  }
  clear() {
    const ctx = this._context;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  resizeTo(dimensions) {
    this._baseTexture.resizeTo(dimensions);
    if (this._width !== dimensions.x) {
      this._width = dimensions.x;
      this._canvas.width = this._width * this._pixelRatio;
    }
    if (this._height !== dimensions.y) {
      this._height = dimensions.y;
      this._canvas.height = this._height * this._pixelRatio;
    }
  }
  getCanvas() {
    return this._canvas;
  }
  getContext() {
    return this._context;
  }
  getFilterStack() {
    return this._filterStack;
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
  }
  getDimensions() {
    return new vector2_default(this._width, this._height);
  }
  getBaseTexture() {
    return this._baseTexture;
  }
  dispose() {
    this._canvas = null;
    this._context = null;
    this._baseTexture.dispose();
  }
}
var canvas_render_target_default = CanvasRenderTarget;

// engine/sdk/core/engine/managers/canvas-filter-manager.js
class CanvasFilterManager {
  constructor(renderer) {
    this._renderer = renderer;
    this._filterStack = [
      {
        renderTarget: renderer.getCurrentRenderTarget(),
        filters: []
      }
    ];
    this._currentFrame = null;
    this._textures = [];
    this._textureFrame = new rectangle_default(0, 0, renderer.getWidth(), renderer.getHeight());
  }
  resizeTo(dimensions) {
    this._textureFrame.width = dimensions.x;
    this._textureFrame.height = dimensions.y;
    this._textures.forEach((texture5) => texture5.resizeTo(dimensions));
  }
  pushFilters(displayObject, filters) {
    const bounds = displayObject.getBounds();
    this._currentFrame = bounds;
    const renderTarget = this._getOrCreateRenderTarget();
    this._renderer.setRenderTarget(renderTarget);
    this._filterStack.push({renderTarget, filters});
    renderTarget.clear();
  }
  popFilters() {
    const {filters, renderTarget} = this._filterStack.pop();
    const lastFilter = this._filterStack[this._filterStack.length - 1];
    const inputRenderTarget = renderTarget;
    const outputRenderTarget = lastFilter.renderTarget;
    if (filters.length === 1) {
      filters[0].apply(this._renderer, inputRenderTarget, outputRenderTarget);
      this._textures.push(inputRenderTarget);
    } else {
      this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
    }
    return filters;
  }
  _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
    let flipRenderTarget = inputRenderTarget;
    let flopRenderTarget = this._getOrCreateRenderTarget(true);
    const lastFilter = filters[filters.length - 1];
    filters.forEach((filter40, i) => {
      const isLastFilter = filter40 === lastFilter;
      if (!isLastFilter) {
        filter40.apply(this._renderer, flipRenderTarget, flopRenderTarget);
        const temp = flipRenderTarget;
        flipRenderTarget = flopRenderTarget;
        flopRenderTarget = temp;
      } else {
        filter40.apply(this._renderer, flipRenderTarget, outputRenderTarget);
      }
    });
    this._textures.push(flipRenderTarget);
    this._textures.push(flopRenderTarget);
  }
  _getOrCreateRenderTarget(clear) {
    let renderTarget = this._textures.pop();
    if (!renderTarget) {
      renderTarget = new canvas_render_target_default(this._textureFrame.width, this._textureFrame.height, 1);
    }
    if (clear) {
      renderTarget.clear();
    }
    return renderTarget;
  }
  setFilterStack(filterStack) {
    this._filterStack = filterStack;
  }
  dispose() {
  }
}
var canvas_filter_manager_default = CanvasFilterManager;

// engine/sdk/core/engine/utils/quad.js
class Quad {
  constructor(renderer) {
    this._renderer = renderer;
    this._context = this._renderer.getContext();
    this._vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);
    this._uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
    this._indices = new Uint16Array([0, 1, 2, 0, 3, 2]);
    this._colors = new Float32Array([
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ]);
    this._initBuffers();
    this._uploadBuffers();
  }
  map(rect1, rect2) {
    const {x, y} = rect2;
    this._uvs[2] = rect2.width / rect1.width;
    this._uvs[4] = this._uvs[2];
    this._uvs[5] = rect2.height / rect1.height;
    this._uvs[7] = this._uvs[5];
    this._vertices[0] = x;
    this._vertices[1] = y;
    this._vertices[2] = x + rect2.width;
    this._vertices[3] = y;
    this._vertices[4] = this._vertices[2];
    this._vertices[5] = y + rect2.height;
    this._vertices[6] = x;
    this._vertices[7] = this._vertices[5];
    this._uploadBuffers();
  }
  _initBuffers() {
    const gl = this._context;
    if (this._vertexBuffer) {
      gl.deleteBuffer(this._vertexBuffer);
      this._vertexBuffer = null;
    }
    if (this._indexBuffer) {
      gl.deleteBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    this._vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);
    this._indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
  }
  _uploadBuffers() {
    const gl = this._context;
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this._uvs);
    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this._colors);
  }
  getVertexBuffer() {
    return this._vertexBuffer;
  }
  getIndexBuffer() {
    return this._indexBuffer;
  }
  dispose() {
    const gl = this._context;
    if (this._vertexBuffer) {
      gl.deleteBuffer(this._vertexBuffer);
      this._vertexBuffer = null;
    }
    if (this._indexBuffer) {
      gl.deleteBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
  }
}
var quad_default = Quad;

// engine/sdk/core/engine/utils/webgl-render-target.js
class WebGLRenderTarget {
  constructor(renderer, width, height, pixelRatio, isRoot = false) {
    this._renderer = renderer;
    this._gl = renderer.getContext();
    this._width = width;
    this._height = height;
    this._frame = null;
    this._pixelRatio = pixelRatio;
    this._projectionMatrix = new matrix_default();
    this._mipMapping = false;
    this._baseTexture = new base_texture_default();
    const frame2 = this._baseTexture.getFrame();
    frame2.width = width;
    frame2.height = height;
    this._baseTexture.setPixelRatio(pixelRatio);
    this._baseTexture.setLoaded(true);
    this._framebuffer = null;
    this._isRoot = isRoot;
    this._filterStack = [
      {
        renderTarget: this,
        filter: []
      }
    ];
    if (!isRoot) {
      this._initFrameBuffer();
    }
  }
  resizeTo(dimensions) {
    this._width = dimensions.x | 0;
    this._height = dimensions.y | 0;
    this._baseTexture.resizeTo(dimensions);
    if (!this._isRoot) {
      this._resizeTexture();
    }
    this._baseTexture.setMinFilter(this._getMinFilter());
    this._baseTexture.setMagFilter(this._getMagFilter());
    this._calculateProjectionMatrix();
  }
  _getMinFilter() {
    let minFilter = base_texture_default.DefaultMinFilter;
    if (this._mipMapping) {
      minFilter = base_texture_default.TrilinearFilter;
    }
    return minFilter;
  }
  _getMagFilter() {
    return base_texture_default.DefaultMagFilter;
  }
  _resizeTexture() {
    const gl = this._gl;
    const realWidth = this._width * this._pixelRatio;
    const realHeight = this._height * this._pixelRatio;
    if (this._texture) {
      gl.deleteTexture(this._texture);
      this._texture = null;
    }
    this._texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, realWidth, realHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);
    this._baseTexture.setGLTextureForRenderer(this._texture, this._renderer);
    if (this._renderer._options.debug) {
      gl_utils_default.checkFramebufferStatus("WebGLRenderTarget#_initFramebuffer", gl);
    }
    const dimensions = new vector2_default(this._width, this._height);
    if (utils_default.isPowerOfTwo(dimensions)) {
      log_default.info("WebGLRenderTarget", "Mip-mapping enabled");
      this._mipMapping = true;
    } else {
      this._mipMapping = false;
    }
    this._baseTexture.setMipMappingEnabled(this._mipMapping);
  }
  activate() {
    const gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
    this._calculateProjectionMatrix();
    gl.viewport(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
    gl.disable(gl.STENCIL_TEST);
  }
  clear(color6 = color_default.TRANSPARENT) {
    const gl = this._gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
    if (this._renderer._options.debug) {
      gl_utils_default.checkFramebufferStatus("WebGLRenderTarget#clear", gl);
    }
    gl.clearColor.apply(gl, color6.toGLColor());
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  _calculateProjectionMatrix() {
    const projectionMatrix = this._projectionMatrix;
    projectionMatrix.reset();
    const frame2 = this._frame || new rectangle_default(0, 0, this._width, this._height);
    const {x, y} = frame2;
    if (!this._isRoot) {
      projectionMatrix.a = 1 / this._width * 2;
      projectionMatrix.d = 1 / this._height * 2;
      projectionMatrix.tx = -1 - x * projectionMatrix.a;
      projectionMatrix.ty = -1 - y * projectionMatrix.d;
    } else {
      projectionMatrix.a = 1 / this._width * 2;
      projectionMatrix.d = -1 / this._height * 2;
      projectionMatrix.tx = -1 - x * projectionMatrix.a;
      projectionMatrix.ty = 1 - y * projectionMatrix.d;
    }
  }
  _initFrameBuffer() {
    const gl = this._gl;
    if (this._framebuffer) {
      gl.deleteFramebuffer(this._framebuffer);
      this._framebuffer = null;
    }
    if (this._texture) {
      gl.deleteTexture(this._texture);
      this._texture = null;
    }
    this._framebuffer = gl.createFramebuffer();
    this._texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);
    this._baseTexture.setGLTextureForRenderer(this._texture, this._renderer);
    this.resizeTo(new vector2_default(this._width, this._height));
    if (this._renderer._options.debug) {
      gl_utils_default.checkFramebufferStatus("WebGLRenderTarget#_initFramebuffer", gl);
    }
  }
  getProjectionMatrix() {
    return this._projectionMatrix;
  }
  getTexture() {
    return this._texture;
  }
  getFrame() {
    return this._frame;
  }
  setFrame(frame2) {
    this._frame = frame2;
  }
  getFilterStack() {
    return this._filterStack;
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    if (!this._isRoot) {
      this._resizeTexture();
    }
  }
  getBaseTexture() {
    return this._baseTexture;
  }
  dispose() {
    const gl = this._gl;
    this._baseTexture.dispose();
    if (this._framebuffer) {
      gl.deleteFramebuffer(this._framebuffer);
      this._framebuffer = null;
    }
    if (this._texture) {
      gl.deleteTexture(this._texture);
      this._texture = null;
    }
  }
}
var webgl_render_target_default = WebGLRenderTarget;

// engine/sdk/core/engine/managers/webgl-filter-manager.js
const {RendererType: RendererType3} = constants_exports;
class WebGLFilterManager {
  constructor(renderer) {
    this._renderer = renderer;
    this._filterStack = [
      {
        filters: []
      }
    ];
    this._currentFrame = null;
    this._renderTargets = [];
    this._textureFrame = new rectangle_default(0, 0, renderer.getWidth(), renderer.getHeight());
    this._onContextChange = this._onContextChange.bind(this);
    this._renderer.on("context", this._onContextChange);
    this._onContextChange();
  }
  resizeTo(dimensions) {
    this._textureFrame.width = dimensions.x;
    this._textureFrame.height = dimensions.y;
    this._renderTargets.forEach((texture5) => texture5.resizeTo(dimensions));
  }
  getFilterStack() {
    return this._filterStack;
  }
  setFilterStack(filterStack) {
    this._filterStack = filterStack;
  }
  _getOrCreateRenderTarget(clear) {
    let renderTarget = this._renderTargets.pop();
    if (!renderTarget) {
      renderTarget = new webgl_render_target_default(this._renderer, this._textureFrame.width, this._textureFrame.height, 1);
    }
    renderTarget.setFrame(this._currentFrame);
    if (clear) {
      renderTarget.clear();
    }
    return renderTarget;
  }
  pushFilters(displayObject, filters) {
    const bounds = displayObject.getBounds();
    this._currentFrame = bounds;
    const filterRectangle = displayObject.getFilterRectangle();
    if (filterRectangle.width > 0 && filterRectangle.height > 0) {
      this._currentFrame = filterRectangle;
    }
    const renderTarget = this._getOrCreateRenderTarget();
    this._renderer.setRenderTarget(renderTarget);
    renderTarget.clear();
    this._filterStack.push({renderTarget, filters});
  }
  popFilters() {
    const {filters, renderTarget} = this._filterStack.pop();
    const lastFilter = this._filterStack[this._filterStack.length - 1];
    const inputRenderTarget = renderTarget;
    const outputRenderTarget = lastFilter.renderTarget;
    this._quad.map(this._textureFrame, inputRenderTarget.getFrame());
    const shader4 = filters[0].getShaderForRenderer(this._renderer);
    const vertexBuffer = this._quad.getVertexBuffer();
    const indexBuffer = this._quad.getIndexBuffer();
    const gl = this._renderer.getContext();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    const attributeLocations = shader4.getAttributeLocations();
    gl.vertexAttribPointer(attributeLocations.a_position, 2, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(attributeLocations.a_texCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
    gl.vertexAttribPointer(attributeLocations.a_color, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
    this._renderer.updateTexture(inputRenderTarget.getBaseTexture(), false);
    if (filters.length === 1) {
      filters[0].apply(this._renderer, inputRenderTarget, outputRenderTarget);
      this._renderTargets.push(inputRenderTarget);
    } else {
      this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
    }
    return filters;
  }
  _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
    let flipRenderTarget = inputRenderTarget;
    let flopRenderTarget = this._getOrCreateRenderTarget(true);
    this._renderer.updateTexture(flopRenderTarget.getBaseTexture(), false);
    const lastFilter = filters[filters.length - 1];
    filters.forEach((filter40, i) => {
      const isLastFilter = filter40 === lastFilter;
      if (!isLastFilter) {
        filter40.apply(this._renderer, flipRenderTarget, flopRenderTarget, true);
        const temp = flipRenderTarget;
        flipRenderTarget = flopRenderTarget;
        flopRenderTarget = temp;
      } else {
        filter40.apply(this._renderer, flipRenderTarget, outputRenderTarget, true);
      }
    });
    this._renderTargets.push(flipRenderTarget);
    this._renderTargets.push(flopRenderTarget);
  }
  _onContextChange() {
    this._renderTargets.length = 0;
    if (this._renderer.isOfType(RendererType3.WEBGL)) {
      if (this._quad) {
        this._quad.dispose();
      }
      this._quad = new quad_default(this._renderer);
    }
  }
  dispose() {
    this._renderer.off("context", this._onContextChange);
    if (this._quad) {
      this._quad.dispose();
    }
    this._renderTargets.forEach((target) => {
      target.dispose();
    });
  }
}
var webgl_filter_manager_default = WebGLFilterManager;

// engine/sdk/core/engine/utils/context-performance-hook.js
const now = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();
class ContextPerformanceHook {
  constructor(context) {
    this._context = context;
    this._tracking = false;
    const self = this;
    for (const key in context) {
      const value = context[key];
      if (typeof value === "function") {
        this[key] = function(...args) {
          const fn = context[key];
          if (!self._tracking) {
            return fn.apply(context, args);
          }
          const start = now();
          const result = fn.apply(context, args);
          const time = now() - start;
          const call = {
            functionName: key,
            arguments: args,
            duration: time
          };
          self._trackedCalls.push(call);
          return result;
        };
      } else {
        this._makePropertyWrapper(key);
      }
    }
  }
  _makePropertyWrapper(property) {
    const insecureProperties = ["_context", "_trackedCalls", "_tracking"];
    if (insecureProperties.indexOf(property) !== -1)
      return;
    const context = this._context;
    this.__defineGetter__(property, () => {
      return context[property];
    });
    this.__defineSetter__(property, (value) => {
      context[property] = value;
    });
  }
  startFrame() {
    this._tracking = true;
    this._trackedCalls = [];
  }
  endFrame() {
    const tag = "Rendering";
    log_default.log(tag, "Frame rendering results:");
    log_default.log(tag, `Context calls: ${this._trackedCalls.length}`);
    const groupedCalls = {};
    this._trackedCalls.forEach(({functionName, duration}) => {
      groupedCalls[functionName] = groupedCalls[functionName] || {
        totalDuration: 0,
        calls: 0
      };
      groupedCalls[functionName].totalDuration += duration;
      groupedCalls[functionName].calls++;
    });
    let callsArray = [];
    for (const key in groupedCalls) {
      const data = groupedCalls[key];
      data.averageDuration = data.totalDuration / data.calls;
      callsArray.push({functionName: key, data});
    }
    callsArray.sort((a, b) => b.data.totalDuration - a.data.totalDuration);
    callsArray = callsArray.slice(0, 3);
    callsArray.forEach((item) => {
      log_default.log(tag, `${item.functionName}: ${item.data.calls} calls, ${item.data.totalDuration.toFixed(2)}ms`);
    });
  }
}
var context_performance_hook_default = ContextPerformanceHook;

// engine/sdk/core/engine/utils/utils.js
const Utils3 = {
  defaults: (object, ...sources) => {
    const newObject = {};
    for (const key in object) {
      newObject[key] = object[key];
    }
    for (let i = 0; i < sources.length; i++) {
      const source = sources[i];
      for (const key in source) {
        if (typeof newObject[key] === "undefined") {
          newObject[key] = source[key];
        }
      }
    }
    return newObject;
  },
  extend: (object, ...sources) => {
    const newObject = {};
    for (const key in object) {
      newObject[key] = object[key];
    }
    for (let i = 0; i < sources.length; i++) {
      const source = sources[i];
      for (const key in source) {
        newObject[key] = source[key];
      }
    }
    return newObject;
  }
};
var utils_default2 = Utils3;

// engine/sdk/core/engine/renderers/base-renderer.js
class BaseRenderer extends event_emitter_default {
  constructor(width, height, options = {}) {
    super();
    this._options = utils_default2.defaults(options, {
      pixelRatio: 1,
      transparent: false,
      clearColor: color_default.BLACK
    });
    this.setMaxListeners(0);
    this._width = width || 800;
    this._height = height || 600;
    this._dimensions = new vector2_default(this._width, this._height);
    this._maxTextureSize = null;
    this._pixelRatio = this._options.pixelRatio;
    this._clearColor = this._options.transparent ? color_default.TRANSPARENT : this._options.clearColor || color_default.BLACK;
  }
  setCanvas(canvas9) {
    const previousCanvas = this._canvas;
    this._canvas = canvas9;
    if (previousCanvas !== canvas9) {
      this._createContext();
      this._onBeforeContext();
      this._setupContext();
    }
    this.resizeTo(new vector2_default(this._width, this._height));
  }
  getCanvas() {
    return this._canvas;
  }
  _onBeforeContext() {
  }
  resizeTo(dimensions, resizeCanvas = true) {
    this._width = dimensions.x * this._pixelRatio;
    this._height = dimensions.y * this._pixelRatio;
    if (resizeCanvas) {
      this._canvas.width = this._width;
      this._canvas.height = this._height;
      if (this._canvas.style) {
        this._canvas.style.width = `${this._width / this._pixelRatio}px`;
        this._canvas.style.height = `${this._height / this._pixelRatio}px`;
      }
    }
    this._dimensions = dimensions.clone();
  }
  _createContext() {
    log_default.warn(this.constructor.name, "`_createContext` is abstract and not implemented in inherited class");
  }
  _setupContext() {
    log_default.warn(this.constructor.name, "`_setupContext` is abstract and not implemented in inherited class");
  }
  render(displayObject) {
    log_default.warn(this.constructor.name, "`render` is abstract and not implemented in inherited class");
  }
  getMaxDimensions() {
    return null;
  }
  getContext() {
    return this._context;
  }
  getWidth() {
    return this._dimensions.x;
  }
  getHeight() {
    return this._dimensions.y;
  }
  getDimensions() {
    return this._dimensions;
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    if (this._defaultRenderTarget) {
      this._defaultRenderTarget.setPixelRatio(pixelRatio);
    }
  }
  getMaxTextureSize() {
    return this._maxTextureSize;
  }
  getFilterManager() {
    return this._filterManager;
  }
  setFilterManager(filterManager) {
    this._filterManager = filterManager;
  }
  static isSupported() {
    return true;
  }
  isOfType(type) {
    return this._type === type;
  }
  dispose() {
    log_default.warn(this.constructor.name, "`dispose` is abstract and not implemented in inherited class");
  }
}
var base_renderer_default = BaseRenderer;

// engine/sdk/core/engine/renderers/canvas/canvas-renderer.js
const {RendererType: RendererType4} = constants_exports;
class CanvasRenderer extends base_renderer_default {
  constructor(...args) {
    super(...args);
    this._type = RendererType4.CANVAS;
    this.setCanvas(this._options.canvas || this._createCanvas());
  }
  _createCanvas() {
    return utils_default.createCanvas();
  }
  _createContext() {
    const canvas9 = this._canvas;
    let ctx = canvas9.getContext("2d");
    if (this._options.debug) {
      ctx = new context_performance_hook_default(ctx);
    }
    this.id = ctx.id = CanvasRenderer.contextId++;
    this._context = ctx;
    ctx.renderer = this;
    this.emit("context", ctx);
    return ctx;
  }
  _setupContext() {
    const ctx = this._context;
    if (!("imageSmoothingEnabled" in ctx)) {
      ["moz", "webkit", "ms"].forEach((prop) => {
        if (ctx[prop]) {
          ctx[prop] = true;
        }
      });
    } else {
      ctx.imageSmoothingEnabled = true;
    }
    this._defaultRenderTarget = new canvas_render_target_default(this._width, this._height, this._pixelRatio, this._canvas, this._context);
    this.setRenderTarget(this._defaultRenderTarget);
    this._filterManager = new canvas_filter_manager_default(this);
  }
  render(displayObject) {
    const ctx = this._renderTarget.getContext();
    const originalParent = displayObject.getParent();
    displayObject.setParent(this._fakeObject);
    displayObject.updateTransform();
    displayObject.setParent(originalParent);
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.globalAlpha = 1;
    const {width, height} = this._canvas;
    ctx.clearRect(0, 0, width, height);
    if (this._clearColor.a !== 0) {
      ctx.save();
      ctx.fillStyle = this._clearColor.toRGBA();
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }
    this.renderDisplayObject(displayObject, this._renderTarget);
  }
  renderDisplayObject(displayObject, renderTarget) {
    const originalRenderTarget = this._renderTarget;
    this._filterManager.setFilterStack(renderTarget.getFilterStack());
    this.setRenderTarget(renderTarget);
    displayObject.renderCanvas(this);
    this.setRenderTarget(originalRenderTarget);
  }
  getCurrentRenderTarget() {
    return this._renderTarget;
  }
  setRenderTarget(renderTarget) {
    this._renderTarget = renderTarget;
  }
  getContext() {
    return this._renderTarget.getContext();
  }
  dispose() {
    this._filterManager.dispose();
  }
}
CanvasRenderer.contextId = 0;
CanvasRenderer.type = "Canvas2D";
var canvas_renderer_default = CanvasRenderer;

// engine/sdk/core/engine/utils/pixel-array-image.js
class PixelArrayImage {
  constructor(width, height, data) {
    this.width = width;
    this.height = height;
    this.data = data;
  }
  static fromNodeCanvasImage(image5) {
    if (!process.env.REACT_APP_BROWSER) {
      const {Canvas} = require("canvas");
      const canvas9 = new Canvas(image5.width, image5.height);
      const context = canvas9.getContext("2d");
      context.drawImage(image5, 0, 0);
      const imageData = context.getImageData(0, 0, image5.width, image5.height);
      return new PixelArrayImage(image5.width, image5.height, imageData.data);
    }
  }
}

// engine/sdk/core/engine/utils/webgl/webgl-memory-manager.js
const stats = __toModule(require("stats.js"));
class WebGLMemoryManager {
  constructor(context) {
    this._context = context;
    this._domAvailable = typeof document !== "undefined";
    this._hookIntoContext();
    this._textures = {};
    this._framebuffers = {};
    this._programs = {};
    this._shaders = {};
    this._buffers = {};
    this._boundTexture = null;
    this._id = 0;
    this._enums = {};
    this._setupStats();
    this._createEnumMap();
    this._updateMemoryStats = this._updateMemoryStats.bind(this);
    this._updateMemoryStats();
  }
  _createEnumMap() {
    for (const key in this._context) {
      const value = this._context[key];
      if (typeof value === "number") {
        this._enums[value] = key;
      }
    }
  }
  _enumValueToString(value) {
    const key = this._enums[value];
    return typeof key === "undefined" ? value : key;
  }
  _setupStats() {
    if (!this._domAvailable)
      return;
    this._stats = new stats.default();
    this._stats.showPanel(3);
    this._memPanel = this._stats.addPanel(new stats.default.Panel("MB [WebGL]", "#43ADEB", "#282828"));
    this._texPanel = this._stats.addPanel(new stats.default.Panel("Textures", "#43ADEB", "#282828"));
    this._bufPanel = this._stats.addPanel(new stats.default.Panel("Buffers", "#43ADEB", "#282828"));
    this._fboPanel = this._stats.addPanel(new stats.default.Panel("FBOs", "#43ADEB", "#282828"));
    this._prgPanel = this._stats.addPanel(new stats.default.Panel("Programs", "#43ADEB", "#282828"));
    this._shdPanel = this._stats.addPanel(new stats.default.Panel("Shaders", "#43ADEB", "#282828"));
  }
  _updatePanel(panel) {
    if (!this._domAvailable)
      return;
    this._stats.begin();
    switch (panel) {
      case "tex":
        this._texPanel.update(this.getTexturesCount(), 50);
        break;
      case "buf":
        this._bufPanel.update(this.getBuffersCount(), 50);
        break;
      case "fbo":
        this._fboPanel.update(this.getFBOCount(), 50);
        break;
      case "prg":
        this._prgPanel.update(this.getProgramCount(), 50);
        break;
      case "shd":
        this._shdPanel.update(this.getShaderCount(), 50);
        break;
    }
    this._stats.end();
  }
  getTexturesCount() {
    return Object.keys(this._textures).length;
  }
  getBuffersCount() {
    return Object.keys(this._buffers).length;
  }
  getFBOCount() {
    return Object.keys(this._framebuffers).length;
  }
  getProgramCount() {
    return Object.keys(this._programs).length;
  }
  getShaderCount() {
    return Object.keys(this._shaders).length;
  }
  _updateMemoryStats() {
    if (!this._domAvailable)
      return;
    const memory = this._getMemoryUsage() / 1e3 / 1e3;
    this._memPanel.update(memory, 400);
    setTimeout(this._updateMemoryStats, 1e3);
  }
  _getMemoryUsage() {
    let bytes = 0;
    for (const name in this._textures) {
      bytes += this._textures[name].memory;
    }
    for (const name in this._buffers) {
      bytes += this._buffers[name].memory;
    }
    return bytes;
  }
  _hookIntoContext() {
    for (const key in this._context) {
      const value = this._context[key];
      if (typeof value === "function") {
        this[key] = function(...args) {
          const fn = this._context[key];
          return this._trackGLCall(fn, key, args);
        };
      } else {
        this._makePropertyWrapper(key);
      }
    }
  }
  _makePropertyWrapper(property) {
    const insecureProperties = ["_context"];
    if (insecureProperties.indexOf(property) !== -1)
      return;
    const context = this._context;
    this.__defineGetter__(property, () => {
      return context[property];
    });
    this.__defineSetter__(property, (value) => {
      context[property] = value;
    });
  }
  _trackGLCall(fn, functionName, args) {
    const overrideFunctions = [
      "texImage2D",
      "bindTexture",
      "createTexture",
      "deleteTexture",
      "createBuffer",
      "bindBuffer",
      "bufferData",
      "deleteBuffer",
      "createFramebuffer",
      "deleteFramebuffer",
      "createProgram",
      "deleteProgram",
      "createShader",
      "deleteShader"
    ];
    let result;
    if (overrideFunctions.indexOf(functionName) !== -1) {
      result = this[`_${functionName}`](args);
    } else {
      result = fn.apply(this._context, args);
    }
    const err = this._context.getError();
    if (err !== 0) {
      let truncatedArgs = args.join(", ");
      if (truncatedArgs.length > 100) {
        truncatedArgs = `${truncatedArgs.substr(0, 100)}...`;
      }
      console.error(new Error(`WebGL Error ${this._enumValueToString(err)} in ${functionName}(${truncatedArgs})`));
    }
    return result;
  }
  _createProgram() {
    const program = this._context.createProgram();
    program._wmmId = this._id++;
    this._programs[program._wmmId] = program;
    this._updatePanel("prg");
    return program;
  }
  _deleteProgram([program]) {
    if (!program || !this._programs[program._wmmId])
      return;
    delete this._programs[program._wmmId];
    this._context.deleteProgram(program);
    this._updatePanel("prg");
  }
  _createShader([type]) {
    const shader4 = this._context.createShader(type);
    shader4._wmmId = this._id++;
    this._shaders[shader4._wmmId] = shader4;
    this._updatePanel("shd");
    return shader4;
  }
  _deleteShader([shader4]) {
    if (!shader4 || !this._shaders[shader4._wmmId])
      return;
    delete this._shaders[shader4._wmmId];
    this._context.deleteShader(shader4);
    this._updatePanel("shd");
  }
  _createFramebuffer() {
    const framebuffer = this._context.createFramebuffer();
    framebuffer._wmmId = this._id++;
    this._framebuffers[framebuffer._wmmId] = framebuffer;
    this._updatePanel("fbo");
    return framebuffer;
  }
  _deleteFramebuffer([framebuffer]) {
    if (!framebuffer || !this._framebuffers[framebuffer._wmmId])
      return;
    delete this._framebuffers[framebuffer._wmmId];
    this._context.deleteFramebuffer(framebuffer);
    this._updatePanel("fbo");
  }
  _createBuffer() {
    const buffer = this._context.createBuffer();
    buffer._wmmId = this._id++;
    this._buffers[buffer._wmmId] = {
      buffer,
      memory: 0
    };
    this._updatePanel("buf");
    return buffer;
  }
  _bindBuffer([target, buffer]) {
    this._context.bindBuffer(target, buffer);
    this._boundBuffer = buffer._wmmId;
  }
  _bufferData([target, sizeOrData, usage]) {
    this._context.bufferData(target, sizeOrData, usage);
    let size;
    if (typeof sizeOrData === "number") {
      size = sizeOrData;
    } else if ("byteLength" in sizeOrData) {
      size = sizeOrData.byteLength;
    } else if ("length" in sizeOrData) {
      size = sizeOrData.length;
    }
    this._buffers[this._boundBuffer].memory = size;
  }
  _deleteBuffer([buffer]) {
    if (!buffer || !this._buffers[buffer._wmmId])
      return;
    delete this._buffers[buffer._wmmId];
    this._context.deleteBuffer(buffer);
    this._updatePanel("buf");
  }
  _createTexture() {
    const texture5 = this._context.createTexture();
    texture5._wmmId = this._id++;
    this._textures[texture5._wmmId] = {
      texture: texture5,
      memory: 0
    };
    this._updatePanel("tex");
    return texture5;
  }
  _deleteTexture([texture5]) {
    if (!texture5 || !this._textures[texture5._wmmId])
      return;
    delete this._textures[texture5._wmmId];
    this._context.deleteTexture(texture5);
    this._updatePanel("tex");
  }
  _bindTexture([target, texture5]) {
    this._context.bindTexture(target, texture5);
    this._boundTexture = texture5._wmmId;
  }
  _texImage2D(args) {
    let [, , internalformat, width, height, border, , , pixels] = args;
    if (typeof pixels === "undefined") {
      pixels = border;
    }
    this._context.texImage2D.apply(this._context, args);
    const byteCount = this._calculateByteCountForTexture(internalformat, width, height, pixels);
    this._textures[this._boundTexture].memory = byteCount;
  }
  _calculateByteCountForTexture(format, width, height, pixels) {
    if (pixels !== null) {
      if ("width" in pixels) {
        width = pixels.width;
        height = pixels.height;
      } else {
        return pixels.length;
      }
    }
    let bytesPerPixel = 1;
    switch (format) {
      case this._context.ALPHA:
        bytesPerPixel = 1;
        break;
      case this._context.RGB:
        bytesPerPixel = 3;
        break;
      case this._context.RGBA:
        bytesPerPixel = 4;
        break;
    }
    return width * height * bytesPerPixel;
  }
}

// engine/sdk/core/engine/renderers/webgl/object-renderers/object-renderer.js
class ObjectRenderer {
  constructor(renderer) {
    this._renderer = renderer;
    this._onContextChange = this._onContextChange.bind(this);
    this._renderer.on("context", this._onContextChange);
  }
  _onContextChange() {
  }
  start() {
  }
  stop() {
    this.flush();
  }
  flush() {
  }
  dispose() {
    this._renderer.off("context", this._onContextChange);
    this._renderer = null;
  }
}
var object_renderer_default = ObjectRenderer;

// engine/sdk/core/engine/renderers/webgl/object-renderers/sprite-renderer.js
class SpriteRenderer extends object_renderer_default {
  constructor(...args) {
    super(...args);
    this._maxBatchSize = BATCH_SIZE;
    this._vertices = new ArrayBuffer(BATCH_SIZE * 4 * VERTEX_BYTE_SIZE);
    this._positions = new Float32Array(this._vertices);
    this._colors = new Uint32Array(this._vertices);
    this._indices = new Uint16Array(BATCH_SIZE * 6);
    for (let i = 0, j = 0; i < BATCH_SIZE * 6; i += 6, j += 4) {
      this._indices[i + 0] = j + 0;
      this._indices[i + 1] = j + 1;
      this._indices[i + 2] = j + 2;
      this._indices[i + 3] = j + 0;
      this._indices[i + 4] = j + 2;
      this._indices[i + 5] = j + 3;
    }
    this._shaders = [];
    this._sprites = [];
    this._currentBatchSize = 0;
    this._onContextChange();
  }
  render(sprite7) {
    const texture5 = sprite7.getTexture();
    const textureFrame = texture5.getFrame();
    const baseTexture = texture5.getBaseTexture();
    if (this._currentBatchSize >= this._maxBatchSize) {
      this.flush();
    }
    const uvs = texture5.getUVs();
    if (!uvs) {
      return;
    }
    const index = this._currentBatchSize * VERTEX_BYTE_SIZE;
    this._addVertexCoordinates(sprite7, index, textureFrame);
    this._addTextureUVs(sprite7, index, uvs);
    this._addColors(sprite7, index);
    this._sprites[this._currentBatchSize] = sprite7;
    this._currentBatchSize++;
  }
  _addColors(sprite7, index) {
    const colors = this._colors;
    const tint2 = sprite7.getTint();
    const color6 = (tint2 >> 16) + (tint2 & 65280) + ((tint2 & 255) << 16) + (sprite7.getWorldAlpha() * 255 << 24);
    colors[index + 4] = colors[index + 9] = colors[index + 14] = colors[index + 19] = color6;
  }
  _addTextureUVs(sprite7, index, uvs) {
    const positions = this._positions;
    let uvCoords = uvs.getUVsAt(0);
    positions[index + 2] = uvCoords.x;
    positions[index + 3] = uvCoords.y;
    uvCoords = uvs.getUVsAt(1);
    positions[index + 7] = uvCoords.x;
    positions[index + 8] = uvCoords.y;
    uvCoords = uvs.getUVsAt(2);
    positions[index + 12] = uvCoords.x;
    positions[index + 13] = uvCoords.y;
    uvCoords = uvs.getUVsAt(3);
    positions[index + 17] = uvCoords.x;
    positions[index + 18] = uvCoords.y;
  }
  _addVertexCoordinates(sprite7, index, textureFrame) {
    const positions = this._positions;
    const worldTransform = sprite7.getWorldTransform();
    const anchor = sprite7.getAnchor();
    const rectPositions = worldTransform.rectangleToCoordinates(textureFrame, anchor);
    const stride = 5;
    for (let i = 0; i < 4; i++) {
      positions[index + i * stride] = rectPositions[i].x;
      positions[index + i * stride + 1] = rectPositions[i].y;
    }
  }
  _onContextChange() {
    const gl = this._renderer.getContext();
    this._shader = this._renderer.shaders.default;
    if (this._vertexBuffer) {
      this._vertexBuffer = null;
    }
    if (this._indexBuffer) {
      this._indexBuffer = null;
    }
    this._vertexBuffer = gl.createBuffer();
    this._indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
  }
  start() {
    this._shader.setupBuffers(this._vertexBuffer, this._indexBuffer);
  }
  flush() {
    const renderer = this._renderer;
    const gl = renderer.getContext();
    if (this._currentBatchSize === 0) {
      return;
    }
    if (this._currentBatchSize > BATCH_SIZE * 0.5) {
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
    } else {
      const subArray = this._positions.subarray(0, this._currentBatchSize * VERTEX_BYTE_SIZE);
      gl.bufferSubData(gl.ARRAY_BUFFER, 0, subArray);
    }
    let currentBatchSize = 0;
    let currentBaseTexture = null;
    let nextBaseTexture = null;
    let currentShader = null;
    let nextShader = null;
    let shaderChanged = false;
    let textureChanged = false;
    let sprite7 = null;
    let batchStartIndex = 0;
    for (let i = 0, j = this._currentBatchSize; i < j; i++) {
      sprite7 = this._sprites[i];
      nextBaseTexture = sprite7.getTexture().getBaseTexture();
      nextShader = sprite7.getShader() || this._shader;
      shaderChanged = currentShader !== nextShader;
      textureChanged = currentBaseTexture !== nextBaseTexture;
      if (textureChanged || shaderChanged) {
        this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);
        batchStartIndex = i;
        currentBatchSize = 0;
        currentBaseTexture = nextBaseTexture;
        if (shaderChanged) {
          currentShader = nextShader;
          renderer.setShader(currentShader);
          const renderTarget = renderer.getCurrentRenderTarget();
          const projectionMatrix = renderTarget.getProjectionMatrix().toArray();
          currentShader.setUniform("u_projMatrix", projectionMatrix);
          currentShader.syncUniforms();
          gl.activeTexture(gl.TEXTURE0);
        }
      }
      currentBatchSize++;
    }
    this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);
    this._currentBatchSize = 0;
    this._sprites = [];
  }
  _renderBatch(baseTexture, batchSize, batchStartIndex) {
    if (batchSize === 0) {
      return;
    }
    const renderer = this._renderer;
    const gl = renderer.getContext();
    let glTexture = baseTexture.getGLTextureForRenderer(renderer);
    if (!glTexture) {
      glTexture = renderer.getOrCreateGLTexture(baseTexture);
    }
    if (baseTexture.isDirty()) {
      renderer.updateTexture(baseTexture);
      baseTexture.setDirty(false);
    }
    gl.activeTexture(gl.TEXTURE0 + baseTexture.getGLUnit());
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    const verticesCount = batchSize * 6;
    const vertexOffset = batchStartIndex * 6 * 2;
    gl.drawElements(gl.TRIANGLES, verticesCount, gl.UNSIGNED_SHORT, vertexOffset);
  }
  dispose() {
    const renderer = this._renderer;
    const gl = renderer.getContext();
    for (const sprite7 in this._sprites) {
      sprite7.dispose();
    }
    if (this._vertexBuffer) {
      gl.deleteBuffer(this._vertexBuffer);
      this._vertexBuffer = null;
    }
    if (this._indexBuffer) {
      gl.deleteBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    this._vertices = null;
    this._positions = null;
    this._colors = null;
    this._indices = null;
    super.dispose();
  }
}
var sprite_renderer_default = SpriteRenderer;

// engine/sdk/core/engine/renderers/webgl/webgl-renderer.js
const {RendererType: RendererType5} = constants_exports;
class WebGLRenderer extends base_renderer_default {
  constructor(...args) {
    super(...args);
    this._type = RendererType5.WEBGL;
    this._fakeObject = new display_object_default();
    this._onContextLost = this._onContextLost.bind(this);
    this._onContextRestored = this._onContextRestored.bind(this);
    this.setCanvas(this._options.canvas || utils_default.createCanvas());
    this._cachedBlitCanvas = utils_default.createCanvas();
    this.shaders = this._initShaders();
    this.renderers = this._initRenderers();
  }
  _onContextLost(e) {
    e.preventDefault();
    log_default.warn(this.constructor.name, "WebGL context has been lost - trying to restore.");
  }
  _onContextCreationError(e) {
    e.preventDefault();
    log_default.warn(this.constructor.name, `Failed to create WebGL context: ${e.statusMessage || "Unknown error"}`);
  }
  _onContextRestored() {
    log_default.warn(this.constructor.name, "WebGL context has been restored. Clearing all textures.");
    this._createContext();
    this._setupContext();
    this.emit("context-restored");
  }
  _onBeforeContext() {
    if (this._filterManager) {
      this._filterManager.dispose();
    }
    this._filterManager = new webgl_filter_manager_default(this);
    this._currentObjectRenderer = new object_renderer_default(this);
  }
  setShader(shader4) {
    this._currentShader = shader4;
    this._context.useProgram(shader4.getProgram());
    this._setAttributesForShader(shader4);
  }
  setCanvas(canvas9) {
    if (this._canvas) {
      this._removeContextEventListeners();
    }
    super.setCanvas(canvas9);
    if (this._canvas.addEventListener) {
      this._addContextEventListeners();
    }
  }
  _addContextEventListeners() {
    this._canvas.addEventListener("webglcontextlost", this._onContextLost);
    this._canvas.addEventListener("webglcontextrestored", this._onContextRestored);
    this._canvas.addEventListener("webglcontextcreationerror", this._onContextCreationError);
  }
  _removeContextEventListeners() {
    this._canvas.removeEventListener("webglcontextlost", this._onContextLost);
    this._canvas.removeEventListener("webglcontextrestored", this._onContextRestored);
    this._canvas.removeEventListener("webglcontextcreationerror", this._onContextCreationError);
  }
  _setAttributesForShader(shader4) {
    const gl = this._context;
    const attributes = shader4.getAttributes();
    const attributeLocations = shader4.getAttributeLocations();
    attributes.forEach((attributeName) => {
      const attributeLocation = attributeLocations[attributeName];
      gl.enableVertexAttribArray(attributeLocation);
    });
  }
  _initShaders() {
    return {
      default: new texture_shader_default(this)
    };
  }
  _initRenderers() {
    return {
      sprite: new sprite_renderer_default(this)
    };
  }
  _createContext() {
    const canvas9 = this._canvas;
    let gl = null;
    const contextOptions = {
      preserveDrawingBuffer: true
    };
    if (process.env.REACT_APP_BROWSER) {
      gl = canvas9.getContext("webgl", contextOptions) || canvas9.getContext("experimental-webgl", contextOptions);
    }
    if (!process.env.REACT_APP_BROWSER) {
      const createContext = require("gl");
      gl = createContext(canvas9.width, canvas9.height, contextOptions);
    }
    if (typeof window !== "undefined" && window.WebGLDebugUtils && this._options.debug) {
      const logGL = (functionName, args) => {
        console.error(`gl.${functionName}(${window.WebGLDebugUtils.glFunctionArgsToString(functionName, args)})`);
      };
      gl = window.WebGLDebugUtils.makeDebugContext(gl, null, logGL);
    }
    if (this._options.debug) {
      gl = new context_performance_hook_default(gl);
      gl = new WebGLMemoryManager(gl);
    }
    this.id = gl.id = WebGLRenderer.contextId++;
    this._context = gl;
    gl.renderer = this;
    this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    this.emit("context", gl);
    return gl;
  }
  _setupContext() {
    const gl = this._context;
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.CULL_FACE);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    this._defaultRenderTarget = new webgl_render_target_default(this, this._width, this._height, this._pixelRatio, true);
    this.setRenderTarget(this._defaultRenderTarget);
    this._getMaxPrecision();
  }
  _getMaxPrecision() {
    const gl = this._context;
    const highFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
    this._maxFloatPrecision = highFloat.precision !== 0 ? "highp" : "mediump";
    const highInt = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT);
    this._maxIntPrecision = highInt.rangeMax !== 0 ? "highp" : "lowp";
  }
  resizeTo(dimensions, resizeCanvas = true) {
    super.resizeTo(dimensions, resizeCanvas);
    if (this._currentRenderTarget) {
      this._currentRenderTarget.resizeTo(dimensions);
    }
    if (!process.env.REACT_APP_BROWSER) {
      this._context.resize(dimensions.x, dimensions.y);
    }
  }
  setRenderTarget(renderTarget = this._defaultRenderTarget) {
    this._currentRenderTarget = renderTarget;
    this._currentRenderTarget.activate();
  }
  setObjectRenderer(objectRenderer) {
    this._currentObjectRenderer.stop();
    this._currentObjectRenderer = objectRenderer;
    this._currentObjectRenderer.start();
  }
  render(displayObject) {
    this.setRenderTarget(this._defaultRenderTarget);
    this._defaultRenderTarget.clear(this._clearColor);
    const originalParent = displayObject.getParent();
    displayObject.setParent(this._fakeObject);
    displayObject.updateTransform();
    displayObject.setParent(originalParent);
    this.renderDisplayObject(displayObject, this._defaultRenderTarget);
  }
  renderDisplayObject(displayObject, renderTarget) {
    this.setRenderTarget(renderTarget);
    this._filterManager.setFilterStack(renderTarget.getFilterStack());
    displayObject.renderWebGL(this);
    this._currentObjectRenderer.flush();
  }
  clear() {
    const gl = this._context;
    gl.clearColor.apply(gl, this._clearColor.toGLColor());
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  save() {
    return {
      renderTarget: this._currentRenderTarget,
      objectRenderer: this._currentObjectRenderer,
      filterStack: this._filterManager.getFilterStack()
    };
  }
  restore(save) {
    this.setRenderTarget(save.renderTarget);
    this._filterManager.setFilterStack(save.filterStack);
    this._currentObjectRenderer = save.objectRenderer;
  }
  getOrCreateGLTexture(texture5) {
    const gl = this._context;
    let glTexture = texture5.getGLTextureForRenderer(this);
    if (!glTexture) {
      glTexture = gl.createTexture();
      texture5.setGLTextureForRenderer(glTexture, this);
    }
    return glTexture;
  }
  updateTexture(texture5, upload = true) {
    let source = texture5.getSource();
    const hasSource = !!source;
    const gl = this._context;
    const glUnit = texture5.getGLUnit();
    const glTexture = this.getOrCreateGLTexture(texture5);
    gl.activeTexture(gl.TEXTURE0 + glUnit);
    gl.bindTexture(gl.TEXTURE_2D, glTexture);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    if (upload && hasSource) {
      if (!process.env.REACT_APP_BROWSER) {
        const Canvas = require("canvas");
        const NodeCanvasImage = typeof Canvas !== "undefined" ? Canvas.Image : void 0;
        if (source instanceof NodeCanvasImage || source instanceof Canvas.Canvas) {
          source = PixelArrayImage.fromNodeCanvasImage(source);
        }
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.width, source.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, source.data);
      }
      if (process.env.REACT_APP_BROWSER) {
        if (source instanceof PixelArrayImage) {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.width, source.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, source.data);
        } else {
          const canvas9 = utils_default.convertHtmlImageToRGBACanvas(source, this._cachedBlitCanvas);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas9);
        }
      }
    }
    if (texture5.isMipMappingEnabled()) {
      gl.generateMipmap(gl.TEXTURE_2D);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texture5.getGLRepeat(gl, "x"));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texture5.getGLRepeat(gl, "y"));
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture5.getGLFilter(gl, "min"));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture5.getGLFilter(gl, "mag"));
    gl.activeTexture(gl.TEXTURE0);
  }
  getMaxDimensions() {
    let result = this.maxTextureDimensions;
    if (result === void 0) {
      if (!process.env.REACT_APP_BROWSER) {
        const gl = this._context;
        result = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      }
      if (process.env.REACT_APP_BROWSER) {
        const canvas9 = utils_default.createCanvas();
        const gl = canvas9.getContext("webgl") || canvas9.getContext("experimental-webgl");
        if (!gl) {
          result = null;
        } else {
          const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          const loseContextExtension = gl.getExtension("WEBGL_lose_context");
          if (loseContextExtension) {
            loseContextExtension.loseContext();
          }
          result = maxTextureSize;
        }
      }
      this.maxTextureDimensions = result;
    }
    return result;
  }
  getCurrentRenderTarget() {
    return this._currentRenderTarget;
  }
  getCurrentObjectRenderer() {
    return this._currentObjectRenderer;
  }
  static isSupported() {
    if (process.env.REACT_APP_BROWSER) {
      const canvas9 = utils_default.createCanvas();
      canvas9.addEventListener("webglcontextcreationerror", this.prototype._onContextCreationError);
      const gl = canvas9.getContext("webgl") || canvas9.getContext("experimental-webgl");
      let hasWebGLSupport = !!gl;
      if (hasWebGLSupport) {
        const gpuName = gl_utils_default.determineGPUName(gl);
        const isBlacklisted = gl_utils_default.isGPUBlacklisted(gpuName);
        hasWebGLSupport &= !isBlacklisted;
      }
      canvas9.removeEventListener("webglcontextcreationerror", this.prototype._onContextCreationError);
      return hasWebGLSupport;
    }
    return true;
  }
  getMaxFloatPrecision() {
    return this._maxFloatPrecision;
  }
  getMaxIntPrecision() {
    return this._maxIntPrecision;
  }
  dispose() {
    this._filterManager.dispose();
    this._currentObjectRenderer.dispose();
    this._defaultRenderTarget.dispose();
    for (const shader4 in this.shaders) {
      this.shaders[shader4].dispose();
      delete this.shaders[shader4];
    }
    this._removeContextEventListeners();
    const gl = this._context;
    const loseContextExtension = gl.getExtension("WEBGL_lose_context");
    if (loseContextExtension) {
      loseContextExtension.loseContext();
    }
  }
}
WebGLRenderer.contextId = 0;
WebGLRenderer.type = "WebGL";
var webgl_renderer_default = WebGLRenderer;

// engine/sdk/core/engine/shaders/index.js
var shaders_default = {
  TextureShader: texture_shader_default
};

// engine/shared/constants/index.js
const Events = {
  EXPORT: "export",
  CLOSE: "close",
  OPERATION_CREATED: "operation:created",
  OPERATION_UPDATED: "operation:updated",
  OPERATION_REMOVED: "operation:removed",
  EDITOR_READY: "editor:ready",
  WINDOW_RESIZE: "window:resize",
  ZOOM_DONE: "editor:zoom_done",
  HISTORY_UNDO: "history:undo",
  HISTORY_UPDATED: "history:update",
  FEATURES_DISABLED: "editor:features:disabled",
  FEATURES_ENABLED: "editor:features:enabled",
  FEATURES_UPDATED: "editor:features:updated",
  TRANSFORM_REAPPLY_RATIO: "transform:reapply_ratio"
};
var constants_default = {
  DEFAULTS: {
    FILTERS: [
      {
        identifier: "imgly_filters_duotone",
        defaultName: "DuoTone",
        assetFileName: "duotone",
        filters: [
          {
            identifier: "imgly_duotone_desert",
            defaultName: "Desert",
            lightColor: "#e1de9a",
            darkColor: "#cb2129"
          },
          {
            identifier: "imgly_duotone_peach",
            defaultName: "Peach",
            lightColor: "#e9abb8",
            darkColor: "#0040ff"
          },
          {
            identifier: "imgly_duotone_clash",
            defaultName: "Clash",
            lightColor: "#f41a0f",
            darkColor: "#23007c"
          },
          {
            identifier: "imgly_duotone_plum",
            defaultName: "Plum",
            lightColor: "#74d7ff",
            darkColor: "#23007c"
          },
          {
            identifier: "imgly_duotone_breezy",
            defaultName: "Breezy",
            lightColor: "#68fdff",
            darkColor: "#c20000"
          },
          {
            identifier: "imgly_duotone_deepblue",
            defaultName: "Deep Blue",
            lightColor: "#2de9eb",
            darkColor: "#58007c"
          },
          {
            identifier: "imgly_duotone_frog",
            defaultName: "Frog",
            lightColor: "#5bff60",
            darkColor: "#7f23a9"
          },
          {
            identifier: "imgly_duotone_sunset",
            defaultName: "Sunset",
            lightColor: "#f8ea46",
            darkColor: "#c400be"
          }
        ]
      },
      {
        identifier: "imgly_filters_bw",
        assetFileName: "b&w",
        defaultName: "Black & White",
        filters: [
          {
            identifier: "imgly_lut_ad1920",
            defaultName: "1920 A.D.",
            lutImage: "filters/imgly_lut_ad1920_5_5_128.png"
          },
          {
            identifier: "imgly_lut_bw",
            defaultName: "Greyed",
            lutImage: "filters/imgly_lut_bw_5_5_128.png"
          },
          {
            identifier: "imgly_lut_x400",
            defaultName: "Dusty",
            lutImage: "filters/imgly_lut_dusty_5_5_128.png"
          },
          {
            identifier: "imgly_lut_litho",
            defaultName: "Litho",
            lutImage: "filters/imgly_lut_litho_5_5_128.png"
          },
          {
            identifier: "imgly_lut_sepiahigh",
            defaultName: "Sepia",
            lutImage: "filters/imgly_lut_sepia_5_5_128.png"
          },
          {
            identifier: "imgly_lut_plate",
            defaultName: "Weathered",
            lutImage: "filters/imgly_lut_weathered_5_5_128.png"
          },
          {
            identifier: "imgly_lut_sin",
            defaultName: "Hard Stuff",
            lutImage: "filters/imgly_lut_hard_stuff_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          }
        ]
      },
      {
        identifier: "imgly_filters_retro",
        assetFileName: "vintage",
        defaultName: "Vintage",
        filters: [
          {
            identifier: "imgly_lut_blues",
            defaultName: "Polaroid",
            lutImage: "filters/imgly_lut_polaroid_5_5_128.png"
          },
          {
            identifier: "imgly_lut_front",
            defaultName: "Sunny 70s",
            lutImage: "filters/imgly_lut_sunny_70s_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_texas",
            defaultName: "Oldtimer",
            lutImage: "filters/imgly_lut_oldtimer_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_celsius",
            defaultName: "Inferno",
            lutImage: "filters/imgly_lut_inferno_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_cool",
            defaultName: "Snappy",
            lutImage: "filters/imgly_lut_snappy_5_5_128.png"
          }
        ]
      },
      {
        identifier: "imgly_filters_analog",
        assetFileName: "smooth",
        defaultName: "Smooth",
        filters: [
          {
            identifier: "imgly_lut_chest",
            defaultName: "Chestnut",
            lutImage: "filters/imgly_lut_chestnut_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_winter",
            defaultName: "Softly",
            lutImage: "filters/imgly_lut_softly_5_5_128.png"
          },
          {
            identifier: "imgly_lut_kdynamic",
            defaultName: "Pebble",
            lutImage: "filters/imgly_lut_pebble_5_5_128.png"
          },
          {
            identifier: "imgly_lut_fall",
            defaultName: "Moss",
            lutImage: "filters/imgly_lut_moss_5_5_128.png"
          },
          {
            identifier: "imgly_lut_lenin",
            defaultName: "Lemon",
            lutImage: "filters/imgly_lut_lemon_5_5_128.png"
          },
          {
            identifier: "imgly_lut_pola669",
            defaultName: "Green Gap",
            lutImage: "filters/imgly_lut_green_gap_5_5_128.png"
          }
        ]
      },
      {
        identifier: "imgly_filters_winter",
        assetFileName: "cold",
        defaultName: "Cold",
        filters: [
          {
            identifier: "imgly_lut_elder",
            defaultName: "Colla",
            lutImage: "filters/imgly_lut_colla_5_5_128.png"
          },
          {
            identifier: "imgly_lut_orchid",
            defaultName: "Solanus",
            lutImage: "filters/imgly_lut_solanus_5_5_128.png"
          },
          {
            identifier: "imgly_lut_bleached",
            defaultName: "Kalmen",
            lutImage: "filters/imgly_lut_kalmen_5_5_128.png"
          },
          {
            identifier: "imgly_lut_bleachedblue",
            defaultName: "Joran",
            lutImage: "filters/imgly_lut_joran_5_5_128.png"
          },
          {
            identifier: "imgly_lut_breeze",
            defaultName: "Levante",
            lutImage: "filters/imgly_lut_levante_5_5_128.png"
          },
          {
            identifier: "imgly_lut_blueshadows",
            defaultName: "Zephyr",
            lutImage: "filters/imgly_lut_zephyr_5_5_128.png"
          }
        ]
      },
      {
        identifier: "imgly_filters_summer",
        assetFileName: "warm",
        defaultName: "Warm",
        filters: [
          {
            identifier: "imgly_lut_sunset",
            defaultName: "Golden",
            lutImage: "filters/imgly_lut_golden_5_5_128.png"
          },
          {
            identifier: "imgly_lut_eighties",
            defaultName: "Low Fire",
            lutImage: "filters/imgly_lut_low_fire_5_5_128.png"
          },
          {
            identifier: "imgly_lut_evening",
            defaultName: "Sunrise",
            lutImage: "filters/imgly_lut_sunrise_5_5_128.png"
          },
          {
            identifier: "imgly_lut_k2",
            defaultName: "Flat Black",
            lutImage: "filters/imgly_lut_flat_black_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_nogreen",
            defaultName: "Pumpkin",
            lutImage: "filters/imgly_lut_pumpkin_5_5_128.png"
          }
        ]
      },
      {
        identifier: "imgly_filters_legacy",
        defaultName: "Legacy",
        assetFileName: "legacy",
        filters: [
          {
            identifier: "imgly_lut_ancient",
            defaultName: "Ancient",
            lutImage: "filters/imgly_lut_ancient_5_5_128.png"
          },
          {
            identifier: "imgly_lut_cottoncandy",
            defaultName: "Candy",
            lutImage: "filters/imgly_lut_cottoncandy_5_5_128.png"
          },
          {
            identifier: "imgly_lut_classic",
            defaultName: "Classic",
            lutImage: "filters/imgly_lut_classic_5_5_128.png"
          },
          {
            identifier: "imgly_lut_colorful",
            defaultName: "Colorful",
            lutImage: "filters/imgly_lut_colorful_5_5_128.png"
          },
          {
            identifier: "imgly_lut_creamy",
            defaultName: "Creamy",
            lutImage: "filters/imgly_lut_creamy_5_5_128.png"
          },
          {
            identifier: "imgly_lut_fixie",
            defaultName: "Fixie",
            lutImage: "filters/imgly_lut_fixie_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_food",
            defaultName: "Food",
            lutImage: "filters/imgly_lut_food_5_5_128.png"
          },
          {
            identifier: "imgly_lut_fridge",
            defaultName: "Fridge",
            lutImage: "filters/imgly_lut_fridge_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_glam",
            defaultName: "Glam",
            lutImage: "filters/imgly_lut_glam_5_5_128.png"
          },
          {
            identifier: "imgly_lut_gobblin",
            defaultName: "Gobblin",
            lutImage: "filters/imgly_lut_gobblin_5_5_128.png"
          },
          {
            identifier: "imgly_lut_highcontrast",
            defaultName: "Hicon",
            lutImage: "filters/imgly_lut_highcontrast_5_5_128.png"
          },
          {
            identifier: "imgly_lut_highcarb",
            defaultName: "High Carb",
            lutImage: "filters/imgly_lut_highcarb_5_5_128.png"
          },
          {
            identifier: "imgly_lut_k1",
            defaultName: "K1",
            lutImage: "filters/imgly_lut_k1_5_5_128.png"
          },
          {
            identifier: "imgly_lut_k6",
            defaultName: "K6",
            lutImage: "filters/imgly_lut_k6_5_5_128.png"
          },
          {
            identifier: "imgly_lut_keen",
            defaultName: "Keen",
            lutImage: "filters/imgly_lut_keen_5_5_128.png"
          },
          {
            identifier: "imgly_lut_lomo",
            defaultName: "Lomo",
            lutImage: "filters/imgly_lut_lomo_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_lomo100",
            defaultName: "Lomo 100",
            lutImage: "filters/imgly_lut_lomo100_5_5_128.png"
          },
          {
            identifier: "imgly_lut_lucid",
            defaultName: "Lucid",
            lutImage: "filters/imgly_lut_lucid_5_5_128.png"
          },
          {
            identifier: "imgly_lut_mellow",
            defaultName: "Mellow",
            lutImage: "filters/imgly_lut_mellow_8_8_512.png",
            resolution: 512,
            horizontalTileCount: 8,
            verticalTileCount: 8
          },
          {
            identifier: "imgly_lut_neat",
            defaultName: "Neat",
            lutImage: "filters/imgly_lut_neat_5_5_128.png"
          },
          {
            identifier: "imgly_lut_pale",
            defaultName: "Pale",
            lutImage: "filters/imgly_lut_pale_5_5_128.png"
          },
          {
            identifier: "imgly_lut_pitched",
            defaultName: "Pitched",
            lutImage: "filters/imgly_lut_pitched_5_5_128.png"
          },
          {
            identifier: "imgly_lut_polasx",
            defaultName: "Pola SX",
            lutImage: "filters/imgly_lut_polasx_5_5_128.png"
          },
          {
            identifier: "imgly_lut_pro400",
            defaultName: "Pro 400",
            lutImage: "filters/imgly_lut_pro400_5_5_128.png"
          },
          {
            identifier: "imgly_lut_quozi",
            defaultName: "Quozi",
            lutImage: "filters/imgly_lut_quozi_5_5_128.png"
          },
          {
            identifier: "imgly_lut_settled",
            defaultName: "Settled",
            lutImage: "filters/imgly_lut_settled_5_5_128.png"
          },
          {
            identifier: "imgly_lut_seventies",
            defaultName: "Seventies",
            lutImage: "filters/imgly_lut_seventies_5_5_128.png"
          },
          {
            identifier: "imgly_lut_soft",
            defaultName: "Soft",
            lutImage: "filters/imgly_lut_soft_5_5_128.png"
          },
          {
            identifier: "imgly_lut_steel",
            defaultName: "Steel",
            lutImage: "filters/imgly_lut_steel_5_5_128.png"
          },
          {
            identifier: "imgly_lut_summer",
            defaultName: "Summer",
            lutImage: "filters/imgly_lut_summer_5_5_128.png"
          },
          {
            identifier: "imgly_lut_tender",
            defaultName: "Tender",
            lutImage: "filters/imgly_lut_tender_5_5_128.png"
          },
          {
            identifier: "imgly_lut_twilight",
            defaultName: "Twilight",
            lutImage: "filters/imgly_lut_twilight_5_5_128.png"
          }
        ]
      }
    ],
    OVERLAYS: [
      {
        identifier: "imgly_overlay_golden",
        defaultName: "Golden",
        image: "overlays/imgly_overlay_golden.jpg",
        thumbnail: "overlays/imgly_overlay_golden_thumb.jpg",
        blendMode: "lighten"
      },
      {
        identifier: "imgly_overlay_bokeh",
        defaultName: "Bokeh",
        image: "overlays/imgly_overlay_bokeh.jpg",
        thumbnail: "overlays/imgly_overlay_bokeh_thumb.jpg",
        blendMode: "lighten"
      },
      {
        identifier: "imgly_overlay_hearts",
        defaultName: "Hearts",
        image: "overlays/imgly_overlay_hearts.jpg",
        thumbnail: "overlays/imgly_overlay_hearts_thumb.jpg",
        blendMode: "screen"
      },
      {
        identifier: "imgly_overlay_lightleak1",
        defaultName: "Light Leak",
        image: "overlays/imgly_overlay_lightleak1.jpg",
        thumbnail: "overlays/imgly_overlay_lightleak1_thumb.jpg",
        blendMode: "screen"
      },
      {
        identifier: "imgly_overlay_lightleak2",
        defaultName: "Light Leak 2",
        image: "overlays/imgly_overlay_lightleak2.jpg",
        thumbnail: "overlays/imgly_overlay_lightleak2_thumb.jpg",
        blendMode: "lighten"
      },
      {
        identifier: "imgly_overlay_rain",
        defaultName: "Rain",
        image: "overlays/imgly_overlay_rain.jpg",
        thumbnail: "overlays/imgly_overlay_rain_thumb.jpg",
        blendMode: "overlay"
      },
      {
        identifier: "imgly_overlay_wood",
        defaultName: "Wood",
        image: "overlays/imgly_overlay_wood.jpg",
        thumbnail: "overlays/imgly_overlay_wood_thumb.jpg",
        blendMode: "multiply"
      },
      {
        identifier: "imgly_overlay_mosaic",
        defaultName: "Mosaic",
        image: "overlays/imgly_overlay_mosaic.jpg",
        thumbnail: "overlays/imgly_overlay_mosaic_thumb.jpg",
        blendMode: "multiply"
      },
      {
        identifier: "imgly_overlay_chop",
        defaultName: "Chop",
        image: "overlays/imgly_overlay_chop.jpg",
        thumbnail: "overlays/imgly_overlay_chop_thumb.jpg",
        blendMode: "multiply"
      },
      {
        identifier: "imgly_overlay_vintage",
        defaultName: "Vintage",
        image: "overlays/imgly_overlay_vintage.jpg",
        thumbnail: "overlays/imgly_overlay_vintage_thumb.jpg",
        blendMode: "darken"
      },
      {
        identifier: "imgly_overlay_metal",
        defaultName: "Metal",
        image: "overlays/imgly_overlay_metal.jpg",
        thumbnail: "overlays/imgly_overlay_metal_thumb.jpg",
        blendMode: "overlay"
      },
      {
        identifier: "imgly_overlay_paper",
        defaultName: "Paper",
        image: "overlays/imgly_overlay_paper.jpg",
        thumbnail: "overlays/imgly_overlay_paper_thumb.jpg",
        blendMode: "multiply"
      },
      {
        identifier: "imgly_overlay_painting",
        defaultName: "Painting",
        image: "overlays/imgly_overlay_painting.jpg",
        thumbnail: "overlays/imgly_overlay_painting_thumb.jpg",
        blendMode: "overlay"
      },
      {
        identifier: "imgly_overlay_grain",
        defaultName: "Grain",
        image: "overlays/imgly_overlay_grain.jpg",
        thumbnail: "overlays/imgly_overlay_grain_thumb.jpg",
        blendMode: "overlay"
      },
      {
        identifier: "imgly_overlay_clouds",
        defaultName: "Clouds",
        image: "overlays/imgly_overlay_clouds.jpg",
        thumbnail: "overlays/imgly_overlay_clouds_thumb.jpg",
        blendMode: "softLight"
      },
      {
        identifier: "imgly_overlay_wall1",
        defaultName: "Wall",
        image: "overlays/imgly_overlay_wall1.jpg",
        thumbnail: "overlays/imgly_overlay_wall1_thumb.jpg",
        blendMode: "lighten"
      },
      {
        identifier: "imgly_overlay_wall2",
        defaultName: "Wall 2",
        image: "overlays/imgly_overlay_wall2.jpg",
        thumbnail: "overlays/imgly_overlay_wall2_thumb.jpg",
        blendMode: "overlay"
      }
    ],
    FRAME_CATEGORIES: [
      {
        identifier: "imgly_frame_generic",
        defaultName: "Generic",
        metaData: {
          backgroundImage: "frames/generic.png"
        },
        frames: [
          {
            identifier: "imgly_frame_dia",
            defaultName: "Dia",
            layoutMode: "horizontal-inside",
            thumbnail: "frames/imgly_frame_dia/imgly_frame_dia_thumb.png",
            imageGroups: {
              top: {
                mid: {
                  image: "frames/imgly_frame_dia/imgly_frame_dia_top.png",
                  mode: "repeat"
                }
              },
              left: {
                start: "frames/imgly_frame_dia/imgly_frame_dia_top_corner_left.png",
                mid: "frames/imgly_frame_dia/imgly_frame_dia_left.png",
                end: "frames/imgly_frame_dia/imgly_frame_dia_bottom_corner_left.png"
              },
              right: {
                start: "frames/imgly_frame_dia/imgly_frame_dia_top_corner_right.png",
                mid: "frames/imgly_frame_dia/imgly_frame_dia_right.png",
                end: "frames/imgly_frame_dia/imgly_frame_dia_bottom_corner_right.png"
              },
              bottom: {
                mid: {
                  image: "frames/imgly_frame_dia/imgly_frame_dia_bottom.png",
                  mode: "repeat"
                }
              }
            }
          },
          {
            identifier: "imgly_frame_art_decor",
            defaultName: "Art Decor",
            tintable: true,
            layoutMode: "horizontal-inside",
            thumbnail: "frames/imgly_frame_art_decor/imgly_frame_art_decor_thumb.png",
            imageGroups: {
              top: {
                start: "frames/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_top.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_art_decor/imgly_frame_art_decor_top_corner_right.png"
              },
              left: {
                mid: {
                  image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_left.png",
                  mode: "stretch"
                }
              },
              right: {
                mid: {
                  image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_right.png",
                  mode: "stretch"
                }
              },
              bottom: {
                start: "frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_art_decor/imgly_frame_art_decor_bottom_corner_right.png"
              }
            }
          },
          {
            identifier: "imgly_frame_black_passepartout",
            defaultName: "Black Passepartout",
            layoutMode: "horizontal-inside",
            thumbnail: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_thumb.png",
            imageGroups: {
              top: {
                start: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_top_corner_right.png"
              },
              left: {
                mid: {
                  image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_left.png",
                  mode: "stretch"
                }
              },
              right: {
                mid: {
                  image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_right.png",
                  mode: "stretch"
                }
              },
              bottom: {
                start: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_black_passepartout/imgly_frame_black_passepartout_bottom_corner_right.png"
              }
            }
          },
          {
            identifier: "imgly_frame_lowpoly_shadow",
            defaultName: "Low Poly",
            layoutMode: "horizontal-inside",
            thumbnail: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_thumb.png",
            imageGroups: {
              top: {
                start: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_top_corner_right.png"
              },
              left: {
                mid: {
                  image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_left.png",
                  mode: "stretch"
                }
              },
              right: {
                mid: {
                  image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_right.png",
                  mode: "stretch"
                }
              },
              bottom: {
                start: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_lowpoly_shadow/imgly_frame_lowpoly_shadow_bottom_corner_right.png"
              }
            }
          },
          {
            identifier: "imgly_frame_wood_passepartout",
            defaultName: "Wood Passepartout",
            layoutMode: "horizontal-inside",
            thumbnail: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_thumb.png",
            imageGroups: {
              top: {
                start: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_top_corner_right.png"
              },
              left: {
                mid: {
                  image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_left.png",
                  mode: "stretch"
                }
              },
              right: {
                mid: {
                  image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_right.png",
                  mode: "stretch"
                }
              },
              bottom: {
                start: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_left.png",
                mid: {
                  image: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom.png",
                  mode: "stretch"
                },
                end: "frames/imgly_frame_wood_passepartout/imgly_frame_wood_passepartout_bottom_corner_right.png"
              }
            }
          }
        ]
      }
    ],
    STICKER_CATEGORIES: [
      {
        identifier: "imgly_sticker_emoticons",
        defaultName: "Emoticons",
        metaData: {
          backgroundImage: "stickers/emoticons/background.png"
        },
        stickers: [
          {
            identifier: "imgly_sticker_emoticons_alien",
            defaultName: "Alien",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_alien.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_alien.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_alien.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_alien.png"
                ],
                width: 1e3,
                height: 935
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_angel",
            defaultName: "Angel",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_angel.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_angel.png"
                ],
                width: 62,
                height: 64
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_angel.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_angel.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_angry",
            defaultName: "Angry",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_angry.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_angry.png"
                ],
                width: 62,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_angry.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_angry.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_anxious",
            defaultName: "Anxious",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_anxious.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_anxious.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_anxious.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_anxious.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_asleep",
            defaultName: "Asleep",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_asleep.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_asleep.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_asleep.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_asleep.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_attention",
            defaultName: "Attention",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_attention.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_attention.png"
                ],
                width: 62,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_attention.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_attention.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_baby_chicken",
            defaultName: "Baby Chicken",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_baby_chicken.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_baby_chicken.png"
                ],
                width: 61,
                height: 42
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_baby_chicken.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_baby_chicken.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_batman",
            defaultName: "Batman",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_batman.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_batman.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_batman.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_batman.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_beer",
            defaultName: "Beer",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_beer.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_beer.png"
                ],
                width: 62,
                height: 59
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_beer.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_beer.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_blush",
            defaultName: "Blush",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_blush.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_blush.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_blush.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_blush.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_boxer",
            defaultName: "Boxer",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_boxer.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_boxer.png"
                ],
                width: 62,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_boxer.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_boxer.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_business",
            defaultName: "Business",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_business.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_business.png"
                ],
                width: 60,
                height: 63
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_business.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_business.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_chicken",
            defaultName: "Chicken",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_chicken.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_chicken.png"
                ],
                width: 63,
                height: 55
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_chicken.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_chicken.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_cool",
            defaultName: "Cool",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_cool.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_cool.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_cool.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_cool.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_cry",
            defaultName: "Cry",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_cry.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_cry.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_cry.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_cry.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_deceased",
            defaultName: "Deceased",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_deceased.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_deceased.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_deceased.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_deceased.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_devil",
            defaultName: "Devil",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_devil.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_devil.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_devil.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_devil.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_duckface",
            defaultName: "Duckface",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_duckface.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_duckface.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_duckface.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_duckface.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_furious",
            defaultName: "Furious",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_furious.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_furious.png"
                ],
                width: 62,
                height: 61
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_furious.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_furious.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_grin",
            defaultName: "Grin",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_grin.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_grin.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_grin.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_grin.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_guitar",
            defaultName: "Guitar",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_guitar.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_guitar.png"
                ],
                width: 64,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_guitar.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_guitar.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_harry_potter",
            defaultName: "Harry Potter",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_harry_potter.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_harry_potter.png"
                ],
                width: 64,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_harry_potter.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_harry_potter.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_hippie",
            defaultName: "Hippie",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_hippie.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_hippie.png"
                ],
                width: 62,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_hippie.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_hippie.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_hitman",
            defaultName: "Hitman",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_hitman.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_hitman.png"
                ],
                width: 64,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_hitman.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_hitman.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_humourous",
            defaultName: "Humourous",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_humourous.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_humourous.png"
                ],
                width: 64,
                height: 64
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_humourous.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_humourous.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_idea",
            defaultName: "Idea",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_idea.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_idea.png"
                ],
                width: 64,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_idea.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_idea.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_impatient",
            defaultName: "Impatient",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_impatient.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_impatient.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_impatient.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_impatient.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_kiss",
            defaultName: "Kiss",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_kiss.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_kiss.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_kiss.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_kiss.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_kisses",
            defaultName: "Kisses",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_kisses.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_kisses.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_kisses.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_kisses.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_laugh",
            defaultName: "Laugh",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_laugh.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_laugh.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_laugh.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_laugh.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_loud_cry",
            defaultName: "Loud Cry",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_loud_cry.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_loud_cry.png"
                ],
                width: 64,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_loud_cry.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_loud_cry.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_loving",
            defaultName: "Loving",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_loving.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_loving.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_loving.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_loving.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_masked",
            defaultName: "Masked",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_masked.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_masked.png"
                ],
                width: 62,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_masked.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_masked.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_music",
            defaultName: "Music",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_music.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_music.png"
                ],
                width: 62,
                height: 54
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_music.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_music.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_nerd",
            defaultName: "Nerd",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_nerd.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_nerd.png"
                ]
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_nerd.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_nerd.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_ninja",
            defaultName: "Ninja",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_ninja.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_ninja.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_ninja.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_ninja.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_not_speaking_to_you",
            defaultName: "Not Speaking To You",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_not_speaking_to_you.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_not_speaking_to_you.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_not_speaking_to_you.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_not_speaking_to_you.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_pig",
            defaultName: "Pig",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_pig.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_pig.png"
                ],
                width: 63,
                height: 41
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_pig.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_pig.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_pumpkin",
            defaultName: "Pumpkin",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_pumpkin.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_pumpkin.png"
                ],
                width: 62,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_pumpkin.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_pumpkin.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_question",
            defaultName: "Question",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_question.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_question.png"
                ],
                width: 62,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_question.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_question.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_rabbit",
            defaultName: "Rabbit",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_rabbit.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_rabbit.png"
                ],
                width: 65,
                height: 47
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_rabbit.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_rabbit.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_sad",
            defaultName: "Sad",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sad.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sad.png"
                ]
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sad.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sad.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_sick",
            defaultName: "Sick",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sick.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sick.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sick.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sick.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_skateboard",
            defaultName: "Skateboard",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_skateboard.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_skateboard.png"
                ],
                width: 62,
                height: 64
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_skateboard.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_skateboard.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_skull",
            defaultName: "Skull",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_skull.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_skull.png"
                ],
                width: 62,
                height: 62
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_skull.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_skull.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_sleepy",
            defaultName: "Sleepy",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sleepy.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sleepy.png"
                ],
                width: 62,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sleepy.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sleepy.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_smile",
            defaultName: "Smile",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_smile.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_smile.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_smile.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_smile.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_smoking",
            defaultName: "Smoking",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_smoking.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_smoking.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_smoking.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_smoking.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_sobbing",
            defaultName: "Sobbing",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sobbing.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sobbing.png"
                ],
                width: 62,
                height: 59
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sobbing.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sobbing.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_star",
            defaultName: "Star",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_star.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_star.png"
                ],
                width: 64,
                height: 64
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_star.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_star.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_steaming_furious",
            defaultName: "Steaming Furious",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_steaming_furious.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_steaming_furious.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_steaming_furious.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_steaming_furious.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_sunbathing",
            defaultName: "Sunbathing",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sunbathing.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_sunbathing.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_sunbathing.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_sunbathing.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_tired",
            defaultName: "Tired",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_tired.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_tired.png"
                ],
                width: 62,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_tired.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_tired.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_tongue_out_wink",
            defaultName: "Tongue Out Wink",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_tongue_out_wink.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_tongue_out_wink.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_tongue_out_wink.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_tongue_out_wink.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_wave",
            defaultName: "Wave",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wave.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wave.png"
                ],
                width: 62,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wave.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wave.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_wide_grin",
            defaultName: "Wide Grin",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wide_grin.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wide_grin.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wide_grin.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wide_grin.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_wink",
            defaultName: "Wink",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wink.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wink.png"
                ],
                width: 62,
                height: 58
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wink.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wink.png"
                ]
              }
            }
          },
          {
            identifier: "imgly_sticker_emoticons_wrestler",
            defaultName: "Wrestler",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wrestler.svg",
                  "stickers/emoticons/stickers/thumbs/imgly_sticker_emoticons_wrestler.png"
                ],
                width: 62,
                height: 60
              },
              mediaBase: {
                uris: [
                  "stickers/emoticons/stickers/imgly_sticker_emoticons_wrestler.svg",
                  "stickers/emoticons/stickers/base/imgly_sticker_emoticons_wrestler.png"
                ]
              }
            }
          }
        ]
      },
      {
        identifier: "imgly_sticker_shapes",
        defaultName: "Shapes",
        metaData: {
          backgroundImage: "stickers/shapes/background.png"
        },
        stickers: [
          {
            identifier: "imgly_sticker_shapes_arrow_02",
            defaultName: "Arrow 1",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_arrow_02.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_arrow_02.png"
                ],
                width: 2e3,
                height: 1236
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_arrow_02.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_arrow_02.png"
                ],
                width: 2e3,
                height: 1236
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_arrow_03",
            defaultName: "Arrow 2",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_arrow_03.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_arrow_03.png"
                ],
                width: 2e3,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_arrow_03.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_arrow_03.png"
                ],
                width: 2e3,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_01",
            defaultName: "Badge 1",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_01.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_01.png"
                ],
                width: 2e3,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_01.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_01.png"
                ],
                width: 2e3,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_04",
            defaultName: "Badge 2",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_04.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_04.png"
                ],
                width: 2e3,
                height: 1589
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_04.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_04.png"
                ],
                width: 2e3,
                height: 1589
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_06",
            defaultName: "Badge 3",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_06.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_06.png"
                ],
                width: 2e3,
                height: 1733
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_06.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_06.png"
                ],
                width: 2e3,
                height: 1733
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_08",
            defaultName: "Badge 4",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_08.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_08.png"
                ],
                width: 2e3,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_08.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_08.png"
                ],
                width: 2e3,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_11",
            defaultName: "Badge 5",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_11.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_11.png"
                ],
                width: 2e3,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_11.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_11.png"
                ],
                width: 2e3,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_12",
            defaultName: "Badge 6",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_12.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_12.png"
                ],
                width: 2001,
                height: 1903
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_12.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_12.png"
                ],
                width: 2001,
                height: 1903
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_13",
            defaultName: "Badge 7",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_13.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_13.png"
                ],
                width: 2e3,
                height: 1718
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_13.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_13.png"
                ],
                width: 2e3,
                height: 1718
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_15",
            defaultName: "Badge 8",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_15.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_15.png"
                ],
                width: 1618,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_15.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_15.png"
                ],
                width: 1618,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_18",
            defaultName: "Badge 9",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_18.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_18.png"
                ],
                width: 1198,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_18.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_18.png"
                ],
                width: 1198,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_19",
            defaultName: "Badge 10",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_19.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_19.png"
                ],
                width: 2127,
                height: 481
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_19.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_19.png"
                ],
                width: 2127,
                height: 481
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_20",
            defaultName: "Badge 11",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_20.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_20.png"
                ],
                width: 2e3,
                height: 1404
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_20.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_20.png"
                ],
                width: 2e3,
                height: 1404
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_28",
            defaultName: "Badge 12",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_28.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_28.png"
                ],
                width: 2e3,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_28.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_28.png"
                ],
                width: 2e3,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_32",
            defaultName: "Badge 13",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_32.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_32.png"
                ],
                width: 1960,
                height: 2e3
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_32.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_32.png"
                ],
                width: 1960,
                height: 2e3
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_35",
            defaultName: "Badge 14",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_35.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_35.png"
                ],
                width: 2e3,
                height: 2002
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_35.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_35.png"
                ],
                width: 2e3,
                height: 2002
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_badge_36",
            defaultName: "Badge 15",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_36.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_badge_36.png"
                ],
                width: 2e3,
                height: 1668
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_badge_36.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_badge_36.png"
                ],
                width: 2e3,
                height: 1668
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_spray_01",
            defaultName: "Spray 1",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_spray_01.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_01.png"
                ],
                width: 1912,
                height: 2039
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_spray_01.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_spray_01.png"
                ],
                width: 1912,
                height: 2039
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_spray_03",
            defaultName: "Spray 2",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_spray_03.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_03.png"
                ],
                width: 1681,
                height: 1779
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_spray_03.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_spray_03.png"
                ],
                width: 1681,
                height: 1779
              }
            }
          },
          {
            identifier: "imgly_sticker_shapes_spray_04",
            defaultName: "Spray 3",
            tintMode: "solid",
            images: {
              mediaThumb: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_spray_04.svg",
                  "stickers/shapes/stickers/thumbs/imgly_sticker_shapes_spray_04.png"
                ],
                width: 1407,
                height: 2248
              },
              mediaBase: {
                uris: [
                  "stickers/shapes/stickers/imgly_sticker_shapes_spray_04.svg",
                  "stickers/shapes/stickers/base/imgly_sticker_shapes_spray_04.png"
                ],
                width: 1407,
                height: 2248
              }
            }
          }
        ]
      }
    ]
  }
};

// engine/sdk/core/vendor/jsbn.js
/*!
 * Copyright (c) 2003-2005  Tom Wu
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
 * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
 * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
 * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * In addition, the following condition applies:
 *
 * All redistributions must retain an intact copy of this copyright notice
 * and disclaimer.
 */
let navigator2 = {};
if (process.env.REACT_APP_BROWSER) {
  navigator2 = window.navigator;
}
var dbits;
var canary = 244837814094590;
var j_lm = (canary & 16777215) == 15715070;
function BigInteger(a, b, c) {
  if (a != null)
    if (typeof a == "number")
      this.fromNumber(a, b, c);
    else if (b == null && typeof a != "string")
      this.fromString(a, 256);
    else
      this.fromString(a, b);
}
function nbi() {
  return new BigInteger(null);
}
function am1(i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c;
    c = Math.floor(v / 67108864);
    w[j++] = v & 67108863;
  }
  return c;
}
function am2(i, x, w, j, c, n) {
  var xl = x & 32767, xh = x >> 15;
  while (--n >= 0) {
    var l = this[i] & 32767;
    var h = this[i++] >> 15;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
    w[j++] = l & 1073741823;
  }
  return c;
}
function am3(i, x, w, j, c, n) {
  var xl = x & 16383, xh = x >> 14;
  while (--n >= 0) {
    var l = this[i] & 16383;
    var h = this[i++] >> 14;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 16383) << 14) + w[j] + c;
    c = (l >> 28) + (m >> 14) + xh * h;
    w[j++] = l & 268435455;
  }
  return c;
}
if (j_lm && navigator2.appName == "Microsoft Internet Explorer") {
  BigInteger.prototype.am = am2;
  dbits = 30;
} else if (j_lm && navigator2.appName != "Netscape") {
  BigInteger.prototype.am = am1;
  dbits = 26;
} else {
  BigInteger.prototype.am = am3;
  dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr;
var vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr++] = vv;
function int2char(n) {
  return BI_RM.charAt(n);
}
function intAt(s, i) {
  var c = BI_RC[s.charCodeAt(i)];
  return c == null ? -1 : c;
}
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i)
    r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
}
function bnpFromInt(x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0)
    this[0] = x;
  else if (x < -1)
    this[0] = x + this.DV;
  else
    this.t = 0;
}
function nbv(i) {
  var r = nbi();
  r.fromInt(i);
  return r;
}
function bnpFromString(s, b) {
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 256)
    k = 8;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else {
    this.fromRadix(s, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while (--i >= 0) {
    var x = k == 8 ? s[i] & 255 : intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == "-")
        mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this[this.t++] = x;
    else if (sh + k > this.DB) {
      this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this[this.t++] = x >> this.DB - sh;
    } else
      this[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB)
      sh -= this.DB;
  }
  if (k == 8 && (s[0] & 128) != 0) {
    this.s = -1;
    if (sh > 0)
      this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }
  this.clamp();
  if (mi)
    BigInteger.ZERO.subTo(this, this);
}
function bnpClamp() {
  var c = this.s & this.DM;
  while (this.t > 0 && this[this.t - 1] == c)
    --this.t;
}
function bnToString(b) {
  if (this.s < 0)
    return "-" + this.negate().toString(b);
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else
    return this.toRadix(b);
  var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
  var p = this.DB - i * this.DB % k;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) > 0) {
      m = true;
      r = int2char(d);
    }
    while (i >= 0) {
      if (p < k) {
        d = (this[i] & (1 << p) - 1) << k - p;
        d |= this[--i] >> (p += this.DB - k);
      } else {
        d = this[i] >> (p -= k) & km;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if (d > 0)
        m = true;
      if (m)
        r += int2char(d);
    }
  }
  return m ? r : "0";
}
function bnNegate() {
  var r = nbi();
  BigInteger.ZERO.subTo(this, r);
  return r;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a) {
  var r = this.s - a.s;
  if (r != 0)
    return r;
  var i = this.t;
  r = i - a.t;
  if (r != 0)
    return this.s < 0 ? -r : r;
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0)
      return r;
  return 0;
}
function nbits(x) {
  var r = 1, t;
  if ((t = x >>> 16) != 0) {
    x = t;
    r += 16;
  }
  if ((t = x >> 8) != 0) {
    x = t;
    r += 8;
  }
  if ((t = x >> 4) != 0) {
    x = t;
    r += 4;
  }
  if ((t = x >> 2) != 0) {
    x = t;
    r += 2;
  }
  if ((t = x >> 1) != 0) {
    x = t;
    r += 1;
  }
  return r;
}
function bnBitLength() {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n, r) {
  var i;
  for (i = this.t - 1; i >= 0; --i)
    r[i + n] = this[i];
  for (i = n - 1; i >= 0; --i)
    r[i] = 0;
  r.t = this.t + n;
  r.s = this.s;
}
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i)
    r[i - n] = this[i];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
}
function bnpLShiftTo(n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
  for (i = this.t - 1; i >= 0; --i) {
    r[i + ds + 1] = this[i] >> cbs | c;
    c = (this[i] & bm) << bs;
  }
  for (i = ds - 1; i >= 0; --i)
    r[i] = 0;
  r[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
}
function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r[0] = this[ds] >> bs;
  for (var i = ds + 1; i < this.t; ++i) {
    r[i - ds - 1] |= (this[i] & bm) << cbs;
    r[i - ds] = this[i] >> bs;
  }
  if (bs > 0)
    r[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
}
function bnpSubTo(a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] - a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c -= a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1)
    r[i++] = this.DV + c;
  else if (c > 0)
    r[i++] = c;
  r.t = i;
  r.clamp();
}
function bnpMultiplyTo(a, r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i + y.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < y.t; ++i)
    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
  r.s = 0;
  r.clamp();
  if (this.s != a.s)
    BigInteger.ZERO.subTo(r, r);
}
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2 * x.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1);
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV;
      r[i + x.t + 1] = 1;
    }
  }
  if (r.t > 0)
    r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
}
function bnpDivRemTo(m, q, r) {
  var pm = m.abs();
  if (pm.t <= 0)
    return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q != null)
      q.fromInt(0);
    if (r != null)
      this.copyTo(r);
    return;
  }
  if (r == null)
    r = nbi();
  var y = nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB - nbits(pm[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y);
    pt.copyTo(r);
  }
  var ys = y.t;
  var y0 = y[ys - 1];
  if (y0 == 0)
    return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
  var i = r.t, j = i - ys, t = q == null ? nbi() : q;
  y.dlShiftTo(j, t);
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t, r);
  }
  BigInteger.ONE.dlShiftTo(ys, t);
  t.subTo(y, y);
  while (y.t < ys)
    y[y.t++] = 0;
  while (--j >= 0) {
    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
      y.dlShiftTo(j, t);
      r.subTo(t, r);
      while (r[i] < --qd)
        r.subTo(t, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms)
      BigInteger.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  if (nsh > 0)
    r.rShiftTo(nsh, r);
  if (ts < 0)
    BigInteger.ZERO.subTo(r, r);
}
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
    a.subTo(r, r);
  return r;
}
function Classic(m) {
  this.m = m;
}
function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0)
    return x.mod(this.m);
  else
    return x;
}
function cRevert(x) {
  return x;
}
function cReduce(x) {
  x.divRemTo(this.m, null, x);
}
function cMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
function cSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var x = this[0];
  if ((x & 1) == 0)
    return 0;
  var y = x & 3;
  y = y * (2 - (x & 15) * y) & 15;
  y = y * (2 - (x & 255) * y) & 255;
  y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
  y = y * (2 - x * y % this.DV) % this.DV;
  return y > 0 ? this.DV - y : -y;
}
function Montgomery(m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m.DB - 15) - 1;
  this.mt2 = 2 * m.t;
}
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
    this.m.subTo(r, r);
  return r;
}
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}
function montReduce(x) {
  while (x.t <= this.mt2)
    x[x.t++] = 0;
  for (var i = 0; i < this.m.t; ++i) {
    var j = x[i] & 32767;
    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
    j = i + this.m.t;
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
    while (x[j] >= x.DV) {
      x[j] -= x.DV;
      x[++j]++;
    }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
}
function montSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function montMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this[0] & 1 : this.s) == 0;
}
function bnpExp(e, z) {
  if (e > 4294967295 || e < 1)
    return BigInteger.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
  g.copyTo(r);
  while (--i >= 0) {
    z.sqrTo(r, r2);
    if ((e & 1 << i) > 0)
      z.mulTo(r2, g, r);
    else {
      var t = r;
      r = r2;
      r2 = t;
    }
  }
  return z.revert(r);
}
function bnModPowInt(e, m) {
  var z;
  if (e < 256 || m.isEven())
    z = new Classic(m);
  else
    z = new Montgomery(m);
  return this.exp(e, z);
}
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
function bnClone() {
  var r = nbi();
  this.copyTo(r);
  return r;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    else if (this.t == 0)
      return -1;
  } else if (this.t == 1)
    return this[0];
  else if (this.t == 0)
    return 0;
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this[0] << 16 >> 16;
}
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
}
function bnSigNum() {
  if (this.s < 0)
    return -1;
  else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
    return 0;
  else
    return 1;
}
function bnpToRadix(b) {
  if (b == null)
    b = 10;
  if (this.signum() == 0 || b < 2 || b > 36)
    return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b, cs);
  var d = nbv(a), y = nbi(), z = nbi(), r = "";
  this.divRemTo(d, y, z);
  while (y.signum() > 0) {
    r = (a + z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d, y, z);
  }
  return z.intValue().toString(b) + r;
}
function bnpFromRadix(s, b) {
  this.fromInt(0);
  if (b == null)
    b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
  for (var i = 0; i < s.length; ++i) {
    var x = intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == "-" && this.signum() == 0)
        mi = true;
      continue;
    }
    w = b * w + x;
    if (++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w, 0);
      j = 0;
      w = 0;
    }
  }
  if (j > 0) {
    this.dMultiply(Math.pow(b, j));
    this.dAddOffset(w, 0);
  }
  if (mi)
    BigInteger.ZERO.subTo(this, this);
}
function bnpFromNumber(a, b, c) {
  if (typeof b == "number") {
    if (a < 2)
      this.fromInt(1);
    else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1))
        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
      if (this.isEven())
        this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a)
          this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
      }
    }
  } else {
    var x = new Array(), t = a & 7;
    x.length = (a >> 3) + 1;
    b.nextBytes(x);
    if (t > 0)
      x[0] &= (1 << t) - 1;
    else
      x[0] = 0;
    this.fromString(x, 256);
  }
}
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB - i * this.DB % 8, d, k = 0;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
      r[k++] = d | this.s << this.DB - p;
    while (i >= 0) {
      if (p < 8) {
        d = (this[i] & (1 << p) - 1) << 8 - p;
        d |= this[--i] >> (p += this.DB - 8);
      } else {
        d = this[i] >> (p -= 8) & 255;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if ((d & 128) != 0)
        d |= -256;
      if (k == 0 && (this.s & 128) != (d & 128))
        ++k;
      if (k > 0 || d != this.s)
        r[k++] = d;
    }
  }
  return r;
}
function bnEquals(a) {
  return this.compareTo(a) == 0;
}
function bnMin(a) {
  return this.compareTo(a) < 0 ? this : a;
}
function bnMax(a) {
  return this.compareTo(a) > 0 ? this : a;
}
function bnpBitwiseTo(a, op, r) {
  var i, f, m = Math.min(a.t, this.t);
  for (i = 0; i < m; ++i)
    r[i] = op(this[i], a[i]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i = m; i < this.t; ++i)
      r[i] = op(this[i], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i = m; i < a.t; ++i)
      r[i] = op(f, a[i]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
}
function op_and(x, y) {
  return x & y;
}
function bnAnd(a) {
  var r = nbi();
  this.bitwiseTo(a, op_and, r);
  return r;
}
function op_or(x, y) {
  return x | y;
}
function bnOr(a) {
  var r = nbi();
  this.bitwiseTo(a, op_or, r);
  return r;
}
function op_xor(x, y) {
  return x ^ y;
}
function bnXor(a) {
  var r = nbi();
  this.bitwiseTo(a, op_xor, r);
  return r;
}
function op_andnot(x, y) {
  return x & ~y;
}
function bnAndNot(a) {
  var r = nbi();
  this.bitwiseTo(a, op_andnot, r);
  return r;
}
function bnNot() {
  var r = nbi();
  for (var i = 0; i < this.t; ++i)
    r[i] = this.DM & ~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}
function bnShiftLeft(n) {
  var r = nbi();
  if (n < 0)
    this.rShiftTo(-n, r);
  else
    this.lShiftTo(n, r);
  return r;
}
function bnShiftRight(n) {
  var r = nbi();
  if (n < 0)
    this.lShiftTo(-n, r);
  else
    this.rShiftTo(n, r);
  return r;
}
function lbit(x) {
  if (x == 0)
    return -1;
  var r = 0;
  if ((x & 65535) == 0) {
    x >>= 16;
    r += 16;
  }
  if ((x & 255) == 0) {
    x >>= 8;
    r += 8;
  }
  if ((x & 15) == 0) {
    x >>= 4;
    r += 4;
  }
  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }
  if ((x & 1) == 0)
    ++r;
  return r;
}
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0)
      return i * this.DB + lbit(this[i]);
  if (this.s < 0)
    return this.t * this.DB;
  return -1;
}
function cbit(x) {
  var r = 0;
  while (x != 0) {
    x &= x - 1;
    ++r;
  }
  return r;
}
function bnBitCount() {
  var r = 0, x = this.s & this.DM;
  for (var i = 0; i < this.t; ++i)
    r += cbit(this[i] ^ x);
  return r;
}
function bnTestBit(n) {
  var j = Math.floor(n / this.DB);
  if (j >= this.t)
    return this.s != 0;
  return (this[j] & 1 << n % this.DB) != 0;
}
function bnpChangeBit(n, op) {
  var r = BigInteger.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
}
function bnSetBit(n) {
  return this.changeBit(n, op_or);
}
function bnClearBit(n) {
  return this.changeBit(n, op_andnot);
}
function bnFlipBit(n) {
  return this.changeBit(n, op_xor);
}
function bnpAddTo(a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] + a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c += a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0)
    r[i++] = c;
  else if (c < -1)
    r[i++] = this.DV + c;
  r.t = i;
  r.clamp();
}
function bnAdd(a) {
  var r = nbi();
  this.addTo(a, r);
  return r;
}
function bnSubtract(a) {
  var r = nbi();
  this.subTo(a, r);
  return r;
}
function bnMultiply(a) {
  var r = nbi();
  this.multiplyTo(a, r);
  return r;
}
function bnSquare() {
  var r = nbi();
  this.squareTo(r);
  return r;
}
function bnDivide(a) {
  var r = nbi();
  this.divRemTo(a, r, null);
  return r;
}
function bnRemainder(a) {
  var r = nbi();
  this.divRemTo(a, null, r);
  return r;
}
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
}
function bnpDMultiply(n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}
function bnpDAddOffset(n, w) {
  if (n == 0)
    return;
  while (this.t <= w)
    this[this.t++] = 0;
  this[w] += n;
  while (this[w] >= this.DV) {
    this[w] -= this.DV;
    if (++w >= this.t)
      this[this.t++] = 0;
    ++this[w];
  }
}
function NullExp() {
}
function nNop(x) {
  return x;
}
function nMulTo(x, y, r) {
  x.multiplyTo(y, r);
}
function nSqrTo(x, r) {
  x.squareTo(r);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e) {
  return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i;
  while (i > 0)
    r[--i] = 0;
  var j;
  for (j = r.t - this.t; i < j; ++i)
    r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
  for (j = Math.min(a.t, n); i < j; ++i)
    this.am(0, a[i], r, i, 0, n - i);
  r.clamp();
}
function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i = r.t = this.t + a.t - n;
  r.s = 0;
  while (--i >= 0)
    r[i] = 0;
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
  r.clamp();
  r.drShiftTo(1, r);
}
function Barrett(m) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
}
function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t)
    return x.mod(this.m);
  else if (x.compareTo(this.m) < 0)
    return x;
  else {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
}
function barrettRevert(x) {
  return x;
}
function barrettReduce(x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0)
    x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
}
function barrettSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function barrettMulTo(x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e, m) {
  var i = e.bitLength(), k, r = nbv(1), z;
  if (i <= 0)
    return r;
  else if (i < 18)
    k = 1;
  else if (i < 48)
    k = 3;
  else if (i < 144)
    k = 4;
  else if (i < 768)
    k = 5;
  else
    k = 6;
  if (i < 8)
    z = new Classic(m);
  else if (m.isEven())
    z = new Barrett(m);
  else
    z = new Montgomery(m);
  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z.convert(this);
  if (k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }
  var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
  i = nbits(e[j]) - 1;
  while (j >= 0) {
    if (i >= k1)
      w = e[j] >> i - k1 & km;
    else {
      w = (e[j] & (1 << i + 1) - 1) << k1 - i;
      if (j > 0)
        w |= e[j - 1] >> this.DB + i - k1;
    }
    n = k;
    while ((w & 1) == 0) {
      w >>= 1;
      --n;
    }
    if ((i -= n) < 0) {
      i += this.DB;
      --j;
    }
    if (is1) {
      g[w].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z.sqrTo(r, r2);
        z.sqrTo(r2, r);
        n -= 2;
      }
      if (n > 0)
        z.sqrTo(r, r2);
      else {
        t = r;
        r = r2;
        r2 = t;
      }
      z.mulTo(r2, g[w], r);
    }
    while (j >= 0 && (e[j] & 1 << i) == 0) {
      z.sqrTo(r, r2);
      t = r;
      r = r2;
      r2 = t;
      if (--i < 0) {
        i = this.DB - 1;
        --j;
      }
    }
  }
  return z.revert(r);
}
function bnGCD(a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y) < 0) {
    var t = x;
    x = y;
    y = t;
  }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if (g < 0)
    return x;
  if (i < g)
    g = i;
  if (g > 0) {
    x.rShiftTo(g, x);
    y.rShiftTo(g, y);
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0)
      x.rShiftTo(i, x);
    if ((i = y.getLowestSetBit()) > 0)
      y.rShiftTo(i, y);
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x);
      x.rShiftTo(1, x);
    } else {
      y.subTo(x, y);
      y.rShiftTo(1, y);
    }
  }
  if (g > 0)
    y.lShiftTo(g, y);
  return y;
}
function bnpModInt(n) {
  if (n <= 0)
    return 0;
  var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d == 0)
      r = this[0] % n;
    else
      for (var i = this.t - 1; i >= 0; --i)
        r = (d * r + this[i]) % n;
  return r;
}
function bnModInverse(m) {
  var ac = m.isEven();
  if (this.isEven() && ac || m.signum() == 0)
    return BigInteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m, b);
        }
        a.rShiftTo(1, a);
      } else if (!b.isEven())
        b.subTo(m, b);
      b.rShiftTo(1, b);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c);
          d.subTo(m, d);
        }
        c.rShiftTo(1, c);
      } else if (!d.isEven())
        d.subTo(m, d);
      d.rShiftTo(1, d);
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      if (ac)
        a.subTo(c, a);
      b.subTo(d, b);
    } else {
      v.subTo(u, v);
      if (ac)
        c.subTo(a, c);
      d.subTo(b, d);
    }
  }
  if (v.compareTo(BigInteger.ONE) != 0)
    return BigInteger.ZERO;
  if (d.compareTo(m) >= 0)
    return d.subtract(m);
  if (d.signum() < 0)
    d.addTo(m, d);
  else
    return d;
  if (d.signum() < 0)
    return d.add(m);
  else
    return d;
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t) {
  var i, x = this.abs();
  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x[0] == lowprimes[i])
        return true;
    return false;
  }
  if (x.isEven())
    return false;
  i = 1;
  while (i < lowprimes.length) {
    var m = lowprimes[i], j = i + 1;
    while (j < lowprimes.length && m < lplim)
      m *= lowprimes[j++];
    m = x.modInt(m);
    while (i < j)
      if (m % lowprimes[i++] == 0)
        return false;
  }
  return x.millerRabin(t);
}
function bnpMillerRabin(t) {
  var n1 = this.subtract(BigInteger.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0)
    return false;
  var r = n1.shiftRight(k);
  t = t + 1 >> 1;
  if (t > lowprimes.length)
    t = lowprimes.length;
  var a = nbi();
  for (var i = 0; i < t; ++i) {
    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
    var y = a.modPow(r, this);
    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this);
        if (y.compareTo(BigInteger.ONE) == 0)
          return false;
      }
      if (y.compareTo(n1) != 0)
        return false;
    }
  }
  return true;
}
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
BigInteger.prototype.square = bnSquare;
var jsbn_default = BigInteger;

// engine/sdk/core/vendor/sha256.js
/*!
 *  Secure Hash Algorithm (SHA256)
 *  http://www.webtoolkit.info/
 *
 *  Original code by Angel Marin, Paul Johnston.
 */
function sha256(s) {
  var chrsz = 8;
  var hexcase = 0;
  function safe_add(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function S(X, n) {
    return X >>> n | X << 32 - n;
  }
  function R(X, n) {
    return X >>> n;
  }
  function Ch(x, y, z) {
    return x & y ^ ~x & z;
  }
  function Maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  function Sigma0256(x) {
    return S(x, 2) ^ S(x, 13) ^ S(x, 22);
  }
  function Sigma1256(x) {
    return S(x, 6) ^ S(x, 11) ^ S(x, 25);
  }
  function Gamma0256(x) {
    return S(x, 7) ^ S(x, 18) ^ R(x, 3);
  }
  function Gamma1256(x) {
    return S(x, 17) ^ S(x, 19) ^ R(x, 10);
  }
  function core_sha256(m, l) {
    var K = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298);
    var HASH = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
    m[l >> 5] |= 128 << 24 - l % 32;
    m[(l + 64 >> 9 << 4) + 15] = l;
    for (var i = 0; i < m.length; i += 16) {
      a = HASH[0];
      b = HASH[1];
      c = HASH[2];
      d = HASH[3];
      e = HASH[4];
      f = HASH[5];
      g = HASH[6];
      h = HASH[7];
      for (var j = 0; j < 64; j++) {
        if (j < 16)
          W[j] = m[j + i];
        else
          W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
        T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
        T2 = safe_add(Sigma0256(a), Maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = safe_add(d, T1);
        d = c;
        c = b;
        b = a;
        a = safe_add(T1, T2);
      }
      HASH[0] = safe_add(a, HASH[0]);
      HASH[1] = safe_add(b, HASH[1]);
      HASH[2] = safe_add(c, HASH[2]);
      HASH[3] = safe_add(d, HASH[3]);
      HASH[4] = safe_add(e, HASH[4]);
      HASH[5] = safe_add(f, HASH[5]);
      HASH[6] = safe_add(g, HASH[6]);
      HASH[7] = safe_add(h, HASH[7]);
    }
    return HASH;
  }
  function str2binb(str) {
    var bin = Array();
    var mask2 = (1 << chrsz) - 1;
    for (var i = 0; i < str.length * chrsz; i += chrsz) {
      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask2) << 24 - i % 32;
    }
    return bin;
  }
  function Utf8Encode(string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";
    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  }
  function binb2hex(binarray) {
    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
    var str = "";
    for (var i = 0; i < binarray.length * 4; i++) {
      str += hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 + 4 & 15) + hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 & 15);
    }
    return str;
  }
  s = Utf8Encode(s);
  return binb2hex(core_sha256(str2binb(s), s.length * chrsz));
}

// engine/sdk/core/lib/semantic-version.js
const correctSemVerPattern = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/g;
const optionalPatchPattern = /^(0|[1-9]\d*)\.(0|[1-9]\d*)(\.(0|[1-9]\d*))?(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/g;
class SemanticVersion {
  get major() {
    return this._major;
  }
  get minor() {
    return this._minor;
  }
  get patch() {
    return this._patch;
  }
  constructor(version, patchVersionOptional = false) {
    const pattern = patchVersionOptional ? optionalPatchPattern : correctSemVerPattern;
    const groups = pattern.exec(version);
    pattern.lastIndex = 0;
    this._major = groups[1];
    this._minor = groups[2];
    this._patch = groups[3] || 0;
  }
  equals(other) {
    return this._major === other._major && this._minor === other._minor && this._patch === other._patch;
  }
  isMoreRecentThan(other) {
    if (this._major < other.major)
      return false;
    if (this._major > other.major)
      return true;
    if (this._minor < other.minor)
      return false;
    if (this._minor > other.minor)
      return true;
    if (this._patch <= other.patch)
      return false;
    if (this._patch > other.patch)
      return true;
  }
}

// engine/sdk/core/lib/license-checker.js
const bd = (str) => utils_default.byteArrayToString(base64_default.decode(str));
function byteArraytoHexString(byteArray) {
  return byteArray.map((byte) => {
    return `0${(byte & 255).toString(16)}`.slice(-2);
  }).join("");
}
const TRACK_PATH = "TDNSeVlXTnJQMkZ3YVV0bGVUMD0=";
const ENTERPRISE_LICENSE = "ZW50ZXJwcmlzZV9saWNlbnNl";
const APP_IDENTIFIERS = "YXBwX2lkZW50aWZpZXJz";
const PLATFORM = "cGxhdGZvcm0=";
const FEATURES = "ZmVhdHVyZXM=";
const EXPIRES_AT = "ZXhwaXJlc19hdA==";
const DOMAINS = "ZG9tYWlucw==";
const API_TOKEN = "YXBpX3Rva2Vu";
const SIGNATURE = "c2lnbmF0dXJl";
const VERSION = "dmVyc2lvbg==";
class L {
  constructor(license) {
    this._version = "2.4";
    this._l = typeof license === "string" ? license.trim() : license;
    this._e = this._parseBigInt("65537", 10);
    this._n = this._parseBigInt("681984042382424091378806337544846672160292647422517223678775230983366046720611873368204040735766698395282492937192783016867164773742859209434481353888637963692711665138989982680829529436715362566735813634679619274059040232728883894511099669775400556584329435375723951309340934658571478665059403241851229195311069345899870108307225910988692123234379186643268583453907260879685992156955936561142314233983397819356937109343127504441076920088455337597736475086676246750168976219763398350254797168313954762459542746440628077261880980924552698138857743609502132632199713575442848784271304503226045319991689413234228439044522583790713890093165912455428688507463773064216328753265963237930998706891042679105987175588970202082466871461192706070321938250462103821558100761330890228135620208935801286878657384108721268761878694436895194628411397454202904351577771506916746612289964053490210990342857409030179406810634136188751670648983222653319056818302012063874664196648868156305696644664362171542503665321455971335955948698828939948786720193132672749776162913092000667953299803216404664087988046584107737900256954976744353601826341965438148646041640662195744770544094748295945844184507459808803114917301124088082458306086473490516969815873631", 10);
    this._parseLicense();
  }
  v() {
    return this._sigValid() && !this.isExp();
  }
  _jsonValid() {
    try {
      this._decLic = JSON.parse(this._l);
    } catch (e) {
      this._decLic = {};
      return false;
    }
    return true;
  }
  _hostnameValid() {
    if (typeof window === "undefined")
      return true;
    if (!this._decLic[bd(APP_IDENTIFIERS)].length)
      return true;
    const {hostname} = window.location;
    let valid = false;
    this._decLic[bd(APP_IDENTIFIERS)].forEach((appIdentifier) => {
      if (utils_default.wildCardMatch(hostname, appIdentifier)) {
        valid = true;
      }
    });
    return valid;
  }
  _platformValid() {
    const licensePlatform = this._decLic[bd(PLATFORM)];
    const systemPlatform = process.env.REACT_APP_BROWSER ? "HTML5" : "Server";
    return systemPlatform === licensePlatform;
  }
  c() {
    return new Promise((resolve, reject) => {
      const error = this._validateError();
      if (error !== null) {
        reject(error);
      }
      resolve();
    });
  }
  validate() {
    const error = this._validateError();
    if (error !== null) {
      return false;
    }
    return true;
  }
  _validateError() {
    const licenseType = typeof this._l;
    if (licenseType !== "string" || !this._jsonValid()) {
      const error = new Error();
      error.code = "ELICINVFMT";
      return error;
    }
    if (!this._sigValid()) {
      const error = new Error();
      error.code = "ELICINV";
      return error;
    }
    if (!this._hostnameValid()) {
      const error = new Error();
      error.code = "ELICINVHOST";
      return error;
    }
    if (!this._platformValid()) {
      const error = new Error();
      error.code = "ELICINVPLAT";
      return error;
    }
    if (this.isExp()) {
      const error = new Error();
      error.code = "ELICEXP";
      return error;
    }
    return null;
  }
  isToolAllowed(identifier) {
    return this._includesFeature(identifier);
  }
  isWhiteLabel() {
    return this._includesFeature("whitelabel", new SemanticVersion("2.4", true));
  }
  areCustomAssetsAllowed() {
    return this._includesFeature("customassets", new SemanticVersion("2.4", true));
  }
  t() {
    if (this._decLic.enterprise_license)
      return Promise.resolve();
    if (this._includesFeature("noexporttracking", new SemanticVersion("2.4", true)))
      return Promise.resolve();
    const trackPath = this._decLic[bd(DOMAINS)][0] + bd(bd(TRACK_PATH)) + this._decLic[bd(API_TOKEN)];
    const jsonLoader = new JSONLoader(trackPath);
    return jsonLoader.load();
  }
  isENT() {
    if (!this._decLic)
      return false;
    return this._decLic[bd(ENTERPRISE_LICENSE)];
  }
  _sigValid() {
    return this._verify(this._message, this._sig);
  }
  exp() {
    return !!this._decLic[bd(EXPIRES_AT)];
  }
  dl() {
    return Math.ceil((this._expAt() - Date.now()) / (60 * 60 * 24 * 1e3));
  }
  isExp(now6 = Date.now()) {
    if (this._decLic[bd(EXPIRES_AT)] === null)
      return false;
    return now6 > this._expAt();
  }
  _expAt() {
    return this._decLic[bd(EXPIRES_AT)] * 1e3;
  }
  _verify(message, signature) {
    let verification;
    let messageDigest;
    messageDigest = this._encodeMessage(message);
    verification = this._decodeSignature(signature);
    verification = verification.substr(-64);
    const isValid = messageDigest === verification;
    return isValid;
  }
  _encodeMessage(message) {
    const messageDigest = sha256(message);
    return messageDigest;
  }
  _decodeSignature(signature) {
    let verification;
    signature = base64_default.decode(signature);
    signature = byteArraytoHexString(signature);
    signature = this._parseBigInt(signature, 16);
    verification = signature.modPowInt(this._e, this._n);
    verification = verification.toString(16);
    return verification;
  }
  _parseBigInt(str, base) {
    return new jsbn_default(str, base);
  }
  _parseLicense() {
    if (typeof this._l !== "string")
      return;
    if (!this._jsonValid())
      return;
    this._sig = this._decLic[bd(SIGNATURE)] || "";
    delete this._decLic[bd(SIGNATURE)];
    this._sig = this._sig.replace(/[^A-Za-z0-9+/=]/g, "");
    this._message = this._l.replace(new RegExp(`,"${bd(SIGNATURE)}":"([^"]*)"`), "");
  }
  _includesFeature(feature, minLicenseVersion = new SemanticVersion("1.0", true)) {
    const version = new SemanticVersion(this._decLic[bd(VERSION)], true);
    if (minLicenseVersion.isMoreRecentThan(version))
      return true;
    return this._decLic[bd(FEATURES)] && this._decLic[bd(FEATURES)].indexOf(feature) !== -1;
  }
}
class FreeLicenseChecker {
  v() {
    return true;
  }
  c() {
    return Promise.resolve();
  }
  isToolAllowed(identifier) {
    return true;
  }
  isWhiteLabel() {
    return false;
  }
  areCustomAssetsAllowed() {
    return true;
  }
  t() {
    return Promise.resolve();
  }
  isENT() {
    return false;
  }
  exp() {
    return false;
  }
  dl() {
    return 0;
  }
  isExp(now6 = Date.now()) {
    return false;
  }
}
var license_checker_default = L;

// engine/shared/async/animation-frame.js
/*
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
 * requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
 * MIT license
 * @license
 */
const root3 = typeof window === "undefined" ? global : window;
let rAF = root3.requestAnimationFrame;
let cAF = root3.cancelAnimationFrame;
let lastTime = 0;
const vendors = ["ms", "moz", "webkit", "o"];
for (let x = 0; x < vendors.length && !rAF; ++x) {
  rAF = root3[`${vendors[x]}RequestAnimationFrame`];
  cAF = root3[`${vendors[x]}CancelAnimationFrame`] || root3[`${vendors[x]}CancelRequestAnimationFrame`];
}
if (rAF) {
  rAF = rAF.bind(root3);
}
if (cAF) {
  cAF = cAF.bind(root3);
}
if (!rAF) {
  rAF = function(callback, element) {
    const currTime = new Date().getTime();
    const timeToCall = Math.max(0, 16 - (currTime - lastTime));
    const id = setTimeout(function() {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
if (!cAF) {
  cAF = function(id) {
    clearTimeout(id);
  };
}

// engine/sdk/core/lib/math/cubic-bezier-curve.js
class CubicBezierCurve {
  constructor(p0 = new vector2_default(0, 0), p1 = new vector2_default(1, 1), p2 = new vector2_default(2, -1), p3 = new vector2_default(2, 0)) {
    this._p0 = p0.clone();
    this._p1 = p1.clone();
    this._p2 = p2.clone();
    this._p3 = p3.clone();
    this._segments = [];
    this._length = -1;
    this._sample = [];
  }
  set(p0 = new vector2_default(0, 0), p1 = new vector2_default(1, 1), p2 = new vector2_default(2, 1), p3 = new vector2_default(2, 0)) {
    this._p0 = p0.clone();
    this._p1 = p1.clone();
    this._p2 = p2.clone();
    this._p3 = p3.clone();
  }
  getLength() {
    return this._length;
  }
  calculateSegments(N = 100) {
    let t = 0;
    let len = 0;
    const segments = [];
    const step = 1 / N;
    let lastPoint = this._p0.clone();
    for (let i = 1; i <= N; i++) {
      const segment = [];
      segment.push({
        t,
        s: len,
        point: lastPoint
      });
      t += step;
      t = Math.min(t, 1);
      const point = this.evalAt(t);
      const delta = point.clone().subtract(lastPoint);
      len += delta.len();
      segment.push({
        t,
        s: len,
        point
      });
      segments.push(segment);
      lastPoint = point;
    }
    this._segments = segments;
    this._length = len;
    return len;
  }
  evalAt(t) {
    t = this.normalizeParameter(t);
    const a = this._p0.clone().multiply((1 - t) ** 3);
    const b = this._p1.clone().multiply(3 * (1 - t) * (1 - t) * t);
    const c = this._p2.clone().multiply(3 * (1 - t) * t * t);
    const d = this._p3.clone().multiply(t * t * t);
    return a.add(b).add(c).add(d);
  }
  isInSegment(s, segment) {
    s = this.normalizeArcLength(s);
    return s >= segment[0].s && s <= segment[1].s;
  }
  getArcLengthSegment(s) {
    s = this.normalizeArcLength(s);
    for (let i = 0; i < this._segments.length; i++) {
      const segment = this._segments[i];
      if (this.isInSegment(s, segment)) {
        return segment;
      }
    }
    return null;
  }
  normalizeArcLength(s) {
    return Math.max(Math.min(this._length, s), 0);
  }
  normalizeParameter(t) {
    return Math.max(Math.min(1, t), 0);
  }
  getParameterForArcLength(s) {
    const arcLen = this.normalizeArcLength(s);
    const segment = this.getArcLengthSegment(arcLen);
    if (!segment) {
      log_default.warn("CubicBezierCurve#getParameterForArcLength", "Segment not found.");
      return -1;
    }
    const a = (arcLen - segment[1].s) / (segment[0].s - segment[1].s);
    return a * segment[0].t + (1 - a) * segment[1].t;
  }
  evalAtArcLength(s) {
    return this.evalAt(this.getParameterForArcLength(s));
  }
  approximateAtArcLength(s) {
    const arcLen = this.normalizeArcLength(s);
    const segment = this.getArcLengthSegment(arcLen);
    if (!segment) {
      return -1;
    }
    const a = (arcLen - segment[1].s) / (segment[0].s - segment[1].s);
    return segment[0].point.clone().multiply(a).add(segment[1].point.clone().multiply(1 - a));
  }
  parameterSample(N = 100) {
    const step = 1 / N;
    const sample = [];
    let t = 0;
    for (let i = 0; i <= N + 1; i++) {
      sample.push(this.evalAt(t));
      t += step;
    }
    this._sample = sample;
    return [...sample];
  }
  arcLengthApproxSample(N = 100, excludeStartPoint = false, excludeEndPoint = false) {
    const step = this._length / N;
    const sample = [];
    let s = 0;
    for (let i = excludeStartPoint ? 1 : 0; i < N + 1; i++) {
      sample.push(this.approximateAtArcLength(s));
      s += step;
    }
    if (excludeEndPoint) {
      sample.pop();
    }
    this._sample = sample;
    return [...sample];
  }
}
var cubic_bezier_curve_default = CubicBezierCurve;

// engine/sdk/core/lib/math/range.js
class Range {
  constructor(min, max) {
    this.min = min;
    this.max = max;
  }
  getMin() {
    return this.min;
  }
  getMax() {
    return this.max;
  }
  getLength() {
    return this.max - this.min;
  }
  contains(value) {
    return this.min <= value && value <= this.max;
  }
}
var range_default = Range;

// engine/sdk/core/lib/math/vector3.js
class Vector3 {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    if (typeof this.x === "undefined") {
      this.x = 0;
    }
    if (typeof this.y === "undefined") {
      this.y = 0;
    }
    if (typeof this.z === "undefined") {
      this.z = 0;
    }
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  copy(other) {
    this.x = other.x;
    this.y = other.y;
    this.z = other.z;
    return this;
  }
  clamp(minimum, maximum) {
    const minimumSet = minimum !== null && typeof minimum !== "undefined";
    const maximumSet = maximum !== null && typeof maximum !== "undefined";
    if (!(minimum instanceof Vector3) && minimumSet) {
      minimum = new Vector3(minimum, minimum, minimum);
    }
    if (!(maximum instanceof Vector3) && maximumSet) {
      maximum = new Vector3(maximum, maximum, maximum);
    }
    if (minimumSet) {
      this.x = Math.max(minimum.x, this.x);
      this.y = Math.max(minimum.y, this.y);
      this.z = Math.max(minimum.z, this.z);
    }
    if (maximumSet) {
      this.x = Math.min(maximum.x, this.x);
      this.y = Math.min(maximum.y, this.y);
      this.z = Math.min(maximum.z, this.z);
    }
    return this;
  }
  divide(divisor) {
    if (divisor instanceof Vector3) {
      this.x /= divisor.x;
      this.y /= divisor.y;
      this.z /= divisor.z;
    } else {
      this.x /= divisor;
      this.y /= divisor;
      this.z /= divisor;
    }
    return this;
  }
  subtract(subtrahend) {
    if (subtrahend instanceof Vector3) {
      this.x -= subtrahend.x;
      this.y -= subtrahend.y;
      this.z -= subtrahend.z;
    } else {
      this.x -= subtrahend;
      this.y -= subtrahend;
      this.z -= subtrahend;
    }
    return this;
  }
  multiply(factor) {
    if (factor instanceof Vector3) {
      this.x *= factor.x;
      this.y *= factor.y;
      this.z *= factor.z;
    } else {
      this.x *= factor;
      this.y *= factor;
      this.z *= factor;
    }
    return this;
  }
  add(addend) {
    if (addend instanceof Vector3) {
      this.x += addend.x;
      this.y += addend.y;
      this.z += addend.z;
    } else {
      this.x += addend;
      this.y += addend;
      this.z += addend;
    }
    return this;
  }
  equals(vec) {
    if (vec instanceof Vector3) {
      return vec.x === this.x && vec.y === this.y && vec.z === this.z;
    }
    return vec === this.x && vec === this.y && vec === this.z;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  fract() {
    this.x %= 1;
    this.y %= 1;
    this.z %= 1;
    return this;
  }
  toInt() {
    this.x |= 0;
    this.y |= 0;
    this.z |= 0;
    return this;
  }
  abs() {
    this.x = Math.abs(this.x);
    this.y = Math.abs(this.y);
    this.z = Math.abs(this.z);
    return this;
  }
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  min() {
    return Math.min(Math.min(this.x, this.y), this.z);
  }
  max() {
    return Math.max(Math.max(this.x, this.y), this.z);
  }
  toObject() {
    return {x: this.x, y: this.y, z: this.z};
  }
  toString() {
    return `Vector3({ x: ${this.x}, y: ${this.y}, z: ${this.z} })`;
  }
  roundDecimal(decimals) {
    this.x = parseFloat(this.x.toFixed(decimals));
    this.y = parseFloat(this.y.toFixed(decimals));
    this.z = parseFloat(this.z.toFixed(decimals));
    return this;
  }
  static fromObject(object) {
    return new Vector3(object.x, object.y, object.z);
  }
  static get NULL() {
    return new Vector3(0, 0, 0);
  }
}
var vector3_default = Vector3;

// engine/sdk/core/lib/math/index.js
const math_exports = {};
__export(math_exports, {
  ColorMatrix: () => color_matrix_default,
  CubicBezierCurve: () => cubic_bezier_curve_default,
  Matrix: () => matrix_default,
  Range: () => range_default,
  Rectangle: () => rectangle_default,
  Vector2: () => vector2_default,
  Vector3: () => vector3_default
});

// engine/sdk/core/globals.js
const globals_exports2 = {};
__export(globals_exports2, {
  Base64: () => base64_default,
  Color: () => color_default,
  ColorMatrix: () => color_matrix_default,
  Configurable: () => configurable_default,
  Constants: () => constants_exports,
  CubicBezierCurve: () => cubic_bezier_curve_default,
  Engine: () => engine_default,
  EventEmitter: () => event_emitter_default,
  Events: () => Events,
  FreeLicenseChecker: () => FreeLicenseChecker,
  GLUtils: () => gl_utils_default,
  LicenseChecker: () => license_checker_default,
  Log: () => log_default,
  Matrix: () => matrix_default,
  Promise: () => promise_default,
  Range: () => range_default,
  Rectangle: () => rectangle_default,
  Utils: () => utils_default,
  Vector2: () => vector2_default,
  Vector3: () => vector3_default,
  cancelAnimationFrame: () => cAF,
  requestAnimationFrame: () => rAF
});
if (Function.prototype.name === void 0 && Object.defineProperty !== void 0) {
  Object.defineProperty(Function.prototype, "name", {
    get() {
      const funcNameRegex = /function\s([^(]{1,})\(/;
      const results = funcNameRegex.exec(this.toString());
      return results && results.length > 1 ? results[1].trim() : "";
    },
    set(value) {
    }
  });
}

// engine/sdk/core/lib/pot-renderer.js
class POTRenderer {
  constructor() {
    this._container = new engine_default.Container();
    this._sprite = new engine_default.Sprite();
    this._container.addChild(this._sprite);
  }
  render(renderer, inputSprite, inputTexture) {
    const textureDimensions = inputTexture.getDimensions();
    const nextPOT = this._getNextHighestPOT(textureDimensions);
    if (!this._renderTexture) {
      this._renderTexture = new engine_default.RenderTexture(renderer, nextPOT.x, nextPOT.y);
    } else {
      this._renderTexture.resizeTo(nextPOT);
    }
    const newDimensions = this._renderTexture.getDimensions();
    this._sprite.setTexture(inputTexture);
    this._sprite.updateTransform();
    this._renderTexture.clear();
    this._renderTexture.render(this._container);
    this._updateSprite(renderer, inputSprite, textureDimensions, newDimensions);
  }
  _updateSprite(renderer, inputSprite, initialDimensions, newDimensions) {
    inputSprite.setTexture(this._renderTexture);
    this._renderTexture.setFrame(new rectangle_default(0, 0, initialDimensions.x, initialDimensions.y));
  }
  _getNextHighestPOT(dimensions) {
    return new vector2_default(utils_default.nextHighestPOT(dimensions.x), utils_default.nextHighestPOT(dimensions.y));
  }
  getRenderTexture() {
    return this._renderTexture;
  }
  dispose() {
    if (!this._renderTexture) {
      return;
    }
    this._renderTexture.dispose();
    this._renderTexture = null;
  }
}

// engine/sdk/core/engine/sprites/sprite.js
class Sprite extends container_default {
  constructor(texture5) {
    super();
    this._onTextureUpdate = this._onTextureUpdate.bind(this);
    this._texture = texture5;
    this._shader = null;
    this._width = 0;
    this._height = 0;
    this._anchor = new vector2_default(0, 0);
    this._canvasSmoothingEnabled = true;
    this.setTexture(texture5);
  }
  _onTextureUpdate() {
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  _renderWebGL(renderer) {
    const save = renderer.save();
    if (this._smoothDownscaling) {
      if (!this._potRenderer) {
        this._potRenderer = new POTRenderer();
      }
      this._potRenderer.render(renderer, this, this._texture);
    }
    renderer.restore(save);
    renderer.setObjectRenderer(renderer.renderers.sprite);
    renderer.renderers.sprite.render(this);
  }
  _renderCanvas(renderer) {
    const transform = this._worldTransform;
    const textureFrame = this._texture.getFrame();
    const {width, height} = textureFrame;
    const pixelRatio = renderer.getCurrentRenderTarget().getPixelRatio();
    const dx = this._anchor.x * -width | 0;
    const dy = this._anchor.y * -height | 0;
    const ctx = renderer.getContext();
    ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * pixelRatio, transform.ty * pixelRatio);
    ctx.globalAlpha = this.getWorldAlpha();
    const baseTexture = this._texture.getBaseTexture();
    const texturePixelRatio = baseTexture.getPixelRatio();
    const source = baseTexture.getSource();
    ctx.imageSmoothingEnabled = this._canvasSmoothingEnabled;
    if (renderer.beforeDraw) {
      renderer.beforeDraw(ctx);
    }
    ctx.drawImage(source, 0, 0, (source.naturalWidth || width) * texturePixelRatio, (source.naturalHeight || height) * texturePixelRatio, dx * pixelRatio, dy * pixelRatio, width * pixelRatio, height * pixelRatio);
  }
  isAtPosition(position) {
    const localPosition = this._worldTransform.applyInverseToVector(position);
    const textureFrame = this._texture.getFrame();
    const {width, height} = textureFrame;
    const upperLeft = new vector2_default(-width, -height);
    upperLeft.multiply(this._anchor);
    const lowerRight = upperLeft.clone().add(width, height);
    if (localPosition.x < upperLeft.x || localPosition.x > lowerRight.x || localPosition.y < upperLeft.y || localPosition.y > lowerRight.y) {
      return false;
    }
    return true;
  }
  getLocalBounds() {
    if (this._localBoundsNeedUpdate) {
      const bounds = this._localBounds;
      const textureFrame = this._texture.getFrame();
      bounds.x = -textureFrame.width * this._anchor.x;
      bounds.y = -textureFrame.height * this._anchor.y;
      bounds.width = textureFrame.width;
      bounds.height = textureFrame.height;
      this._localBoundsNeedUpdate = false;
    }
    return this._localBounds.clone();
  }
  getBounds() {
    if (this._boundsNeedUpdate) {
      const bounds = this._bounds;
      const textureFrame = this._texture.getFrame();
      const worldTransform = this._worldTransform;
      const anchor = this._anchor;
      const positions = worldTransform.rectangleToCoordinates(textureFrame, anchor);
      let minX = positions[0].x;
      let minY = positions[0].y;
      let maxX = minX;
      let maxY = minY;
      positions.forEach(({x, y}) => {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      });
      bounds.x = minX;
      bounds.width = Math.abs(maxX - minX);
      bounds.y = minY;
      bounds.height = Math.abs(maxY - minY);
      this._boundsNeedUpdate = false;
    }
    return this._bounds.clone();
  }
  getTexture() {
    return this._texture;
  }
  clearTexture(dispose = true) {
    if (!this._texture) {
      return;
    }
    this._texture.off("update", this._onTextureUpdate);
    dispose && this._texture.dispose();
    this._texture = null;
    if (this._potRenderer) {
      dispose && this._potRenderer.dispose();
      this._potRenderer = null;
    }
  }
  setTexture(texture5) {
    if (!texture5) {
      return;
    }
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate);
    }
    if (this._potRenderer) {
      this._potRenderer.getRenderTexture().getBaseTexture().setDirty(true);
    }
    this._texture = texture5;
    if (texture5.getBaseTexture().isLoaded()) {
      this._onTextureUpdate();
    }
    texture5.on("update", this._onTextureUpdate);
  }
  getShader() {
    return this._shader;
  }
  setShader(shader4) {
    this._shader = shader4;
  }
  getWidth() {
    return this._width;
  }
  setWidth(width) {
    this._scale.x = width / this._texture.getFrame().width;
    this._width = width;
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  getHeight() {
    return this._height;
  }
  setHeight(height) {
    this._scale.y = height / this._texture.getFrame().height;
    this._height = height;
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  getDimensions() {
    return new vector2_default(this._width, this._height);
  }
  getAnchor() {
    return this._anchor;
  }
  setAnchor(anchor, y) {
    if (anchor instanceof vector2_default) {
      this._anchor.copy(anchor);
    } else {
      this._anchor.set(anchor, y);
    }
    this._boundsNeedUpdate = true;
    this._localBoundsNeedUpdate = true;
  }
  isSmoothDownscaling() {
    return this._smoothDownscaling;
  }
  setSmoothDownscaling(smoothDownscaling) {
    this._smoothDownscaling = smoothDownscaling;
  }
  dispose(texture5 = false, baseTexture = false) {
    if (this._texture) {
      this._texture.off("update", this._onTextureUpdate);
    }
    (texture5 || baseTexture) && this._texture.dispose(baseTexture);
    if (this._potRenderer) {
      this._potRenderer.dispose();
    }
  }
}
var sprite_default = Sprite;

// engine/sdk/core/engine/utils/texture-uvs.js
class TextureUVs {
  constructor() {
    this._uvs = [
      new vector2_default(0, 0),
      new vector2_default(1, 0),
      new vector2_default(1, 1),
      new vector2_default(0, 1)
    ];
  }
  update(frame2, baseFrame) {
    let uv = this._uvs[0];
    uv.x = frame2.x / baseFrame.width;
    uv.y = frame2.y / baseFrame.height;
    uv = this._uvs[1];
    uv.x = (frame2.x + frame2.width) / baseFrame.width;
    uv.y = frame2.y / baseFrame.height;
    uv = this._uvs[2];
    uv.x = (frame2.x + frame2.width) / baseFrame.width;
    uv.y = (frame2.y + frame2.height) / baseFrame.height;
    uv = this._uvs[3];
    uv.x = frame2.x / baseFrame.width;
    uv.y = (frame2.y + frame2.height) / baseFrame.height;
  }
  getUVsAt(index) {
    return this._uvs[index];
  }
  getUVs() {
    return this._uvs;
  }
}
var texture_uvs_default = TextureUVs;

// engine/sdk/core/engine/textures/texture.js
class Texture extends event_emitter_default {
  constructor(baseTexture, frame2) {
    super();
    if (!(baseTexture instanceof base_texture_default)) {
      throw new Error("`baseTexture` should be an instance of BaseTexture");
    }
    this._uvs = new texture_uvs_default();
    this._frame = frame2 ? frame2.clone() : null;
    this._frameLocked = !!frame2;
    this._onBaseTextureLoaded = this._onBaseTextureLoaded.bind(this);
    this._onBaseTextureUpdated = this._onBaseTextureUpdated.bind(this);
    if (!this._frame) {
      this._frame = new rectangle_default(0, 0, 1, 1);
    }
    this.setBaseTexture(baseTexture);
  }
  static fromImage(image5) {
    const baseTexture = new base_texture_default(image5);
    return new Texture(baseTexture);
  }
  static fromCanvas(canvas9) {
    const baseTexture = new base_texture_default(canvas9);
    return new Texture(baseTexture);
  }
  _onBaseTextureLoaded() {
    if (!this._frameLocked) {
      const frame2 = this._baseTexture.getFrame().clone();
      this.setFrame(frame2);
    }
    this._baseTexture.on("update", this._onBaseTextureUpdated);
  }
  _onBaseTextureUpdated() {
    const {width, height} = this._baseTexture.getFrame();
    this._frame.width = width;
    this._frame.height = height;
    this.emit("update");
  }
  _updateUVs() {
    this._uvs.update(this._frame, this._baseTexture.getFrame());
  }
  getBaseTexture() {
    return this._baseTexture;
  }
  setBaseTexture(baseTexture) {
    this._baseTexture = baseTexture;
    if (!this._baseTexture.isLoaded()) {
      this._baseTexture.once("loaded", this._onBaseTextureLoaded);
    } else {
      const {width, height} = baseTexture.getFrame();
      if (!this._frameLocked) {
        this._frame = new rectangle_default(0, 0, width, height);
      }
      this._onBaseTextureLoaded();
    }
  }
  getFrame() {
    return this._frame;
  }
  setFrame(frame2) {
    this._frame = frame2;
    this._updateUVs();
  }
  getWidth() {
    return this._frame.width;
  }
  getHeight() {
    return this._frame.height;
  }
  getUVs() {
    return this._uvs;
  }
  getDimensions() {
    return new vector2_default(this._frame.width, this._frame.height);
  }
  dispose(baseTexture = true) {
    baseTexture && this._baseTexture.dispose();
  }
}
var texture_default3 = Texture;

// engine/sdk/core/engine/textures/render-texture.js
const {RendererType: RendererType6} = constants_exports;
class RenderTexture extends texture_default3 {
  constructor(renderer, width = 100, height = 100, pixelRatio = 1) {
    super(new base_texture_default(), new rectangle_default(0, 0, width, height));
    this._loaded = true;
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this._renderer = renderer;
    this._setupFilterManager();
    this._setupBuffer();
    this.setBaseTexture(this._renderTarget.getBaseTexture());
    this._updateUVs();
  }
  _setupFilterManager() {
    if (this._filterManager) {
      this._filterManager.dispose();
    }
    if (this._renderer.isOfType(RendererType6.WEBGL)) {
      this._filterManager = new webgl_filter_manager_default(this._renderer);
    } else if (this._renderer.isOfType(RendererType6.CANVAS)) {
      this._filterManager = new canvas_filter_manager_default(this._renderer);
    }
    this._filterManager.resizeTo(new vector2_default(this._width, this._height));
  }
  _setupBuffer() {
    if (this._renderer.isOfType(RendererType6.WEBGL)) {
      this._setupWebGLRenderTarget();
    } else if (this._renderer.isOfType(RendererType6.CANVAS)) {
      this._setupCanvasRenderTarget();
    }
  }
  _setupWebGLRenderTarget() {
    if (this._renderTarget) {
      this._renderTarget.dispose();
    }
    this._renderTarget = new webgl_render_target_default(this._renderer, this._width, this._height, this._pixelRatio);
  }
  _setupCanvasRenderTarget() {
    if (this._renderTarget) {
      this._renderTarget.dispose();
    }
    this._renderTarget = new canvas_render_target_default(this._width, this._height, this._pixelRatio);
  }
  clear(color6) {
    this._renderTarget.clear(color6);
  }
  resizeTo(dimensions) {
    if (this._width === dimensions.x && this._height === dimensions.y) {
      return;
    }
    this._width = dimensions.x;
    this._height = dimensions.y;
    this._frame.width = dimensions.x;
    this._frame.height = dimensions.y;
    this._renderTarget.resizeTo(dimensions);
    this._filterManager.resizeTo(dimensions);
  }
  render(displayObject) {
    if (this._renderer.isOfType(RendererType6.WEBGL)) {
      this._renderWebGL(displayObject);
    } else if (this._renderer.isOfType(RendererType6.CANVAS)) {
      this._renderCanvas(displayObject);
    } else {
      throw new Error(`RenderTexture does not support rendering via ${this._renderer.constructor.name}`);
    }
  }
  _renderWebGL(displayObject) {
    this._renderTarget.activate();
    displayObject.getWorldTransform().reset();
    displayObject.getChildren().forEach((child) => {
      child.updateTransform();
    });
    const tempFilterManager = this._renderer.getFilterManager();
    this._renderer.setFilterManager(this._filterManager);
    this._renderer.renderDisplayObject(displayObject, this._renderTarget);
    this._renderer.setFilterManager(tempFilterManager);
  }
  _renderCanvas(displayObject) {
    displayObject.getWorldTransform().reset();
    displayObject.getChildren().forEach((child) => {
      child.updateTransform();
    });
    const tempFilterManager = this._renderer.getFilterManager();
    this._renderer.setFilterManager(this._filterManager);
    this._renderer.renderDisplayObject(displayObject, this._renderTarget);
    this._renderer.setFilterManager(tempFilterManager);
  }
  getRenderTarget() {
    return this._renderTarget;
  }
  dispose() {
    this._renderTarget.dispose();
    this._filterManager.dispose();
    super.dispose();
  }
}
var render_texture_default = RenderTexture;

// engine/sdk/core/engine/index.js
const Engine = {
  WebGLRenderer: webgl_renderer_default,
  CanvasRenderer: canvas_renderer_default,
  WebGLFilterManager: webgl_filter_manager_default,
  CanvasFilterManager: canvas_filter_manager_default,
  DisplayObject: display_object_default,
  Container: container_default,
  BaseTexture: base_texture_default,
  Texture: texture_default3,
  RenderTexture: render_texture_default,
  WebGLRenderTarget: webgl_render_target_default,
  CanvasRenderTarget: canvas_render_target_default,
  Sprite: sprite_default,
  Shaders: shaders_default,
  Shader: shader_default,
  Filter: filter_default,
  Filters: filters_exports,
  PixelArrayImage,
  autoDetectRenderer(width, height, options = {}) {
    if (webgl_renderer_default.isSupported()) {
      return new webgl_renderer_default(width, height, options);
    }
    return new canvas_renderer_default(width, height, options);
  }
};
var engine_default = Engine;

// engine/sdk/core/lib/env.js
class Env {
  static current() {
    return process.env.ENV;
  }
  static isTest() {
    return process.env.ENV === "test";
  }
  static isDevelopment() {
    return process.env.ENV === "development";
  }
  static isProduction() {
    return process.env.ENV === "production" || !this.isTest() && !this.isDevelopment();
  }
}
var env_default = Env;

// engine/sdk/core/lib/array-stream.js
class ArrayStream {
  constructor(buf) {
    this._head = 0;
    this._buf = buf;
  }
  peekInt8() {
    return this._buf[this._head];
  }
  peekInt16(littleEndian = false) {
    const a = this._buf[this._head];
    const b = this._buf[this._head + 1];
    if (!littleEndian) {
      return (a << 8) + b;
    }
    return (b << 8) + a;
  }
  peekInt24(littleEndian = false) {
    const a = this._buf[this._head];
    const b = this._buf[this._head + 1];
    const c = this._buf[this._head + 2];
    if (!littleEndian) {
      return (a << 16) + (b << 8) + c;
    }
    return (c << 16) + (b << 8) + a;
  }
  peekInt32(littleEndian = false) {
    const a = this._buf[this._head];
    const b = this._buf[this._head + 1];
    const c = this._buf[this._head + 2];
    const d = this._buf[this._head + 3];
    if (!littleEndian) {
      return (a << 32) + (b << 16) + (c << 8) + d;
    }
    return (d << 32) + (c << 16) + (b << 8) + a;
  }
  writeInt8(num) {
    this._buf[this._head] = num & 255;
  }
  writeInt16(num) {
    this._buf[this._head] = num >> 8;
    this._buf[this._head + 1] = num & 255;
  }
  readInt8() {
    const num = this.peekInt8();
    this._head += 1;
    return num;
  }
  readInt16(littleEndian = false) {
    const num = this.peekInt16(littleEndian);
    this._head += 2;
    return num;
  }
  readInt24(littleEndian = false) {
    const num = this.peekInt24(littleEndian);
    this._head += 3;
    return num;
  }
  readInt32(littleEndian = false) {
    const num = this.peekInt32(littleEndian);
    this._head += 4;
    return num;
  }
  readString(length) {
    let str = "";
    for (let i = 0; i < length; i++) {
      const character = this.readInt8();
      str += String.fromCharCode(character);
    }
    return str;
  }
  getHead() {
    return this._head;
  }
  setHead(head) {
    this._head = head;
  }
}
var array_stream_default = ArrayStream;

// engine/sdk/core/lib/jpeg/constants.js
const MARKERS = {
  SOI: 65496,
  SOS: 65498,
  APP0: 65504,
  APP1: 65505,
  JFIF: 65504,
  EXIF: 65505
};
const EXIF_TAGS = {
  256: "ImageWidth",
  257: "ImageHeight",
  34665: "ExifIFDPointer",
  34853: "GPSInfoIFDPointer",
  40965: "InteroperabilityIFDPointer",
  258: "BitsPerSample",
  259: "Compression",
  262: "PhotometricInterpretation",
  274: "Orientation",
  277: "SamplesPerPixel",
  284: "PlanarConfiguration",
  530: "YCbCrSubSampling",
  531: "YCbCrPositioning",
  282: "XResolution",
  283: "YResolution",
  296: "ResolutionUnit",
  273: "StripOffsets",
  278: "RowsPerStrip",
  279: "StripByteCounts",
  513: "JPEGInterchangeFormat",
  514: "JPEGInterchangeFormatLength",
  301: "TransferFunction",
  318: "WhitePoint",
  319: "PrimaryChromaticities",
  529: "YCbCrCoefficients",
  532: "ReferenceBlackWhite",
  306: "DateTime",
  270: "ImageDescription",
  271: "Make",
  272: "Model",
  305: "Software",
  315: "Artist",
  33432: "Copyright"
};
var constants_default2 = {
  MARKERS,
  EXIF_TAGS
};

// engine/sdk/core/lib/jpeg/exif-data.js
const {invariant} = utils_default;
const {MARKERS: MARKERS2, EXIF_TAGS: EXIF_TAGS2} = constants_default2;
class EXIFData {
  constructor(buf) {
    this._buf = buf;
    this._stream = new array_stream_default(this._buf);
    this._stream.setHead(0);
    this._parse();
    this._bigEndian = false;
  }
  isValid() {
    this._stream.setHead(0);
    const marker = this._stream.readInt16();
    if (marker !== MARKERS2.EXIF) {
      return false;
    }
    const length = this._stream.readInt16();
    if (!(length > 0)) {
      return false;
    }
    const header = this._stream.readString(4);
    if (header !== "Exif") {
      return false;
    }
    return true;
  }
  _parse() {
    if (!this.isValid()) {
      return;
    }
    this._stream.setHead(10);
    const tiffOffset = this._stream.getHead();
    this._bigEndian = false;
    const endian = this._stream.readInt16();
    if (endian === 18761) {
      this._bigEndian = false;
    } else if (endian === 19789) {
      this._bigEndian = true;
    } else {
      invariant(false, "Invalid TIFF data: No endian type found");
    }
    invariant(this._stream.readInt16(!this._bigEndian) === 42, "Invalid TIFF data: No 0x002A");
    const firstIFDOffset = this._stream.readInt32(!this._bigEndian);
    invariant(firstIFDOffset >= 8, "Invalid TIFF data: First IFD offset < 8");
    const ifdOffset = tiffOffset + firstIFDOffset;
    const tags = this._readTags(this._stream, tiffOffset, ifdOffset, this._bigEndian);
    this._tags = tags.tags;
    this._tagData = tags.tagData;
  }
  getTags() {
    return this._tags;
  }
  getTagData() {
    return this._tagData;
  }
  setOrientation(orientation) {
    if (this._tagData.Orientation) {
      const {entryOffset} = this._tagData.Orientation;
      this._stream.setHead(entryOffset + 8);
      this._stream.writeInt16(this._bigEndian ? orientation : (orientation & 255) << 8 | orientation >> 8 & 255);
    }
  }
  _readTags(stream, tiffStart, ifdStart, bigEndian) {
    stream.setHead(ifdStart);
    const entriesCount = stream.readInt16(!bigEndian);
    const tags = {};
    const tagData = [];
    for (let i = 0; i < entriesCount; i++) {
      const entryOffset = ifdStart + i * 12 + 2;
      stream.setHead(entryOffset);
      let tag = stream.readInt16(!bigEndian);
      let type;
      let numValues;
      let valueOffset;
      if (EXIF_TAGS2[tag]) {
        tag = EXIF_TAGS2[tag];
        type = stream.readInt16(!bigEndian);
        numValues = stream.readInt32(!bigEndian);
        valueOffset = stream.readInt32(!bigEndian) + tiffStart;
        let value = null;
        switch (type) {
          case 1:
          case 7:
            if (numValues === 1) {
              value = stream.readInt8(!bigEndian);
            } else {
              value = [];
              for (let i2 = 0; i2 < numValues; i2++) {
                value.push(stream.readInt8(!bigEndian));
              }
            }
            break;
          case 2:
            stream.setHead(numValues > 4 ? valueOffset : entryOffset + 8);
            value = stream.readString(numValues);
            break;
          case 3:
            stream.setHead(numValues > 2 ? valueOffset : entryOffset + 8);
            if (numValues === 1) {
              value = stream.readInt16(!bigEndian);
            } else {
              value = [];
              for (let i2 = 0; i2 < numValues; i2++) {
                value.push(stream.readInt16(!bigEndian));
              }
            }
            break;
          case 4:
          case 9:
            stream.setHead(numValues > 1 ? valueOffset : entryOffset + 8);
            if (numValues === 1) {
              value = stream.readInt32(!bigEndian);
            } else {
              value = [];
              for (let i2 = 0; i2 < numValues; i2++) {
                value.push(stream.readInt32(!bigEndian));
              }
            }
            break;
          case 5:
          case 10:
            stream.setHead(valueOffset);
            if (numValues === 1) {
              const numerator = stream.readInt32(!bigEndian);
              const denominator = stream.readInt32(!bigEndian);
              value = numerator / denominator;
            } else {
              value = [];
              for (let i2 = 0; i2 < numValues; i2++) {
                const numerator = stream.readInt32(!bigEndian);
                const denominator = stream.readInt32(!bigEndian);
                const val = numerator / denominator;
                value.push(val);
              }
            }
            break;
        }
        tags[tag] = value;
        tagData[tag] = {
          value,
          numValues,
          entryOffset,
          valueOffset,
          type
        };
      }
    }
    return {tags, tagData};
  }
  getBuffer() {
    return this._buf;
  }
}
var exif_data_default = EXIFData;

// engine/sdk/core/lib/jpeg/jfif-data.js
const {MARKERS: MARKERS3} = constants_default2;
class JFIFData {
  constructor(buf) {
    this._buf = buf;
    this._stream = new array_stream_default(this._buf);
    this._stream.setHead(0);
  }
  isValid() {
    this._stream.setHead(0);
    const marker = this._stream.readInt16();
    if (marker !== MARKERS3.APP0) {
      return false;
    }
    const length = this._stream.readInt16();
    if (!(length >= 16)) {
      return false;
    }
    const fileIdentifier = this._stream.readString(4);
    const fileIdentifierEndMarker = this._stream.readInt8();
    if (!(fileIdentifier === "JFIF")) {
      return false;
    }
    if (!(fileIdentifierEndMarker === 0)) {
      return false;
    }
    return true;
  }
  setUnitDensity(val) {
    this._stream.setHead(11);
    this._stream.writeInt8(val);
  }
  setDensityX(val) {
    this._stream.setHead(12);
    this._stream.writeInt16(val);
  }
  setDensityY(val) {
    this._stream.setHead(14);
    this._stream.writeInt16(val);
  }
  getUnitDensity() {
    this._stream.setHead(11);
    return this._stream.readInt8();
  }
  getDensityX() {
    this._stream.setHead(12);
    return this._stream.readInt16();
  }
  getDensityY() {
    this._stream.setHead(14);
    return this._stream.readInt16();
  }
  getBuffer() {
    return this._buf;
  }
}
var jfif_data_default = JFIFData;

// engine/sdk/core/lib/exif.js
/*
 * Based on https://github.com/exif-js/exif-js by Jacob Seidelin
 * Licensed under MIT
 * @license
 */
const {invariant: invariant2} = utils_default;
const {MARKERS: MARKERS4} = constants_default2;
const DATA_JPEG_PREFIX = "data:image/jpeg;base64,";
const JPEG_REGEX = new RegExp(`^${DATA_JPEG_PREFIX}`, "i");
class EXIF {
  constructor(buf) {
    this._buf = buf;
    this._stream = new array_stream_default(this._buf);
    this._stream.setHead(0);
    this._segments = this._sliceIntoSegments(this._buf);
    this._exifData = new exif_data_default(this._getMarkerBuffer(MARKERS4.EXIF));
    this._jfifData = new jfif_data_default(this._getMarkerBuffer(MARKERS4.JFIF));
  }
  static toDataURL(data) {
    return DATA_JPEG_PREFIX + base64_default.encode(data);
  }
  static fromDataURL(dataURL) {
    const raw = dataURL.replace(DATA_JPEG_PREFIX, "");
    const data = base64_default.decode(raw);
    return data;
  }
  restoreSegmentsInArray(buffer) {
    buffer = this.restoreExifTagsToImageData(buffer);
    return this.restoreJfifSegmentToImageData(buffer);
  }
  restoreSegments(base64String) {
    let data = EXIF.fromDataURL(base64String);
    data = this.restoreSegmentsInArray(data);
    return EXIF.toDataURL(data);
  }
  restoreExifTagsToImageData(data) {
    if (!this._exifData.isValid()) {
      return data;
    }
    const segments = this._sliceIntoSegments(data);
    const segmentStart = segments[1][0];
    const dataBefore = data.slice(0, segmentStart);
    const dataAfter = data.slice(segmentStart);
    let newData = dataBefore.concat(this._exifData.getBuffer());
    newData = newData.concat(dataAfter);
    return newData;
  }
  restoreJfifSegmentToImageData(data) {
    if (!this._jfifData.isValid()) {
      return data;
    }
    const segments = this._sliceIntoSegments(data);
    const segment = this._findSegment(MARKERS4.JFIF, segments);
    let newData = [];
    if (segment) {
      const offset = segment[0];
      const end = segment[1];
      const dataBefore = data.slice(0, offset);
      const dataBuf = data.slice(offset, end);
      const dataAfter = data.slice(end);
      const jfifData = new jfif_data_default(dataBuf);
      jfifData.setDensityX(this._jfifData.getDensityX());
      jfifData.setDensityY(this._jfifData.getDensityY());
      jfifData.setUnitDensity(this._jfifData.getUnitDensity());
      newData = dataBefore.concat(dataBuf).concat(dataAfter);
    } else {
      return data;
    }
    return newData;
  }
  restoreExifTags(base64String) {
    const data = EXIF.fromDataURL(base64String);
    const newData = this.restoreExifTagsToImageData(data);
    return EXIF.toDataURL(newData);
  }
  restoreJfifSegment(base64String) {
    if (!this._jfifData.isValid()) {
      return base64String;
    }
    const data = EXIF.fromDataURL(base64String);
    const newData = this.restoreJfifSegmentToImageData(data);
    return EXIF.toDataURL(newData);
  }
  setOrientation(orientation) {
    return this._exifData.setOrientation(orientation);
  }
  static isJPEG(base64String) {
    return JPEG_REGEX.test(base64String);
  }
  static bufferIsJPEG(data) {
    return data[0] === 255 && data[1] === 216 && data[2] === 255;
  }
  static fromBase64String(base64String) {
    const raw = base64String.replace(DATA_JPEG_PREFIX, "");
    const data = base64_default.decode(raw);
    return new EXIF(data);
  }
  _findSegment(identifier, segments = this._segments) {
    for (let i = 0; i < segments.length; i++) {
      const offset = segments[i][0];
      const end = segments[i][1];
      this._stream.setHead(offset);
      const marker = this._stream.peekInt16();
      if (marker === identifier) {
        return [offset, end];
      }
    }
    return false;
  }
  _getLastSegment(segments = this._segments) {
    return segments[segments.length - 1];
  }
  _getMarkerBuffer(identifier, segments = this._segments) {
    const segment = this._findSegment(identifier, segments);
    if (segment) {
      const offset = segment[0];
      const end = segment[1];
      return this._buf.slice(offset, end);
    }
    return false;
  }
  _sliceIntoSegments(buf) {
    const stream = new array_stream_default(buf);
    const segments = [];
    while (stream.getHead() < buf.length) {
      const marker = stream.readInt16();
      if (marker === MARKERS4.SOI) {
        continue;
      }
      if (marker === MARKERS4.SOS) {
        break;
      }
      if (marker >= 65280 && marker <= 65535) {
        const length = stream.readInt16();
        const end = stream.getHead() + length - 2;
        segments.push([stream.getHead() - 4, end]);
        stream.setHead(end);
      } else {
        throw new Error(`Invalid marker: 0x${marker.toString(16)}`);
      }
    }
    this._stream.setHead(0);
    return segments;
  }
  getTags() {
    return this._exifData.getTags();
  }
  getTagData() {
    return this._exifData.getTagData();
  }
  dispose() {
    this._buf = [];
    this._segments = [];
  }
}
var exif_default = EXIF;

// engine/sdk/core/lib/operations-stack.js
class OperationsStack extends event_emitter_default {
  constructor(operations3 = []) {
    super();
    this._onOperationUpdate = this._onOperationUpdate.bind(this);
    this._cacheEnabled = true;
    this._stack = operations3;
    this._stack.forEach((operation3) => {
      operation3.on("update", this._onOperationUpdate);
    });
  }
  clear() {
    this.forEach((operation3) => this.remove(operation3));
    this._stack = [];
  }
  hasChanges() {
    return this._stack.filter((op) => !!op).some((op) => op.hasChanges());
  }
  _onOperationUpdate(operation3, options) {
    this.emit(Events.OPERATION_UPDATED, operation3, options);
  }
  enableCache() {
    this._cacheEnabled = true;
  }
  disableCache() {
    this._cacheEnabled = false;
  }
  forEach(iterator) {
    return this._stack.filter((op) => !!op).forEach(iterator);
  }
  render(sdk14, inputTexture) {
    const currentTexture = inputTexture;
    const operations3 = this._stack.filter((op) => !!op).filter((op) => op.getEnabled());
    operations3.reverse();
    const firstUndirtyOperation = operations3.filter((o) => !o.isDirtyForRenderer(sdk14.getRenderer()))[0];
    const firstUndirtyIndex = operations3.indexOf(firstUndirtyOperation);
    operations3.reverse();
    let startIndex = 0;
    if (firstUndirtyIndex !== -1) {
      startIndex = operations3.length - firstUndirtyIndex - 1;
    }
    for (let index = 0; index < startIndex; index++) {
      log_default.info(this.constructor.name, `Skipping ${operations3[index].constructor.name}`);
    }
    let promise8 = promise_default.resolve(currentTexture);
    for (let index = startIndex; index < operations3.length; index++) {
      const operation3 = operations3[index];
      let lastTexture;
      let lastTextureOperation;
      promise8 = promise8.then((inputTexture2) => {
        return operation3.render(inputTexture2).then((outputTexture) => {
          if (lastTexture && outputTexture !== lastTexture && !this._cacheEnabled) {
            lastTextureOperation.disposeRenderTextures();
          }
          lastTexture = outputTexture;
          lastTextureOperation = operation3;
          return outputTexture;
        });
      });
    }
    return promise8.then((outputTexture) => {
      const renderDone = !operations3.some((op) => op.isDirtyForRenderer(sdk14.getRenderer()));
      return {outputTexture, renderDone};
    });
  }
  validateSettings() {
    return promise_default.all(this._stack.filter((op) => !!op).map((op) => op.validateSettings()));
  }
  setAllToDirty(dimensionsChanged = false) {
    this.forEach((op) => op.setDirty(true, dimensionsChanged));
  }
  updateDirtinessForRenderer(renderer) {
    let dirtyFound = false;
    for (let i = 0; i < this._stack.length; i++) {
      const operation3 = this._stack[i];
      if (!operation3)
        continue;
      if (operation3.isDirtyForRenderer(renderer)) {
        dirtyFound = true;
      }
      if (dirtyFound) {
        operation3.setDirtyForRenderer(true, renderer);
      }
    }
  }
  push(operation3) {
    this._stack.push(operation3);
    operation3.on("update", this._onOperationUpdate);
  }
  pop() {
    const operation3 = this._stack.pop();
    if (operation3) {
      operation3.off("update", this._onOperationUpdate);
      operation3.dispose();
    }
  }
  unshift(operation3) {
    this._stack.unshift(operation3);
    operation3.on("update", this._onOperationUpdate);
  }
  clone() {
    return new OperationsStack(this._stack.slice(0));
  }
  get(index) {
    return this._stack[index];
  }
  getByIdentifier(identifier) {
    return utils_default.Array.find(this._stack, (item) => item && item.constructor.identifier === identifier);
  }
  getIndexByIdentifier(identifier) {
    return utils_default.Array.findIndex(this._stack, (item) => item && item.constructor.identifier === identifier);
  }
  moveToTop(identifier) {
    const index = utils_default.Array.findIndex(this._stack, (item) => item && item.constructor.identifier === identifier);
    if (index < 0 || index === this._stack.length - 1) {
      return;
    }
    const operation3 = this.getByIdentifier(identifier);
    this._stack.splice(index, 1);
    this._stack[this._stack.length] = operation3;
  }
  set(index, operation3) {
    if (this._stack[index]) {
      this._stack[index].off("update", this._onOperationUpdate);
      this._stack[index].dispose();
    }
    this._stack[index] = operation3;
    operation3.on("update", this._onOperationUpdate);
  }
  remove(operation3) {
    const index = this._stack.indexOf(operation3);
    if (index === -1) {
      return;
    }
    if (this._stack[index]) {
      this._stack[index].off("update", this._onOperationUpdate);
      this._stack[index].dispose();
    }
    this._stack.splice(index, 1);
  }
  removeAt(index) {
    if (this._stack[index]) {
      this._stack[index].off("update", this._onOperationUpdate);
      this._stack[index].dispose();
    }
    delete this._stack[index];
  }
  getStack() {
    return this._stack;
  }
  dispose() {
    this.forEach((operation3) => {
      operation3.dispose();
    });
  }
}
var operations_stack_default = OperationsStack;

// engine/sdk/core/lib/performance-test.js
const now2 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();
class PerformanceTest {
  constructor(tag, name) {
    this._tag = tag;
    this._name = name;
    this._start = now2();
  }
  stop() {
    const end = now2();
    const ms = end - this._start;
    const fps = Math.round(1e3 / ms);
    log_default.info(this._tag, `${this._name} took ${ms.toFixed(2)}ms (${fps} FPS)`);
  }
}
var performance_test_default = PerformanceTest;

// engine/sdk/core/operations/operation.js
class Operation extends configurable_default {
  constructor(sdk14, options = {}) {
    super(options, {
      enabled: {type: OptionType.BOOLEAN, default: true, serializable: false}
    });
    this._sdk = sdk14;
    this._cacheEnabled = false;
    this._dirtiness = {};
    this._sprite = new engine_default.Sprite();
    this._container = new engine_default.Container();
    this._container.addChild(this._sprite);
  }
  _onOptionsChange() {
    this.setDirty(true);
  }
  render(inputTexture) {
    if (!this.getEnabled()) {
      log_default.info(this.constructor.name, "Disabled - skipping");
      return promise_default.resolve(inputTexture);
    }
    if (!this._renderTexture) {
      const newDimensions = inputTexture.getDimensions().floor();
      this._renderTexture = new engine_default.RenderTexture(this._sdk.getRenderer(), newDimensions.x, newDimensions.y);
    }
    const renderer = this._sdk.getRenderer();
    let promise8;
    let perf;
    if (log_default.canLog("info")) {
      perf = new performance_test_default(this.constructor.name, "Rendering");
    }
    if (this.isDirtyForRenderer(renderer)) {
      this._sprite.setTexture(inputTexture);
      const newDimensions = this.getNewDimensions(inputTexture.getDimensions()).floor();
      this._renderTexture.resizeTo(newDimensions);
      this._renderTexture.clear();
      promise8 = this._render(inputTexture).then((stillDirty = false) => {
        this.setDirtyForRenderer(stillDirty, renderer);
        return this._renderTexture;
      });
    } else {
      log_default.info(this.constructor.name, "Rendering from cache");
      promise8 = promise_default.resolve(this._renderTexture);
    }
    return promise8.then((outputTexture) => {
      if (perf)
        perf.stop();
      return outputTexture;
    });
  }
  _render(inputTexture) {
    let renderFn;
    if (this._sdk.getRenderer().isOfType(RendererType.WEBGL)) {
      renderFn = this._renderWebGL.bind(this);
    } else {
      renderFn = this._renderCanvas.bind(this);
    }
    return renderFn(inputTexture);
  }
  _renderWebGL(inputTexture) {
    throw new Error("Operation#_renderWebGL is abstract and not implemented in inherited class.");
  }
  _renderCanvas(inputTexture) {
    throw new Error("Operation#_renderCanvas is abstract and not implemented in inherited class.");
  }
  getNewDimensions(dimensions) {
    return dimensions.clone();
  }
  onBeforeExport() {
    if (this.transform && this._tempTransformChange) {
      this.transform(this._tempTransformChange);
    }
    this._onBeforeExport();
  }
  onAfterExport() {
    if (this.transform && this._tempInverseTransformChange) {
      this.transform(this._tempInverseTransformChange);
    }
    this._onAfterExport();
  }
  _onBeforeExport() {
  }
  _onAfterExport() {
  }
  setTemporaryTransformChange(transformChange, inverseTransformChange) {
    this._tempTransformChange = transformChange;
    this._tempInverseTransformChange = inverseTransformChange;
  }
  reset() {
    this._dirty = true;
    this._glslPrograms = {};
  }
  isDirtyForRenderer(renderer) {
    const dirty = this._dirtiness[renderer.id];
    return typeof dirty === "undefined" ? true : dirty;
  }
  setDirtyForRenderer(dirty, renderer, dimensionsChanged = false) {
    this._dirtiness[renderer.id] = dirty;
  }
  setDirty(dirty, dimensionsChanged = false) {
    for (const rendererId in this._dirtiness) {
      this.setDirtyForRenderer(dirty, {id: rendererId}, dimensionsChanged);
    }
  }
  getSDK() {
    return this._sdk;
  }
  getInputDimensions(incorporateZoom = true) {
    let dimensions = this._sdk.getInputDimensions();
    if (incorporateZoom) {
      dimensions.multiply(this._sdk.getZoom()).floor();
    }
    let opFound;
    this._sdk.getOperationsStack().forEach((op) => {
      if (opFound)
        return;
      if (op === this) {
        opFound = true;
        return;
      }
      dimensions = op.getNewDimensions(dimensions);
    });
    return dimensions.floor();
  }
  clone() {
    const Operation2 = this.constructor;
    return new Operation2(this._sdk, this.serializeOptions());
  }
  disposeRenderTextures() {
    if (this._renderTexture) {
      this._renderTexture.dispose();
    }
    this._renderTexture = null;
  }
  dispose() {
    this.disposeRenderTextures();
    this._sprite.dispose();
  }
}
Operation.identifier = null;
var operation_default = Operation;

// engine/sdk/core/operations/exif-orientation-operation.js
const {OptionType: OptionType6} = constants_exports;
class ExifOrientationOperation extends operation_default {
  getRotation() {
    let degrees = 0;
    switch (this.getTags().Orientation) {
      case 7:
      case 8:
        degrees = -90;
        break;
      case 3:
      case 4:
        degrees = -180;
        break;
      case 5:
      case 6:
        degrees = 90;
        break;
    }
    return degrees;
  }
  _getFlipVertically() {
    const {Orientation} = this.getTags();
    return [5, 7].indexOf(Orientation) !== -1;
  }
  _getFlipHorizontally() {
    const {Orientation} = this.getTags();
    return [2, 4].indexOf(Orientation) !== -1;
  }
  _getFinalOptions() {
    return {
      rotation: this.getRotation(),
      flipVertically: this._getFlipVertically(),
      flipHorizontally: this._getFlipHorizontally()
    };
  }
  _render(sdk14) {
    const options = this._getFinalOptions();
    const actualDegrees = options.rotation % 360;
    const radians = actualDegrees * (Math.PI / 180);
    this._sprite.setScale(options.flipHorizontally ? -1 : 1, options.flipVertically ? -1 : 1);
    this._sprite.setRotation(radians);
    this._sprite.setAnchor(0.5, 0.5);
    this._sprite.updateTransform();
    const bounds = this._sprite.getBounds();
    this._renderTexture.resizeTo(new vector2_default(bounds.width, bounds.height));
    this._sprite.setPosition(this._renderTexture.getDimensions().divide(2));
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  getNewDimensions(dimensions) {
    const options = this._getFinalOptions();
    dimensions = dimensions.clone();
    if (options.rotation % 180) {
      dimensions.flip();
    }
    return dimensions;
  }
  applyTo(image5) {
    const options = this._getFinalOptions();
    const canvas9 = utils_default.createCanvas();
    if (Math.abs(options.rotation % 180) === 90) {
      canvas9.width = image5.height;
      canvas9.height = image5.width;
    } else {
      canvas9.width = image5.width;
      canvas9.height = image5.height;
    }
    const context = canvas9.getContext("2d");
    const rotation = options.rotation * Math.PI / 180;
    const adjustX = 0.5 * (canvas9.width - image5.width);
    const adjustY = 0.5 * (canvas9.height - image5.height);
    context.translate(adjustX, adjustY);
    context.translate(0.5 * image5.width, 0.5 * image5.height);
    context.rotate(rotation);
    context.translate(-0.5 * image5.width, -0.5 * image5.height);
    if (options.flipVertically) {
      context.translate(0, image5.height);
      context.scale(1, -1);
    }
    if (options.flipHorizontally) {
      context.translate(image5.width, 0);
      context.scale(-1, 1);
    }
    context.drawImage(image5, 0, 0);
    return canvas9;
  }
}
ExifOrientationOperation.identifier = "exif-orientation";
ExifOrientationOperation.prototype.availableOptions = {
  tags: {type: OptionType6.OBJECT, default: {}}
};
var exif_orientation_operation_default = ExifOrientationOperation;

// engine/sdk/core/operations/index.js
const operations_exports = {};
__export(operations_exports, {
  ExifOrientationOperation: () => exif_orientation_operation_default
});

// engine/sdk/core/lib/image-exporter.js
class ImageExporter extends configurable_default {
  constructor(sdk14, options = {}) {
    super(options);
    this._sdk = sdk14;
  }
  export() {
    const {imageFormat} = this._options;
    const rerenderIfNeeded = (response) => {
      if (!response.renderDone) {
        return this._sdk.render().then((response2) => {
          return rerenderIfNeeded(response2);
        });
      }
      return response;
    };
    return this.validateSettings().then(() => {
      return this._prepareSDK().then((response) => {
        return rerenderIfNeeded(response);
      });
    }).then((response) => {
      const {outputTexture, renderDone} = response;
      const renderer = this._sdk.getRenderer();
      let canvas9 = renderer.getCanvas();
      if (renderer.isOfType(RendererType.WEBGL)) {
        canvas9 = this._createCanvasFromTexture(outputTexture);
      }
      return this._encodeImageFormat(canvas9);
    }).then((result) => {
      return this._restoreExifMetadata(result, imageFormat);
    }).then((result) => {
      return this._restoreSDK().then(() => result);
    });
  }
  _restoreExifMetadata(result, imageFormat, quality) {
    if (imageFormat === ImageFormat.JPEG) {
      const exif4 = this._sdk.getExif();
      if (exif4) {
        if (process.env.REACT_APP_BROWSER) {
          if (typeof result === "string") {
            result = exif4.restoreSegments(result);
          }
        }
        if (!process.env.REACT_APP_BROWSER) {
          const {renderType} = this._options;
          if (renderType === RenderType.BUFFER) {
            result = Buffer.from(exif4.restoreSegmentsInArray([...result]));
          } else if (renderType === RenderType.DATAURL && typeof result === "string") {
            result = exif4.restoreSegments(result);
          }
        }
      }
    }
    return Promise.resolve(result);
  }
  _encodeAsDataURL(canvas9, imageFormat, quality) {
    if (utils_default.isBrowser) {
      return Promise.resolve(canvas9.toDataURL(imageFormat, quality));
    }
    return new Promise((resolve, reject) => {
      canvas9.toDataURL(imageFormat, quality, (err, jpeg) => {
        if (err) {
          reject(err);
        } else {
          resolve(jpeg);
        }
      });
    });
  }
  _encodeAsHTMLImage(canvas9, imageFormat, quality) {
    return this._encodeAsDataURL(canvas9, imageFormat, quality).then((dataURI) => {
      const outputImage = new image_default();
      outputImage.src = dataURI;
      return Promise.resolve(outputImage);
    });
  }
  _encodeAsBuffer(canvas9, imageFormat, quality) {
    if (!process.env.REACT_APP_BROWSER) {
      if (imageFormat === ImageFormat.JPEG) {
        return Promise.resolve(canvas9.toBuffer(imageFormat, {
          quality,
          progressive: true,
          chromaSubsampling: false
        }));
      }
      if (imageFormat === ImageFormat.PNG) {
        return Promise.resolve(canvas9.toBuffer(imageFormat, {quality}));
      }
      if (imageFormat === ImageFormat.RAW) {
        return Promise.resolve(canvas9.toBuffer(imageFormat));
      }
      return Promise.reject(new Error(`Unsupported imageFormat: ${imageFormat}`));
    }
    return Promise.reject(new Error("Unsupported platform for RenderType"));
  }
  _encodeAsMSBlob(canvas9, imageFormat, quality) {
    return Promise.resolve(canvas9.msToBlob());
  }
  _encodeAsBLOB(canvas9, imageFormat, quality) {
    return new Promise((resolve, reject) => {
      canvas9.toBlob((blob) => {
        resolve(blob);
      }, imageFormat, quality);
    });
  }
  _encodeImageFormat(canvas9) {
    const {imageFormat, quality} = this._options;
    let {renderType} = this._options;
    if (renderType === RenderType.BLOB && canvas9.msToBlob && !canvas9.toBlob) {
      renderType = RenderType.MSBLOB;
    }
    switch (renderType) {
      case RenderType.IMAGE: {
        return this._encodeAsHTMLImage(canvas9, imageFormat, quality);
      }
      case RenderType.DATAURL: {
        return this._encodeAsDataURL(canvas9, imageFormat, quality);
      }
      case RenderType.BUFFER: {
        return this._encodeAsBuffer(canvas9, imageFormat, quality);
      }
      case RenderType.MSBLOB: {
        return this._encodeAsMSBlob(canvas9, imageFormat, quality);
      }
      case RenderType.BLOB: {
        return this._encodeAsBLOB(canvas9, imageFormat, quality);
      }
    }
    return Promise.reject(new Error(`Unsupported RenderType: ${renderType}!`));
  }
  _prepareSDK() {
    const renderer = this._sdk.getRenderer();
    this._sdkSettings = {
      dimensions: renderer.getDimensions().clone(),
      textureQuality: this._sdk.getTextureQuality(),
      pixelRatio: this._sdk.getPixelRatio(),
      renderMode: this._sdk.getRenderMode()
    };
    this._sdk.setRenderMode("export");
    this._sdk.setTextureQuality(1);
    const resizeCanvas = renderer.isOfType(RendererType.CANVAS);
    renderer.setPixelRatio(1);
    renderer.resizeTo(this._sdk.getFinalDimensions(), resizeCanvas);
    this._sdk.setAllOperationsToDirty(true);
    const stack = this._sdk.getOperationsStack();
    stack.forEach((operation3) => {
      operation3.disposeRenderTextures();
    });
    stack.disableCache();
    return this._sdk.render();
  }
  _restoreSDK() {
    const stack = this._sdk.getOperationsStack();
    stack.enableCache();
    this._sdk.setRenderMode(this._sdkSettings.renderMode);
    const renderer = this._sdk.getRenderer();
    const resizeCanvas = renderer.isOfType(RendererType.CANVAS);
    renderer.setPixelRatio(this._sdkSettings.pixelRatio);
    renderer.resizeTo(this._sdkSettings.dimensions, resizeCanvas);
    this._sdk.setTextureQuality(this._sdkSettings.textureQuality);
    this._sdk.setAllOperationsToDirty(true);
    return this._sdk.render();
  }
  _createCanvasFromTexture(texture5) {
    const renderer = this._sdk.getRenderer();
    const finalDimensions = this._sdk.getFinalDimensions();
    const gl = this._sdk.getRenderer().getContext();
    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    const glTexture = texture5.getBaseTexture().getGLTextureForRenderer(renderer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);
    const pixels = new Uint8Array(finalDimensions.x * finalDimensions.y * 4);
    gl.readPixels(0, 0, finalDimensions.x, finalDimensions.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    const hasTransparency = this._checkPixelsForTransparency(pixels);
    let renderTexture;
    if (hasTransparency) {
      const sprite7 = new engine_default.Sprite(texture5);
      sprite7.setFilters([new engine_default.Filters.UnpremultiplyFilter()]);
      const container3 = new engine_default.Container();
      container3.addChild(sprite7);
      renderTexture = new engine_default.RenderTexture(renderer, finalDimensions.x, finalDimensions.y);
      renderTexture.render(container3);
      const glTexture2 = renderTexture.getBaseTexture().getGLTextureForRenderer(renderer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture2, 0);
      gl.readPixels(0, 0, finalDimensions.x, finalDimensions.y, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      renderer.setRenderTarget();
      renderTexture.dispose();
    }
    const canvas9 = utils_default.createCanvas();
    canvas9.width = finalDimensions.x;
    canvas9.height = finalDimensions.y;
    const context = canvas9.getContext("2d");
    const imageData = context.createImageData(finalDimensions.x, finalDimensions.y);
    imageData.data.set(pixels);
    context.putImageData(imageData, 0, 0);
    gl.deleteFramebuffer(fbo);
    return canvas9;
  }
  _checkPixelsForTransparency(pixels) {
    const finalDimensions = this._sdk.getFinalDimensions();
    const maxIndex = finalDimensions.x * finalDimensions.y * 4;
    let value;
    for (let i = 3; i < maxIndex; i += 4) {
      value = pixels[i];
      if (value !== 255) {
        return true;
      }
    }
    return false;
  }
}
ImageExporter.prototype.availableOptions = {
  renderType: {
    type: OptionType.STRING,
    available: utils_default.values(RenderType),
    default: RenderType.IMAGE
  },
  imageFormat: {
    type: OptionType.STRING,
    available: utils_default.values(ImageFormat),
    default: ImageFormat.PNG
  },
  quality: {type: OptionType.NUMBER, default: 0.8}
};
var image_exporter_default = ImageExporter;

// engine/sdk/core/sdk.js
const bd2 = (str) => Utils4.byteArrayToString(Base642.decode(str));
const {
  Rectangle: Rectangle2,
  Constants,
  Engine: Engine2,
  Utils: Utils4,
  EventEmitter: EventEmitter2,
  Events: Events2,
  Vector2: Vector22,
  Log: Log3,
  Base64: Base642,
  Color: Color2
} = globals_exports2;
const {RenderType: RenderType2, ImageFormat: ImageFormat2, RendererType: RendererType7} = Constants;
class PhotoEditorSDK extends EventEmitter2 {
  constructor(preferredRenderer, options = {}) {
    super();
    this._onOperationUpdate = this._onOperationUpdate.bind(this);
    this._onContextRestored = this._onContextRestored.bind(this);
    this.version = "4.25.0";
    this[bd2("VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=")] = true;
    this._preferredRenderer = preferredRenderer;
    this._options = Utils4.defaults(options, {
      extensions: {},
      renderMode: "dynamic",
      versionCheck: true,
      displayWelcomeMessage: true,
      image: null,
      canvas: null,
      transparent: false,
      clearColor: Color2.TRANSPARENT,
      textureQuality: 1,
      zoom: 1,
      spriteScale: 1,
      rotation: 0,
      smoothDownscaling: false,
      smoothUpscaling: false,
      crossOrigin: "anonymous",
      logLevel: "warn",
      pixelRatio: typeof window !== "undefined" && window.devicePixelRatio || 1
    });
    if (this._options.smoothUpscaling) {
      Engine2.BaseTexture.DefaultMagFilter = Engine2.BaseTexture.LinearFilter;
    }
    this._options.extensions = Utils4.defaults(this._options.extensions, {
      operations: [],
      controls: [],
      languages: []
    });
    Log3.setLevel(this._options.logLevel);
    this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")] = false;
    if (!this[bd2("X29wdGlvbnM=")][bd2("bGljZW5zZQ==")]) {
      this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")] = true;
      this._l = new globals_exports2[bd2("RnJlZUxpY2Vuc2VDaGVja2Vy")]();
    } else {
      if (!this._v())
        return;
      const L2 = globals_exports2[bd2("TGljZW5zZUNoZWNrZXI=")];
      this._l = new L2(this[bd2("X29wdGlvbnM=")][bd2("bGljZW5zZQ==")]);
      this._cv(true).then(() => {
        this._ct();
      }).catch((e) => {
        Log3.error(bd2("TGljZW5zaW5n"), e.message);
      });
    }
    this._defaultRenderMode = this._options.renderMode;
    this._renderMode = this._options.renderMode;
    this._textureQuality = this._options.textureQuality;
    this._offset = new Vector22();
    this._zoom = this._options.zoom;
    this._spriteScale = this._options.spriteScale;
    this._rotation = this._options.rotation;
    this._operations = {};
    this._operationsStack = null;
    this.setOperationsStack(new operations_stack_default());
    this._container = new Engine2.Container();
    this._sprite = new Engine2.Sprite();
    this._container.addChild(this._sprite);
    this._inputTexture = this._options.inputTexture;
    this._currentInputTexture = null;
    this._currentTexture = null;
    this._resizedTexture = null;
    this._resizedContainer = new Engine2.Container();
    this._resizedSprite = new Engine2.Sprite();
    this._resizedContainer.addChild(this._resizedSprite);
    this._texturesToDispose = [];
    this.setSmoothDownscaling(this._options.smoothDownscaling);
    this._registerOperations();
    this._initRenderer();
    const renderer = this._renderer.constructor.type;
    if (this._options.displayWelcomeMessage) {
      if (!process.env.REACT_APP_BROWSER) {
        Log3.log("Version:", `${this.version} (${renderer}) - https://www.photoeditorsdk.com`);
      }
    }
    if (this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")]) {
      Log3.log(bd2("VGhlIFBob3RvRWRpdG9yIFNESyBpcyBhIGNvbW1lcmNpYWwgcHJvZHVjdC4gQmVmb3JlIGJlaW5nIGFibGUgdG8gdXNlIGl0IHdpdGhvdXQgbGltaXRhdGlvbnMsIHlvdSBuZWVkIHRvIHVubG9jayB0aGUgU0RLIHdpdGggYSBsaWNlbnNlIGZpbGUuIFlvdSBjYW4gb2J0YWluIGEgdGltZS1saW1pdGVkIGV2YWx1YXRpb24gbGljZW5zZSBieSBzdGFydGluZyBhIHRyaWFsIGF0IGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS91c2Vycy9uZXcgb3IgeW91IGNhbiBwdXJjaGFzZSBhIGxpY2Vuc2UgYnkgcmVxdWVzdGluZyBhIHF1b3RlIGF0IGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9wcmljaW5nLgoKQmVjYXVzZSB5b3UgZGlkIG5vdCBzcGVjaWZ5IGEgbGljZW5zZSBmaWxlIHlldCwgdGhlIFNESyB3aWxsIG5vdyBkaXNwbGF5IGEgd2F0ZXJtYXJrIGltYWdlIG9uIHRvcCBvZiBhbnkgcGhvdG9zIHlvdSBkaXNwbGF5IG9yIGV4cG9ydCB3aXRoIGl0LiBGb3IgaW5zdHJ1Y3Rpb25zIGZvciBob3cgdG8gdW5sb2NrIHRoZSBTREssIHBsZWFzZSB2aXNpdCBodHRwczovL2RvY3MucGhvdG9lZGl0b3JzZGsuY29tL2d1aWRlcy9odG1sNS92NC9pbnRyb2R1Y3Rpb24vZ2V0dGluZ19zdGFydGVkLg=="));
    }
    if (this._options.image) {
      this.setImage(this._options.image, this._options.exif);
    }
  }
  _v() {
    if (!this[bd2("X29wdGlvbnM=")][bd2("bGljZW5zZQ==")]) {
      Log3.error(bd2("TGljZW5zaW5n"), bd2("Tm8gYGxpY2Vuc2VgIG9wdGlvbiBnaXZlbi4="));
      Log3.error(bd2("TGljZW5zaW5n"), bd2("SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIGxpY2Vuc2UgeWV0LCBwbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAcGhvdG9lZGl0b3JzZGsuY29tIHRvIG9idGFpbiBhIGxpY2Vuc2Ugb3IgbG9nIGluIHRvIHlvdXIgY3VzdG9tZXIgZGFzaGJvYXJkLg=="));
      return false;
    }
    return true;
  }
  _ct() {
    if (this._l.exp()) {
      const expired = this._l.isExp();
      if (expired) {
        Log3.error(bd2("TGljZW5zaW5n"), bd2("WW91ciB0cmlhbCBsaWNlbnNlIGhhcyBleHBpcmVkLiBQbGVhc2UgY29udGFjdCB1cyBhdCBzYWxlc0BwaG90b2VkaXRvcnNkay5jb20gdG8gb2J0YWluIGEgbGljZW5zZS4="));
      } else {
        Log3.warn(bd2("TGljZW5zaW5n"), bd2("WW91ciB0cmlhbCBsaWNlbnNlIHdpbGwgZXhwaXJlIGluICVkIGRheXMu").replace("%d", this._l.dl()));
      }
    }
  }
  _cv(print = false) {
    return this._l.c().catch((e) => {
      this[bd2("VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=")] = false;
      let errorMessage = bd2("SW52YWxpZCBsaWNlbnNlLg==");
      if (print) {
        if (e.code === "ELICEXP") {
          errorMessage = bd2("WW91ciB0cmlhbCBsaWNlbnNlIGhhcyBleHBpcmVkLiBQbGVhc2UgY29udGFjdCB1cyBhdCBzYWxlc0BwaG90b2VkaXRvcnNkay5jb20gdG8gb2J0YWluIGEgbGljZW5zZS4=");
        } else if (e.code === "ELICINVHOST") {
          errorMessage = `${bd2("VGhpcyBsaWNlbnNlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIGhvc3RuYW1lIA==") + window.location.hostname}.`;
        } else if (e.code === "ELICINVPLAT") {
          errorMessage = bd2("VGhpcyBsaWNlbnNlIGlzIG5vdCB2YWxpZCBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0u");
        } else if (e.code === "ELICINVFMT") {
          errorMessage = bd2("SW52YWxpZCBsaWNlbnNlIGZvcm1hdC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UncmUgcGFzc2luZyB5b3VyIGxpY2Vuc2UgYXMgYSBzdHJpbmcsIG5vdCBhcyBgJGZvcm1hdGAu").replace("$format", typeof this._options.license);
        } else if (e.code === "ELICINV") {
          errorMessage = bd2("SW52YWxpZCBsaWNlbnNlISBQbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc3VwcG9ydEBwaG90b2VkaXRvcnNkay5jb20gdG8gb2J0YWluIGEgbGljZW5zZSBvciBsb2cgaW4gdG8geW91ciBjdXN0b21lciBkYXNoYm9hcmQu");
        } else {
          errorMessage = bd2("SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIGxpY2Vuc2UgeWV0LCBwbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAcGhvdG9lZGl0b3JzZGsuY29tIHRvIG9idGFpbiBhIGxpY2Vuc2Ugb3IgbG9nIGluIHRvIHlvdXIgY3VzdG9tZXIgZGFzaGJvYXJkLg==");
        }
      }
      e.message = errorMessage;
      throw new Error(e);
    });
  }
  _t() {
    this._l.t();
  }
  _fl() {
    return this[bd2("Wm5KbFpVeHBZMlZ1YzAxdlpHVT0=")];
  }
  _onOperationUpdate(...args) {
    this.emit(Events2.OPERATION_UPDATED, ...args);
  }
  _onContextRestored() {
    Log3.warn(this.constructor.name, "Trying to re-render after WebGL context has been restored.");
    this.setAllOperationsToDirty();
    this._operationsStack.forEach((operation3) => {
      operation3.disposeRenderTextures();
    });
    this.render();
  }
  export(renderType = RenderType2.DATAURL, imageFormat = ImageFormat2.PNG, quality = 0.8) {
    return this._cv(true).then(() => {
      if (this.hasChanges()) {
        this._t();
      }
      this._operationsStack.forEach((op) => {
        op.onBeforeExport();
      });
      const imageExporter = new image_exporter_default(this, {
        renderType,
        imageFormat,
        quality
      });
      return imageExporter.export().then((result) => {
        this._operationsStack.forEach((op) => {
          op.onAfterExport();
        });
        return Promise.resolve(result);
      });
    });
  }
  render(renderOutput = true) {
    if (!this._inputTexture) {
      throw new Error("You need to set an image before calling PhotoEditorSDK#render.");
    }
    const context = this._renderer.getContext();
    if (context.startFrame) {
      context.startFrame();
    }
    let perfTest;
    if (Log3.canLog("info")) {
      perfTest = new performance_test_default("⚡⚡⚡", "Frame rendering");
    }
    Log3.info("⚡⚡⚡", "Rendering starts");
    const stack = this._operationsStack;
    stack.updateDirtinessForRenderer(this._renderer);
    return this._prepareTexture().then((texture5) => {
      if (this._renderMode === "export") {
        texture5 = this._inputTexture;
      }
      this._currentTexture = texture5;
      this._sprite.setTexture(texture5);
      this._container.updateTransform();
    }).then(() => stack.validateSettings()).then(() => {
      if (this._fl() || !this[bd2("VG04Z1lHRndhVXRsZVdBZ2IzQjBhVzl1SUdkcGRtVnU=")]) {
        if (!stack.getByIdentifier("license-watermark")) {
          this.createOperation("license-watermark");
        } else {
          stack.moveToTop("license-watermark");
        }
      }
      return stack.render(this, this._currentTexture);
    }).then((response) => {
      const {outputTexture} = response;
      this._currentTexture = outputTexture;
      this._sprite.setTexture(this._currentTexture);
      switch (this._renderMode) {
        case "dynamic": {
          const center = this._renderer.getDimensions().clone().divide(2).add(this._offset);
          this._container.setScale(this._zoom / this.getTextureScale(), this._zoom / this.getTextureScale());
          this._container.setPosition(center);
          this._sprite.setAnchor(0.5, 0.5);
          this._sprite.setScale(this._spriteScale, this._spriteScale);
          this._sprite.setRotation(this._rotation);
          break;
        }
        case "export":
          this._container.setScale(1, 1);
          this._container.setPosition(0, 0);
          this._sprite.setAnchor(0, 0);
          this._sprite.setPosition(0, 0);
          this._sprite.setScale(this._spriteScale, this._spriteScale);
          this._sprite.setRotation(0);
          break;
        case "adapter":
          this._container.setScale(1, 1);
          this._container.setPosition(0, 0);
          this._sprite.setAnchor(0, 0);
          this._sprite.setPosition(0, 0);
          this._sprite.setScale(1, 1);
          this._sprite.setRotation(0);
          break;
      }
      if (renderOutput) {
        this._renderer.render(this._container);
      }
      return response;
    }).then((response) => {
      if (perfTest) {
        perfTest.stop();
      }
      if (context.endFrame) {
        context.endFrame();
      }
      this._disposeTextures();
      return response;
    });
  }
  getTextureScale() {
    return Math.min(1, this._textureQuality * this._options.pixelRatio);
  }
  _prepareTexture() {
    return new Promise((resolve, reject) => {
      const textureScale = this.getTextureScale();
      if (this._textureQuality === 1) {
        return resolve(this._inputTexture);
      }
      const dimensions = this.getInputDimensions().multiply(textureScale).floor();
      let needsRerender;
      if (!this._resizedTexture) {
        this._resizedTexture = new Engine2.RenderTexture(this._renderer, dimensions.x, dimensions.y);
        needsRerender = true;
      } else if (!this._resizedTexture.getDimensions().equals(dimensions)) {
        this._resizedTexture.resizeTo(dimensions);
        needsRerender = true;
      }
      if (needsRerender) {
        this._resizedSprite.setScale(textureScale, textureScale);
        this._resizedSprite.setTexture(this._inputTexture);
        this._resizedTexture.render(this._resizedContainer);
      }
      resolve(this._resizedTexture);
    });
  }
  _registerOperations() {
    this._operations = {};
    for (const operationName in operations_exports) {
      const operation3 = operations_exports[operationName];
      this._operations[operation3.identifier] = operation3;
    }
    this._operations = Utils4.extend(this._operations, this._options.extensions.operations);
  }
  registerOperations(operations3) {
    operations3.forEach((operation3) => {
      this._operations[operation3.identifier] = operation3;
    });
  }
  setAllOperationsToDirty(dimensionsChanged = false) {
    this._operationsStack.setAllToDirty(dimensionsChanged);
  }
  createOperation(identifier, options = {}, addToStack = true) {
    const Operation2 = this._operations[identifier];
    if (!Operation2) {
      throw new Error(`No operation with identifier \`${identifier}\` found.`);
    }
    const operation3 = new Operation2(this, options);
    if (addToStack) {
      this.addOperation(operation3);
    }
    return operation3;
  }
  addOperation(operation3) {
    this._operationsStack.push(operation3);
  }
  removeOperation(operation3) {
    this._operationsStack.remove(operation3);
  }
  getInputDimensions() {
    const frame2 = this._inputTexture.getFrame();
    return new Vector22(frame2.width, frame2.height);
  }
  getFinalDimensions(incorporateSpriteScale = false) {
    let dimensions = this.getInputDimensions();
    const operationsStack = this._operationsStack;
    operationsStack.forEach((operation3) => {
      if (!operation3.getEnabled())
        return;
      dimensions = operation3.getNewDimensions(dimensions);
    });
    if (incorporateSpriteScale) {
      dimensions.multiply(this._spriteScale);
    }
    return dimensions.floor();
  }
  getOutputDimensions(incorporateSpriteScale = false) {
    return this.getFinalDimensions(incorporateSpriteScale).clone().multiply(this._zoom).floor();
  }
  getOutputTextureDimensions(incorporateSpriteScale = false) {
    const textureScale = this.getTextureScale();
    let dimensions = this.getInputDimensions().multiply(textureScale).floor();
    this._operationsStack.forEach((op) => {
      dimensions = op.getNewDimensions(dimensions);
    });
    return dimensions;
  }
  getCrossOrigin() {
    return Utils4.getCrossOrigin(this._options.crossOrigin || "Anonymous");
  }
  _initRenderer() {
    const rendererOptions = {
      canvas: this._options.canvas,
      pixelRatio: this._options.pixelRatio,
      debug: this._options.debug,
      transparent: this._options.transparent,
      clearColor: this._options.clearColor
    };
    let width;
    let height;
    if (this._renderMode !== "export" && this._options.canvas) {
      const {canvas: canvas9} = this._options;
      width = canvas9.width;
      height = canvas9.height;
    } else if (this._inputTexture) {
      const dimensions = this.getFinalDimensions();
      width = dimensions.x;
      height = dimensions.y;
    } else {
      width = 1;
      height = 1;
    }
    switch (this._preferredRenderer) {
      case RendererType7.WEBGL:
        this._renderer = Engine2.autoDetectRenderer(width, height, rendererOptions);
        this._renderer.on("context-restored", this._onContextRestored);
        break;
      case RendererType7.CANVAS:
        this._renderer = new Engine2.CanvasRenderer(width, height, rendererOptions);
        this._renderer.on("context-restored", this._onContextRestored);
        break;
      default:
        Log3.warn("PhotoEditorSDK", `PhotoEditorSDK Error: Renderer \`${this._preferredRenderer}\` not supported. Falling back to automatically detected renderer.`);
        this._renderer = Engine2.autoDetectRenderer(width, height, rendererOptions);
    }
  }
  resizeTo(dimensions) {
    this._renderer.resizeTo(dimensions, true);
  }
  reset() {
    this._operationsStack.clear();
  }
  parseExif(image5) {
    if (!image5) {
      return;
    }
    let {src} = image5;
    let isJPEG = false;
    let base64String = null;
    if (process.env.REACT_APP_BROWSER) {
      isJPEG = exif_default.isJPEG(src);
      base64String = src;
    } else if (image5 instanceof image_default && image5.rawSource) {
      let buf = image5.rawSource;
      if (!(image5.rawSource instanceof Buffer)) {
        const source = image5.rawSource.replace("data:image/jpeg;base64,", "");
        buf = Buffer.from(source, "base64");
        src = image5.rawSource;
      } else {
        src = image5.rawSource.toString("base64");
      }
      isJPEG = exif_default.bufferIsJPEG(buf);
      if (isJPEG) {
        base64String = src;
      }
    }
    if (isJPEG) {
      let exif4 = null;
      try {
        exif4 = exif_default.fromBase64String(base64String);
      } catch (e) {
      }
      if (!exif4) {
        return;
      }
      return exif4;
    }
  }
  _handleExifOrientation() {
    const exifTags = this._exif.getTags();
    if (exifTags && exifTags.Orientation) {
      const rotationNeedsChange = exifTags.Orientation !== 1 && exifTags.Orientation !== 2;
      const flipNeedsChange = [2, 4, 5, 7].indexOf(exifTags.Orientation) !== -1;
      if (rotationNeedsChange || flipNeedsChange) {
        if (typeof navigator === "undefined") {
          if (!this._exifOperation) {
            this._exifOperation = this.createOperation("exif-orientation");
          }
          this._exifOperation.setTags(exifTags);
        } else {
          const userAgent = window && window.navigator && window.navigator.userAgent || "";
          if (!!userAgent.match(/msie|trident/i) || userAgent.indexOf("Edge") !== -1 || !CSS.supports("image-orientation", "from-image")) {
            if (!this._exifOperation) {
              this._exifOperation = this.createOperation("exif-orientation");
            }
            this._exifOperation.setTags(exifTags);
          }
        }
        this._exif.setOrientation(1);
      }
    }
  }
  correctExifOrientation(image5) {
    const exifData = this.parseExif(image5);
    if (!exifData) {
      return image5;
    }
    const tags = exifData.getTags();
    if (tags && tags.Orientation) {
      const rotationNeedsChange = tags.Orientation !== 1 && tags.Orientation !== 2;
      const flipNeedsChange = [2, 4, 5, 7].indexOf(tags.Orientation) !== -1;
      if (rotationNeedsChange || flipNeedsChange) {
        if (typeof navigator === "undefined") {
          const exifOperation = this.createOperation("exif-orientation", {}, false);
          exifOperation.setTags(tags);
          image5 = exifOperation.applyTo(image5);
        } else {
          const userAgent = window && window.navigator && window.navigator.userAgent || "";
          if (!!userAgent.match(/msie|trident/i) || userAgent.indexOf("Edge") !== -1 || !CSS.supports("image-orientation", "from-image")) {
            const exifOperation = this.createOperation("exif-orientation", {}, false);
            exifOperation.setTags(tags);
            image5 = exifOperation.applyTo(image5);
          }
        }
        exifData.setOrientation(1);
        tags.Orientation = 1;
        return image5;
      }
    }
    return image5;
  }
  hasImage() {
    return this._image !== null && typeof this._image !== "undefined";
  }
  getImage() {
    return this._image;
  }
  disposeTexture(texture5) {
    this._texturesToDispose.push(texture5);
  }
  _disposeTextures() {
    for (let i = 0; i < this._texturesToDispose.length; i++) {
      this._texturesToDispose[i].dispose();
    }
    this._texturesToDispose = [];
  }
  setImage(image5, exif4 = null, dimensions = null) {
    this._disposeTextures();
    if (this._exifOperation) {
      this.removeOperation(this._exifOperation);
      this._exifOperation = null;
    }
    this._options.image = image5;
    this._image = image5;
    this._exif = exif4 || this.parseExif(image5);
    if (this._exif) {
      this._handleExifOrientation();
    }
    const baseTexture = new Engine2.BaseTexture(this._image);
    const frame2 = new Rectangle2(0, 0, this._image.naturalWidth || this._image.width, this._image.naturalHeight || this._image.height);
    if (dimensions) {
      frame2.width = dimensions.x;
      frame2.height = dimensions.y;
    }
    if (this._resizedTexture) {
      this._resizedTexture.dispose();
    }
    this._resizedTexture = null;
    if (this._inputTexture) {
      this.disposeTexture(this._inputTexture.getBaseTexture());
    }
    this._inputTexture = new Engine2.Texture(baseTexture, frame2);
    this._currentTexture = this._inputTexture;
    this._sprite.clearTexture(false);
    this._sprite.setTexture(this._inputTexture);
    this.emit("new-image");
    this.setAllOperationsToDirty(true);
  }
  setInputTexture(texture5) {
    this._inputTexture = texture5;
  }
  getCanvas() {
    return this._renderer.getCanvas();
  }
  setCanvas(canvas9) {
    this._renderer.setCanvas(canvas9);
  }
  getSprite() {
    return this._sprite;
  }
  getContainer() {
    return this._container;
  }
  getOperationsStack() {
    return this._operationsStack;
  }
  setOperationsStack(operationsStack) {
    if (this._operationsStack) {
      this._operationsStack.off(Events2.OPERATION_UPDATED, this._onOperationUpdate);
    }
    this._operationsStack = operationsStack;
    this._operationsStack.on(Events2.OPERATION_UPDATED, this._onOperationUpdate);
  }
  getOperations() {
    return this._operations;
  }
  getRenderer() {
    return this._renderer;
  }
  getOffset() {
    return this._offset;
  }
  setOffset(offset, y) {
    if (offset instanceof Vector22) {
      this._offset.copy(offset);
    } else {
      this._offset.set(offset, y);
    }
  }
  getRenderMode() {
    return this._renderMode;
  }
  setRenderMode(renderMode) {
    this._renderMode = renderMode;
  }
  getZoom() {
    return this._zoom;
  }
  setZoom(zoom) {
    this._zoom = zoom;
    this._container.setScale(this._zoom, this._zoom);
    this._container.updateTransform();
  }
  getTextureQuality() {
    if (this._renderMode === "export") {
      return 1;
    }
    return this._textureQuality;
  }
  setTextureQuality(textureQuality) {
    if (textureQuality !== this._textureQuality) {
      this.setAllOperationsToDirty(true);
    }
    this._textureQuality = Math.min(1, textureQuality);
    if (this._textureQuality === 1 && this._resizedTexture) {
      this._resizedTexture.dispose();
      this._resizedTexture = null;
    }
  }
  getSpriteScale() {
    return this._spriteScale;
  }
  setSpriteScale(spriteScale) {
    this._spriteScale = spriteScale;
    this._sprite.setScale(spriteScale, spriteScale);
    this._sprite.updateTransform();
  }
  getPixelRatio() {
    return this._options.pixelRatio;
  }
  getExif() {
    return this._exif;
  }
  getOptions() {
    return this._options;
  }
  getInputTexture() {
    return this._inputTexture;
  }
  setSmoothDownscaling(smoothDownscaling) {
    this._options.smoothDownscaling = smoothDownscaling;
    this._sprite.setSmoothDownscaling(smoothDownscaling);
    this._resizedSprite.setSmoothDownscaling(smoothDownscaling);
  }
  setRotation(rotation) {
    this._rotation = rotation;
  }
  getRotation() {
    return this._rotation;
  }
  hasChanges() {
    return this.getOperationsStack().hasChanges();
  }
  dispose() {
    this._operationsStack.dispose();
    this._renderer.dispose();
    if (this._exif) {
      this._exif.dispose();
    }
    if (this._resizedTexture) {
      this._resizedTexture.dispose();
    }
  }
}
var sdk_default = PhotoEditorSDK;

// engine/sdk/core/exports.js
sdk_default.version = "4.25.0";
sdk_default.Math = math_exports;
sdk_default.Operations = operations_exports;
sdk_default.Engine = engine_default;
sdk_default.Color = color_default;
sdk_default.LicenseChecker = license_checker_default;
sdk_default.Operation = operation_default;
sdk_default.EventEmitter = event_emitter_default;
sdk_default.Utils = utils_default;
sdk_default.Env = env_default;
sdk_default.OperationsStack = operations_stack_default;
sdk_default.EXIF = exif_default;
sdk_default.Image = image_default;
sdk_default.Promise = promise_default;
sdk_default.Configurable = configurable_default;
sdk_default.Log = log_default;
sdk_default.Loaders = loaders_exports;
sdk_default.RenderType = RenderType;
sdk_default.ImageFormat = ImageFormat;
sdk_default.OptionType = OptionType;
sdk_default.RendererType = RendererType;
sdk_default.UniformType = UniformType;
sdk_default.Base64 = base64_default;
const UI = {};
sdk_default.UI = UI;
var exports_default = sdk_default;

// engine/sdk/core/index.js

// engine/sdk/operations/shared/shaders/adjustments/adjustments.frag
var adjustments_default = "precision highp float;\n\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nuniform float u_gamma;\nuniform float u_shadows;\nuniform float u_highlights;\nuniform float u_whites;\nuniform float u_blacks;\n\nuniform mat4 u_colorMatrix;\nuniform vec4 u_colorOffset;\n\nconst float EPSILON = 0.0000001;\n\nfloat calculateLuminance(vec3 rgb) {\n    // This is the luminance calculation part of the RGB to HSL formular.\n    vec4 p = mix(\n        vec4(rgb.gb, 0.0, -1.0 / 3.0),\n        vec4(rgb.bg, -1.0, 2.0 / 3.0),\n        vec4(rgb.g < rgb.b)\n    );\n\n    vec4 q = mix(\n        vec4(rgb.r, p.yzx),\n        vec4(p.xyw, rgb.r),\n        vec4(rgb.r < p.x)\n    );\n\n    float croma = q.x - min(q.w, q.y);\n    float luminance = q.x - croma * 0.5;\n    return luminance;\n}\n\nvec3 map(vec3 x, float in_min, float in_max, float out_min, float out_max){\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\nvoid main() {\n\n  vec4 color = clamp(texture2D(u_image, v_texCoord), 0.0, 1.0);\n  color.rgb /= max(color.a, EPSILON); // Revert premultiplied alpha\n\n  // Apply gamma\n  if (u_gamma != 1.0) {\n    color.rgb = pow(color.rgb, vec3(1.0 / max(u_gamma, EPSILON)));\n  }\n\n  // Apply shadows and highlights\n  float luminance = calculateLuminance(color.rgb);\n\n  float shadow = u_shadows >= 0.0\n    ? clamp(\n          pow(luminance, 1.0 / (u_shadows + 1.0))\n          + pow(luminance, 2.0 / (u_shadows + 1.0)) * -0.76\n          - luminance\n    , 0.0, max(u_shadows, 1.0))\n    : -clamp(\n          pow(luminance, 1.0 / (-u_shadows + 1.0))\n          + pow(luminance, 2.0 / (-u_shadows + 1.0)) * -0.76\n          - luminance\n    , 0.0, max(-u_shadows, 1.0));\n\n  float highlight = u_highlights < 0.0\n    ? clamp(\n          1.0\n          - pow(1.0 - luminance, 1.0 / (1.0 - u_highlights))\n          - pow(1.0 - luminance, 2.0 / (1.0 - u_highlights)) * -0.8\n          - luminance\n     , -1.0, 0.0)\n    : -clamp(\n          1.0\n          - pow(1.0 - luminance, 1.0 / (1.0 + u_highlights))\n          - pow(1.0 - luminance, 2.0 / (1.0 + u_highlights)) * -0.8\n          - luminance\n     , -1.0, 0.0);\n\n  // Bright color need more contrast and dark color need more brightness.\n  // This is to keep saturatation because the color information of a dark colors is lost.\n  float shadowContrast   = shadow * luminance * luminance;\n  float shadowBrightness = shadow - shadowContrast;\n\n  float offset = luminance + shadowContrast + highlight;\n  color.rgb = clamp(offset * ((color.rgb + shadowBrightness) / max(luminance, EPSILON)), 0.0, 1.0);\n  \n  // Apply Color Matrix\n  color.rgb = clamp(color * u_colorMatrix + u_colorOffset, 0.0, 1.0).rgb;\n  color.rgb = map(color.rgb, 0.0, 1.0, u_blacks / 2.0, 1.0 + u_whites / 2.0);\n  color = clamp(color, 0.0, 1.0);\n  color.rgb *= color.a; // Reset premultiplied alpha\n\n  gl_FragColor = color;\n}\n";

// engine/sdk/operations/shared/filters/adjustments-filter.js
const {ColorMatrix: ColorMatrix2} = math_exports;
const EPSILON2 = 1e-7;
function map(x, inMin, inMax, outMin, outMax) {
  return (x - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
}
const calculateLuminance = (color6) => {
  const max = Math.max(color6.r, color6.g, color6.b);
  const min = Math.min(color6.r, color6.g, color6.b);
  return (max + min) / 2;
};
class AdjustmentsFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = adjustments_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {
      colorMatrix,
      gamma: gamma3,
      shadows,
      highlights,
      whites,
      blacks
    } = this._options;
    const applyGamma = gamma3 !== 1;
    const applyShadowsAndHighlights = shadows !== 0 || highlights !== 0;
    let color6 = new color_default(0, 0, 0, 0);
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      color6.r = imageData.data[index] / 255;
      color6.g = imageData.data[index + 1] / 255;
      color6.b = imageData.data[index + 2] / 255;
      if (applyGamma) {
        color6.r = Math.pow(color6.r, 1 / Math.max(gamma3, EPSILON2));
        color6.g = Math.pow(color6.g, 1 / Math.max(gamma3, EPSILON2));
        color6.b = Math.pow(color6.b, 1 / Math.max(gamma3, EPSILON2));
      }
      if (applyShadowsAndHighlights) {
        const luminance = calculateLuminance(color6);
        const shadow = shadows >= 0 ? utils_default.clamp(Math.pow(luminance, 1 / (shadows + 1)) + Math.pow(luminance, 2 / (shadows + 1)) * -0.76 - luminance, 0, Math.max(shadows, 1)) : -utils_default.clamp(Math.pow(luminance, 1 / (-shadows + 1)) + Math.pow(luminance, 2 / (-shadows + 1)) * -0.76 - luminance, 0, Math.max(-shadows, 1));
        const highlight = highlights < 0 ? utils_default.clamp(1 - Math.pow(1 - luminance, 1 / (1 - highlights)) - Math.pow(1 - luminance, 2 / (1 - highlights)) * -0.8 - luminance, -1, 0) : -utils_default.clamp(1 - Math.pow(1 - luminance, 1 / (1 + highlights)) - Math.pow(1 - luminance, 2 / (1 + highlights)) * -0.8 - luminance, -1, 0);
        const shadowContrast = shadow * luminance * luminance;
        const shadowBrightness = shadow - shadowContrast;
        const offset = luminance + shadowContrast + highlight;
        color6.r = utils_default.clamp(offset * ((color6.r + shadowBrightness) / Math.max(luminance, EPSILON2)), 0, 1);
        color6.g = utils_default.clamp(offset * ((color6.g + shadowBrightness) / Math.max(luminance, EPSILON2)), 0, 1);
        color6.b = utils_default.clamp(offset * ((color6.b + shadowBrightness) / Math.max(luminance, EPSILON2)), 0, 1);
      }
      color6 = colorMatrix.apply(color6).clamp(0, 1);
      color6.r = map(color6.r, 0, 1, blacks / 2, 1 + whites / 2);
      color6.g = map(color6.g, 0, 1, blacks / 2, 1 + whites / 2);
      color6.b = map(color6.b, 0, 1, blacks / 2, 1 + whites / 2);
      imageData.data[index] = color6.r * 255;
      imageData.data[index + 1] = color6.g * 255;
      imageData.data[index + 2] = color6.b * 255;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
AdjustmentsFilter.prototype.availableOptions = {
  gamma: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.FLOAT
  },
  shadows: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  },
  highlights: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.FLOAT
  },
  whites: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  },
  blacks: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  },
  colorMatrix: {
    type: OptionType.COLOR_MATRIX,
    default: new ColorMatrix2(),
    uniformType: UniformType.MAT4
  },
  colorOffset: {
    type: OptionType.ARRAY,
    default: [],
    uniformType: UniformType.FLOAT4
  }
};
var adjustments_filter_default = AdjustmentsFilter;

// engine/sdk/operations/shared/shaders/adjustments/clarity.frag
var clarity_default = "precision mediump float;\n\n// Input Image with config WRAP_S and WRAP_T: CLAMP_TO_EDGE\nuniform sampler2D u_image;\n\n// Size of one pixel == vec2(1.0 / u_image.width, 1.0 / u_image.height)\nuniform vec2 u_pixelDimension;\n\n// Range (-1.0 - 1.0)\nuniform float u_clarity;\n\nvarying vec2 v_texCoord;\n\nuniform mat4 u_colorMatrix;\nuniform vec4 u_colorOffset;\n\nconst float EPSILON = 0.000001;\n\nvec4 unpremultiply(vec4 col) {\n    col.rgb /= max(col.a, EPSILON);\n    return col;\n}\n\nvoid main() {\n    vec4 color = texture2D(u_image, v_texCoord);\n    color = unpremultiply(color);\n\n    // L = Left, R = Right, C = Center, T = Top, B = Bottom\n    vec4 colLB = texture2D(u_image, v_texCoord + vec2(-u_pixelDimension.x, -u_pixelDimension.y));\n    vec4 colLC = texture2D(u_image, v_texCoord + vec2(-u_pixelDimension.x,                 0.0));\n    vec4 colLT = texture2D(u_image, v_texCoord + vec2(-u_pixelDimension.x,  u_pixelDimension.y));\n\n    vec4 colCL = texture2D(u_image, v_texCoord + vec2(                0.0, -u_pixelDimension.y));\n    vec4 colCR = texture2D(u_image, v_texCoord + vec2(                0.0,  u_pixelDimension.y));\n    \n    vec4 colRB = texture2D(u_image, v_texCoord + vec2( u_pixelDimension.x, -u_pixelDimension.y));\n    vec4 colRC = texture2D(u_image, v_texCoord + vec2( u_pixelDimension.x,                 0.0));\n    vec4 colRT = texture2D(u_image, v_texCoord + vec2( u_pixelDimension.x,  u_pixelDimension.y));\n\n    vec4 mergedColor = color;\n    mergedColor.rgb += unpremultiply(colLB).rgb + unpremultiply(colLC).rgb + unpremultiply(colLT).rgb;\n    mergedColor.rgb += unpremultiply(colCL).rgb + unpremultiply(colCR).rgb;\n    mergedColor.rgb += unpremultiply(colRB).rgb + unpremultiply(colRC).rgb + unpremultiply(colRT).rgb;\n\n    mergedColor /= 9.0;\n\n    float grayValue = clamp(color.r * 0.3 + color.g * 0.59 + color.b * 0.1, 0.111111, 0.999999);\n    // 1.0 and 0.0 result in white not black, therefore we clamp\n\n    // Here we create a function that will map values below 0.1 to 0. Values above 0.2 will be mapped to 1,\n    // and for values between 0.1 and 0.2 it will produce a gradient.\n    // The funtion is mirror at 0.5, meaning values between 0.8 and 0.9 will result in a decending gradient.\n    // And values above 0.9 will be mapped to 0.\n    float frequenceFactor = min(smoothstep(1.0 - grayValue, 0.0, 0.11), smoothstep(grayValue, 0.0, 0.11));\n\n    // here we apply the high pass filter. Its strength is determined by the uniform ,\n    // and the frequence factor. That means the only the mid tones are affected by this filter.\n    // Clarity input is ranging from -1 to 1. But we want to strengthen the effect.\n    // Therefore we see this little magic number '3.7'.\n    color.rgb = clamp(color + clamp((color - mergedColor) * u_clarity * 3.7 * frequenceFactor, 0.0, 10.0), 0.0, 1.0).rgb;\n\n    // apply exposure but only to the mid tones.\n    color.rgb = color.rgb * pow(2.0, u_clarity * 0.27 * frequenceFactor);\n\n    // apply contrast and desaturation matrix\n    color.rgb = clamp(color * u_colorMatrix + u_colorOffset, 0.0, 1.0).rgb;\n\n    color.rgb *= color.a; // Premultiply alpha\n\n    gl_FragColor = clamp(color, 0.0, 1.0);\n}\n";

// engine/sdk/operations/adjustments-operation/clarity-filter.js
const {Vector2: Vector23, ColorMatrix: ColorMatrix3} = math_exports;
class ClarityFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = clarity_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const outputContext = outputTarget.getContext();
    const inputCanvas = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const {clarity: clarity2} = this._options;
    const {colorMatrix} = this._options;
    const colorOffset = new color_default(this._options.colorOffset[0], this._options.colorOffset[1], this._options.colorOffset[2], this._options.colorOffset[3]);
    const {width} = inputCanvas;
    const {height} = inputCanvas;
    const inputImageData = inputContext.getImageData(0, 0, width, height);
    const outputImageData = outputContext.createImageData(width, height);
    this.canvasShader(inputImageData, outputImageData, clarity2, colorMatrix, colorOffset);
    outputContext.putImageData(outputImageData, 0, 0);
  }
  canvasShader(inputImageData, outputImageData, clarity2, colorMatrix, colorOffset) {
    const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
    const smoothstep = (edge0, edge1, x) => {
      const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
      return t * t * (3 - 2 * t);
    };
    const stride = inputImageData.width * 4;
    const {length} = inputImageData.data;
    const maxIdx = length - 1;
    const minIdx = 0;
    const inData = inputImageData.data;
    const outData = outputImageData.data;
    const tmpColor = new color_default();
    const divisor = 255 * 9;
    const sampleEdge = (idx) => {
      idx = idx < minIdx ? minIdx : idx;
      idx = idx > maxIdx ? maxIdx : idx;
      return inData[idx];
    };
    for (let idx = 0; idx < length; idx += 4) {
      let colorR = sampleEdge(idx + 0);
      let colorG = sampleEdge(idx + 1);
      let colorB = sampleEdge(idx + 2);
      let colorA = sampleEdge(idx + 3);
      const mergedR = (colorR + sampleEdge(idx - 4 - stride + 0) + sampleEdge(idx - 4 + 0) + sampleEdge(idx - 4 + stride + 0) + sampleEdge(idx - stride + 0) + sampleEdge(idx + stride + 0) + sampleEdge(idx + 4 - stride + 0) + sampleEdge(idx + 4 + 0) + sampleEdge(idx + 4 + stride)) / divisor;
      const mergedG = (colorG + sampleEdge(idx - 4 - stride + 1) + sampleEdge(idx - 4 + 1) + sampleEdge(idx - 4 + stride + 1) + sampleEdge(idx - stride + 1) + sampleEdge(idx + stride + 1) + sampleEdge(idx + 4 - stride + 1) + sampleEdge(idx + 4 + 1) + sampleEdge(idx + 4 + stride + 1)) / divisor;
      const mergedB = (colorB + sampleEdge(idx - 4 - stride + 2) + sampleEdge(idx - 4 + 2) + sampleEdge(idx - 4 + stride + 2) + sampleEdge(idx - stride + 2) + sampleEdge(idx + stride + 2) + sampleEdge(idx + 4 - stride + 2) + sampleEdge(idx + 4 + 2) + sampleEdge(idx + 4 + stride + 2)) / divisor;
      const mergedA = (colorA + sampleEdge(idx - 4 - stride + 3) + sampleEdge(idx - 4 + 3) + sampleEdge(idx - 4 + stride + 3) + sampleEdge(idx - stride + 3) + sampleEdge(idx + stride + 3) + sampleEdge(idx + 4 - stride + 3) + sampleEdge(idx + 4 + 3) + sampleEdge(idx + 4 + stride + 3)) / divisor;
      colorR /= 255;
      colorG /= 255;
      colorB /= 255;
      colorA /= 255;
      const grayValue = clamp(colorR * 0.3 + colorG * 0.59 + colorB * 0.1, 0.111111, 0.999999);
      const frequenceFactor = Math.min(smoothstep(1 - grayValue, 0, 0.11), smoothstep(grayValue, 0, 0.11));
      const scalar = clarity2 * 3.7 * frequenceFactor;
      const scale = Math.pow(2, clarity2 * 0.27 * frequenceFactor);
      const outR = clamp(colorR + clamp((colorR - mergedR) * scalar, 0, 10), 0, 1) * scale;
      const outG = clamp(colorG + clamp((colorG - mergedG) * scalar, 0, 10), 0, 1) * scale;
      const outB = clamp(colorB + clamp((colorB - mergedB) * scalar, 0, 10), 0, 1) * scale;
      const outA = clamp(colorA + clamp((colorA - mergedA) * scalar, 0, 10), 0, 1);
      tmpColor.set(outR, outG, outB, outA);
      const outColor = colorMatrix.apply(tmpColor).clamp(0, 1);
      outData[idx + 0] = outColor.r * 255;
      outData[idx + 1] = outColor.g * 255;
      outData[idx + 2] = outColor.b * 255;
      outData[idx + 3] = outColor.a * 255;
    }
  }
}
ClarityFilter.prototype.availableOptions = {
  clarity: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  },
  pixelDimension: {
    type: OptionType.VECTOR2,
    default: new Vector23(100, 100),
    uniformType: UniformType.FLOAT2
  },
  colorMatrix: {
    type: OptionType.COLOR_MATRIX,
    default: new ColorMatrix3(),
    uniformType: UniformType.MAT4
  },
  colorOffset: {
    type: OptionType.ARRAY,
    default: [],
    uniformType: UniformType.FLOAT4
  }
};
var clarity_filter_default = ClarityFilter;

// engine/sdk/operations/shared/shaders/adjustments/sharpness.frag
var sharpness_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec2 u_pixelDimension;\nuniform float u_sharpness;\n \nconst float EPSILON = 0.000001;\n \nvoid main() {\n    vec4 color = clamp(texture2D(u_image, v_texCoord), 0.0, 1.0);\n\n    float factor        = mix(0.2, -1.0, float(u_sharpness > 0.0));\n    vec4 sharpenedColor = mix(0.2,  5.0, float(u_sharpness > 0.0)) * color;\n \n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2(-1.0,  0.0)), 0.0, 1.0);\n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2( 0.0, -1.0)), 0.0, 1.0);\n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2( 0.0,  1.0)), 0.0, 1.0);\n    sharpenedColor += factor * clamp(texture2D(u_image, v_texCoord + u_pixelDimension * vec2( 1.0,  0.0)), 0.0, 1.0);\n \n    color.rgb /= max(color.a, EPSILON); // unpremultiply\n    sharpenedColor.rgb /= max(sharpenedColor.a, EPSILON); // unpremultiply\n \n    sharpenedColor = clamp(sharpenedColor, 0.0, 1.0);\n \n    color = clamp(mix(color, sharpenedColor, abs(u_sharpness)), 0.0, 1.0);\n      \n    gl_FragColor = vec4(color.rgb * color.a, color.a); // premultiply\n}";

// engine/sdk/operations/adjustments-operation/sharpness-filter.js
const {Vector2: Vector24} = math_exports;
class SharpnessFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = sharpness_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const outputContext = outputTarget.getContext();
    const inputCanvas = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const {sharpness: sharpness2} = this._options;
    const {width} = inputCanvas;
    const {height} = inputCanvas;
    const inputImageData = inputContext.getImageData(0, 0, width, height);
    const outputImageData = outputContext.createImageData(width, height);
    this.canvasShader(inputImageData, outputImageData, sharpness2);
    outputContext.putImageData(outputImageData, 0, 0);
  }
  canvasShader(inputImageData, outputImageData, sharpness2) {
    const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
    const EPSILON3 = 1e-6;
    const {width} = inputImageData;
    const {height} = inputImageData;
    const inData = inputImageData.data;
    const outData = outputImageData.data;
    const mix = (x, y, a) => {
      return x * (1 - a) + y * a;
    };
    const sample = (idx) => {
      return clamp(inData[idx] / 255, 0, 1);
    };
    const clampedIndex = (x, y) => {
      const sampleX = clamp(x, 0, width - 1);
      const sampleY = clamp(y, 0, height - 1);
      return 4 * (sampleX + width * sampleY);
    };
    const color6 = [];
    const sharpenedColor = [];
    const dXOffsets = [-1, 0, 0, 1];
    const dYOffsets = [0, -1, 1, 0];
    const factor = sharpness2 > 0 ? -1 : 0.2;
    const totalWeight = sharpness2 > 0 ? 5 : 0.2;
    const absSharpness = Math.abs(sharpness2);
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height; y++) {
        const idx = clampedIndex(x, y);
        color6[0] = sample(idx + 0);
        color6[1] = sample(idx + 1);
        color6[2] = sample(idx + 2);
        color6[3] = sample(idx + 3);
        sharpenedColor[0] = totalWeight * color6[0] * color6[3];
        sharpenedColor[1] = totalWeight * color6[1] * color6[3];
        sharpenedColor[2] = totalWeight * color6[2] * color6[3];
        sharpenedColor[3] = totalWeight * color6[3];
        for (let i = 0; i < 4; i++) {
          const dX = dXOffsets[i];
          const dY = dYOffsets[i];
          const offsetIndex = clampedIndex(x + dX, y + dY);
          const tempA = sample(offsetIndex + 3);
          sharpenedColor[3] += factor * tempA;
          for (let c = 0; c < 3; c++) {
            sharpenedColor[c] += factor * sample(offsetIndex + c) * tempA;
          }
        }
        for (let i = 0; i < 3; i++) {
          sharpenedColor[i] /= Math.max(sharpenedColor[3], EPSILON3);
          sharpenedColor[i] = clamp(sharpenedColor[i], 0, 1);
        }
        sharpenedColor[3] = clamp(sharpenedColor[3], 0, 1);
        for (let i = 0; i < 4; i++) {
          color6[i] = clamp(mix(color6[i], sharpenedColor[i], absSharpness), 0, 1);
          outData[idx + i] = color6[i] * 255;
        }
      }
    }
  }
}
SharpnessFilter.prototype.availableOptions = {
  sharpness: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  },
  pixelDimension: {
    type: OptionType.VECTOR2,
    default: new Vector24(100, 100),
    uniformType: UniformType.FLOAT2
  }
};
var sharpness_filter_default = SharpnessFilter;

// engine/sdk/operations/shared/shaders/adjustments/temperature.frag
var temperature_default = "precision mediump float;\n\n// Input Image with config WRAP_S and WRAP_T: CLAMP_TO_EDGE\nuniform sampler2D u_image;\n\n// Range (-1.0 - 1.0)\nuniform float u_temperature;\n\nconst lowp vec3 warmFilter = vec3(0.93, 0.54, 0.0);\n\nconst mediump mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\nconst mediump mat3 YIQtoRGB = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n\nconst float EPSILON = 0.0000001;\n\nvarying vec2 v_texCoord;\nvoid main() {\n  float temperature = u_temperature;\n  const float tint = 0.0;\n  vec4 source = texture2D(u_image, v_texCoord);\n\n  source.rgb /= max(source.a, EPSILON);   // Revert premultiplied alpha\n\n  vec3 yiq = RGBtoYIQ * source.rgb;\n  yiq.b = clamp(yiq.b + tint*0.5226*0.1, -0.5226, 0.5226);\n  vec3 rgb = YIQtoRGB * yiq;\n\n  vec3 processed = mix(\n    (1.0 - 2.0 * (1.0 - rgb) * (1.0 - warmFilter)),\n    (2.0 * rgb * warmFilter),\n    vec3(rgb.r < 0.5, rgb.g < 0.5, rgb.b < 0.5)\n  );\n\n  vec4 color = vec4(mix(rgb, processed, temperature), source.a);\n\n  color.rgb *= color.a;   // Premultiply alpha again\n\n  gl_FragColor = color;\n}\n";

// engine/sdk/operations/adjustments-operation/temperature-filter.js
const {Vector3: Vector32} = math_exports;
class TemperatureFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = temperature_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const outputContext = outputTarget.getContext();
    const inputCanvas = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const {temperature: temperature2} = this._options;
    const {width} = inputCanvas;
    const {height} = inputCanvas;
    const inputImageData = inputContext.getImageData(0, 0, width, height);
    const outputImageData = outputContext.createImageData(width, height);
    this.canvasShader(inputImageData, outputImageData, temperature2);
    outputContext.putImageData(outputImageData, 0, 0);
  }
  canvasShader(inputImageData, outputImageData, temperature2) {
    const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
    const mix = (x, y, a) => x * (1 - a) + y * a;
    const mat3Vec3DotProduct = (mat3, vec3) => {
      const outX = mat3[0] * vec3[0] + mat3[3] * vec3[1] + mat3[6] * vec3[2];
      const outY = mat3[1] * vec3[0] + mat3[4] * vec3[1] + mat3[7] * vec3[2];
      const outZ = mat3[2] * vec3[0] + mat3[5] * vec3[1] + mat3[8] * vec3[2];
      return [outX, outY, outZ];
    };
    const {length} = inputImageData.data;
    const maxIdx = length - 1;
    const minIdx = 0;
    const inData = inputImageData.data;
    const outData = outputImageData.data;
    const sampleEdge = (idx) => {
      idx = idx < minIdx ? minIdx : idx;
      idx = idx > maxIdx ? maxIdx : idx;
      return inData[idx];
    };
    const warmFilter = [0.93, 0.54, 0];
    const RGBtoYIQ = [
      0.299,
      0.587,
      0.114,
      0.596,
      -0.274,
      -0.322,
      0.212,
      -0.523,
      0.311
    ];
    const YIQtoRGB = [
      1,
      0.956,
      0.621,
      1,
      -0.272,
      -0.647,
      1,
      -1.105,
      1.702
    ];
    const tint2 = 0;
    for (let idx = 0; idx < length; idx += 4) {
      const colorR = sampleEdge(idx + 0) / 255;
      const colorG = sampleEdge(idx + 1) / 255;
      const colorB = sampleEdge(idx + 2) / 255;
      const colorA = sampleEdge(idx + 3) / 255;
      const source = [colorR, colorG, colorB];
      const yiq = mat3Vec3DotProduct(RGBtoYIQ, source);
      yiq.z = clamp(yiq.z + tint2 * 0.5226 * 0.1, -0.5226, 0.5226);
      const rgb = mat3Vec3DotProduct(YIQtoRGB, yiq);
      const processed = [
        rgb[0] < 0.5 ? 2 * rgb[0] * warmFilter[0] : 1 - 2 * (1 - rgb[0]) * (1 - warmFilter[0]),
        rgb[1] < 0.5 ? 2 * rgb[1] * warmFilter[1] : 1 - 2 * (1 - rgb[1]) * (1 - warmFilter[1]),
        rgb[2] < 0.5 ? 2 * rgb[2] * warmFilter[2] : 1 - 2 * (1 - rgb[2]) * (1 - warmFilter[2])
      ];
      outData[idx + 0] = mix(rgb[0], processed[0], temperature2) * 255;
      outData[idx + 1] = mix(rgb[1], processed[1], temperature2) * 255;
      outData[idx + 2] = mix(rgb[2], processed[2], temperature2) * 255;
      outData[idx + 3] = colorA * 255;
    }
  }
}
TemperatureFilter.prototype.availableOptions = {
  temperature: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  }
};
var temperature_filter_default = TemperatureFilter;

// engine/sdk/operations/adjustments-operation/index.js
const {ColorMatrix: ColorMatrix4} = math_exports;
class AdjustmentsOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._clarityFilter = new clarity_filter_default();
    this._temperatureFilter = new temperature_filter_default();
    this._sharpnessFilter = new sharpness_filter_default();
    this._filter = new adjustments_filter_default();
    this._sprite.setFilters([
      this._clarityFilter,
      this._temperatureFilter,
      this._filter
    ]);
  }
  _render(sdk14) {
    const dimensions = sdk14.getDimensions();
    dimensions.x = 1 / dimensions.x;
    dimensions.y = 1 / dimensions.y;
    const clarityColorMatrix = new ColorMatrix4();
    clarityColorMatrix.multiply(ColorMatrix4.createSaturationMatrix(-0.3 * this._options.clarity + 1));
    clarityColorMatrix.multiply(ColorMatrix4.createContrastMatrix(0.1 * this._options.clarity + 1));
    this._clarityFilter.set({
      clarity: this._options.clarity,
      pixelDimension: dimensions,
      colorMatrix: clarityColorMatrix,
      colorOffset: clarityColorMatrix.getOffsets()
    });
    this._temperatureFilter.set({
      temperature: this._options.temperature
    });
    this._sharpnessFilter.set({
      sharpness: this._options.sharpness,
      pixelDimension: dimensions
    });
    const colorMatrix = new ColorMatrix4();
    colorMatrix.multiply(ColorMatrix4.createExposureMatrix(this._options.exposure));
    colorMatrix.multiply(ColorMatrix4.createSaturationMatrix(this._options.saturation + 1));
    colorMatrix.multiply(ColorMatrix4.createContrastMatrix((this._options.contrast > 0 ? this._options.contrast * 2 : this._options.contrast) + 1));
    colorMatrix.multiply(ColorMatrix4.createBrightnessMatrix(this._options.brightness));
    this._filter.set({
      gamma: this._options.gamma,
      shadows: this._options.shadows,
      highlights: this._options.highlights,
      whites: this._options.whites,
      blacks: this._options.blacks,
      colorMatrix,
      colorOffset: colorMatrix.getOffsets()
    });
    const filters = [];
    if (this._options.clarity !== 0) {
      filters.push(this._clarityFilter);
    }
    if (this._options.sharpness !== 0) {
      filters.push(this._sharpnessFilter);
    }
    if (this._options.temperature !== 0) {
      filters.push(this._temperatureFilter);
    }
    filters.push(this._filter);
    this._sprite.setFilters(filters);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  dispose() {
    super.dispose();
    this._filter.dispose();
    this._clarityFilter.dispose();
    this._temperatureFilter.dispose();
    this._sharpnessFilter.dispose();
  }
}
AdjustmentsOperation.identifier = "adjustments";
AdjustmentsOperation.prototype.availableOptions = {
  brightness: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  saturation: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  contrast: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  gamma: {
    type: OptionType.NUMBER,
    default: 1,
    minValue: 0.5,
    midValue: 1,
    maxValue: 2
  },
  exposure: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  shadows: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -2,
    midValue: 0,
    maxValue: 2
  },
  highlights: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  clarity: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  whites: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  blacks: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  temperature: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  },
  sharpness: {
    type: OptionType.NUMBER,
    default: 0,
    minValue: -1,
    midValue: 0,
    maxValue: 1
  }
};
exports_default.Operations.AdjustmentsOperation = AdjustmentsOperation;
var adjustments_operation_default = AdjustmentsOperation;

// engine/sdk/operations/shared/shaders/generic/blur.frag
var blur_default = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n    float radius = u_blurRadius;\n\n    const float steps = 30.0;\n\n    for (float t = -steps; t <= steps; t++) {\n        float percent = (t + offset - 0.5) / steps;\n        float weight = 1.0 - abs(percent);\n\n        // Somehow `sample` is a keyword in headless-gl\n        vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        color += _sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n}\n";

// engine/sdk/operations/shared/filters/blur-filter.js
const {Vector2: Vector25} = math_exports;
class BlurFilter extends engine_default.Filter {
  constructor(...args) {
    super(...args);
    this._fragmentSource = blur_default;
    this._lastBlurRadius = null;
    this._lastDimensions = new Vector25(0, 0);
    this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false, blurRadius = null) {
    if (this._options.blurQuality === "low") {
      this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
      return;
    }
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    if (this._lastBlurRadius === this._options.blurRadius) {
      outputContext.drawImage(canvas9, 0, 0);
    }
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const outputData = outputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    let radius = this._options.blurRadius;
    const {delta} = this._options;
    const steps = 30;
    for (let x = 0; x < canvas9.width; x++) {
      for (let y = 0; y < canvas9.height; y++) {
        const i = x + y * canvas9.width;
        const index = i * 4;
        let colorR = 0;
        let colorG = 0;
        let colorB = 0;
        let colorA = 0;
        let total = 0;
        if (blurRadius) {
          radius = blurRadius(x / canvas9.width, y / canvas9.height);
        }
        const rand = this._random(x, 1 - y / canvas9.height);
        for (let t = -steps; t <= steps; t++) {
          const percent = (t + rand - 0.5) / steps;
          const weight = 1 - Math.abs(percent);
          const offsetX = delta.x * percent * radius;
          const offsetY = delta.y * percent * radius;
          const clampedX = Math.max(Math.min(x + offsetX, canvas9.width - 1), 0);
          const clampedY = Math.max(Math.min(y + offsetY, canvas9.height - 1), 0);
          const i2 = (Math.round(clampedY) * canvas9.width + Math.round(clampedX)) * 4;
          const sampleA = imageData.data[i2 + 3];
          const sampleR = sampleA * imageData.data[i2];
          const sampleG = sampleA * imageData.data[i2 + 1];
          const sampleB = sampleA * imageData.data[i2 + 2];
          colorR += sampleR * weight;
          colorG += sampleG * weight;
          colorB += sampleB * weight;
          colorA += sampleA * weight;
          total += weight;
        }
        colorR /= total;
        colorG /= total;
        colorB /= total;
        colorA /= total;
        outputData.data[index] = colorR / colorA;
        outputData.data[index + 1] = colorG / colorA;
        outputData.data[index + 2] = colorB / colorA;
        outputData.data[index + 3] = colorA;
      }
    }
    outputContext.putImageData(outputData, 0, 0);
    this._lastDimensions.copy(new Vector25(canvas9.width, canvas9.height));
  }
  _renderLQBlur(renderer, inputTarget, outputTarget, clear) {
    const inputDimensions = inputTarget.getDimensions();
    const dimensionsChanged = !this._lastDimensions.equals(inputDimensions);
    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
    outputTarget.setPixelRatio(inputTarget.getPixelRatio());
    outputTarget.resizeTo(inputTarget.getDimensions());
    if (this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged) {
      this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
      this._lastBlurRadius = this._options.blurRadius;
    }
    const outputContext = outputTarget.getContext();
    outputContext.drawImage(this._blurredRenderTarget.getCanvas(), 0, 0);
    this._lastDimensions.copy(inputDimensions);
  }
  _random(x, y) {
    const a = 12.9898;
    const b = 78.233;
    const c = 43758.5453;
    const dt = x * a + y * b;
    const sn = dt - 3.14 * Math.floor(dt / 3.14);
    const tempR = Math.sin(sn) * c;
    return tempR - Math.floor(tempR);
  }
}
BlurFilter.prototype.availableOptions = {
  blurRadius: {
    type: OptionType.NUMBER,
    default: 30,
    uniformType: UniformType.FLOAT
  },
  delta: {
    type: OptionType.VECTOR2,
    default: new Vector25(1, 1),
    uniformType: UniformType.FLOAT2
  },
  texSize: {
    type: OptionType.VECTOR2,
    default: new Vector25(100, 100),
    uniformType: UniformType.FLOAT2
  },
  blurQuality: {type: OptionType.STRING, default: "low"}
};
var blur_filter_default = BlurFilter;

// engine/sdk/operations/blur-operation/index.js
const {Vector2: Vector26} = math_exports;
class BlurOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._lastBlurRadius = this._options.blurRadius;
    const blurOption = {
      blurQuality: {
        type: OptionType.STRING
      }
    };
    this._horizontalFilter = new blur_filter_default({}, blurOption);
    this._verticalFilter = new blur_filter_default({}, blurOption);
    this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
    this._horizontalFilter.setDelta(new Vector26(0.5, 0.5));
    this._verticalFilter.setDelta(new Vector26(-0.5, 0.5));
    this._filter = new blur_filter_default({}, blurOption);
  }
  _renderWebGL(inputTexture) {
    return this._renderBlur(inputTexture);
  }
  _renderCanvas(inputTexture) {
    if (this._options.highQualityCanvasBlur) {
      return this._renderBlur(inputTexture);
    }
    return this._renderLQCanvasBlur(inputTexture);
  }
  _renderBlur(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const shortestSide = inputDimensions.min();
    const {blurRadius} = this._options;
    const commonOptions = {
      blurRadius: blurRadius * shortestSide,
      texSize: inputDimensions,
      blurQuality: "high"
    };
    this._horizontalFilter.set(commonOptions);
    this._verticalFilter.set(commonOptions);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  _renderLQCanvasBlur(inputTexture) {
    const {blurRadius} = this._options;
    const inputDimensions = inputTexture.getDimensions();
    this._filter.set({
      blurRadius,
      texSize: inputDimensions,
      blurQuality: "low"
    });
    this._sprite.setFilters([this._filter]);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  transform(transformChange) {
    const size = this.getBlurRadius();
    const blurRadius = transformChange.applyToRelativeSize(size);
    this.set({blurRadius}, false);
  }
  dispose() {
    super.dispose();
    this._filter.dispose();
    this._verticalFilter.dispose();
    this._horizontalFilter.dispose();
  }
  hasChanges() {
    return true;
  }
}
BlurOperation.identifier = "blur";
BlurOperation.prototype.availableOptions = {
  blurRadius: {type: OptionType.NUMBER, default: 0.025},
  highQualityCanvasBlur: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.BlurOperation = BlurOperation;
var blur_operation_default = BlurOperation;

// engine/sdk/operations/shared/shaders/generic/blend.frag
var blend_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_filteredImage;\nuniform float u_intensity;\n\nvoid main() {\n  vec4 color0 = texture2D(u_image, v_texCoord);\n  vec4 color1 = texture2D(u_filteredImage, v_texCoord);\n  gl_FragColor = mix(color0, color1, u_intensity);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives-stack.js
class BlendFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = blend_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const outputContext = outputTarget.getContext();
    const {filteredCanvas} = this._options;
    outputContext.save();
    outputContext.globalAlpha = 1 - this._options.intensity;
    outputContext.drawImage(canvas9, 0, 0);
    outputContext.globalAlpha = this._options.intensity;
    outputContext.drawImage(filteredCanvas, 0, 0);
    outputContext.restore();
  }
}
BlendFilter.prototype.availableOptions = {
  filteredImage: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.INT
  },
  filteredCanvas: {type: OptionType.OBJECT, default: null},
  intensity: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.FLOAT
  }
};
class PrimitivesStack {
  constructor(intensity = 1) {
    this._intensity = intensity;
    this._stack = [];
    this._dirtiness = {};
    this._renderTextures = {};
    this._container = new engine_default.Container();
    this._sprite = new engine_default.Sprite();
    this._container.addChild(this._sprite);
    this._blendFilter = new BlendFilter();
  }
  push(primitive16) {
    this._stack.push(primitive16);
  }
  clear() {
    this._stack = [];
  }
  render(sdk14, inputTexture, outputTexture) {
    if (this.isEmpty()) {
      return promise_default.resolve();
    }
    const renderer = sdk14.getRenderer();
    this._sprite.setTexture(inputTexture);
    let filteredRenderTexture = this._renderTextures[renderer.id];
    if (!filteredRenderTexture) {
      const frame2 = sdk14.getSprite().getTexture().getFrame();
      filteredRenderTexture = new engine_default.RenderTexture(sdk14.getRenderer(), frame2.width, frame2.height);
      this._renderTextures[renderer.id] = filteredRenderTexture;
    }
    const textureDimensions = outputTexture.getDimensions();
    filteredRenderTexture.resizeTo(textureDimensions);
    const shouldRender = this.isDirtyForRenderer(renderer);
    if (shouldRender) {
      this._stack.forEach((p) => {
        p.update(sdk14);
      });
      const filters = this._stack.map((p) => p.getFilter());
      this._sprite.setFilters(filters);
      filteredRenderTexture.render(this._container);
      this.setDirtyForRenderer(false, renderer);
    }
    this._blendFilter.setIntensity(this._intensity);
    if (renderer.isOfType(RendererType.CANVAS)) {
      this._blendFilter.setFilteredCanvas(filteredRenderTexture.getRenderTarget().getCanvas());
    } else if (renderer.isOfType(RendererType.WEBGL)) {
      const baseTexture = filteredRenderTexture.getBaseTexture();
      baseTexture.setGLUnit(this._blendFilter.getFilteredImage());
      renderer.updateTexture(baseTexture, false);
    }
    this._sprite.setFilters([this._blendFilter]);
    outputTexture.clear(color_default.TRANSPARENT);
    outputTexture.render(this._container);
    if (shouldRender) {
      this.disposeRenderTextures();
    }
    return promise_default.resolve();
  }
  setIntensity(intensity) {
    this._intensity = intensity;
  }
  isEmpty() {
    return this._stack.length === 0;
  }
  isDirtyForRenderer(renderer) {
    if (!(renderer.id in this._dirtiness)) {
      this._dirtiness[renderer.id] = true;
    }
    return this._dirtiness[renderer.id];
  }
  setDirtyForRenderer(dirty, renderer) {
    this._dirtiness[renderer.id] = dirty;
  }
  setDirty(dirty) {
    for (const rendererId in this._dirtiness) {
      this._dirtiness[rendererId] = dirty;
    }
  }
  disposeRenderTextures() {
    for (const rendererId in this._renderTextures) {
      this._renderTextures[rendererId].dispose();
      delete this._renderTextures[rendererId];
    }
  }
  dispose() {
    this.disposeRenderTextures();
    this._stack.forEach((primitive16) => primitive16.dispose());
    this._stack = [];
    this._blendFilter.dispose();
    this._sprite.dispose();
  }
}
var primitives_stack_default = PrimitivesStack;

// engine/sdk/operations/filter-operation/filters/filter.js
class Filter2 extends configurable_default {
  constructor(options = {}, additionalOptions = {}) {
    super(options, __assign({
      intensity: {
        type: OptionType.NUMBER,
        default: 1,
        setter(intensity) {
          this._stack && this._stack.setIntensity(intensity);
          return intensity;
        }
      },
      dirty: {
        type: OptionType.BOOLEAN,
        default: true
      }
    }, additionalOptions));
    this._stack = new primitives_stack_default(this._options.intensity);
  }
  render(sdk14, inputTexture, outputTexture) {
    return this._stack.render(sdk14, inputTexture, outputTexture).then((response) => {
      this.setDirty(false);
      return response;
    });
  }
  setDirtyForRenderer(dirty, renderer) {
    this._stack.setDirtyForRenderer(dirty, renderer);
  }
  disposeRenderTextures() {
    this._stack.disposeRenderTextures();
  }
  dispose() {
    this._stack.dispose();
  }
}
Filter2.identifier = null;
Filter2.isIdentity = false;
Filter2.displayName = null;
Filter2.PrimitivesStack = primitives_stack_default;
var filter_default2 = Filter2;

// engine/sdk/operations/shared/shaders/primitives/brightness.frag
var brightness_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_brightness;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4((texColor.rgb + vec3(u_brightness) * texColor.a), texColor.a);;\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/primitive.js
class Primitive extends configurable_default {
  update() {
  }
  getFilter() {
    return this._filter;
  }
  dispose() {
    if (this._filter) {
      this._filter.dispose();
      this._filter = null;
    }
  }
}
var primitive_default = Primitive;

// engine/sdk/operations/filter-operation/filters/primitives/brightness.js
class BrightnessFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = brightness_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    let {brightness: brightness3} = this._options;
    if (brightness3 === 0) {
      outputContext.putImageData(imageData, 0, 0);
      return;
    }
    brightness3 *= 255;
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      imageData.data[index] += brightness3;
      imageData.data[index + 1] += brightness3;
      imageData.data[index + 2] += brightness3;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
BrightnessFilter.prototype.availableOptions = {
  brightness: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  }
};
class Brightness extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new BrightnessFilter();
  }
  update() {
    this._filter.setBrightness(this._options.brightness);
  }
}
Brightness.prototype.availableOptions = BrightnessFilter.prototype.availableOptions;
var brightness_default2 = Brightness;

// engine/sdk/operations/shared/shaders/primitives/contrast.frag
var contrast_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_contrast;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(((texColor.rgb - vec3(0.5)) * u_contrast + vec3(0.5) * texColor.a), texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/contrast.js
class ContrastFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = contrast_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {contrast: contrast3} = this._options;
    if (contrast3 === 1) {
      return;
    }
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      imageData.data[index] = (imageData.data[index] - 127) * contrast3 + 127;
      imageData.data[index + 1] = (imageData.data[index + 1] - 127) * contrast3 + 127;
      imageData.data[index + 2] = (imageData.data[index + 2] - 127) * contrast3 + 127;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
ContrastFilter.prototype.availableOptions = {
  contrast: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.FLOAT
  }
};
class Contrast extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new ContrastFilter();
  }
  update() {
    this._filter.setContrast(this._options.contrast);
  }
}
Contrast.prototype.availableOptions = ContrastFilter.prototype.availableOptions;
var contrast_default2 = Contrast;

// engine/sdk/operations/shared/shaders/primitives/color-matrix.frag
var color_matrix_default2 = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform mat4 u_colorMatrix;\nuniform vec4 u_colorMatrixOffset;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = texColor * u_colorMatrix + u_colorMatrixOffset;\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/color-matrix.js
const {ColorMatrix: ColorMatrix5} = math_exports;
class ColorMatrixFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = color_matrix_default2;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {colorMatrix} = this._options;
    let color6 = new color_default(0, 0, 0, 0);
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      color6.r = imageData.data[index] / 255;
      color6.g = imageData.data[index + 1] / 255;
      color6.b = imageData.data[index + 2] / 255;
      color6 = colorMatrix.apply(color6);
      imageData.data[index] = color6.r * 255;
      imageData.data[index + 1] = color6.g * 255;
      imageData.data[index + 2] = color6.b * 255;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
ColorMatrixFilter.prototype.availableOptions = {
  colorMatrix: {
    type: OptionType.COLOR_MATRIX,
    default: new ColorMatrix5(),
    uniformType: UniformType.MAT4
  },
  colorMatrixOffset: {
    type: OptionType.ARRAY,
    default: [],
    uniformType: UniformType.FLOAT4
  }
};
class ColorMatrixPrimitive extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new ColorMatrixFilter();
  }
  update() {
    this._filter.setColorMatrix(this._options.colorMatrix);
  }
}
ColorMatrixPrimitive.prototype.availableOptions = ColorMatrixFilter.prototype.availableOptions;
var color_matrix_default3 = ColorMatrixPrimitive;

// engine/sdk/operations/shared/shaders/primitives/desaturation.frag
var desaturation_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_desaturation;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n  vec3 gray = vec3(dot(grayXfer, texColor.xyz));\n  gl_FragColor = vec4(mix(texColor.xyz, gray, u_desaturation) * texColor.a, texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/desaturation.js
class DesaturationFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = desaturation_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const grayXfer = [0.3, 0.59, 0.11];
    const {desaturation: desaturation3} = this._options;
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      const gray = grayXfer[0] * imageData.data[index] / 255 + grayXfer[1] * imageData.data[index + 1] / 255 + grayXfer[2] * imageData.data[index + 2] / 255;
      imageData.data[index] += (gray * 255 - imageData.data[index]) * desaturation3;
      imageData.data[index + 1] += (gray * 255 - imageData.data[index + 1]) * desaturation3;
      imageData.data[index + 2] += (gray * 255 - imageData.data[index + 2]) * desaturation3;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
DesaturationFilter.prototype.availableOptions = {
  desaturation: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.FLOAT
  }
};
class Desaturation extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new DesaturationFilter();
  }
  update() {
    this._filter.setDesaturation(this._options.desaturation);
  }
}
Desaturation.prototype.availableOptions = DesaturationFilter.prototype.availableOptions;
var desaturation_default2 = Desaturation;

// engine/sdk/operations/shared/shaders/primitives/duotone.frag
var duotone_default = 'precision highp float;\n\nuniform sampler2D u_image;\nuniform vec4 u_lightColor;\nuniform vec4 u_darkColor;\nuniform float u_intensity;\nvarying vec2 v_texCoord;\n\nconst float EPSILON = 0.0000001;\nconst vec3 GRAYSCALE_WEIGHTS = vec3(0.2126, 0.7152, 0.0722);\n\nvec4 duotoneKernel(vec4 sampledCol, vec4 light, vec4 dark, float intensity) {\n  vec4 color = clamp(sampledCol, 0.0, 1.0);\n  color.rgb /= max(color.a, EPSILON);\n  color = clamp(color, 0.0, 1.0); // necessary to get rid of all extended sRGB issues with OpenGL ES\n \n  // Apply intensity as "symmetric gamma"\n  if (intensity > 0.0) {\n    color.rgb = 1.0 - pow(1.0 - color.rgb, vec3(max(intensity + 1.0, EPSILON)));\n  } else {\n    color.rgb = pow(color.rgb, vec3(max(-intensity + 1.0, EPSILON)));\n  }\n \n  // Colorimetric (perceptual luminance-preserving) RGB to grayscale conversion\n  // https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale\n  float luminance = dot(GRAYSCALE_WEIGHTS, color.rgb);\n \n  // Apply DuoTone\n  vec4 duotone = mix(dark, light, clamp(luminance, 0.0, 1.0));\n  duotone.a *= color.a;\n  \n  duotone.rgb *= duotone.a;\n\n  return duotone;\n}\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = duotoneKernel(texColor, u_lightColor, u_darkColor, u_intensity);\n}';

// engine/sdk/operations/filter-operation/filters/primitives/duotone.js
class DuoToneFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = duotone_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {lightColor, darkColor, intensity} = this._options;
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      const r = imageData.data[index] / 255;
      const g = imageData.data[index + 1] / 255;
      const b = imageData.data[index + 2] / 255;
      const a = imageData.data[index + 3] / 255;
      const color6 = new color_default(r, g, b, a);
      const duotone3 = this._duoToneKernel(color6, lightColor, darkColor, intensity);
      imageData.data[index] = duotone3.r * 255;
      imageData.data[index + 1] = duotone3.g * 255;
      imageData.data[index + 2] = duotone3.b * 255;
      imageData.data[index + 3] = duotone3.a * 255;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
  _duoToneKernel(color6, light, dark, intensity) {
    const EPSILON3 = 1e-7;
    color6.clone().clamp(0, 1);
    if (intensity > 0) {
      const exp = Math.max(intensity + 1, EPSILON3);
      color6.r = 1 - Math.pow(1 - color6.r, exp);
      color6.g = 1 - Math.pow(1 - color6.g, exp);
      color6.b = 1 - Math.pow(1 - color6.b, exp);
    } else {
      const exp = Math.max(-intensity + 1, EPSILON3);
      color6.r = Math.pow(color6.r, exp);
      color6.g = Math.pow(color6.g, exp);
      color6.b = Math.pow(color6.b, exp);
    }
    const luminance = 0.2126 * color6.r + 0.7152 * color6.g + 0.0722 * color6.b;
    const clampedLuminance = Math.min(Math.max(luminance, 0), 1);
    const duotone3 = dark.clone().mix(light, clampedLuminance);
    duotone3.a *= color6.a;
    return duotone3;
  }
}
DuoToneFilter.prototype.availableOptions = {
  lightColor: {
    type: OptionType.COLOR,
    default: color_default.RED,
    uniformType: UniformType.FLOAT4
  },
  darkColor: {
    type: OptionType.COLOR,
    default: color_default.BLACK,
    uniformType: UniformType.FLOAT4
  },
  intensity: {
    type: OptionType.NUMBER,
    default: 0.5,
    uniformType: UniformType.FLOAT
  }
};
class DuoTone extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new DuoToneFilter();
  }
  update() {
    this._filter.setLightColor(this._options.lightColor);
    this._filter.setDarkColor(this._options.darkColor);
    const shaderIntensity = 2 * this._options.intensity - 1;
    this._filter.setIntensity(shaderIntensity);
  }
}
DuoTone.prototype.availableOptions = DuoToneFilter.prototype.availableOptions;
var duotone_default2 = DuoTone;

// engine/sdk/operations/shared/shaders/primitives/gamma.frag
var gamma_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec3 u_gamma;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec3 rgb = vec3(texColor.r, texColor.g, texColor.b);\n  rgb = pow(rgb, u_gamma);\n  gl_FragColor = vec4(rgb * texColor.a, texColor.a);;\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/gamma.js
class GammaFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = gamma_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {gamma: gamma3} = this._options;
    const gammaArrayRed = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
      gammaArrayRed[i] = 255 * Math.pow(i / 255, gamma3.r);
    }
    const gammaArrayGreen = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
      gammaArrayGreen[i] = 255 * Math.pow(i / 255, gamma3.g);
    }
    const gammaArrayBlue = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
      gammaArrayBlue[i] = 255 * Math.pow(i / 255, gamma3.b);
    }
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      imageData.data[index] = gammaArrayRed[imageData.data[index]];
      imageData.data[index + 1] = gammaArrayGreen[imageData.data[index + 1]];
      imageData.data[index + 2] = gammaArrayBlue[imageData.data[index + 2]];
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
GammaFilter.prototype.availableOptions = {
  gamma: {
    type: OptionType.COLOR,
    default: color_default.WHITE,
    uniformType: UniformType.FLOAT3
  }
};
class Gamma extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new GammaFilter();
  }
  update() {
    this._filter.setGamma(this._options.gamma);
  }
}
Gamma.prototype.availableOptions = GammaFilter.prototype.availableOptions;
var gamma_default2 = Gamma;

// engine/sdk/operations/shared/shaders/primitives/glow.frag
var glow_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n\n  vec2 textureCoord = v_texCoord - vec2(0.5, 0.5);\n  textureCoord /= 0.75;\n\n  float d = 1.0 - dot(textureCoord, textureCoord);\n  d = clamp(d, 0.2, 1.0);\n  vec3 newColor = texColor.rgb * d * u_color.rgb;\n  gl_FragColor = vec4(vec3(newColor) * texColor.a, texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/glow.js
class GlowFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = glow_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {color: color6} = this._options;
    let d;
    for (let x = 0; x < canvas9.width; x++) {
      for (let y = 0; y < canvas9.height; y++) {
        const index = (canvas9.width * y + x) * 4;
        const x01 = x / canvas9.width;
        const y01 = y / canvas9.height;
        const nx = (x01 - 0.5) / 0.75;
        const ny = (y01 - 0.5) / 0.75;
        const scalarX = nx * nx;
        const scalarY = ny * ny;
        d = 1 - (scalarX + scalarY);
        d = Math.min(Math.max(d, 0.1), 1);
        imageData.data[index] *= d * color6.r;
        imageData.data[index + 1] = imageData.data[index + 1] * (d * color6.g);
        imageData.data[index + 2] = imageData.data[index + 2] * (d * color6.b);
        imageData.data[index + 3] = 255;
      }
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
GlowFilter.prototype.availableOptions = {
  color: {
    type: OptionType.COLOR,
    default: color_default.WHITE,
    uniformType: UniformType.FLOAT3
  }
};
class Glow extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new GlowFilter();
  }
  update() {
    this._filter.setColor(this._options.color);
  }
}
Glow.prototype.availableOptions = GlowFilter.prototype.availableOptions;
var glow_default2 = Glow;

// engine/sdk/operations/shared/shaders/primitives/gobblin.frag
var gobblin_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  texColor.b = texColor.g * 0.33;\n  texColor.r = texColor.r * 0.6;\n  texColor.b += texColor.r * 0.33;\n  texColor.g = texColor.g * 0.7;\n  gl_FragColor = texColor;\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/gobblin.js
class GobblinFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = gobblin_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    for (let x = 0; x < canvas9.width; x++) {
      for (let y = 0; y < canvas9.height; y++) {
        const index = (canvas9.width * y + x) * 4;
        imageData.data[index + 2] = imageData.data[index + 1] * 0.33;
        imageData.data[index] *= 0.6;
        imageData.data[index + 2] += imageData.data[index] * 0.33;
        imageData.data[index + 1] = imageData.data[index + 1] * 0.7;
        imageData.data[index + 3] = 255;
      }
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
class Gobblin extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new GobblinFilter();
  }
}
var gobblin_default2 = Gobblin;

// engine/sdk/operations/shared/shaders/primitives/grayscale.frag
var grayscale_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nvec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, W);\n  gl_FragColor = vec4(vec3(luminance) * texColor.a, texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/grayscale.js
class GrayscaleFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = grayscale_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    for (let x = 0; x < canvas9.width; x++) {
      for (let y = 0; y < canvas9.height; y++) {
        const index = (canvas9.width * y + x) * 4;
        const luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
        imageData.data[index] = luminance;
        imageData.data[index + 1] = luminance;
        imageData.data[index + 2] = luminance;
      }
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
class Grayscale extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new GrayscaleFilter();
  }
}
var grayscale_default2 = Grayscale;

// engine/sdk/operations/shared/shaders/primitives/lookup-table.frag
var lookup_table_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_lookupTable;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float r = texture2D(u_lookupTable, vec2(texColor.r, 0.0)).r;\n  float g = texture2D(u_lookupTable, vec2(texColor.g, 0.0)).g;\n  float b = texture2D(u_lookupTable, vec2(texColor.b, 0.0)).b;\n\n  gl_FragColor = vec4(vec3(r, g, b) * texColor.a, texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/lookup-table.js
class LookupTableFilter extends engine_default.Filter {
  constructor(...args) {
    super(...args);
    this._fragmentSource = lookup_table_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const table = this._options.lookupTableData;
    for (let i = 0; i < canvas9.width * canvas9.height; i++) {
      const index = i * 4;
      const r = imageData.data[index];
      imageData.data[index] = table[r * 4];
      const g = imageData.data[index + 1];
      imageData.data[index + 1] = table[1 + g * 4];
      const b = imageData.data[index + 2];
      imageData.data[index + 2] = table[2 + b * 4];
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
LookupTableFilter.prototype.availableOptions = {
  lookupTable: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.INT
  },
  lookupTableData: {type: OptionType.ARRAY, default: []}
};
class LookupTable extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new LookupTableFilter({
      lookupTable: this._options.textureGLUnit
    });
    this._textures = {};
    this._renderers = {};
  }
  update(sdk14) {
    const renderer = sdk14.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      this._updateWebGLTexture(sdk14);
    } else if (renderer.isOfType(RendererType.CANVAS)) {
      this._filter.setLookupTableData(this._options.data);
    }
  }
  _updateWebGLTexture(sdk14) {
    if (typeof this._options.data === "undefined") {
      throw new Error("LookupTable: No data specified.");
    }
    const data = new Uint8Array(this._options.data);
    const renderer = sdk14.getRenderer();
    const {id} = renderer;
    this._renderers[id] = renderer;
    if (!this._textures[id]) {
      this._textures[id] = new engine_default.BaseTexture();
    }
    const texture5 = this._textures[id];
    const pixelArrayImage = new engine_default.PixelArrayImage(256, 1, data);
    texture5.setSource(pixelArrayImage);
    texture5.setGLUnit(this._options.textureGLUnit);
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(texture5);
    }
  }
  dispose() {
    super.dispose();
    for (const id in this._textures) {
      this._textures[id].dispose();
      delete this._textures[id];
    }
    delete this._options.data;
  }
}
var lookup_table_default2 = LookupTable;

// engine/sdk/operations/shared/shaders/primitives/lookup-table-image.frag
var lookup_table_image_default = "/**\n * Based off of GPUImage's LookupFilter:\n * https://github.com/BradLarson/GPUImage/blob/master/framework/Source/GPUImageLookupFilter.m\n */\n\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_lookupTable;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float blueColor = texColor.b * 63.0;\n\n  vec2 quad1;\n  quad1.y = floor(floor(blueColor) / 8.0);\n  quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\n  vec2 quad2;\n  quad2.y = floor(ceil(blueColor) / 8.0);\n  quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\n  vec2 texCoord1;\n  texCoord1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.r);\n  texCoord1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.g);\n\n  vec2 texCoord2;\n  texCoord2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.r);\n  texCoord2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * texColor.g);\n\n  vec4 newColor1 = texture2D(u_lookupTable, texCoord1);\n  vec4 newColor2 = texture2D(u_lookupTable, texCoord2);\n\n  vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n  gl_FragColor = mix(texColor, vec4(newColor.rgb, texColor.w), texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/lookup-table-image.js
const {Vector2: Vector27} = math_exports;
const TEXTURE_GL_UNIT = 3;
class LookupTableImageFilter extends engine_default.Filter {
  constructor() {
    super();
    this._precomputeQuads();
    this._fragmentSource = lookup_table_image_default;
  }
  _precomputeQuads() {
    this._quads = [];
    for (let i = 0; i < 256; i++) {
      const blueColor = i / 255 * 63;
      const quad2 = new Vector27();
      quad2.y = (blueColor | 0) * 0.125 | 0;
      quad2.x = (blueColor | 0) - quad2.y * 8;
      this._quads.push(quad2);
    }
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const lutImage = this._options.lookupTableImage;
    const lutCanvas = this._createImageCanvas(lutImage);
    const lutContext = lutCanvas.getContext("2d");
    const inputImageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const filterImageData = lutContext.getImageData(0, 0, lutImage.width, lutImage.height);
    const texCoord = new Vector27();
    for (let index = 0; index < canvas9.width * canvas9.height * 4; index += 4) {
      const r = inputImageData.data[index];
      const g = inputImageData.data[index + 1];
      const b = inputImageData.data[index + 2];
      const a = inputImageData.data[index + 3] / 255;
      const quad2 = this._quads[b];
      const tileSideLength = 64;
      texCoord.x = quad2.x * tileSideLength;
      texCoord.y = quad2.y * tileSideLength;
      texCoord.x += Math.floor(r / 4);
      texCoord.y += Math.floor(g / 4);
      const texCoordIndex = (lutImage.width * texCoord.y + texCoord.x) * 4 | 0;
      let newR = filterImageData.data[texCoordIndex];
      newR = r * (1 - a) + newR * a;
      let newG = filterImageData.data[texCoordIndex + 1];
      newG = g * (1 - a) + newG * a;
      let newB = filterImageData.data[texCoordIndex + 2];
      newB = b * (1 - a) + newB * a;
      inputImageData.data[index] = newR;
      inputImageData.data[index + 1] = newG;
      inputImageData.data[index + 2] = newB;
    }
    outputContext.putImageData(inputImageData, 0, 0);
  }
  _createImageCanvas(image5) {
    const canvas9 = utils_default.createCanvas();
    canvas9.width = image5.width;
    canvas9.height = image5.height;
    const context = canvas9.getContext("2d");
    context.drawImage(image5, 0, 0);
    return canvas9;
  }
}
LookupTableImageFilter.prototype.availableOptions = {
  lookupTable: {
    type: OptionType.NUMBER,
    default: TEXTURE_GL_UNIT,
    uniformType: UniformType.INT
  },
  lookupTableImage: {type: OptionType.IMAGE, uniformType: null}
};
class LookupTableImage extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new LookupTableImageFilter();
    this._textures = {};
  }
  update(sdk14) {
    const renderer = sdk14.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      this._updateWebGLTexture(sdk14);
    } else if (renderer.isOfType(RendererType.CANVAS)) {
      this._filter.setLookupTableImage(this._options.image);
    }
  }
  _updateWebGLTexture(sdk14) {
    const renderer = sdk14.getRenderer();
    const {id} = renderer;
    if (!this._textures[id]) {
      this._textures[id] = new engine_default.BaseTexture();
    }
    const texture5 = this._textures[id];
    texture5.setSource(this._options.image);
    texture5.setGLUnit(TEXTURE_GL_UNIT);
    renderer.updateTexture(texture5);
  }
  dispose() {
    super.dispose();
    for (const id in this._textures) {
      delete this._textures[id];
    }
  }
}
LookupTableImage.prototype.availableOptions = {
  image: {type: OptionType.IMAGE}
};
var lookup_table_image_default2 = LookupTableImage;

// engine/sdk/operations/shared/shaders/primitives/saturation.frag
var saturation_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_saturation;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, luminanceWeighting);\n\n  vec3 greyScaleColor = vec3(luminance);\n\n  gl_FragColor = vec4(mix(greyScaleColor, texColor.rgb, u_saturation) * texColor.a, texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/saturation.js
class SaturationFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = saturation_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const {saturation: saturation3} = this._options;
    for (let x = 0; x < canvas9.width; x++) {
      for (let y = 0; y < canvas9.height; y++) {
        const index = (canvas9.width * y + x) * 4;
        const luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
        imageData.data[index] = luminance * (1 - saturation3) + imageData.data[index] * saturation3;
        imageData.data[index + 1] = luminance * (1 - saturation3) + imageData.data[index + 1] * saturation3;
        imageData.data[index + 2] = luminance * (1 - saturation3) + imageData.data[index + 2] * saturation3;
      }
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
SaturationFilter.prototype.availableOptions = {
  saturation: {
    type: OptionType.NUMBER,
    default: 0,
    uniformType: UniformType.FLOAT
  }
};
class Saturation extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new SaturationFilter();
  }
  update() {
    this._filter.setSaturation(this._options.saturation);
  }
}
Saturation.prototype.availableOptions = SaturationFilter.prototype.availableOptions;
var saturation_default2 = Saturation;

// engine/sdk/operations/shared/shaders/primitives/soft-color-overlay.frag
var soft_color_overlay_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec4 overlayVec4 = vec4(u_color, texColor.a);\n  gl_FragColor = max(overlayVec4 * texColor.a, texColor);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/soft-color-overlay.js
class SoftColorOverlayFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = soft_color_overlay_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    for (let x = 0; x < canvas9.width; x++) {
      for (let y = 0; y < canvas9.height; y++) {
        const index = (canvas9.width * y + x) * 4;
        imageData.data[index] = Math.max(this._options.color.r * 255, imageData.data[index]);
        imageData.data[index + 1] = Math.max(this._options.color.g * 255, imageData.data[index + 1]);
        imageData.data[index + 2] = Math.max(this._options.color.b * 255, imageData.data[index + 2]);
      }
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
SoftColorOverlayFilter.prototype.availableOptions = {
  color: {
    type: OptionType.COLOR,
    default: color_default.WHITE,
    uniformType: UniformType.FLOAT3
  }
};
class SoftColorOverlay extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new SoftColorOverlayFilter();
  }
  update() {
    this._filter.setColor(this._options.color);
  }
}
SoftColorOverlay.prototype.availableOptions = SoftColorOverlayFilter.prototype.availableOptions;
var soft_color_overlay_default2 = SoftColorOverlay;

// engine/sdk/operations/filter-operation/filters/primitives/tone-curve.js
class ToneCurve extends lookup_table_default2 {
  constructor(...args) {
    super(...args);
    if (!this._options.rgbControlPoints) {
      this._options.rgbControlPoints = {
        red: this._options.controlPoints,
        green: this._options.controlPoints,
        blue: this._options.controlPoints
      };
    }
    this._updateLookupTable();
  }
  _updateLookupTable() {
    const r = this._calculateSplineCurve(this._options.rgbControlPoints.red);
    const g = this._calculateSplineCurve(this._options.rgbControlPoints.green);
    const b = this._calculateSplineCurve(this._options.rgbControlPoints.blue);
    this._options.data = this._buildLookupTable(r, g, b);
  }
  _buildLookupTable(r, g, b) {
    const data = [];
    for (let i = 0; i < 256; i++) {
      data.push(Math.min(Math.max(i + r[i], 0), 255));
      data.push(Math.min(Math.max(i + g[i], 0), 255));
      data.push(Math.min(Math.max(i + b[i], 0), 255));
      data.push(255);
    }
    return data;
  }
  _calculateSplineCurve(points) {
    points = points.sort(function(a, b) {
      return a[0] > b[0];
    });
    const splinePoints = this._getSplineCurve(points);
    const firstSplinePoint = splinePoints[0];
    let i;
    if (firstSplinePoint[0] > 0) {
      for (i = 0; i < firstSplinePoint[0]; i++) {
        splinePoints.unshift([0, 0]);
      }
    }
    const preparedPoints = [];
    for (i = 0; i < splinePoints.length; i++) {
      const newPoint = splinePoints[i];
      const origPoint = [newPoint[0], newPoint[0]];
      let distance = Math.sqrt(Math.pow(origPoint[0] - newPoint[0], 2) + Math.pow(origPoint[1] - newPoint[1], 2));
      if (origPoint[1] > newPoint[1]) {
        distance = -distance;
      }
      preparedPoints.push(distance);
    }
    return preparedPoints;
  }
  _getSplineCurve(points) {
    const sdA = this._secondDerivative(points);
    const n = sdA.length;
    const sd = [];
    let i;
    for (i = 0; i < n; i++) {
      sd[i] = sdA[i];
    }
    const output = [];
    for (i = 0; i < n - 1; i++) {
      const cur = points[i];
      const next = points[i + 1];
      for (let x = cur[0]; x < next[0]; x++) {
        const t = (x - cur[0]) / (next[0] - cur[0]);
        const a = 1 - t;
        const b = t;
        const h = next[0] - cur[0];
        let y = a * cur[1] + b * next[1] + h * h / 6 * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);
        if (y > 255) {
          y = 255;
        } else if (y < 0) {
          y = 0;
        }
        output.push([x, y]);
      }
    }
    if (output.length === 255) {
      output.push(points[points.length - 1]);
    }
    return output;
  }
  _secondDerivative(points) {
    const n = points.length;
    if (n <= 0 || n === 1) {
      return null;
    }
    const matrix4 = [];
    const result = [];
    let i;
    let k;
    matrix4[0] = [0, 1, 0];
    for (i = 1; i < n - 1; i++) {
      const P1 = points[i - 1];
      const P2 = points[i];
      const P3 = points[i + 1];
      matrix4[i] = matrix4[i] || [];
      matrix4[i][0] = (P2[0] - P1[0]) / 6;
      matrix4[i][1] = (P3[0] - P1[0]) / 3;
      matrix4[i][2] = (P3[0] - P2[0]) / 6;
      result[i] = (P3[1] - P2[1]) / (P3[0] - P2[0]) - (P2[1] - P1[1]) / (P2[0] - P1[0]);
    }
    result[0] = 0;
    result[n - 1] = 0;
    matrix4[n - 1] = [0, 1, 0];
    for (i = 1; i < n; i++) {
      k = matrix4[1][0] / matrix4[i - 1][1];
      matrix4[i][1] -= k * matrix4[i - 1][2];
      matrix4[i][0] = 0;
      result[i] -= k * result[i - 1];
    }
    for (i = n - 2; i > 0; i--) {
      k = matrix4[i][2] / matrix4[i + 1][1];
      matrix4[i][1] -= k * matrix4[i + 1][0];
      matrix4[i][2] = 0;
      result[i] -= k * result[i + 1];
    }
    const y2 = [];
    for (i = 0; i < n; i++) {
      y2[i] = result[i] / matrix4[i][1];
    }
    return y2;
  }
}
ToneCurve.prototype.availableOptions = {
  rgbControlPoints: {type: OptionType.OBJECT},
  controlPoints: {type: OptionType.ARRAY, default: []},
  textureGLUnit: {type: OptionType.NUMBER, default: 1}
};
var tone_curve_default = ToneCurve;

// engine/sdk/operations/shared/shaders/primitives/x400.frag
var x400_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float gray = texColor.r * 0.3 + texColor.g * 0.3 + texColor.b * 0.3;\n  gray -= 0.2;\n  gray = clamp(gray, 0.0, 1.0);\n  gray += 0.15;\n  gray *= 1.4;\n  gl_FragColor = vec4(vec3(gray) * texColor.a, texColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/x400.js
class X400Filter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = x400_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    for (let x = 0; x < canvas9.width; x++) {
      for (let y = 0; y < canvas9.height; y++) {
        const index = (canvas9.width * y + x) * 4;
        let gray = imageData.data[index] / 255 * 0.3 + imageData.data[index + 1] / 255 * 0.3 + imageData.data[index + 2] / 255 * 0.3;
        gray -= 0.2;
        gray = Math.max(0, Math.min(1, gray));
        gray += 0.15;
        gray *= 1.4;
        gray *= 255;
        imageData.data[index] = gray;
        imageData.data[index + 1] = gray;
        imageData.data[index + 2] = gray;
      }
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
class X400 extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new X400Filter();
  }
}
var x400_default2 = X400;

// engine/sdk/operations/shared/shaders/primitives/3d-lookup-table-image.frag
var d_lookup_table_image_default = "precision highp float;\n\nuniform sampler2D u_image;\n\nuniform sampler2D u_lookupTable;\n\nuniform float u_resolution;     // Texture-Resolution, must be power of 2: 64, 128, 256, 512, 1024, 2048, 4096\nuniform float u_horizontalTileCount; // Horizontal Blue Tiles\nuniform float u_verticalTileCount; // Vertical Blue Tiles\n\nvarying vec2 v_texCoord;\n\nconst float EPSILON = 0.000001;\n\n// Try to get the exact pixel of the lut map image\nvec3 lutColor(int texPosX, int texPosY) {\n    return texture2D(u_lookupTable, (0.5 / u_resolution) + vec2(float(texPosX), float(texPosY)) / u_resolution).rgb;\n}\n\nvec3 bilinearInterpolate(vec3 cRfGf, vec3 cRfGc, vec3 cRcGf, vec3 cRcGc, float redFract, float greenFract) {\n    return mix(mix(cRfGf, cRcGf, redFract), mix(cRfGc, cRcGc, redFract), greenFract);\n}\n\nvoid main() {\n    vec4 inputColor = clamp(texture2D(u_image, v_texCoord.xy), 0.0, 1.0);\n\n    vec3 sourceColor = vec3(inputColor.rgb / max(inputColor.a, EPSILON)); \n\n    vec3 ranges = vec3(\n        floor(u_resolution / u_horizontalTileCount - 1.0),\n        floor(u_resolution / u_verticalTileCount - 1.0),\n        floor(u_horizontalTileCount * u_horizontalTileCount - 1.0)\n    );\n    \n    vec3 tmp = sourceColor * ranges;\n    ivec3 floors = ivec3(tmp);\n    ivec3 ceils = ivec3(ceil(tmp));\n    vec3 fracts = fract(tmp);\n\n    // Map tile index to tile pixel pos.\n    ivec2 pixelsPerTile = ivec2(\n        u_resolution / u_horizontalTileCount, \n        u_resolution / u_verticalTileCount\n      );\n\n    ivec2 tileFloor; // Blue tile index\n    tileFloor.y = floors.z / int(u_horizontalTileCount);\n    tileFloor.x = (floors.z - (tileFloor.y * int(u_horizontalTileCount)));\n\n    ivec2 tileCeil; // Blue tile index\n    tileCeil.y = ceils.z / int(u_horizontalTileCount);\n    tileCeil.x = (ceils.z - (tileCeil.y * int(u_horizontalTileCount)));\n    \n    tileFloor *= pixelsPerTile;\n    tileCeil *= pixelsPerTile; \n    \n    \n    // Interpolate between red and green\n    vec3 lutColorFB = bilinearInterpolate(\n        lutColor(tileFloor.x + floors.x, tileFloor.y + floors.y),\n        lutColor(tileFloor.x + floors.x, tileFloor.y + ceils.y),\n        lutColor(tileFloor.x + ceils.x,  tileFloor.y + floors.y),\n        lutColor(tileFloor.x + ceils.x,  tileFloor.y + ceils.y),\n        fracts.x, fracts.y\n    );\n    vec3 lutColorCB = bilinearInterpolate(\n        lutColor(tileCeil.x + floors.x, tileCeil.y + floors.y),\n        lutColor(tileCeil.x + floors.x, tileCeil.y + ceils.y),\n        lutColor(tileCeil.x + ceils.x,  tileCeil.y + floors.y),\n        lutColor(tileCeil.x + ceils.x,  tileCeil.y + ceils.y),\n        fracts.x, fracts.y\n    );\n\n    // Interpolate between the blue values\n    vec3 interpolation = mix(lutColorFB, lutColorCB, fracts.z);\n\n    // Round Color Values to prevent that for ex. 254.999999 is cutting to 254 instead of 255;\n    interpolation = clamp(floor(interpolation * 255. + .5) / 255., 0.0, 1.0);\n\n    gl_FragColor = vec4(interpolation.rgb * inputColor.a, inputColor.a);\n}\n";

// engine/sdk/operations/filter-operation/filters/primitives/3d-lookup-table-image.js
const {Vector2: Vector28, Vector3: Vector33} = math_exports;
const TEXTURE_GL_UNIT2 = 3;
class ThreeDLookupTableImageFilter extends engine_default.Filter {
  constructor() {
    super();
    this._precomputeQuads();
    this._fragmentSource = d_lookup_table_image_default;
  }
  _precomputeQuads() {
    this._quads = [];
    for (let i = 0; i < 256; i++) {
      const blueColor = i / 255 * 63;
      const quad2 = new Vector28();
      quad2.y = (blueColor | 0) * 0.125 | 0;
      quad2.x = (blueColor | 0) - quad2.y * 8;
      this._quads.push(quad2);
    }
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const {
      resolution,
      horizontalTileCount,
      verticalTileCount
    } = this._options;
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const lutImage = this._options.lookupTableImage;
    const lutCanvas = this._createImageCanvas(lutImage);
    const lutContext = lutCanvas.getContext("2d");
    let lutImageDimensions = {width: 128, height: 128};
    if (resolution) {
      lutImageDimensions = {width: resolution, height: resolution};
    } else if (lutImage.width && lutImage.height) {
      lutImageDimensions = {width: lutImage.width, height: lutImage.height};
    }
    const inputImageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const lutImageData = lutContext.getImageData(0, 0, lutImageDimensions.width, lutImageDimensions.height);
    const ranges = new Vector33(lutImageDimensions.width / horizontalTileCount - 1 | 0, lutImageDimensions.height / verticalTileCount - 1 | 0, horizontalTileCount * verticalTileCount - 1 | 0);
    const inputColor = new color_default();
    const outputColor = new color_default();
    const lutColorFB = new color_default();
    const lutColorCB = new color_default();
    const cRfGf = new color_default();
    const cRfGc = new color_default();
    const cRcGf = new color_default();
    const cRcGc = new color_default();
    const tileFloor = new Vector28();
    const tileCeil = new Vector28();
    const mix = (target, x, y, a) => {
      target.r = x.r * (1 - a) + y.r * a;
      target.g = x.g * (1 - a) + y.g * a;
      target.b = x.b * (1 - a) + y.b * a;
    };
    const lookup = (target, x, y) => {
      x = 0.5 + x | 0;
      y = 0.5 + y | 0;
      const index = (y * lutImageDimensions.width + x) * 4;
      target.r = lutImageData.data[index] / 255;
      target.g = lutImageData.data[index + 1] / 255;
      target.b = lutImageData.data[index + 2] / 255;
      target.a = lutImageData.data[index + 3] / 255;
    };
    const interpolateTempA = new color_default();
    const interpolateTempB = new color_default();
    const bilinearInterpolate = (target, cRfGf2, cRfGc2, cRcGf2, cRcGc2, redFract, greenFract) => {
      mix(interpolateTempA, cRfGf2, cRcGf2, redFract);
      mix(interpolateTempB, cRfGc2, cRcGc2, redFract);
      mix(target, interpolateTempA, interpolateTempB, greenFract);
    };
    const pixelsPerTile = new Vector28(lutImageDimensions.width, lutImageDimensions.height).divide(horizontalTileCount, verticalTileCount).floor();
    for (let index = 0; index < canvas9.width * canvas9.height * 4; index += 4) {
      inputColor.set(inputImageData.data[index] / 255, inputImageData.data[index + 1] / 255, inputImageData.data[index + 2] / 255, inputImageData.data[index + 3] / 255);
      const tmp = new Vector33(inputColor.r * ranges.x, inputColor.g * ranges.y, inputColor.b * ranges.z);
      const floors = tmp.clone().floor().toInt();
      const ceils = tmp.clone().ceil().toInt();
      const fracts = tmp.clone().fract();
      tileFloor.y = floors.z / horizontalTileCount | 0;
      tileFloor.x = floors.z - tileFloor.y * horizontalTileCount | 0;
      tileCeil.y = ceils.z / horizontalTileCount | 0;
      tileCeil.x = ceils.z - tileCeil.y * horizontalTileCount | 0;
      tileFloor.multiply(pixelsPerTile);
      tileCeil.multiply(pixelsPerTile);
      lookup(cRfGf, tileFloor.x + floors.x, tileFloor.y + floors.y);
      lookup(cRfGc, tileFloor.x + floors.x, tileFloor.y + ceils.y);
      lookup(cRcGf, tileFloor.x + ceils.x, tileFloor.y + floors.y);
      lookup(cRcGc, tileFloor.x + ceils.x, tileFloor.y + ceils.y);
      bilinearInterpolate(lutColorFB, cRfGf, cRfGc, cRcGf, cRcGc, fracts.x, fracts.y);
      lookup(cRfGf, tileCeil.x + floors.x, tileCeil.y + floors.y);
      lookup(cRfGc, tileCeil.x + floors.x, tileCeil.y + ceils.y);
      lookup(cRcGf, tileCeil.x + ceils.x, tileCeil.y + floors.y);
      lookup(cRcGc, tileCeil.x + ceils.x, tileCeil.y + ceils.y);
      bilinearInterpolate(lutColorCB, cRfGf, cRfGc, cRcGf, cRcGc, fracts.x, fracts.y);
      mix(outputColor, lutColorFB, lutColorCB, fracts.z);
      inputImageData.data[index] = Math.ceil(outputColor.r * 255);
      inputImageData.data[index + 1] = Math.ceil(outputColor.g * 255);
      inputImageData.data[index + 2] = Math.ceil(outputColor.b * 255);
    }
    outputContext.putImageData(inputImageData, 0, 0);
  }
  _createImageCanvas(image5) {
    const canvas9 = utils_default.createCanvas();
    canvas9.width = image5.width;
    canvas9.height = image5.height;
    const context = canvas9.getContext("2d");
    context.drawImage(image5, 0, 0);
    return canvas9;
  }
}
ThreeDLookupTableImageFilter.prototype.availableOptions = {
  lookupTable: {
    type: OptionType.NUMBER,
    default: TEXTURE_GL_UNIT2,
    uniformType: UniformType.INT
  },
  lookupTableImage: {type: OptionType.IMAGE, uniformType: null},
  resolution: {type: OptionType.NUMBER, uniformType: UniformType.FLOAT},
  horizontalTileCount: {
    type: OptionType.NUMBER,
    default: 5,
    uniformType: UniformType.FLOAT
  },
  verticalTileCount: {
    type: OptionType.NUMBER,
    default: 5,
    uniformType: UniformType.FLOAT
  }
};
class LookupTableImage2 extends primitive_default {
  constructor(...args) {
    super(...args);
    this._filter = new ThreeDLookupTableImageFilter();
    this._textures = {};
  }
  update(sdk14) {
    const renderer = sdk14.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      this._updateWebGLTexture(sdk14);
    } else if (renderer.isOfType(RendererType.CANVAS)) {
      this._filter.setLookupTableImage(this._options.image);
    }
    const {
      resolution,
      verticalTileCount,
      horizontalTileCount,
      image: image5
    } = this._options;
    this._filter.set({
      resolution: resolution || image5.width,
      verticalTileCount,
      horizontalTileCount
    });
  }
  _updateWebGLTexture(sdk14) {
    const renderer = sdk14.getRenderer();
    const {id} = renderer;
    if (!this._textures[id]) {
      this._textures[id] = new engine_default.BaseTexture();
    }
    const texture5 = this._textures[id];
    texture5.setSource(this._options.image);
    texture5.setGLUnit(TEXTURE_GL_UNIT2);
    texture5.setMinFilter(engine_default.BaseTexture.NearestFilter);
    renderer.updateTexture(texture5);
  }
  dispose() {
    super.dispose();
    for (const id in this._textures) {
      delete this._textures[id];
    }
  }
}
LookupTableImage2.prototype.availableOptions = {
  image: {type: OptionType.IMAGE},
  resolution: {type: OptionType.NUMBER},
  horizontalTileCount: {type: OptionType.NUMBER, default: 5},
  verticalTileCount: {type: OptionType.NUMBER, default: 5}
};
var d_lookup_table_image_default2 = LookupTableImage2;

// engine/sdk/operations/filter-operation/filters/primitives/index.js
const primitives_exports = {};
__export(primitives_exports, {
  Brightness: () => brightness_default2,
  ColorMatrixPrimitive: () => color_matrix_default3,
  Contrast: () => contrast_default2,
  Desaturation: () => desaturation_default2,
  DuoTone: () => duotone_default2,
  Gamma: () => gamma_default2,
  Glow: () => glow_default2,
  Gobblin: () => gobblin_default2,
  Grayscale: () => grayscale_default2,
  LookupTable: () => lookup_table_default2,
  LookupTableImage: () => lookup_table_image_default2,
  Saturation: () => saturation_default2,
  SoftColorOverlay: () => soft_color_overlay_default2,
  ThreeDLookupTableImage: () => d_lookup_table_image_default2,
  ToneCurve: () => tone_curve_default,
  X400: () => x400_default2
});

// engine/sdk/operations/filter-operation/filters/identity-filter.js
class IdentityFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new brightness_default2({
      brightness: 0
    }));
  }
  render(sdk14, inputTexture, outputTexture) {
    if (this._stack.isEmpty()) {
      this._stack.push(new brightness_default2({
        brightness: 0
      }));
    }
    return super.render(sdk14, inputTexture, outputTexture);
  }
}
IdentityFilter.isIdentity = true;
IdentityFilter.identifier = "identity";
var identity_filter_default = IdentityFilter;

// engine/sdk/operations/filter-operation/filters/a15-filter.js
class A15Filter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new contrast_default2({
      contrast: 0.63
    }));
    this._stack.push(new brightness_default2({
      brightness: 0.12
    }));
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 38],
          [94, 94],
          [148, 142],
          [175, 187],
          [255, 255]
        ],
        green: [
          [0, 0],
          [77, 53],
          [171, 190],
          [255, 255]
        ],
        blue: [
          [0, 10],
          [48, 85],
          [174, 228],
          [255, 255]
        ]
      }
    }));
  }
}
A15Filter.identifier = "a15";
var a15_filter_default = A15Filter;

// engine/sdk/operations/filter-operation/filters/breeze-filter.js
class BreezeFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new desaturation_default2({
      desaturation: 0.5
    }));
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [170, 170],
          [212, 219],
          [234, 242],
          [255, 255]
        ],
        green: [
          [0, 0],
          [170, 168],
          [234, 231],
          [255, 255]
        ],
        blue: [
          [0, 0],
          [170, 170],
          [212, 208],
          [255, 255]
        ]
      }
    }));
  }
}
BreezeFilter.identifier = "breeze";
var breeze_filter_default = BreezeFilter;

// engine/sdk/operations/filter-operation/filters/bw-filter.js
class BWFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new grayscale_default2());
  }
}
BWFilter.identifier = "bw";
var bw_filter_default = BWFilter;

// engine/sdk/operations/filter-operation/filters/bwhard-filter.js
class BWHardFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new grayscale_default2());
    this._stack.push(new contrast_default2({
      contrast: 1.5
    }));
  }
}
BWHardFilter.identifier = "bwhard";
var bwhard_filter_default = BWHardFilter;

// engine/sdk/operations/filter-operation/filters/celsius-filter.js
class CelsiusFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 69],
          [55, 110],
          [202, 230],
          [255, 255]
        ],
        green: [
          [0, 44],
          [89, 93],
          [185, 141],
          [255, 189]
        ],
        blue: [
          [0, 76],
          [39, 82],
          [218, 138],
          [255, 171]
        ]
      }
    }));
  }
}
CelsiusFilter.identifier = "celsius";
var celsius_filter_default = CelsiusFilter;

// engine/sdk/operations/filter-operation/filters/chest-filter.js
class ChestFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [44, 44],
          [124, 143],
          [221, 204],
          [255, 255]
        ],
        green: [
          [0, 0],
          [130, 127],
          [213, 199],
          [255, 255]
        ],
        blue: [
          [0, 0],
          [51, 52],
          [219, 204],
          [255, 255]
        ]
      }
    }));
  }
}
ChestFilter.identifier = "chest";
var chest_filter_default = ChestFilter;

// engine/sdk/operations/filter-operation/filters/duotone-filter.js
class DuoToneFilter2 extends filter_default2 {
  constructor(...args) {
    super(...args, {
      intensity: {
        type: OptionType.NUMBER,
        default: 0.5,
        required: true,
        setter(intensity) {
          if (this._filterPrimitive) {
            this._filterPrimitive.setIntensity(intensity);
            this._stack.setIntensity(1);
          }
          this._dirty = true;
          return intensity;
        }
      }
    });
    this._filterPrimitive = new duotone_default2({
      lightColor: this._options.lightColor || color_default.WHITE,
      darkColor: this._options.darkColor || color_default.BLACK,
      intensity: this._options.intensity || 0.5
    });
    this._stack.push(this._filterPrimitive);
  }
}
DuoToneFilter2.prototype.availableOptions = {
  lightColor: {
    type: OptionType.COLOR,
    default: color_default.WHITE,
    required: true,
    setter(color6) {
      if (this._filterPrimitive) {
        this._filterPrimitive.setLightColor(color6);
      }
      this.setDirty && this.setDirty(true);
      return color6;
    }
  },
  darkColor: {
    type: OptionType.COLOR,
    default: color_default.BLACK,
    required: true,
    setter(color6) {
      if (this._filterPrimitive) {
        this._filterPrimitive.setDarkColor(color6);
      }
      this.setDirty && this.setDirty(true);
      return color6;
    }
  },
  intensity: {
    type: OptionType.NUMBER,
    default: 0.5,
    required: true
  }
};
DuoToneFilter2.identifier = "duotone";
var duotone_filter_default = DuoToneFilter2;

// engine/sdk/operations/filter-operation/filters/fixie-filter.js
class FixieFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [44, 28],
          [63, 48],
          [128, 132],
          [235, 248],
          [255, 255]
        ],
        green: [
          [0, 0],
          [20, 10],
          [60, 45],
          [190, 209],
          [211, 231],
          [255, 255]
        ],
        blue: [
          [0, 31],
          [41, 62],
          [150, 142],
          [234, 212],
          [255, 224]
        ]
      }
    }));
  }
}
FixieFilter.identifier = "fixie";
var fixie_filter_default = FixieFilter;

// engine/sdk/operations/filter-operation/filters/food-filter.js
class FoodFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new saturation_default2({
      saturation: 1.35
    }));
    this._stack.push(new contrast_default2({
      contrast: 1.1
    }));
  }
}
FoodFilter.identifier = "food";
var food_filter_default = FoodFilter;

// engine/sdk/operations/filter-operation/filters/fridge-filter.js
class FridgeFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 9],
          [21, 11],
          [45, 24],
          [255, 220]
        ],
        green: [
          [0, 12],
          [21, 21],
          [42, 42],
          [150, 150],
          [170, 173],
          [255, 210]
        ],
        blue: [
          [0, 28],
          [43, 72],
          [128, 185],
          [255, 220]
        ]
      }
    }));
  }
}
FridgeFilter.identifier = "fridge";
var fridge_filter_default = FridgeFilter;

// engine/sdk/operations/filter-operation/filters/front-filter.js
class FrontFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 65],
          [28, 67],
          [67, 113],
          [125, 183],
          [187, 217],
          [255, 229]
        ],
        green: [
          [0, 52],
          [42, 59],
          [104, 134],
          [169, 209],
          [255, 240]
        ],
        blue: [
          [0, 52],
          [65, 68],
          [93, 104],
          [150, 153],
          [255, 198]
        ]
      }
    }));
  }
}
FrontFilter.identifier = "front";
var front_filter_default = FrontFilter;

// engine/sdk/operations/filter-operation/filters/glam-filter.js
class GlamFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new contrast_default2({
      contrast: 1.1
    }));
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [94, 74],
          [181, 205],
          [255, 255]
        ],
        green: [
          [0, 0],
          [127, 127],
          [255, 255]
        ],
        blue: [
          [0, 0],
          [102, 73],
          [227, 213],
          [255, 255]
        ]
      }
    }));
  }
}
GlamFilter.identifier = "glam";
var glam_filter_default = GlamFilter;

// engine/sdk/operations/filter-operation/filters/gobblin-filter.js
class GobblinFilter2 extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new gobblin_default2());
  }
}
GobblinFilter2.identifier = "gobblin";
var gobblin_filter_default = GobblinFilter2;

// engine/sdk/operations/filter-operation/filters/k1-filter.js
class K1Filter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      controlPoints: [
        [0, 0],
        [53, 32],
        [91, 80],
        [176, 205],
        [255, 255]
      ]
    }));
    this._stack.push(new saturation_default2({
      saturation: 0.9
    }));
  }
}
K1Filter.identifier = "k1";
var k1_filter_default = K1Filter;

// engine/sdk/operations/filter-operation/filters/k2-filter.js
class K2Filter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      controlPoints: [
        [0, 0],
        [54, 33],
        [77, 82],
        [94, 103],
        [122, 126],
        [177, 193],
        [229, 232],
        [255, 255]
      ]
    }));
    this._stack.push(new soft_color_overlay_default2({
      color: new color_default(40 / 255, 40 / 255, 40 / 255)
    }));
  }
}
K2Filter.identifier = "k2";
var k2_filter_default = K2Filter;

// engine/sdk/operations/filter-operation/filters/k6-filter.js
class K6Filter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new saturation_default2({
      saturation: 0.5
    }));
  }
}
K6Filter.identifier = "k6";
var k6_filter_default = K6Filter;

// engine/sdk/operations/filter-operation/filters/kdynamic-filter.js
class KDynamicFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      controlPoints: [
        [0, 0],
        [17, 27],
        [46, 69],
        [90, 112],
        [156, 200],
        [203, 243],
        [255, 255]
      ]
    }));
    this._stack.push(new saturation_default2({
      saturation: 0.7
    }));
  }
}
KDynamicFilter.identifier = "kdynamic";
var kdynamic_filter_default = KDynamicFilter;

// engine/sdk/operations/filter-operation/filters/lenin-filter.js
class LeninFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new desaturation_default2({
      desaturation: 0.4
    }));
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 20],
          [40, 20],
          [106, 111],
          [129, 153],
          [190, 223],
          [255, 255]
        ],
        green: [
          [0, 20],
          [40, 20],
          [62, 41],
          [106, 108],
          [132, 159],
          [203, 237],
          [255, 255]
        ],
        blue: [
          [0, 40],
          [40, 40],
          [73, 60],
          [133, 160],
          [191, 297],
          [203, 237],
          [237, 239],
          [255, 255]
        ]
      }
    }));
  }
}
LeninFilter.identifier = "lenin";
var lenin_filter_default = LeninFilter;

// engine/sdk/operations/filter-operation/filters/lomo-filter.js
class LomoFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      controlPoints: [
        [0, 0],
        [87, 20],
        [131, 156],
        [183, 205],
        [255, 200]
      ]
    }));
  }
}
LomoFilter.identifier = "lomo";
var lomo_filter_default = LomoFilter;

// engine/sdk/operations/filter-operation/filters/mellow-filter.js
class MellowFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [41, 84],
          [87, 134],
          [255, 255]
        ],
        green: [
          [0, 0],
          [255, 216]
        ],
        blue: [
          [0, 0],
          [255, 131]
        ]
      }
    }));
  }
}
MellowFilter.identifier = "mellow";
var mellow_filter_default = MellowFilter;

// engine/sdk/operations/filter-operation/filters/metal-filter.js
const {ColorMatrix: ColorMatrix6} = math_exports;
class MetalFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    const matrix1 = new ColorMatrix6(0.8158218291630716, 0, 0, 0, -0.01779810181190647, 0, 0.8098360655737704, 0, 0, 0.0916393442622953, 0, 0, 0.4596336773932402, 0, 0.12760574782432707, 0, 0, 0, 1, 0);
    this._stack.push(new color_matrix_default3({
      colorMatrix: matrix1
    }));
    const gammaColor = new color_default(0.8, 0.6, 0.9);
    this._stack.push(new gamma_default2({
      gamma: gammaColor
    }));
  }
}
MetalFilter.identifier = "metal";
var metal_filter_default = MetalFilter;

// engine/sdk/operations/filter-operation/filters/morning-filter.js
class MorningFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 40],
          [255, 230]
        ],
        green: [
          [0, 10],
          [255, 225]
        ],
        blue: [
          [0, 20],
          [255, 181]
        ]
      }
    }));
    this._stack.push(new glow_default2());
  }
}
MorningFilter.identifier = "morning";
var morning_filter_default = MorningFilter;

// engine/sdk/operations/filter-operation/filters/orchid-filter.js
class OrchidFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [115, 130],
          [195, 215],
          [255, 255]
        ],
        green: [
          [0, 0],
          [148, 153],
          [172, 215],
          [255, 255]
        ],
        blue: [
          [0, 46],
          [58, 75],
          [178, 205],
          [255, 255]
        ]
      },
      textureGLUnit: 2
    }));
    this._stack.push(new tone_curve_default({
      controlPoints: [
        [0, 0],
        [117, 151],
        [189, 217],
        [255, 255]
      ],
      textureGLUnit: 3
    }));
    this._stack.push(new desaturation_default2({
      desaturation: 0.65
    }));
  }
}
OrchidFilter.identifier = "orchid";
var orchid_filter_default = OrchidFilter;

// engine/sdk/operations/filter-operation/filters/pola-filter.js
class PolaFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [94, 74],
          [181, 205],
          [255, 255]
        ],
        green: [
          [0, 0],
          [34, 34],
          [99, 76],
          [176, 190],
          [255, 255]
        ],
        blue: [
          [0, 0],
          [102, 73],
          [227, 213],
          [255, 255]
        ]
      }
    }));
    this._stack.push(new saturation_default2({
      saturation: 0.8
    }));
    this._stack.push(new contrast_default2({
      contrast: 1.5
    }));
  }
}
PolaFilter.identifier = "pola";
var pola_filter_default = PolaFilter;

// engine/sdk/operations/filter-operation/filters/pola669-filter.js
class Pola669Filter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [56, 18],
          [196, 209],
          [255, 255]
        ],
        green: [
          [0, 38],
          [71, 84],
          [255, 255]
        ],
        blue: [
          [0, 0],
          [131, 133],
          [204, 211],
          [255, 255]
        ]
      }
    }));
    this._stack.push(new saturation_default2({
      saturation: 0.8
    }));
    this._stack.push(new contrast_default2({
      contrast: 1.5
    }));
  }
}
Pola669Filter.identifier = "pola669";
var pola669_filter_default = Pola669Filter;

// engine/sdk/operations/filter-operation/filters/quozi-filter.js
class QuoziFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new desaturation_default2({
      desaturation: 0.65
    }));
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 50],
          [40, 78],
          [118, 170],
          [181, 211],
          [255, 255]
        ],
        green: [
          [0, 27],
          [28, 45],
          [109, 157],
          [157, 195],
          [179, 208],
          [206, 212],
          [255, 240]
        ],
        blue: [
          [0, 50],
          [12, 55],
          [46, 103],
          [103, 162],
          [194, 182],
          [241, 201],
          [255, 219]
        ]
      }
    }));
  }
}
QuoziFilter.identifier = "quozi";
var quozi_filter_default = QuoziFilter;

// engine/sdk/operations/filter-operation/filters/semired-filter.js
class SemiredFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 129],
          [75, 153],
          [181, 227],
          [255, 255]
        ],
        green: [
          [0, 8],
          [111, 85],
          [212, 158],
          [255, 226]
        ],
        blue: [
          [0, 5],
          [75, 22],
          [193, 90],
          [255, 229]
        ]
      }
    }));
    this._stack.push(new glow_default2());
  }
}
SemiredFilter.identifier = "semired";
var semired_filter_default = SemiredFilter;

// engine/sdk/operations/filter-operation/filters/sunny-filter.js
class SunnyFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 0],
          [62, 82],
          [141, 154],
          [255, 255]
        ],
        green: [
          [0, 39],
          [56, 96],
          [192, 176],
          [255, 255]
        ],
        blue: [
          [0, 0],
          [174, 99],
          [255, 235]
        ]
      },
      textureGLUnit: 2
    }));
    this._stack.push(new tone_curve_default({
      controlPoints: [
        [0, 0],
        [55, 20],
        [158, 191],
        [255, 255]
      ],
      textureGLUnit: 3
    }));
  }
}
SunnyFilter.identifier = "sunny";
var sunny_filter_default = SunnyFilter;

// engine/sdk/operations/filter-operation/filters/texas-filter.js
class TexasFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new tone_curve_default({
      rgbControlPoints: {
        red: [
          [0, 72],
          [89, 99],
          [176, 212],
          [255, 237]
        ],
        green: [
          [0, 49],
          [255, 192]
        ],
        blue: [
          [0, 72],
          [255, 151]
        ]
      }
    }));
  }
}
TexasFilter.identifier = "texas";
var texas_filter_default = TexasFilter;

// engine/sdk/operations/filter-operation/filters/x400-filter.js
class X400Filter2 extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._stack.push(new x400_default2());
  }
}
X400Filter2.identifier = "x400";
var x400_filter_default = X400Filter2;

// engine/sdk/operations/filter-operation/filters/lut-filter.js
class LUTFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    this._lutPrimitive = new lookup_table_image_default2({
      image: this._options.image
    });
    this._stack.push(this._lutPrimitive);
  }
}
LUTFilter.prototype.availableOptions = {
  image: {
    type: OptionType.IMAGE,
    required: true,
    setter(image5) {
      if (this._lutPrimitive) {
        this._lutPrimitive.setImage(image5);
      }
      this.setDirty(true);
      return image5;
    }
  }
};
LUTFilter.identifier = "lut";
var lut_filter_default = LUTFilter;

// engine/sdk/operations/filter-operation/filters/3d-lut-filter.js
class ThreeDLUTFilter extends filter_default2 {
  constructor(...args) {
    super(...args);
    const {
      image: image5,
      resolution,
      verticalTileCount,
      horizontalTileCount
    } = this._options;
    this._lutPrimitive = new d_lookup_table_image_default2({
      image: image5,
      resolution,
      verticalTileCount,
      horizontalTileCount
    });
    this._stack.push(this._lutPrimitive);
  }
}
ThreeDLUTFilter.prototype.availableOptions = {
  image: {
    type: OptionType.IMAGE,
    required: true,
    setter(image5) {
      if (this._lutPrimitive) {
        this._lutPrimitive.setImage(image5);
      }
      this.setDirty(true);
      return image5;
    }
  },
  resolution: {type: OptionType.NUMBER},
  horizontalTileCount: {type: OptionType.NUMBER, default: 5},
  verticalTileCount: {type: OptionType.NUMBER, default: 5}
};
ThreeDLUTFilter.identifier = "3d-lut";
var d_lut_filter_default = ThreeDLUTFilter;

// engine/sdk/operations/filter-operation/filters/index.js
const filters_exports2 = {};
__export(filters_exports2, {
  A15Filter: () => a15_filter_default,
  BWFilter: () => bw_filter_default,
  BWHardFilter: () => bwhard_filter_default,
  BreezeFilter: () => breeze_filter_default,
  CelsiusFilter: () => celsius_filter_default,
  ChestFilter: () => chest_filter_default,
  DuoToneFilter: () => duotone_filter_default,
  FixieFilter: () => fixie_filter_default,
  FoodFilter: () => food_filter_default,
  FridgeFilter: () => fridge_filter_default,
  FrontFilter: () => front_filter_default,
  GlamFilter: () => glam_filter_default,
  GobblinFilter: () => gobblin_filter_default,
  IdentityFilter: () => identity_filter_default,
  K1Filter: () => k1_filter_default,
  K2Filter: () => k2_filter_default,
  K6Filter: () => k6_filter_default,
  KDynamicFilter: () => kdynamic_filter_default,
  LUTFilter: () => lut_filter_default,
  LeninFilter: () => lenin_filter_default,
  LomoFilter: () => lomo_filter_default,
  MellowFilter: () => mellow_filter_default,
  MetalFilter: () => metal_filter_default,
  MorningFilter: () => morning_filter_default,
  OrchidFilter: () => orchid_filter_default,
  Pola669Filter: () => pola669_filter_default,
  PolaFilter: () => pola_filter_default,
  QuoziFilter: () => quozi_filter_default,
  SemiredFilter: () => semired_filter_default,
  SunnyFilter: () => sunny_filter_default,
  TexasFilter: () => texas_filter_default,
  ThreeDLUTFilter: () => d_lut_filter_default,
  X400Filter: () => x400_filter_default
});

// engine/sdk/operations/filter-operation/index.js
class FilterOperation extends operation_default {
  _render(inputTexture) {
    return this._selectedFilter.render(this._sdk, inputTexture, this._renderTexture);
  }
  render(inputTexture) {
    if (this._selectedFilter.getDirty()) {
      this.setDirty(true);
    }
    if (!this.getEnabled()) {
      this.setDirtyForRenderer(false, this._sdk.getRenderer());
      return promise_default.resolve(inputTexture);
    }
    return super.render(inputTexture);
  }
  setDirtyForRenderer(dirty, renderer) {
    super.setDirtyForRenderer(dirty, renderer);
    this._selectedFilter.setDirtyForRenderer(dirty, renderer);
  }
  disposeRenderTextures() {
    super.disposeRenderTextures();
    if (this._selectedFilter) {
      this._selectedFilter.disposeRenderTextures();
    }
  }
  dispose() {
    super.dispose();
    if (this._selectedFilter) {
      this._selectedFilter.dispose();
    }
  }
  restoreSnapshot(serializedOptions) {
    const options = __assign({}, serializedOptions);
    delete options.filter;
    if (serializedOptions.filter) {
      const FilterConstructor = serializedOptions.filter.constructor;
      if (FilterConstructor.identifier === "3d-lut") {
        this.setFilter(new FilterConstructor({
          image: serializedOptions.filter.getImage(),
          resolution: serializedOptions.filter.getResolution(),
          horizontalTileCount: serializedOptions.filter.getHorizontalTileCount(),
          verticalTileCount: serializedOptions.filter.getVerticalTileCount()
        }));
      } else if (FilterConstructor.identifier === "duotone") {
        this.setFilter(new FilterConstructor({
          lightColor: serializedOptions.filter.getLightColor(),
          darkColor: serializedOptions.filter.getDarkColor(),
          intensity: serializedOptions.filter.getIntensity()
        }));
      } else {
        this.setFilter(new FilterConstructor());
      }
    }
    this.set(options);
  }
  resetToDefaultFilterIntensity() {
    const filterOptions = this._selectedFilter && this._selectedFilter.availableOptions;
    const defaultIntensity = filterOptions && filterOptions.intensity.default;
    this.setIntensity(defaultIntensity || 1);
  }
}
FilterOperation.identifier = "filter";
FilterOperation.prototype.availableOptions = {
  identifier: {
    type: OptionType.STRING,
    default: "identity"
  },
  intensity: {
    type: OptionType.NUMBER,
    default: 1,
    setter(intensity) {
      this._selectedFilter && this._selectedFilter.setIntensity(intensity);
      return intensity;
    }
  },
  filter: {
    type: OptionType.OBJECT,
    default: new identity_filter_default(),
    setter(Filter3) {
      if (this._selectedFilter) {
        this._selectedFilter.dispose();
        this._selectedFilter = null;
      }
      this._selectedFilter = Filter3;
      if (typeof this._options.intensity !== "undefined") {
        this._selectedFilter.set({
          intensity: this._options.intensity
        });
      }
      return Filter3;
    }
  }
};
FilterOperation.FilterPrimitives = primitives_exports;
FilterOperation.Filters = filters_exports2;
FilterOperation.Filter = filter_default2;
exports_default.Operations.FilterOperation = FilterOperation;
var filter_operation_default = FilterOperation;

// engine/sdk/operations/flip-operation/index.js
const {Vector2: Vector29} = math_exports;
class FlipOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._flipContainer = new engine_default.Container();
  }
  _render(inputTexture) {
    const {
      outputResolution,
      flipHorizontally,
      flipVertically
    } = this._options;
    if (flipHorizontally || flipVertically) {
      const dimensions = inputTexture.getDimensions();
      if (!this._flipRenderTexture) {
        this._flipRenderTexture = new engine_default.RenderTexture(this._sdk.getRenderer(), dimensions.x, dimensions.y);
        this._flipSprite = new engine_default.Sprite(this._flipRenderTexture);
        this._flipContainer.addChild(this._flipSprite);
      } else {
        this._flipRenderTexture.resizeTo(dimensions);
      }
      const scaleX = flipHorizontally ? -1 : 1;
      const scaleY = flipVertically ? -1 : 1;
      this._flipSprite.setScale(scaleX, scaleY);
      this._flipSprite.setPivot(0, 0);
      this._flipSprite.setPosition(dimensions.x * (1 - scaleX) * 0.5, dimensions.y * (1 - scaleY) * 0.5);
      this._flipRenderTexture.clear();
      this._flipRenderTexture.render(this._container);
      this._renderTexture.render(this._flipContainer);
    } else {
      this._renderTexture.render(this._container);
    }
    return promise_default.resolve();
  }
}
FlipOperation.identifier = "flip";
FlipOperation.prototype.availableOptions = {
  flipHorizontally: {type: OptionType.BOOLEAN, default: false},
  flipVertically: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.FlipOperation = FlipOperation;
var flip_operation_default = FlipOperation;

// engine/sdk/operations/frame-operation/index.js
const {Vector2: Vector210} = math_exports;
class FrameOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._colorOverlayFilter = new engine_default.Filters.ColorOverlayFilter({
      color: this.getTintColor()
    });
    this._frameContainer = new engine_default.Container();
    this._resetSprites();
    if (this._options.frame) {
      this._createSpritesForFrame(this._options.frame);
    }
  }
  _resetSprites() {
    this._spriteGroups = {
      top: {},
      left: {},
      right: {},
      bottom: {}
    };
    this._sprites = [];
    this._repeatSprites = {
      top: [],
      left: [],
      right: [],
      bottom: []
    };
  }
  _createSpritesForFrame(frame2) {
    if (!frame2)
      return this._disposeSprites();
    const {imageGroups, layoutMode} = frame2;
    this._layoutMode = layoutMode || "horizontal-inside";
    this._disposeSprites();
    ["top", "left", "right", "bottom"].forEach((group) => {
      if (typeof imageGroups[group] === "undefined")
        return;
      ["start", "mid", "end"].forEach((part) => {
        if (typeof imageGroups[group][part] === "undefined")
          return;
        let image5 = imageGroups[group][part];
        if ("image" in image5) {
          image5 = image5.image;
        }
        const texture5 = engine_default.Texture.fromImage(image5);
        const sprite7 = new engine_default.Sprite(texture5);
        this._spriteGroups[group][part] = sprite7;
        this._sprites.push(sprite7);
        this._frameContainer.addChild(sprite7);
      });
    });
  }
  _render(inputTexture) {
    const dimensions = this._renderTexture.getDimensions();
    if (this._options.frame) {
      this._colorOverlayFilter.setColor(this.getTintColor());
      this._updateSprites(inputTexture);
    }
    if (!this._frameRenderTexture) {
      this._frameRenderTexture = new engine_default.RenderTexture(this._sdk.getRenderer(), dimensions.x, dimensions.y);
      this._frameSprite = new engine_default.Sprite(this._frameRenderTexture);
      this._container.addChild(this._frameSprite);
    } else {
      this._frameRenderTexture.resizeTo(dimensions);
    }
    this._frameSprite.setAlpha(this._options.alpha);
    if (this._options.frame && this._options.frame.tintable) {
      this._frameSprite.setFilters([this._colorOverlayFilter]);
    } else {
      this._frameSprite.setFilters([]);
    }
    this._frameRenderTexture.clear();
    this._frameRenderTexture.render(this._frameContainer);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  _updateSprites(inputTexture) {
    const dimensions = inputTexture.getDimensions();
    this._frameWidth = Math.ceil(inputTexture.getDimensions().min() * this._options.scale);
    this._updateHorizontalSpriteGroup(inputTexture, "top", 0);
    this._updateHorizontalSpriteGroup(inputTexture, "bottom", dimensions.y - this._frameWidth);
    this._updateVerticalSpriteGroup(inputTexture, "left", 0);
    this._updateVerticalSpriteGroup(inputTexture, "right", dimensions.x - this._frameWidth);
  }
  _updateHorizontalSpriteGroup(inputTexture, group, offset = 0) {
    const dimensions = inputTexture.getDimensions();
    const verticalInside = this._layoutMode === "vertical-inside";
    const startSprite = this._spriteGroups[group].start;
    const midSprite = this._spriteGroups[group].mid;
    const endSprite = this._spriteGroups[group].end;
    let startWidth = 0;
    let endWidth = 0;
    let textureDimensions;
    let textureRatio;
    if (startSprite) {
      textureDimensions = startSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;
      startWidth = Math.floor(this._frameWidth / textureRatio);
      const startPosition = new Vector210(0, offset);
      startPosition.x = verticalInside ? this._frameWidth : 0;
      startSprite.setPosition(startPosition);
      startSprite.setHeight(this._frameWidth);
      startSprite.setWidth(startWidth);
    }
    if (endSprite) {
      textureDimensions = endSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;
      endWidth = Math.floor(this._frameWidth * textureRatio);
      const endPosition = new Vector210(dimensions.x - endWidth, offset);
      endPosition.x -= verticalInside ? this._frameWidth : 0;
      endSprite.setPosition(endPosition);
      endSprite.setHeight(this._frameWidth);
      endSprite.setWidth(endWidth);
    }
    if (midSprite) {
      textureDimensions = midSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;
      const midPosition = new Vector210(startWidth, offset);
      let midWidth = dimensions.x - startWidth - endWidth;
      if (verticalInside) {
        midPosition.x += this._frameWidth;
        midWidth -= this._frameWidth * 2;
      }
      midSprite.setPosition(midPosition);
      midSprite.setWidth(midWidth);
      midSprite.setHeight(this._frameWidth);
      if (!process.env.REACT_APP_BROWSER) {
        midSprite._canvasSmoothingEnabled = false;
      }
      if (this._options.frame.imageGroups[group].mid.mode === "repeat") {
        const defaultSpriteWidth = this._frameWidth / textureRatio;
        const requiredRepeatSprites = Math.ceil(midWidth / defaultSpriteWidth);
        let consumedWidth = 0;
        if (requiredRepeatSprites !== -1) {
          let spriteWidth = Math.round(midWidth / requiredRepeatSprites);
          midSprite.setWidth(spriteWidth);
          consumedWidth += spriteWidth;
          this._ensureRepeatSpritesExist(requiredRepeatSprites - 1, group, midSprite);
          for (let i = 0; i < requiredRepeatSprites - 1; i++) {
            spriteWidth = Math.round((midWidth - consumedWidth) / (requiredRepeatSprites - i - 1));
            const sprite7 = this._repeatSprites[group][i];
            const spritePosition = midPosition.clone().add(consumedWidth, 0).floor();
            sprite7.setPosition(spritePosition);
            sprite7.setWidth(spriteWidth);
            sprite7.setHeight(this._frameWidth);
            consumedWidth += spriteWidth;
          }
        }
      }
    }
  }
  _ensureRepeatSpritesExist(requiredSpritesCount, group, sourceSprite) {
    sourceSprite.getTexture().setMaxListeners(requiredSpritesCount + 1);
    const existingSpritesCount = this._repeatSprites[group].length;
    if (requiredSpritesCount > existingSpritesCount) {
      const missingRepeatSprites = requiredSpritesCount - existingSpritesCount;
      for (let i = 0; i < missingRepeatSprites; i++) {
        const sprite7 = new engine_default.Sprite(sourceSprite.getTexture());
        this._repeatSprites[group].push(sprite7);
        this._frameContainer.addChild(sprite7);
        this._sprites.push(sprite7);
      }
    } else if (requiredSpritesCount < existingSpritesCount) {
      const spareRepeatSprites = this._repeatSprites[group].splice(requiredSpritesCount);
      spareRepeatSprites.forEach((sprite7) => {
        const index = this._sprites.indexOf(sprite7);
        if (index === -1)
          return;
        this._sprites.splice(index, 1);
        this._frameContainer.removeChild(sprite7);
        sprite7.dispose();
      });
    }
  }
  _updateVerticalSpriteGroup(inputTexture, group, offset = 0) {
    const dimensions = inputTexture.getDimensions();
    const horizontalInside = this._layoutMode === "horizontal-inside";
    const startSprite = this._spriteGroups[group].start;
    const midSprite = this._spriteGroups[group].mid;
    const endSprite = this._spriteGroups[group].end;
    let startHeight = 0;
    let endHeight = 0;
    let textureDimensions;
    let textureRatio;
    if (startSprite) {
      textureDimensions = startSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;
      startHeight = Math.floor(this._frameWidth * textureRatio);
      const startPosition = new Vector210(offset, 0);
      startPosition.y = horizontalInside ? this._frameWidth : 0;
      startSprite.setPosition(startPosition);
      startSprite.setWidth(this._frameWidth);
      startSprite.setHeight(startHeight);
    }
    if (endSprite) {
      textureDimensions = endSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;
      endHeight = Math.floor(this._frameWidth * textureRatio);
      const endPosition = new Vector210(offset, dimensions.y - endHeight);
      endPosition.y -= horizontalInside ? this._frameWidth : 0;
      endSprite.setPosition(endPosition);
      endSprite.setWidth(this._frameWidth);
      endSprite.setHeight(endHeight);
    }
    if (midSprite) {
      textureDimensions = midSprite.getTexture().getDimensions();
      textureRatio = textureDimensions.y / textureDimensions.x;
      const midPosition = new Vector210(offset, startHeight);
      let midHeight = dimensions.y - startHeight - endHeight;
      if (horizontalInside) {
        midPosition.y += this._frameWidth;
        midHeight -= this._frameWidth * 2;
      }
      midSprite.setPosition(midPosition);
      midSprite.setHeight(midHeight);
      midSprite.setWidth(this._frameWidth);
      if (!process.env.REACT_APP_BROWSER) {
        midSprite._canvasSmoothingEnabled = false;
      }
      if (this._options.frame.imageGroups[group].mid.mode === "repeat") {
        const defaultSpriteHeight = this._frameWidth * textureRatio;
        const requiredRepeatSprites = Math.ceil(midHeight / defaultSpriteHeight);
        let consumedHeight = 0;
        if (requiredRepeatSprites !== -1) {
          let spriteHeight = Math.round(midHeight / requiredRepeatSprites);
          midSprite.setHeight(spriteHeight);
          consumedHeight += spriteHeight;
          this._ensureRepeatSpritesExist(requiredRepeatSprites - 1, group, midSprite);
          for (let i = 0; i < requiredRepeatSprites - 1; i++) {
            spriteHeight = Math.round((midHeight - consumedHeight) / (requiredRepeatSprites - i - 1));
            const sprite7 = this._repeatSprites[group][i];
            const spritePosition = midPosition.clone().add(0, consumedHeight).floor();
            sprite7.setPosition(spritePosition);
            sprite7.setHeight(spriteHeight);
            sprite7.setWidth(this._frameWidth);
            consumedHeight += spriteHeight;
          }
        }
      }
    }
  }
  _disposeSprites() {
    this._sprites.forEach((sprite7) => {
      this._frameContainer.removeChild(sprite7);
      sprite7.getTexture().dispose();
      sprite7.dispose();
    });
    this._resetSprites();
  }
  dispose() {
    super.dispose();
    this._disposeSprites();
    if (this._colorOverlayFilter)
      this._colorOverlayFilter.dispose();
    if (this._frameRenderTexture)
      this._frameRenderTexture.dispose();
  }
  static validateFrame(frame2) {
    if (!frame2)
      return;
    const {imageGroups, layoutMode} = frame2;
    if (typeof frame2.identifier !== "string") {
      throw new Error("Frame needs a property `identifier` of type String.");
    }
    if (typeof frame2.imageGroups !== "object") {
      throw new Error("Frame needs a property `imageGroups` of type Object.");
    }
    const validateImageGroup = (group) => {
      const {start, end, mid} = imageGroups[group];
      if (typeof imageGroups[group] === "undefined")
        return;
      if (typeof imageGroups[group] !== "object") {
        throw new Error(`Frame: \`imageGroups.${group}\` needs to be of type Object.`);
      }
      if (typeof start !== "undefined" && !(start instanceof image_default || typeof HTMLImageElement !== "undefined" && start instanceof HTMLImageElement)) {
        throw new Error(`Frame: \`imageGroups.${group}.start\` needs to be of type Image.`);
      }
      if (typeof mid !== "undefined" && !(start instanceof image_default || typeof HTMLImageElement !== "undefined" && start instanceof HTMLImageElement) && typeof mid !== "object") {
        throw new Error(`Frame: \`imageGroups.${group}.mid\` needs to be of type Image or Object.`);
      }
      if (typeof end !== "undefined" && !(end instanceof image_default || typeof HTMLImageElement !== "undefined" && end instanceof HTMLImageElement)) {
        throw new Error(`Frame: \`imageGroups.${group}.end\` needs to be of type Image.`);
      }
    };
    if (typeof layoutMode !== "undefined" && ["vertical-inside", "horizontal-inside"].indexOf(layoutMode) === -1) {
      throw new Error(`Frame: \`layoutMode\` must be one of vertical-inside, horizontal-inside`);
    }
    if (typeof tintable !== "undefined" && typeof tintable !== "boolean") {
      throw new Error(`Frame: \`tintable\` needs to be of type Boolean.`);
    }
    validateImageGroup("top");
    validateImageGroup("left");
    validateImageGroup("right");
    validateImageGroup("bottom");
  }
}
FrameOperation.identifier = "frame";
FrameOperation.prototype.availableOptions = {
  frame: {
    type: OptionType.OBJECT,
    validation: FrameOperation.validateFrame,
    setter(frame2, initial) {
      if (!initial) {
        this._createSpritesForFrame(frame2);
      }
      return frame2;
    },
    default: null
  },
  alpha: {type: OptionType.NUMBER, default: 1},
  tintColor: {type: OptionType.COLOR, default: new color_default(1, 1, 1, 0)},
  scale: {type: OptionType.NUMBER, default: 0.1}
};
exports_default.Operations.FrameOperation = FrameOperation;
var frame_operation_default = FrameOperation;

// engine/sdk/operations/license-watermark-operation/watermark.js
const watermark = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDA4NDFGODc4N0ZCMTFFOEFCRjZEQ0E4MkRCQzYyNjIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDA4NDFGODg4N0ZCMTFFOEFCRjZEQ0E4MkRCQzYyNjIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowMDg0MUY4NTg3RkIxMUU4QUJGNkRDQTgyREJDNjI2MiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDowMDg0MUY4Njg3RkIxMUU4QUJGNkRDQTgyREJDNjI2MiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Ppk6b2UAAAASUExURQAAAP///8zMzDMzM2ZmZpmZmer1GSkAABunSURBVHja7F3rgt6mDlzr8v6v3O5ukqaJbQSS0GDjn+c0+9lomBkJEB8fD3tEPvbz5ocO3oPw6vgfx+aA9z56HBsBL37k+H50D8UrHz6OjYAd/42ANxvAjYC3G8BfD+0ReacB3AjYBmAj4IXPcfJQVVFQaFuQSgNYiwBW2uxTbADrEMDyA4p7RaLUABYhgP8D4i5H1xrAAgT8mvzbgWIYgLkI4D9VaGtAuQGYiAD5G4NbAxAEYAoCvmz/rkJAVQAmxoKvCGhrAIABSEeAXP/81oDiDDAfASx36NvFQAgDkIcA1kLh2U+HAKTMx1b4twlAyADTEMBUgLn9DAtAcDyYCo3HfroywAQEiFl2tgbgCEAYAuzh34lgUQaokheRnvBvE1BjAOiuNiATw79NQE0GyB9JCOgN/zYBJQIgd/+nIybcH/5tAgoEQO/hMYqAofBvDZgvANTOEAYWh1mPYwNgCQFgQ45Is8K/TcB0ARBTlaAPAY7wbxNQJgD3oevIz+3WX8+YYmtAlQDEIMAcfhI+p6WtAVUCcI8AEzWzPfyXvLQBME8A1F4ssiDA7P1Ibn5tV4PnCUBPubA9NcUafr79N9sEFArALY3flwOs4q/ceDPaGhD+aJev44Fk0Mr+ym2+2QCYIwDUSxg38iyD4T8FwK4EzHGA/BGFAKP3V7ZBZ5uAUgG4n9EyXPhTtmJtA2CGA6RBR89j5k+5g562CZggADJEG395dHaGf5uAIgfYrraoJRUQb/i3CUh/OkpAtoKQ9k1/5W6F2gBId4AmkqWGEZTOqp/domwTkOwA1fFvf8bHMv1NRb3tAqFKAFYEGKY/yShH7fWgXAcovn/+ObMNub+Mk9Q2AakOkLwAOgK83wZAnQNk91+IEf9tApAdYCsVCBD/XQoqcYAU8UdC9/XKdoHfbCs8gwAk5K9EiP82AX9NNSJhxiKATiNIEgPUF5qAX8NAGgMCiTp4I3nsv13gxTwg8usBhTVg0Azvf//35eUACGACCTx6SVnsf/mqLzQB5wEbBgEHUrTJCGog9l8JALo9QxVD2xQYoqjpf/7tGwBOIuDgo9eS2ttpu0CDzvYRgUaHSdOm//kffx0ALDJL5iJLNAHcAtRfttu1QHPBzSgGGt96gbOm/3aBvdWWthhwRvcdyWvtuAHQu+7awACl9F7RvKY+2wX2L7rdYCCFAD6MXWY2ACYB4AYDlDRROU0EZBeDx9oqnmIgiwDMjYZCoPWyNICP4cdy5D6KUTVJBLYLdADgz/oAZ3n1a6LShL+7ATAqBZrZf5OTROD1LlAO9/OjIpNKAGki8HoA0BHwfElBKgF8jJ4232nADAB80UAuAWSJwOvTgCgA5BXrGmql4QCglwOAhKJQoTPAKuED8B86fnvkt+f3//15ScDn97MQHAEMNh0acYGi9P1YtO/7UZUl8XAtgcxKWATgPnM8QwO/0SDLYIFvx9OJgfghoPjf0TQD9BMJqwHgj25c42KgU17X9UMBNGcGwjJ1II4aJZ7zvqO/xHFm14oDQBhYd0UOYCAnm4o5dzg7+L/DAAsDHZXQXgzwLM3q9IFTaH/6uGRkwT4M0DzO6vixoPzWQwEfCwOgBwNpFXXHr5VH/wEA+DDe0ZD3naOHT4uZH3OpabASbiBSmQlaw+8JRPThLMD4UkgLAzz1pVuvDRN+tIuJXIuhd5yauqTae/wIJ/xwFoCd3H05tDz5rW9GFin8cJsN2B26cxpIxrnYKQAr/HD7zSTgDaXA6lopgMHC/0gAaMFnim1sFS38cLuNAhokcInQWXRH4KY/3n7DgE3RFQpgoQD2Tf9f+3z+t//r/4+IdmwdgtxxHAAAquE5akwvGY770HaeH4jQFhoYHgC9weOie9hPA+yY/t+r9THx+cLCKRDgNhwHAKAK5nRDsNIZ+5yNGitcSeMHgFbBXK5toHbEXvM26axwHYEfAFQGc7rgHnPuTzK9XsmPA0DhV8q5DbTRf+bMv34/OAvgPxdV+JV8utamtujXMJQ+DwCVXzmY6CuX4ZMXAIC6ASCFb1+t+68DQO1XDnS4mze2uoAFcG8HKDY6ghv+Re6kcwOg9isZN/yLXEjl3g9S3GGnQwNmG/A1bqPxAqC6vYZZA+ZvxaQNACAKEISRRWw+5QVA+X0LBJT4N7mJnweA8iZ7Ajn9V0kCHwAAhpz+H8tcTC7hAKD6gUYY9VVuJXYCAKDHnmKew1pEARIAoABTDWDxbYWVwBwACBAA6kR3kSTQDQCpFzqGPIari1gAbwQB7t1UyBMYtIgF8AKgvtc+Qx7AWEYB4gGAkgUK2rCC3kKxOgAEswvHMgqwPAAwT+CuowCrA0AxD+CuowCLA4Ax47+QAiwOAELk/6UUYG0ABDYOf2cV6MO9HFwLAALtwLGQAiwNAFQCWEkBVgYAAxaAllOAlQGgmA5wLQVYGACwBLCUAngX9AsBQKgEsJQCrAsAVAe4mAJ493TVLQejpoBFXROrAFC2IWQpAgBWAO+23qotYbAO8LxtzQfw41NxLgIAbAq4mgIsCgBcAlhNARIAIEWjjEEADGpNJwJgwufiOsDFigABmXxJIQA2BTzdogZtAd2ZfAUAzveBQYymLKcArUz+99sRQAAA7ADXs4CnmP3tGgz6+woN+r5CI4ZAnpUCrlcE+BhrtvnzYo1/cTC/FMjA93DoakWAz/tfD9cznwGAHeDHsZACfM7ejquOeloxvzUFXMYCfoX+SHto+iRDGWV8C3h1k9E6AAB2gOAW8Cv2x5Rn9r3xKD4L1gJOjH02AGgxAqhXAD6/2zv1yUM9sgO8UCcpfLvJE3/CjEROAT+gGlUmG/0iAEATgMD0Kq1g/SkhgXaA9x1L50GAEW5MT4oJcgrYbFo9AwJVmj+JAhYmgAkQqOf9dF+GnALa1tT00byfTQHQDtB4hWXKtVVQUz9xYkKngOZF9WAIMGT0U6T5CQTwDQFeg/h/bglSVZHPPUKnm4Sun1c5wL5dNUFuUJOCLtcbAH/SDkt7K4FOmGIwS21aYZI1NvByG/SBaiNvAsi1AhwTehVmnw7RBB9IjyKAICtA3tAzx8xS1mwKwHaAg1PRbQWkatbPV2jkfWAOMZbpwPua9utVaYGPAvm02KkDhBD7CRyN7QDP4WnN0V06YL85O39fSmadDtsB8tXbMaXrAFVP/CkUwNAO8DwI329ng4BDB7Q98bl0HAidXBIJoAMCEjs3ZrH+JKGWZQnADoFhEiCM4GemgoydAkr7q00Q0Lifr7owK4kCsFPAJgF8h8li1sZGCokdU7h6xRTwhPYsENCoFyCo2aAJfxM7BTzHvOaQAD+cAlZ0gBeQZ00hAUJySPHTldZzgNfwNLjBfhKAooBwwX4QAVitgEa8RJlHCk4FV3SADXhqeE1AoLKk2KRdF3SALXgarID6x7xskoRyNjgBjDqetg70kQBUJhjq2lbcBybj/3QU5Qw1TQKX7lbcB2aEZzsf0GUpIE63sVNA8sGzqQMdMoDVmyZMuBWaADRl3g7+McKngKMOSBPNbt9XchgJCNZUiaFu6BSQYzZ2aJQXxKKAEPO2YjeI/iFvkoA+hwJo/t+YrHJDIy4xMoDllwNm74r9wMboqUkCsiAF+PUbeR+YBJ+FlAAZ4IdRAPI+MA4/Dd0iAYsMKBYFOBkc2QFyxjm/VjrAq1GAMxUEdoCccxi+RQLyKgoAPgp0GSj326nTCCxBATSDPkriH3EAhnxGAIwCODilgSCAy/jHoFNdCECjgOFU8GKdleufy3wtyp6IywgsQQHqnQeQD6dTjGX0GMw6DzI5rxd/ySZOYzjBKGDQy9Fy8dcJ88YEADQKGMrmZLn4R4/w3bZhHqAPAaMAehgBxM8wHfYaa1CAPIsABCf+eBTQvaazoAOMvhhOPVBDo4DuVd0FU8CvL2KM+ONRQO/x2WPVJ6otizP+eMsofT6QjuPdEFC31VCwgnCXD5Rj6ccPAfLXGuAooGdJgI7j1RAIiD/edvoOCtBj/cdjB0Pif2G80Sjg7IX4eMQzCgEOir+lcyHmkoAeD3mkNP4XA46fCvLxmGeg3RsHrjXBbaixpYJ0POhRros/3pY6kw+U41lPwDmo4bgtmQqef720n3N+kZyn455WLYs/3rZ6AwWMZ6+T4W6/q9d3ut/F23AHa5q2xPPG0ysfZgw43t+p27qED9QYzqqAu/VGqKL4412y0KAAX+JSkvbYaKAtA5QR/+VSQWfeUpT2mGiAR8s/zg9Yygd64VoGd0sHeBlL/70AFjQRuNkd5hfxOrizp+mnRNeT29oCeVDIb+Mr0x4e7veXGn9fJ9OpPjAieqWL4E0IaK/9D8GuFs6KLp6O4O/iygcPHO7Pjv8qIsAxlbzqtKcBAe2x/1HAFTQROJ/qQTlc+QrY/cFe7fiPw2CLJgIdK/4cxS/1LucMAXLMiP/VgIO1D4wCKUDl41YH1DYOofe+womAdR0tvNSEQAJqiv8E1S0UAckSgEapCcMJSFv+o00LnAhQGgF8oLSX1XsEyDEx/ldvUycCnEcAMCtgcvdlk+N/NeXq1gRy7s9FSQWbKKcjP/03vYwAU0B4qWn+Rw7tcJapU67MBkjmOMCcixtAAM99F7CbJYNeDGczZO8xJ+LZpKugFMAJ4/4BjwAteBWBpADN+OOKjgAtGfEqG8CZSgi0GVKr7V9rxMtsgGZOBaDNkAoS/8s3ITgKoKw/XqN3VGz/miNeZQRl+k6oIqwbEECV411mBClxMJAoIPaW+Iy8S6AogBP/eI3l5XL5b1kRBqIAyhz0Irnj6tFvkhDSzJBMxDMU2VXbv3J7pJM9QF3OI6jyXzwwaRRAaI63MAlXhDrkZKsmaEi/hKRU/TAIAmhiJbCWArjGfnFKP6PsYeE0AsBb/aAS2OEgIMMHMiDVXcNS5/8k0tBkpIKKmPNWpKbdfXcVZlQyaQ9tHxTBxH9OVcKUCmr4MANvhtWZcMNDQHQqaNC9MgqQeSJwb/8FSSGDU0HYlHeqCHBjmgsQQcamgibhqzsWN2nM22ePBGh+RKaCtsQX7lgcT4y/NP+b2UYgMhU0Oh+09gg0L/5s4UqIA/WZlS+0HjmhI25tPaE42UCYDzSnPnA9cubEX+1+SespgGO5D1sEdH78GwggqaYAiplcinZ7Tmrrvj5lV5SqUIwPvEgn0LqmZ/Zv7e08pyiFwYhU8BJFaF3T01r33ZX/LmLZ7HDL61DAZZzhbs+hHB94G//hytkkCPh5+uYvrHGXsibGXz3OeY4QuK3azR+Ao4CM+5yGL54w5E4zMoLUG0PgLtCa1RjFBHVL+YyESyiAfN8v4aWmVLhLSfytW0ezzYCPpxsyv+hdyiHx59Hhm00DHqvWRM+CF6nGlECNDs5aRE3FgMMbN+P7aB8YsbRrP0GQh4Fxnjb8S7RUMNCWSMyyZ8cmUkp6hn/MwB2rXaQaEv++z5OhfaS4T9aAg/nAyM1d+qT4Sx7nZvpALoz/aIdjyIfyOBch7THkf2MO9zE6wOm5d1LaI6Xxf4wOaHruneUDqTj+tuuwVyQApDbSd5wkxfF/BAQ0vNQ0zwdSefwfAIHs3BuBAm4ce4SsLQ0BmbQGk5QKOsATaWvWhQAl597ZqaBAxP9zuBZNCjk394agAHUt/z67LqDTlmGzKEBh4v8x2GkClQBW2R3Gw/Gfe9R8LQeIuSQgA++jARsA/Lnmcg5wpVSQxyelvDv+7e9HSwX7KaCRn+mrDQANglpWooBppzovf4cAnmETrMtTQNOaSeKbFXumADe3BgWMF4K/xiGCBHhaqhHHTjwObMaigDEvExokQo6/axov0TPCUQyK+R5Fjr9PyJ9BAS0j4DzSycj679VxtFSQxl6ntYdTw2kJJf7eCKL5QBl9nQYCHAmhQsffzeH6DAow9HiJFQDCiL9/bxfaQaFhCmgu1gySwHiZpS4FnMshKBTQPsyhYSOMEv8QBacFKIBd0XKQACMngEEenh9DAYY1e40YYRQDGMXeYD7QQwFtGeirCQi0AYwib7RUkFxf1SYBdo4MigGIs29gB4XE91kcd1uWQhuAwAQOTOi8b9Pcxm80g4wtAIHSDZYKipeQ2vs3TXgiaAEIVW6sJQF2f1lbBmh0iQlFAGJjBuYD1f9pAZ1/CVoAgllb8Smg89sMTV6UJ44waAq4EAVkdHqSKR57AQJAwzuHvIyBBK6tgEILQMKExVoSoJiXMZDAhRVgbAeYAE8sCpCg0pSl3ZuaLxHSBxMAmumlqA+0NHdQ4whjO0BCRFUoBYx9oYUE/rIC+i4HCGd7+PzUH0eO1x0EPB1r1ksBwSjg3+BT9L4+6oSArucAI/Sp3gfeBN83B03dHX5BgN+WAkKkgq3g+77S1unrBwT0bSlgufdlIdMBfM9n2ro8fUJgRQIIClJBKvg58e3dFzh86pxAQN+XAtb4QLZO/Cg9ctwC8NRVQNskgYh9SByGu/3BEED2GlX6Ghj3cf6cakcy86SngOkME3JDmjP0YeUOWpgAJmj01fCQMo9HXvyhD6x30LIEMMGl3zXEo08UcE/gP+d8bIc1zeM5fAKYUqprb6omEvkMLp/H/N/5/jnhKaW1XtAF7n0d4J92FGicAv6GgqllXVTwIy9r7YHAqwgA9bYsCr+13ewGUQhg2jZFekH0e9wgyirAtPV6rMbolHlTuwUC2ASQgk56+tTvgsCjukGE+8BVp74dAigEMHW3hr4l+AYIQBNAVoWK3xP8JgT4hQRQB4CK4N9DAKQKPHvDJtUYvtLZJgRMALO3bNP8ic+QLEvvJICJpQCqnvj3qAd+tVRw8stif/XNIAQwf8M+vyv2lzIrwASg838yKPQCF/tLzDMsNLPfjRIi37edBIFmH3EpSBgAnKv9uKFHt4Alp3blbDT4azf3IBDAAYBrAWvOa/Ed53xt+1I9u8VS9Wu3mCwHAFwLWNO5g32CyMsBAFYBis5ssw90jLuqZudZDAtYtUJB7wKAohJAWSv3cADoagRAqC82ZzKFA4CQASCoFrCudxv5KJHWAgCqBSxsV6dvAgCsAhQ27ZE3AQBVASrbdvGbAECYBFDauO9NAEAtApS27nwTAATTAtZ27nSWcpYCAKgC1LbvfhEAQBWguHGrs5anC60GgZaBi6/weBEAMBWgunPzewDAkEWA+t7tPhVfaEcIpgLU397wGgBAKgDA5Q1vAQCkAiDcW/0WACBWgQRgX63TBK4DAEAFEIST6m8BAKACXPVn+dgAeIUCEEavGmcpeBkAoCnAZfvK2W/lXA1cBQBoCiAwJ6vkHQAAUwDF6Van7wCAIinAXffi6W9F7wAAAa0EC9ThWueC/iIAYCAFUKiOtd6THYsAAEcBms3rdQPgyQrQbstG5S8kzqkFCACUJNB0d8Xc8fMGcA0AgCSBtq6Mc5FJrwAARBnQenXN1Ddzn+6lFQBwNvTTFcDemp/XBgDgtnCAJLDnEkuphaU+DwDlSWDfNbYz383N4EsAoDgJ7L7FmBfixhUAUKsAAzfZz0OnuPlnBQBIHcuyDHXb5HW4cQUAlCWBpmtrqdIG+tOjRQEgM6Jvmvxc2bYmQBwXAECBBWBj9A/i872BkyggID1aAACTLYA5+D/jXHiFkd8CrNAncGIS2BP87+n/+ZTZwABuXKFT6BQL8NlWvbO/vt4Q8ZxpFKAACwCAL641oa9+9+yP/NfdCv0Xq8j9G/Ia3LhAs2hp3nDzfb1RDxz4+yaF4Us1/hhoqqGAiF0SC9wX0BOi/12I8eP5N9I/nv+uzjicD0kbo1yhAN2/+jAATHrU8o4Vd4X0/yj+lkCGCz+xTaakQBvleQAQtPCfjnHFqnBI53T8HWEEzv5lFHBOjequBG8A3IWfu3LV6Rbwm6Ie1SqYVwj/VTikaGBINgDitf+eXKdfGSKet10IAIps/ZovqoXSaMMAPAAInfuLKEBssOX+t6atAGOmSqb6QIp5e/i1IF4k+le1gCwfyEHfAL8WJLW2j/3vmiMCGoRj+KUACVi5GQp+XzZ9Q8sEQoznH7REd4CBvRrzg39NAVJPANcYWOm2gO+NG9lAEM8Wk/OXQ3JGf+aGtA4AfgeC5gGB4wMTb6sljOAWuzn4DyD83NQTCQZJoOZwEYgray4MgL/BIPrfhqDWjiH93CnEEj5djxk+UOKczkMAcAGJkye7DiYzRCDQ7h5PBUDZWhjli0BubURfDgCvCeYEb2kgAO060ZJngjYALnwgJRMAfww1MjjWywLT7ZQkgCp0Yt3gK4IG3gWAjMWw5Iuk9P6Ps24A+ABAOSGKEoH25kN2ScG7koCcPJgz7bVp76EDAxsAARwoef7avPt41A5sAESIoKbJa8/m4yEM6MsAICkTlbNmV+/xg34MyMsAkLQpMutKUeqPWScGeAMgRAUpZX4N7jvtwcDbAJCzHHbdW5bjYWX6k9a84G0eMMcFStIA+zaef26o2gCw2GrvcpAmueyAoydNMXgfAML3hEiazdaQiN2LgbwOAMEu0FCK5zoC+PmXromANwBcAJBEn0WhinLhCN4HgEgXyJlOO+Hc0QkINgAco6Cp5VbKKdz+HwTv84BxLjD5VilNPHPyubv+vQCIMQGd+zA44C1jPfunMaTXLQVdDS0H0EgsAuacO+UXWoAIEzCw/YIiAPbKcE0BQBe1ju3C6yPbXbWb6wJ7hnZ0E6a6f2MTAIALNLA/uVOBWYeOtwb0Ti5L+PnDjYBZbQc2ADrX2MlG9OxMBeY1HnnpM3YBt8n7yW2SSDacbQcIaAJM4f/VjkU8ySBtB4hXCtLOgq+OpwKyHSCcCTAVfv7fjYlGEXBhIHbQkgGgzvD/2VyaR9eFaDtArFKQreyr1pnciqVsB1jkAtkRfmJzKBsImNBvZD92E2Bc9JFO48hbAAABIKPhv75boB8BWwBgTID5ZI10G7rrgtAWABQTYF7xlZGU7nJO0y4BQJgAc/h14IKWGwRsAYCoBJjDb6nsS8fuAN5ndwBMgNjv5hn9oSsEbAGoNQFHT/jt81KtCNDtAKsTQXtbhZ4Le40I2AJQDoAjI/x3P6VbAKBMQKD360fAFgAAExDo/Yy/JQ08bgEA0wCSYLTJ7X+wBQALADQ8IaWBANoCgG8CSFJ+Ta4NwBYAIBNAkoU32QKArwEkiYxzUX3aawDJj84M/0f/mcJtAEA0gGQ64rYATAEATQ1/JwK2AECYAIo14roFYKlEkLgAczsDRDEByjWsswUAQQNIefpv7oNgMIkgSQnqtgHA0ABKFWBD8rEzwEoN0Ozp10TANgB1GkAygX1bCNgCUKUBOmno7xGwM8CJAKAJvr8TAdsAlJgA5TLkbQNQ+Mg85TciYBuA2SaAtGTMeXcCwMgDykb8FAHbALy7CrENwLsRsOP/cgRsA/g+C7IN4EbANoAbAdsAbATs+L/2kW0ANwK2AXz1w4+L/z8CDADebzi4XHs84QAAAABJRU5ErkJggg==";
var watermark_default = watermark;

// engine/sdk/operations/license-watermark-operation/watermark.frag
var watermark_default2 = "uniform sampler2D u_image;\nuniform sampler2D u_watermarkTex;\n\nvarying vec2 v_texCoord;\n\n\nvoid main() {\n  vec4 color = texture2D(u_image, v_texCoord);\n  vec4 watermarkColor = texture2D(u_watermarkTex, v_texCoord);\n\n  if (watermarkColor.r > 0.8) {\n    gl_FragColor = mix(color, watermarkColor, 0.3);\n  } else {\n    gl_FragColor = color;\n  }\n}\n";

// engine/sdk/operations/license-watermark-operation/watermark-filter.js
class WatermarkFilter extends engine_default.Filter {
  constructor(...args) {
    super(...args);
    this._fragmentSource = watermark_default2;
  }
  _applyWebGL(renderer, inputTarget, outputTarget, clear = false) {
    const gl = renderer.getContext();
    const {canvas: canvas9} = gl;
    const shader4 = this.getShaderForRenderer(renderer);
    const frame2 = inputTarget.getFrame();
    const existingCanvas = this._watermarkCanvas;
    if (!existingCanvas || frame2.width !== existingCanvas.width || frame2.height !== existingCanvas.height) {
      this._createWatermarkCanvas(frame2.width, frame2.height);
    }
    const texture5 = engine_default.Texture.fromCanvas(this._watermarkCanvas);
    const baseTexture = texture5.getBaseTexture();
    renderer.updateTexture(baseTexture);
    baseTexture.setGLUnit(1);
    renderer.setRenderTarget(outputTarget);
    if (clear) {
      outputTarget.clear();
    }
    renderer.setShader(shader4);
    const projectionMatrix = renderer.getCurrentRenderTarget().getProjectionMatrix().toArray();
    shader4.setUniform("u_projMatrix", projectionMatrix);
    shader4.syncUniforms();
    gl.uniform1i(gl.getUniformLocation(shader4.getProgram(), "u_watermarkTex"), 1);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputTarget.getTexture());
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, baseTexture.getGLTextureForRenderer(renderer));
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    texture5.dispose();
  }
  _createWatermarkCanvas(width, height) {
    const image5 = this._options.watermarkImage;
    const watermarkCanvas = utils_default.createCanvas();
    watermarkCanvas.width = width;
    watermarkCanvas.height = height;
    const watermarkContext = watermarkCanvas.getContext("2d");
    let scale;
    let x;
    let y;
    let sx;
    let sy;
    if (width > height) {
      scale = width / image5.width;
      y = (height - image5.height * scale) / 2;
      x = 0;
    } else {
      scale = height / image5.height;
      y = 0;
      x = (width - image5.width * scale) / 2;
    }
    watermarkContext.drawImage(image5, 0, 0, image5.width, image5.height, x, y, image5.width * scale, image5.height * scale);
    this._watermarkCanvas = watermarkCanvas;
    this._watermarkContext = watermarkContext;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const canvas9 = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const image5 = this._options.watermarkImage;
    this._createWatermarkCanvas(canvas9.width, canvas9.height);
    const imageData = inputContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const waterMarkImageData = this._watermarkContext.getImageData(0, 0, canvas9.width, canvas9.height);
    const inputColor = new color_default();
    const overlayColor = new color_default();
    const outputColor = new color_default();
    for (let i = 0; i < canvas9.width * canvas9.height * 4; i += 4) {
      inputColor.set(imageData.data[i] / 255, imageData.data[i + 1] / 255, imageData.data[i + 2] / 255, imageData.data[i + 3] / 255);
      overlayColor.set(waterMarkImageData.data[i] / 255, waterMarkImageData.data[i + 1] / 255, waterMarkImageData.data[i + 2] / 255, waterMarkImageData.data[i + 3] / 255);
      if (overlayColor.r > 0.8) {
        outputColor.copy(inputColor.clone().mix(overlayColor, 0.3));
      } else {
        outputColor.copy(inputColor);
      }
      imageData.data[i] = outputColor.r * 255;
      imageData.data[i + 1] = outputColor.g * 255;
      imageData.data[i + 2] = outputColor.b * 255;
      imageData.data[i + 3] = outputColor.a * 255;
    }
    outputContext.putImageData(imageData, 0, 0);
  }
}
WatermarkFilter.prototype.availableOptions = {
  watermarkImage: {type: OptionType.OBJECT, required: true}
};
var watermark_filter_default = WatermarkFilter;

// engine/sdk/operations/license-watermark-operation/index.js
class LicenseWatermarkOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._applyWatermarkFilter = () => {
      if (!this._watermarkFilter) {
        this._watermarkFilter = new watermark_filter_default({
          watermarkImage: this._watermarkImage
        });
      }
      this._sprite.setFilters([this._watermarkFilter]);
      this._renderTexture.render(this._container);
      return promise_default.resolve();
    };
    this._loadWatermarkImage = () => {
      if (!this._watermarkImage) {
        return new promise_default((resolve, reject) => {
          this._watermarkImage = new image_default();
          this._watermarkImage.onload = resolve;
          this._watermarkImage.src = watermark_default;
        });
      }
      return promise_default.resolve();
    };
    this._watermarkFilter = null;
    this._watermarkImage = null;
  }
  _render(sdk14) {
    return this._loadWatermarkImage().then(this._applyWatermarkFilter);
  }
  dispose() {
    if (this._watermarkFilter) {
      this._watermarkFilter.dispose();
    }
    super.dispose();
  }
}
LicenseWatermarkOperation.identifier = "license-watermark";
LicenseWatermarkOperation.prototype.availableOptions = {};
exports_default.Operations.LicenseWatermarkOperation = LicenseWatermarkOperation;
var license_watermark_operation_default = LicenseWatermarkOperation;

// engine/sdk/operations/linear-focus-operation/linear-focus.frag
var linear_focus_default = "/*!\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform vec2 u_controlPoint1;\nuniform vec2 u_controlPoint2;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    vec2 vector = u_controlPoint2 - u_controlPoint1;\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    float radius = smoothstep(0.0, 1.0,\n      abs(\n        clamp(dot(v_texCoord - u_controlPoint1, vector) / dot(vector, vector), 0.0, 1.0)\n      )\n    ) * u_blurRadius;\n\n    for (float t = -30.0; t <= 30.0; t++) {\n      float percent = (t + offset - 0.5) / 30.0;\n      float weight = 1.0 - abs(percent);\n      vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n      color += _sample * weight;\n      total += weight;\n    }\n\n    gl_FragColor = color / total;\n}\n";

// engine/sdk/operations/linear-focus-operation/linear-focus-filter.js
const {Vector2: Vector211} = math_exports;
class LinearFocusFilter extends engine_default.Filter {
  constructor(...args) {
    super(...args);
    this._fragmentSource = linear_focus_default;
    this._lastBlurRadius = null;
    this._lastControlPoint1 = new Vector211();
    this._lastControlPoint2 = new Vector211();
    this._blurFilter = new blur_filter_default();
    this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
    this._maskRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    if (this._options.blurQuality === "low") {
      this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
      return;
    }
    const inputDimensions = inputTarget.getDimensions();
    const dimensionsChanged = !outputTarget.getDimensions().equals(inputDimensions);
    const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
    if (shouldUpdateBlur) {
      const delta = new Vector211(this._options.delta.x, this._options.delta.y);
      this._blurFilter.setDelta(delta);
      const options = {
        blurRadius: this._options.blurRadius,
        texSize: inputDimensions
      };
      const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
      const smoothstep = (e0, e1, x) => {
        const t = clamp((x - e0) / (e1 - e0), 0, 1);
        return t * t * (3 - 2 * t);
      };
      const controlVec = this._options.controlPoint2.clone().subtract(this._options.controlPoint1.clone());
      const {blurRadius} = this._options;
      const radius = (x, y) => {
        return smoothstep(0, 1, Math.abs(clamp(new Vector211(x, y).subtract(this._options.controlPoint1).dot(controlVec) / controlVec.dot(controlVec), 0, 1))) * blurRadius;
      };
      this._blurFilter.set(options);
      this._blurFilter._applyCanvas(renderer, inputTarget, outputTarget, clear, radius);
      this._lastBlurRadius = this._options.blurRadius;
    }
  }
  _renderLQBlur(renderer, inputTarget, outputTarget, clear = false) {
    const inputDimensions = inputTarget.getDimensions();
    const dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
    this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
    const shouldUpdateMask = !this._lastControlPoint1.equals(this._options.controlPoint1) || !this._lastControlPoint2.equals(this._options.controlPoint2) || dimensionsChanged;
    const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
    if (shouldUpdateMask) {
      this._renderMask();
      this._lastControlPoint1 = this._options.controlPoint1.clone();
      this._lastControlPoint2 = this._options.controlPoint2.clone();
    }
    if (shouldUpdateBlur) {
      this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
      this._lastBlurRadius = this._options.blurRadius;
    }
    this._applyMask(inputTarget, outputTarget);
  }
  _renderMask() {
    const canvas9 = this._maskRenderTarget.getCanvas();
    const context = this._maskRenderTarget.getContext();
    const canvasDimensions = new Vector211(canvas9.width, canvas9.height);
    const controlPoint1 = this._options.controlPoint1.clone().multiply(canvasDimensions);
    const controlPoint2 = this._options.controlPoint2.clone().multiply(canvasDimensions);
    const gradient = context.createLinearGradient(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y);
    gradient.addColorStop(0, "#FFFFFF");
    gradient.addColorStop(1, "#000000");
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas9.width, canvas9.height);
  }
  _applyMask(inputTarget, outputTarget) {
    const outputContext = outputTarget.getContext();
    const inputCanvas = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const blurredContext = this._blurredRenderTarget.getContext();
    const maskContext = this._maskRenderTarget.getContext();
    const inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    const pixels = inputImageData.data;
    const blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    let alpha;
    for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      alpha = maskPixels[i] / 255;
      pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
      pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
      pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
    }
    outputContext.putImageData(inputImageData, 0, 0);
  }
  dispose() {
    super.dispose();
    this._blurFilter.dispose();
    this._blurredRenderTarget.dispose();
    this._maskRenderTarget.dispose();
  }
}
LinearFocusFilter.prototype.availableOptions = {
  blurRadius: {
    type: OptionType.NUMBER,
    default: 30,
    uniformType: UniformType.FLOAT
  },
  controlPoint1: {
    type: OptionType.VECTOR2,
    default: new Vector211(0, 0.5),
    uniformType: UniformType.FLOAT2
  },
  controlPoint2: {
    type: OptionType.VECTOR2,
    default: new Vector211(1, 0.5),
    uniformType: UniformType.FLOAT2
  },
  delta: {
    type: OptionType.VECTOR2,
    default: new Vector211(1, 1),
    uniformType: UniformType.FLOAT2
  },
  texSize: {
    type: OptionType.VECTOR2,
    default: new Vector211(100, 100),
    uniformType: UniformType.FLOAT2
  }
};
var linear_focus_filter_default = LinearFocusFilter;

// engine/sdk/operations/linear-focus-operation/index.js
const {Vector2: Vector212} = math_exports;
class LinearFocusOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._lastBlurRadius = this._options.blurRadius;
    this._lastControlPoint1 = this._options.controlPoint1.clone();
    this._lastControlPoint2 = this._options.controlPoint2.clone();
    const blurOption = {
      blurQuality: {
        type: OptionType.STRING
      }
    };
    this._horizontalFilter = new linear_focus_filter_default({}, blurOption);
    this._verticalFilter = new linear_focus_filter_default({}, blurOption);
    this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
    this._horizontalFilter.setDelta(new Vector212(0.5, 0.5));
    this._verticalFilter.setDelta(new Vector212(-0.5, 0.5));
    this._filter = new linear_focus_filter_default({}, blurOption);
  }
  rotate(degrees) {
    const {controlPoint1} = this._options;
    const {controlPoint2} = this._options;
    if (degrees === 90) {
      controlPoint1.flip();
      controlPoint1.x = 1 - controlPoint1.x;
      controlPoint2.flip();
      controlPoint2.x = 1 - controlPoint2.x;
    } else if (degrees === -90) {
      controlPoint1.flip();
      controlPoint1.y = 1 - controlPoint1.y;
      controlPoint2.flip();
      controlPoint2.y = 1 - controlPoint2.y;
    }
    this.set({controlPoint1, controlPoint2});
  }
  flip(direction) {
    const {controlPoint1} = this._options;
    const {controlPoint2} = this._options;
    switch (direction) {
      case "horizontal":
        controlPoint1.x = 1 - controlPoint1.x;
        controlPoint2.x = 1 - controlPoint2.x;
        break;
      case "vertical":
        controlPoint1.y = 1 - controlPoint1.y;
        controlPoint2.y = 1 - controlPoint2.y;
        break;
    }
    this.set({controlPoint1, controlPoint2});
  }
  transform(transformChange) {
    const newOptions = {};
    ["controlPoint1", "controlPoint2"].forEach((optionName) => {
      const vector = this.getOption(optionName);
      newOptions[optionName] = transformChange.applyToRelativePoint(vector);
    });
    ["blurRadius"].forEach((optionName) => {
      const size = this.getOption(optionName);
      newOptions[optionName] = transformChange.applyToRelativeSize(size);
    });
    this.set(newOptions, false);
  }
  _renderWebGL(inputTexture) {
    return this._renderBlur(inputTexture);
  }
  _renderCanvas(inputTexture) {
    if (this._options.highQualityCanvasBlur) {
      return this._renderBlur(inputTexture);
    }
    return this._renderLQCanvasBlur(inputTexture);
  }
  _renderBlur(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const shortestSide = inputDimensions.min();
    const {blurRadius, controlPoint1, controlPoint2} = this._options;
    const commonOptions = {
      blurRadius: blurRadius * shortestSide,
      controlPoint1: controlPoint1.clone(),
      controlPoint2: controlPoint2.clone(),
      texSize: inputDimensions,
      blurQuality: "high"
    };
    this._horizontalFilter.set(commonOptions);
    this._verticalFilter.set(commonOptions);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  _renderLQCanvasBlur(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const {blurRadius, controlPoint1, controlPoint2} = this._options;
    this._filter.set({
      blurRadius,
      controlPoint1: controlPoint1.clone(),
      controlPoint2: controlPoint2.clone(),
      texSize: inputDimensions,
      blurQuality: "low"
    });
    this._sprite.setFilters([this._filter]);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  dispose() {
    super.dispose();
    this._filter.dispose();
    this._verticalFilter.dispose();
    this._horizontalFilter.dispose();
  }
  hasChanges() {
    return true;
  }
}
LinearFocusOperation.identifier = "linear-focus";
LinearFocusOperation.prototype.availableOptions = {
  controlPoint1: {type: OptionType.VECTOR2, default: new Vector212(0, 0.5)},
  controlPoint2: {type: OptionType.VECTOR2, default: new Vector212(1, 0.5)},
  blurRadius: {type: OptionType.NUMBER, default: 0.025},
  highQualityCanvasBlur: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.LinearFocusOperation = LinearFocusOperation;
var linear_focus_operation_default = LinearFocusOperation;

// engine/sdk/operations/mirrored-focus-operation/mirrored-focus.frag
var mirrored_focus_default = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform float u_gradientSize;\nuniform float u_size;\nuniform vec2 u_start;\nuniform vec2 u_end;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    vec2 normal = normalize(vec2(u_start.y - u_end.y, u_end.x - u_start.x));\n    float radius = smoothstep(0.0, 1.0,\n      (abs(\n        dot(v_texCoord * u_texSize - u_start, normal)\n      ) - u_size) / u_gradientSize\n    ) * u_blurRadius;\n\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        color += _sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n}\n";

// engine/sdk/operations/mirrored-focus-operation/mirrored-focus-filter.js
const {Vector2: Vector213} = math_exports;
class MirroredFocusFilter extends engine_default.Filter {
  constructor(...args) {
    super(...args);
    this._fragmentSource = mirrored_focus_default;
    this._lastBlurRadius = null;
    this._lastGradientRadius = null;
    this._lastStart = new Vector213();
    this._lastEnd = new Vector213();
    this._blurFilter = new blur_filter_default();
    this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
    this._maskRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    if (this._options.blurQuality === "low") {
      this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
      return;
    }
    const inputDimensions = inputTarget.getDimensions();
    const dimensionsChanged = !outputTarget.getDimensions().equals(inputDimensions);
    const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
    if (shouldUpdateBlur) {
      const delta = new Vector213(this._options.delta.x, this._options.delta.y);
      this._blurFilter.setDelta(delta);
      const options = {
        blurRadius: this._options.blurRadius,
        texSize: inputDimensions
      };
      const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
      const smoothstep = (e0, e1, x) => {
        const t = clamp((x - e0) / (e1 - e0), 0, 1);
        return t * t * (3 - 2 * t);
      };
      const {
        blurRadius,
        gradientSize,
        size,
        start,
        end,
        texSize
      } = this._options;
      const normal = new Vector213(start.y - end.y, end.x - start.x);
      normal.divide(normal.len());
      const radius = (x, y) => {
        return smoothstep(0, 1, (Math.abs(texSize.clone().multiply(x, y).subtract(start).dot(normal)) - size) / gradientSize) * blurRadius;
      };
      this._blurFilter.set(options);
      this._blurFilter._applyCanvas(renderer, inputTarget, outputTarget, clear, radius);
      this._lastBlurRadius = this._options.blurRadius;
    }
  }
  _renderLQBlur(renderer, inputTarget, outputTarget, clear = false) {
    const inputDimensions = inputTarget.getDimensions();
    const dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
    this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
    const shouldUpdateMask = !this._lastStart.equals(this._options.start) || !this._lastEnd.equals(this._options.end) || this._lastGradientRadius !== this._options.size || dimensionsChanged;
    const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
    if (shouldUpdateMask) {
      this._renderMask();
      this._lastStart = this._options.start.clone();
      this._lastEnd = this._options.end.clone();
      this._lastGradientRadius = this._options.size;
    }
    if (shouldUpdateBlur) {
      this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
      this._lastBlurRadius = this._options.blurRadius;
    }
    this._applyMask(inputTarget, outputTarget);
  }
  _renderMask() {
    const canvas9 = this._maskRenderTarget.getCanvas();
    const context = this._maskRenderTarget.getContext();
    const pixelRatio = this._maskRenderTarget.getPixelRatio();
    const canvasDimensions = new Vector213(canvas9.width, canvas9.height);
    const size = this._options.size * canvasDimensions.min() * pixelRatio;
    const gradientSize = this._options.gradientSize * canvasDimensions.min() * pixelRatio;
    const start = this._options.start.clone().multiply(canvasDimensions);
    const end = this._options.end.clone().multiply(canvasDimensions);
    const dist = end.clone().subtract(start);
    const middle = start.clone().add(dist.clone().divide(2));
    const totalDist = dist.len();
    const factor = dist.clone().divide(totalDist);
    const gradientStart = middle.clone().add((size + gradientSize) * factor.y, -(size + gradientSize) * factor.x);
    const gradientEnd = middle.clone().add(-(size + gradientSize) * factor.y, (size + gradientSize) * factor.x);
    const gradient = context.createLinearGradient(gradientStart.x, gradientStart.y, gradientEnd.x, gradientEnd.y);
    const fullGradientSize = gradientEnd.clone().subtract(gradientStart).len();
    gradient.addColorStop(0, "#000000");
    gradient.addColorStop(gradientSize / 2 / fullGradientSize, "#FFFFFF");
    gradient.addColorStop(1 - gradientSize / 2 / fullGradientSize, "#FFFFFF");
    gradient.addColorStop(1, "#000000");
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas9.width, canvas9.height);
  }
  _applyMask(inputTarget, outputTarget) {
    const outputContext = outputTarget.getContext();
    const inputCanvas = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const blurredContext = this._blurredRenderTarget.getContext();
    const maskContext = this._maskRenderTarget.getContext();
    const inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    const pixels = inputImageData.data;
    const blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    let alpha;
    for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      alpha = maskPixels[i] / 255;
      pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
      pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
      pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
    }
    outputContext.putImageData(inputImageData, 0, 0);
  }
  dispose() {
    super.dispose();
    this._blurFilter.dispose();
  }
}
MirroredFocusFilter.prototype.availableOptions = {
  blurRadius: {
    type: OptionType.NUMBER,
    default: 30,
    uniformType: UniformType.FLOAT
  },
  size: {
    type: OptionType.NUMBER,
    default: 50,
    uniformType: UniformType.FLOAT
  },
  gradientSize: {
    type: OptionType.NUMBER,
    default: 50,
    uniformType: UniformType.FLOAT
  },
  start: {
    type: OptionType.VECTOR2,
    default: new Vector213(0, 0.5),
    uniformType: UniformType.FLOAT2
  },
  end: {
    type: OptionType.VECTOR2,
    default: new Vector213(1, 0.5),
    uniformType: UniformType.FLOAT2
  },
  delta: {
    type: OptionType.VECTOR2,
    default: new Vector213(1, 1),
    uniformType: UniformType.FLOAT2
  },
  texSize: {
    type: OptionType.VECTOR2,
    default: new Vector213(100, 100),
    uniformType: UniformType.FLOAT2
  }
};
var mirrored_focus_filter_default = MirroredFocusFilter;

// engine/sdk/operations/mirrored-focus-operation/index.js
const {Vector2: Vector214} = math_exports;
class MirroredFocusOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._lastBlurRadius = this._options.blurRadius;
    this._lastSize = this._options.size;
    this._lastGradientSize = this._options.gradientSize;
    const blurOption = {
      blurQuality: {
        type: OptionType.STRING
      }
    };
    this._horizontalFilter = new mirrored_focus_filter_default({}, blurOption);
    this._verticalFilter = new mirrored_focus_filter_default({}, blurOption);
    this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
    this._horizontalFilter.setDelta(new Vector214(0.5, 0.5));
    this._verticalFilter.setDelta(new Vector214(-0.5, 0.5));
    this._filter = new mirrored_focus_filter_default({}, blurOption);
    this._renderBlur.bind(this);
  }
  rotate(degrees) {
    const {start} = this._options;
    const {end} = this._options;
    if (degrees === 90) {
      start.flip();
      start.x = 1 - start.x;
      end.flip();
      end.x = 1 - end.x;
    } else if (degrees === -90) {
      start.flip();
      start.y = 1 - start.y;
      end.flip();
      end.y = 1 - end.y;
    }
    this.set({start, end});
  }
  flip(direction) {
    const {start} = this._options;
    const {end} = this._options;
    switch (direction) {
      case "horizontal":
        start.x = 1 - start.x;
        end.x = 1 - end.x;
        break;
      case "vertical":
        start.y = 1 - start.y;
        end.y = 1 - end.y;
        break;
    }
    this.set({start, end});
  }
  transform(transformChange) {
    const newOptions = {};
    ["start", "end"].forEach((optionName) => {
      const vector = this.getOption(optionName);
      newOptions[optionName] = transformChange.applyToRelativePoint(vector);
    });
    ["blurRadius", "size", "gradientSize"].forEach((optionName) => {
      const size = this.getOption(optionName);
      newOptions[optionName] = transformChange.applyToRelativeSize(size);
    });
    this.set(newOptions, false);
  }
  _renderWebGL(inputTexture) {
    return this._renderBlur(inputTexture);
  }
  _renderCanvas(inputTexture) {
    if (this._options.highQualityCanvasBlur) {
      return this._renderBlur(inputTexture);
    }
    return this._renderLQCanvasBlur(inputTexture);
  }
  _renderBlur(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const shortestSide = inputDimensions.min();
    const start = this._options.start.clone();
    const end = this._options.end.clone();
    const {blurRadius, size, gradientSize} = this._options;
    const commonOptions = {
      blurRadius: blurRadius * shortestSide,
      size: size * shortestSide,
      gradientSize: gradientSize * shortestSide,
      start: start.clone().multiply(inputDimensions),
      end: end.clone().multiply(inputDimensions),
      texSize: inputDimensions,
      blurQuality: "high"
    };
    this._horizontalFilter.set(commonOptions);
    this._verticalFilter.set(commonOptions);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  _renderLQCanvasBlur(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const {blurRadius, size, gradientSize, start, end} = this._options;
    this._filter.set({
      blurRadius,
      gradientSize,
      size,
      start: start.clone(),
      end: end.clone(),
      texSize: inputDimensions,
      blurQuality: "low"
    });
    this._sprite.setFilters([this._filter]);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  dispose() {
    super.dispose();
    this._filter.dispose();
    this._verticalFilter.dispose();
    this._horizontalFilter.dispose();
  }
  hasChanges() {
    return true;
  }
}
MirroredFocusOperation.identifier = "mirrored-focus";
MirroredFocusOperation.prototype.availableOptions = {
  start: {type: OptionType.VECTOR2, default: new Vector214(0, 0.5)},
  end: {type: OptionType.VECTOR2, default: new Vector214(1, 0.5)},
  blurRadius: {type: OptionType.NUMBER, default: 0.025},
  size: {type: OptionType.NUMBER, default: 0.1},
  gradientSize: {type: OptionType.NUMBER, default: 0.1},
  highQualityCanvasBlur: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.MirroredFocusOperation = MirroredFocusOperation;
var mirrored_focus_operation_default = MirroredFocusOperation;

// engine/sdk/operations/orientation-operation/index.js
const {Vector2: Vector215} = math_exports;
class OrientationOperation extends operation_default {
  _render(sdk14) {
    const actualDegrees = this._options.rotation % 360;
    const radians = actualDegrees * (Math.PI / 180);
    const rot90Or270 = actualDegrees === 90 || actualDegrees === 270;
    const xorFlips = this._options.flipHorizontally !== this._options.flipVertically;
    const actualFlipVert = rot90Or270 && xorFlips ? !this._options.flipVertically : this._options.flipVertically;
    const actualFlipHoriz = rot90Or270 && xorFlips ? !this._options.flipHorizontally : this._options.flipHorizontally;
    this._sprite.setScale(actualFlipHoriz ? -1 : 1, actualFlipVert ? -1 : 1);
    this._sprite.setRotation(radians);
    this._sprite.setAnchor(0.5, 0.5);
    this._sprite.updateTransform();
    const bounds = this._sprite.getBounds();
    this._renderTexture.resizeTo(new Vector215(bounds.width, bounds.height));
    this._sprite.setPosition(this._renderTexture.getDimensions().divide(2).round());
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  getNewDimensions(dimensions) {
    dimensions = dimensions.clone();
    if (this._options.rotation % 180) {
      dimensions.flip();
    }
    return dimensions;
  }
  flip(direction) {
    const {rotation} = this._options;
    if (rotation === 90 || rotation === 270) {
      if (direction === "vertical") {
        direction = "horizontal";
      } else {
        direction = "vertical";
      }
    }
    switch (direction) {
      case "vertical":
        this.setFlipVertically(!this.getFlipVertically());
        break;
      case "horizontal":
        this.setFlipHorizontally(!this.getFlipHorizontally());
        break;
    }
  }
}
OrientationOperation.identifier = "orientation";
OrientationOperation.prototype.availableOptions = {
  rotation: {
    type: OptionType.NUMBER,
    default: 0,
    validation(value) {
      if (value % 90 !== 0) {
        throw new Error("OrientationOperation: `rotation` has to be a multiple of 90.");
      }
    },
    setter: (value) => (value + 360) % 360
  },
  flipVertically: {type: OptionType.BOOLEAN, default: false},
  flipHorizontally: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.OrientationOperation = OrientationOperation;
var orientation_operation_default = OrientationOperation;

// engine/sdk/operations/output-operation/index.js
const {Vector2: Vector216} = math_exports;
class OutputOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._flipContainer = new engine_default.Container();
  }
  _render(inputTexture) {
    const {
      position,
      rotation,
      scale,
      pivot,
      outputResolution
    } = this._options;
    const textureScale = this._sdk.getTextureScale();
    const resolution = outputResolution.clone().multiply(textureScale).ceil();
    this._renderTexture.resizeTo(resolution);
    this._sprite.setRotation(rotation);
    this._sprite.setPosition(position);
    this._sprite.setPivot(pivot);
    this._sprite.setScale(scale);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  getNewDimensions(inputDimensions) {
    const textureScale = this._sdk.getTextureScale();
    return this._options.outputResolution.clone().multiply(textureScale).ceil();
  }
}
OutputOperation.identifier = "output";
OutputOperation.prototype.availableOptions = {
  position: {type: OptionType.VECTOR2, default: new Vector216(0, 0)},
  rotation: {type: OptionType.NUMBER, default: 0},
  scale: {type: OptionType.VECTOR2, default: new Vector216(1, 1)},
  pivot: {type: OptionType.VECTOR2, default: new Vector216(0, 0)},
  outputResolution: {
    type: OptionType.VECTOR2,
    default: new Vector216(100, 100)
  }
};
exports_default.Operations.OutputOperation = OutputOperation;
var output_operation_default = OutputOperation;

// engine/sdk/operations/overlay-operation/index.js
const {OverlayFilter: OverlayFilter2} = engine_default.Filters;
const {Vector2: Vector217} = math_exports;
const GL_UNIT = 4;
class OverlayOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._overlayTexture = engine_default.Texture.fromImage(this._options.image);
    this._overlayContainer = new engine_default.Container();
    this._overlaySprite = new engine_default.Sprite();
    this._overlaySprite.setTexture(this._overlayTexture);
    this._overlaySprite.setAnchor(0, 0);
    this._overlayContainer.addChild(this._overlaySprite);
    this._overlayFilter = new engine_default.Filters.OverlayFilter({
      overlayImage: this._overlayTexture.getBaseTexture().getGLUnit(),
      overlayTexture: this._overlayTexture
    });
    this._sprite.setFilters([this._overlayFilter]);
    this._renderedOverlaySprite = new engine_default.Sprite();
    this._renderedOverlayContainer = new engine_default.Container();
    this._renderedOverlayContainer.addChild(this._renderedOverlaySprite);
    this._overlayRendered = false;
    this._lastInputDimensions = new Vector217(0, 0);
  }
  setOption(name, value) {
    super.setOption(name, value);
    if (name === "image" && value && this._sdk) {
      const renderer = this._sdk.getRenderer();
      const baseTexture = this._overlayTexture.getBaseTexture();
      baseTexture.setSource(value);
      if (renderer.isOfType(RendererType.WEBGL)) {
        renderer.updateTexture(baseTexture);
      }
      this._overlayRendered = false;
    }
  }
  _render(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const {image: image5, alpha, blendMode} = this._options;
    if (!image5) {
      this._sprite.setFilters([]);
      this._renderTexture.render(this._container);
      return promise_default.resolve();
    }
    if (!this._overlayRendered || !this._lastInputDimensions.equals(inputDimensions)) {
      this._renderOverlayToRenderTexture(inputTexture);
      this._overlayRendered = true;
      this._lastInputDimensions.copy(inputDimensions);
    }
    this._overlayFilter.set({
      blendMode,
      overlayImage: this._overlayRenderTexture.getBaseTexture().getGLUnit(),
      overlayTexture: this._overlayRenderTexture,
      alpha
    });
    this._sprite.setFilters([this._overlayFilter]);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  _renderOverlayToRenderTexture(inputTexture) {
    const renderer = this._sdk.getRenderer();
    const textureDimensions = inputTexture.getDimensions();
    if (!this._overlayRenderTexture) {
      this._overlayRenderTexture = new engine_default.RenderTexture(renderer, textureDimensions.x, textureDimensions.y);
      this._renderedOverlaySprite.setTexture(this._overlayRenderTexture);
    }
    const {width, height} = this._options.image;
    const dimensions = utils_default.resizeVectorToFill(new Vector217(width, height), textureDimensions);
    const {flipHorizontally, flipVertically} = this._options;
    const scaleX = flipHorizontally ? -1 : 1;
    const scaleY = flipVertically ? -1 : 1;
    this._overlaySprite.setWidth(dimensions.x * scaleX);
    this._overlaySprite.setHeight(dimensions.y * scaleY);
    this._overlaySprite.setPosition(textureDimensions.x * (1 - scaleX) * 0.5, textureDimensions.y * (1 - scaleY) * 0.5);
    const baseTexture = this._overlayRenderTexture.getBaseTexture();
    this._overlayRenderTexture.resizeTo(textureDimensions);
    if (renderer.isOfType(RendererType.WEBGL)) {
      baseTexture.setGLUnit(GL_UNIT);
      renderer.updateTexture(baseTexture, false);
    }
    this._overlayRenderTexture.render(this._overlayContainer);
  }
  dispose() {
    super.dispose();
    if (this._overlaySprite)
      this._overlaySprite.dispose();
    if (this._overlayRenderTexture)
      this._renderedOverlaySprite.dispose();
    if (this._overlayFilter)
      this._overlayFilter.dispose();
    if (this._overlayTexture)
      this._overlayTexture.dispose();
    if (this._overlayRenderTexture)
      this._overlayRenderTexture.dispose();
    if (this._renderedOverlaySprite)
      this._renderedOverlaySprite.dispose();
  }
}
OverlayOperation.identifier = "overlay";
OverlayOperation.BLEND_MODES = OverlayFilter2.BLEND_MODES;
OverlayOperation.prototype.availableOptions = {
  identifier: {type: OptionType.STRING},
  image: {type: OptionType.IMAGE},
  blendMode: {
    type: OptionType.NUMBER,
    default: OverlayFilter2.BLEND_MODES.MULTIPLY,
    available: Object.keys(OverlayFilter2.BLEND_MODES).map((o) => OverlayFilter2.BLEND_MODES[o])
  },
  alpha: {type: OptionType.NUMBER, default: 1},
  flipHorizontally: {type: OptionType.BOOLEAN, default: false},
  flipVertically: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.OverlayOperation = OverlayOperation;
var overlay_operation_default = OverlayOperation;

// engine/sdk/operations/radial-focus-operation/radial-focus.frag
var radial_focus_default = "/*\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n * @license\n */\n\nuniform sampler2D u_image;\nuniform float u_radius;\nuniform float u_blurRadius;\nuniform float u_gradientRadius;\nuniform vec2 u_position;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nconst float blurSteps = 30.0;\nconst float EPSILON = 0.000000001;\n\nfloat random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy,vec2(a,b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    vec2 coord = v_texCoord * u_texSize;\n    vec2 diff = coord - u_position;\n    float dist = sqrt(diff.x * diff.x + diff.y * diff.y);\n\n    float blurPercentage = smoothstep( \n      0.0, 1.0,\n      (abs(dist) - u_radius) / u_gradientRadius\n    );\n\n    float radius = blurPercentage * u_blurRadius;\n    float offset = random(gl_FragCoord.xy / u_texSize.xy);\n\n    for (float t = -blurSteps; t <= blurSteps; t++) {\n        float percent = (t + offset - 0.5) / blurSteps;\n        float weight = 1.0 - abs(percent);\n        vec4 _sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        color += _sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / max(total, EPSILON);\n}\n";

// engine/sdk/operations/radial-focus-operation/radial-focus-filter.js
const {Vector2: Vector218} = math_exports;
class RadialFocusFilter extends engine_default.Filter {
  constructor(...args) {
    super(...args);
    this._fragmentSource = radial_focus_default;
    this._lastBlurRadius = null;
    this._lastGradientRadius = null;
    this._lastPosition = new Vector218();
    this._blurFilter = new blur_filter_default();
    this._blurredRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
    this._maskRenderTarget = new engine_default.CanvasRenderTarget(100, 100, 1);
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    if (this._options.blurQuality === "low") {
      this._renderLQBlur(renderer, inputTarget, outputTarget, clear);
      return;
    }
    const inputDimensions = inputTarget.getDimensions();
    const dimensionsChanged = !outputTarget.getDimensions().equals(inputDimensions);
    const {blurRadius, position, texSize, gradientRadius} = this._options;
    const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== blurRadius || dimensionsChanged;
    if (shouldUpdateBlur) {
      const delta = new Vector218(this._options.delta.x, this._options.delta.y);
      this._blurFilter.setDelta(delta);
      const options = {
        blurRadius,
        texSize: inputDimensions
      };
      const clamp = (x, minVal, maxVal) => Math.min(Math.max(x, minVal), maxVal);
      const smoothstep = (e0, e1, x) => {
        const t = clamp((x - e0) / (e1 - e0), 0, 1);
        return t * t * (3 - 2 * t);
      };
      const radius = (x, y) => {
        return smoothstep(0, 1, (Math.abs(texSize.clone().multiply(x, y).subtract(position).len()) - this._options.radius) / (gradientRadius * 2)) * blurRadius;
      };
      this._blurFilter.set(options);
      this._blurFilter._applyCanvas(renderer, inputTarget, outputTarget, clear, radius);
      this._lastBlurRadius = blurRadius;
    }
  }
  _renderLQBlur(renderer, inputTarget, outputTarget, clear = false) {
    const inputDimensions = inputTarget.getDimensions();
    const dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
    this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
    this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
    const shouldUpdateMask = !this._lastPosition.equals(this._options.position) || this._lastGradientRadius !== this._options.gradientRadius || dimensionsChanged;
    const shouldUpdateBlur = inputTarget.getBaseTexture().isDirty() || this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged;
    if (shouldUpdateMask) {
      this._renderMask();
      this._lastPosition = this._options.position.clone();
      this._lastGradientRadius = this._options.gradientRadius;
    }
    if (shouldUpdateBlur) {
      this._blurImage(inputTarget, this._blurredRenderTarget, this._options.blurRadius);
      this._lastBlurRadius = this._options.blurRadius;
    }
    this._applyMask(inputTarget, outputTarget);
  }
  _renderMask() {
    const canvas9 = this._maskRenderTarget.getCanvas();
    const context = this._maskRenderTarget.getContext();
    const canvasDimensions = new Vector218(canvas9.width, canvas9.height);
    const pixelRatio = this._maskRenderTarget.getPixelRatio();
    const position = this._options.position.clone().multiply(canvasDimensions);
    let {radius, gradientRadius} = this._options;
    radius *= canvas9.height;
    gradientRadius *= canvas9.height;
    const gradient = context.createRadialGradient(position.x, position.y, 0, position.x, position.y, (radius + gradientRadius) * pixelRatio);
    gradient.addColorStop(0, "#FFFFFF");
    gradient.addColorStop(radius / (radius + gradientRadius), "#FFFFFF");
    gradient.addColorStop(1, "#000000");
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvasDimensions.x, canvasDimensions.y);
  }
  _applyMask(inputTarget, outputTarget) {
    const outputContext = outputTarget.getContext();
    const inputCanvas = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const blurredContext = this._blurredRenderTarget.getContext();
    const maskContext = this._maskRenderTarget.getContext();
    const inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    const pixels = inputImageData.data;
    const blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    let alpha;
    for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      alpha = maskPixels[i] / 255;
      pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
      pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
      pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
    }
    outputContext.putImageData(inputImageData, 0, 0);
  }
  dispose() {
    super.dispose();
    this._blurFilter.dispose();
    this._blurredRenderTarget.dispose();
    this._maskRenderTarget.dispose();
  }
}
RadialFocusFilter.prototype.availableOptions = {
  blurRadius: {
    type: OptionType.NUMBER,
    default: 30,
    uniformType: UniformType.FLOAT
  },
  radius: {
    type: OptionType.NUMBER,
    default: 50,
    uniformType: UniformType.FLOAT
  },
  gradientRadius: {
    type: OptionType.NUMBER,
    default: 25,
    uniformType: UniformType.FLOAT
  },
  position: {
    type: OptionType.VECTOR2,
    default: new Vector218(0.5, 0.5),
    uniformType: UniformType.FLOAT2
  },
  delta: {
    type: OptionType.VECTOR2,
    default: new Vector218(1, 1),
    uniformType: UniformType.FLOAT2
  },
  texSize: {
    type: OptionType.VECTOR2,
    default: new Vector218(100, 100),
    uniformType: UniformType.FLOAT2
  }
};
var radial_focus_filter_default = RadialFocusFilter;

// engine/sdk/operations/radial-focus-operation/index.js
const {Vector2: Vector219} = math_exports;
class RadialFocusOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._lastBlurRadius = this._options.blurRadius;
    this._lastGradientRadius = this._options.gradientRadius;
    const blurOptions = {
      blurQuality: {
        type: OptionType.STRING
      }
    };
    this._horizontalFilter = new radial_focus_filter_default({}, blurOptions);
    this._verticalFilter = new radial_focus_filter_default({}, blurOptions);
    this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
    this._horizontalFilter.setDelta(new Vector219(0.5, 0.5));
    this._verticalFilter.setDelta(new Vector219(-0.5, 0.5));
    this._filter = new radial_focus_filter_default({}, blurOptions);
  }
  rotate(degrees) {
    const {position} = this._options;
    if (degrees === 90) {
      position.flip();
      position.x = 1 - position.x;
    } else if (degrees === -90) {
      position.flip();
      position.y = 1 - position.y;
    }
    this.set({position});
  }
  flip(direction) {
    const {position} = this._options;
    switch (direction) {
      case "horizontal":
        position.x = 1 - position.x;
        break;
      case "vertical":
        position.y = 1 - position.y;
        break;
    }
    this.set({position});
  }
  transform(transformChange) {
    const newOptions = {};
    const vector = this.getPosition();
    newOptions.position = transformChange.applyToRelativePoint(vector);
    ["radius", "blurRadius", "gradientRadius"].forEach((optionName) => {
      const size = this.getOption(optionName);
      newOptions[optionName] = transformChange.applyToRelativeSize(size);
    });
    this.set(newOptions, false);
  }
  _renderWebGL(inputTexture) {
    return this._renderBlur(inputTexture);
  }
  _renderCanvas(inputTexture) {
    if (this._options.highQualityCanvasBlur) {
      return this._renderBlur(inputTexture);
    }
    return this._renderLQCanvasBlur(inputTexture);
  }
  _renderBlur(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const shortestSide = inputDimensions.min();
    const {position, blurRadius, radius, gradientRadius} = this._options;
    const commonOptions = {
      blurRadius: blurRadius * shortestSide,
      radius: radius * shortestSide,
      gradientRadius: gradientRadius * shortestSide,
      position: position.clone().multiply(inputDimensions),
      texSize: inputDimensions,
      blurQuality: "high"
    };
    this._horizontalFilter.set(commonOptions);
    this._verticalFilter.set(commonOptions);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  _renderLQCanvasBlur(inputTexture) {
    const {blurRadius, radius, gradientRadius, position} = this._options;
    const inputDimensions = inputTexture.getDimensions();
    this._filter.set({
      blurRadius,
      radius,
      gradientRadius,
      position,
      texSize: inputDimensions,
      blurQuality: "low"
    });
    this._sprite.setFilters([this._filter]);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  dispose() {
    super.dispose();
    this._filter.dispose();
    this._verticalFilter.dispose();
    this._horizontalFilter.dispose();
  }
  hasChanges() {
    return true;
  }
}
RadialFocusOperation.identifier = "radial-focus";
RadialFocusOperation.prototype.availableOptions = {
  position: {type: OptionType.VECTOR2, default: new Vector219(0.5, 0.5)},
  radius: {type: OptionType.NUMBER, default: 0.25},
  gradientRadius: {type: OptionType.NUMBER, default: 0.125},
  blurRadius: {type: OptionType.NUMBER, default: 0.025},
  highQualityCanvasBlur: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.RadialFocusOperation = RadialFocusOperation;
var radial_focus_operation_default = RadialFocusOperation;

// engine/sdk/operations/shared/shaders/generic/mask.frag
var mask_default = "varying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_filterImage;\nuniform sampler2D u_maskImage;\n\nvoid main() {\n  vec4 color0 = texture2D(u_image, v_texCoord);\n  vec4 color1 = texture2D(u_filterImage, v_texCoord);\n  vec4 mask = texture2D(u_maskImage, v_texCoord);\n  gl_FragColor = mix(color0, color1, mask);\n}\n";

// engine/sdk/operations/shared/filters/mask-filter.js
class MaskFilter extends engine_default.Filter {
  constructor() {
    super();
    this._fragmentSource = mask_default;
  }
  _applyCanvas(renderer, inputTarget, outputTarget, clear = false) {
    const inputCanvas = inputTarget.getCanvas();
    const inputContext = inputTarget.getContext();
    const outputContext = outputTarget.getContext();
    const {maskCanvas, filterCanvas} = this._options;
    const maskContext = maskCanvas.getContext("2d");
    const filterContext = filterCanvas.getContext("2d");
    const maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    const existingImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
    const existingPixels = existingImageData.data;
    const newPixels = filterContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
    let alpha;
    for (let i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
      alpha = maskPixels[i] / 255;
      existingPixels[i] = alpha * newPixels[i] + (1 - alpha) * existingPixels[i];
      existingPixels[i + 1] = alpha * newPixels[i + 1] + (1 - alpha) * existingPixels[i + 1];
      existingPixels[i + 2] = alpha * newPixels[i + 2] + (1 - alpha) * existingPixels[i + 2];
    }
    outputContext.putImageData(existingImageData, 0, 0);
  }
}
MaskFilter.prototype.availableOptions = {
  maskImage: {
    type: OptionType.NUMBER,
    default: 1,
    uniformType: UniformType.INT
  },
  maskCanvas: {type: OptionType.OBJECT, default: null},
  filterImage: {
    type: OptionType.NUMBER,
    default: 2,
    uniformType: UniformType.INT
  },
  filterCanvas: {type: OptionType.OBJECT, default: null}
};
var mask_filter_default = MaskFilter;

// engine/sdk/operations/shared/sprite.js
const {Vector2: Vector220} = math_exports;
class Sprite2 extends configurable_default {
  constructor(operation3, options) {
    super(options);
    this._isDisposed = false;
    this._operation = operation3;
    this._dirtiness = {};
    this.id = utils_default.getUUID();
    this._renderTextures = {};
    this._identitySprite = new engine_default.Sprite();
    this._sprite = new engine_default.Sprite();
    this._hitTestSprite = new engine_default.Sprite();
    this._renderers = [];
  }
  applyScale(scale) {
  }
  applyRotation(degrees) {
    const inputDimensions = this._operation.getInputDimensions();
    let spriteDegrees = this.getRotation() * 180 / Math.PI;
    spriteDegrees += degrees;
    this.setRotation(spriteDegrees * Math.PI / 180);
    const actualDegrees = (degrees + 360) % 360;
    const radians = actualDegrees * Math.PI / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);
    const relativePosition = this._options.position.clone().subtract(0.5).multiply(inputDimensions);
    const newRelativePosition = new Vector220(relativePosition.x * cos - relativePosition.y * sin, relativePosition.x * sin + relativePosition.y * cos).divide(inputDimensions.clone().flip());
    this.setPosition(new Vector220(0.5, 0.5).add(newRelativePosition));
  }
  applyFlip(direction) {
    const position = this.getPosition().clone();
    switch (direction) {
      case "horizontal":
        position.x = 1 - this._options.position.x;
        break;
      case "vertical":
        position.y = 1 - this._options.position.y;
        break;
    }
    this.setPosition(position);
  }
  applyTransform(transformChange) {
    const newOptions = {};
    newOptions.rotation = transformChange.applyToRotation(this.getRotation());
    newOptions.position = transformChange.applyToRelativePoint(this.getPosition());
    if (this._options.dimensions) {
      newOptions.dimensions = transformChange.applyToDimensions(this.getDimensions());
    }
    this.set(newOptions, false);
  }
  getDisplayObject() {
    return this._sprite;
  }
  getHitTestDisplayObject() {
    return this._sprite;
  }
  _getTexture() {
    throw new Error("Sprite#_getTexture is abstract and not implemented in child class.");
  }
  _prepareRenderTexture(sdk14) {
    if (!this._renderTexture) {
      const texture5 = this._getTexture();
      this._renderTextureContainer = new engine_default.Container();
      this._renderTextureSprite = new engine_default.Sprite(texture5);
      this._renderTextureContainer.addChild(this._renderTextureSprite);
      this._renderTexture = this._getRenderTexture(sdk14.getRenderer(), texture5.getDimensions());
    } else {
      this._renderTexture.clear();
    }
  }
  _rendersToRenderTexture(sdk14) {
    return sdk14.getOptions().smoothDownscaling && sdk14.getRenderer().isOfType(RendererType.WEBGL);
  }
  _optionEquals(optionName, value) {
    if (optionName === "type") {
      return true;
    }
    return super._optionEquals(optionName, value);
  }
  update(sdk14, inputDimensions) {
    if (this._isDisposed) {
      return;
    }
    if (this._rendersToRenderTexture(sdk14)) {
      this._prepareRenderTexture(sdk14);
      this._renderToRenderTexture(sdk14);
    }
    this._updateSprite(inputDimensions);
  }
  _updateSprite(inputDimensions) {
    const sprites = [this._sprite, this._hitTestSprite];
    sprites.forEach((sprite7) => {
      if (!sprite7.getTexture())
        return;
      sprite7.setAnchor(this._options.anchor);
      sprite7.setPosition(this._options.position.clone().multiply(inputDimensions));
      if (typeof this._options.alpha !== "undefined") {
        sprite7.setAlpha(this._options.alpha);
      }
      let {dimensions} = this._options;
      if (dimensions) {
        dimensions = dimensions.clone().multiply(this._operation.getSDK().getTextureScale());
        sprite7.setWidth(dimensions.x);
        sprite7.setHeight(dimensions.y);
      }
      sprite7.updateTransform();
      const frame2 = sprite7.getTexture().getFrame();
      const spriteDimensions = new Vector220(frame2.width, frame2.height);
      sprite7.setPivot(this._options.pivot.clone().multiply(spriteDimensions));
      sprite7.setRotation(this._options.rotation);
      sprite7.updateTransform();
    });
  }
  _renderToRenderTexture(sdk14) {
    const textureDimensions = this._getTexture().getDimensions();
    const renderTexture = this._getRenderTexture(sdk14.getRenderer(), textureDimensions);
    const finalDimensions = textureDimensions.clone();
    if (this._options.smoothDownscaling) {
      finalDimensions.x = utils_default.nextHighestPOT(finalDimensions.x);
      finalDimensions.y = utils_default.nextHighestPOT(finalDimensions.y);
    }
    this._renderTexture.resizeTo(finalDimensions);
    this._renderTexture.render(this._renderTextureContainer);
    if (this._options.smoothDownscaling) {
      const relativeDifference = finalDimensions.clone().subtract(textureDimensions.x, textureDimensions.y).divide(finalDimensions);
      const uvs = renderTexture.getUVs().getUVs();
      uvs[0].x = uvs[3].x = 0;
      uvs[1].x = uvs[2].x = 1 - relativeDifference.x;
      uvs[0].y = uvs[1].y = 0;
      uvs[2].y = uvs[3].y = 1 - relativeDifference.y;
    }
    this._sprite.setTexture(renderTexture);
  }
  isDirtyForRenderer(renderer) {
    if (!(renderer.id in this._dirtiness)) {
      this._dirtiness[renderer.id] = true;
    }
    return this._dirtiness[renderer.id];
  }
  setDirtyForRenderer(dirty, renderer) {
    this._renderers[renderer.id] = renderer;
    this._dirtiness[renderer.id] = dirty;
  }
  setDirty(dirty) {
    for (const rendererId in this._dirtiness) {
      this.setDirtyForRenderer(dirty, this._renderers[rendererId]);
    }
  }
  _getRenderTexture(renderer, dimensions = new Vector220(100, 100)) {
    if (!this._renderTextures[renderer.id]) {
      this._renderTextures[renderer.id] = new engine_default.RenderTexture(renderer, dimensions.x, dimensions.y, 1);
    }
    return this._renderTextures[renderer.id];
  }
  dispose() {
    this._isDisposed = true;
    for (const rendererId in this._renderTextures) {
      this._renderTextures[rendererId].dispose();
    }
  }
  canBeDuplicated() {
    return true;
  }
  canBeDeleted() {
    return true;
  }
  canMaskCanvas() {
    return false;
  }
  canAdjustPadding() {
    return false;
  }
  canBeTakenToFront() {
    return true;
  }
  canBeFlippedHorizontally() {
    return true;
  }
}
var sprite_default2 = Sprite2;

// engine/sdk/operations/shared/sprites/brush/brushes/brush.js
const {Vector2: Vector221} = math_exports;
class Brush extends configurable_default {
  constructor(...args) {
    super(...args);
    this._lastOptions = {};
    this._lastInputDimensions = new Vector221(0, 0);
    this._brush = null;
  }
  getBrushImage(inputDimensions) {
    if (this._brush && this.optionsEqual(this._lastOptions) && inputDimensions.equals(this._lastInputDimensions)) {
      return this._brush;
    }
    const {image: image5, size} = this._options;
    image5.width = image5.height = Math.ceil(size * inputDimensions.min());
    const canvas9 = utils_default.createCanvas();
    canvas9.width = image5.width;
    canvas9.height = image5.height;
    const context = canvas9.getContext("2d");
    context.drawImage(image5, 0, 0, canvas9.width, canvas9.height);
    const tintedBrush = this._tintImageData(context.getImageData(0, 0, canvas9.width, canvas9.height), canvas9.width, canvas9.height);
    context.putImageData(tintedBrush, 0, 0);
    this._lastOptions = this.serializeOptions(["size", "color"]);
    this._brush = canvas9;
    this._lastInputDimensions = inputDimensions.clone();
    return canvas9;
  }
  _tintImageData(imageData) {
    const {color: color6} = this._options;
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] += (color6.r * 255 - imageData.data[i]) * color6.a;
      imageData.data[i + 1] += (color6.g * 255 - imageData.data[i + 1]) * color6.a;
      imageData.data[i + 2] += (color6.b * 255 - imageData.data[i + 2]) * color6.a;
    }
    return imageData;
  }
  clone() {
    const Constructor = this.constructor;
    return new Constructor(this._options);
  }
}
Brush.prototype.availableOptions = {
  identifier: {type: OptionType.STRING},
  image: {type: OptionType.IMAGE},
  size: {type: OptionType.NUMBER, default: 0.05},
  color: {type: OptionType.COLOR, default: color_default.RED}
};

// engine/sdk/operations/shared/sprites/brush/brushes/radial-brush.js
class RadialBrush extends Brush {
  getBrushImage(inputDimensions) {
    if (this._brush && this.optionsEqual(this._lastOptions) && inputDimensions.equals(this._lastInputDimensions)) {
      return this._brush;
    }
    let {size, hardness, color: color6} = this._options;
    const canvas9 = utils_default.createCanvas();
    canvas9.width = canvas9.height = Math.ceil(size * inputDimensions.min());
    const context = canvas9.getContext("2d");
    color6 = color6.clone();
    color6.a = 1;
    if (canvas9.width === 1) {
      context.fillStyle = color6.toRGBA();
      context.fillRect(0, 0, 1, 1);
    } else {
      const gradient = context.createRadialGradient(canvas9.width / 2, canvas9.height / 2, Math.min(canvas9.width / 2 - 1, canvas9.width / 2 * hardness), canvas9.width / 2, canvas9.height / 2, canvas9.width / 2);
      gradient.addColorStop(0, color6.toRGBA());
      const transparentColor = color6.clone();
      transparentColor.a = 0;
      gradient.addColorStop(1, transparentColor.toRGBA());
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas9.width, canvas9.height);
    }
    this._lastOptions = this.serializeOptions(["size", "color", "hardness"]);
    this._brush = canvas9;
    this._lastInputDimensions = inputDimensions.clone();
    return canvas9;
  }
}
RadialBrush.identifier = "imgly_brush_radial";
RadialBrush.prototype.availableOptions = utils_default.extend(Brush.prototype.availableOptions, {
  hardness: {type: OptionType.NUMBER, default: 1}
});

// engine/sdk/operations/shared/sprites/brush/control-point.js
const {Vector2: Vector222, CubicBezierCurve: CubicBezierCurve2} = math_exports;
class ControlPoint {
  constructor(path2, position, smooth = 3) {
    this._path = path2;
    this._drawnCanvases = [];
    this._position = position;
    this._smooth = smooth;
  }
  getBezierCurve(beforeLastPoint, lastPoint, point, nextPoint) {
    if (!lastPoint) {
      return null;
    }
    let pointDx;
    let pointDy;
    if (!nextPoint) {
      pointDx = (point.x - lastPoint.x) / this._smooth;
      pointDy = (point.y - lastPoint.y) / this._smooth;
    } else {
      pointDx = (nextPoint.x - lastPoint.x) / this._smooth;
      pointDy = (nextPoint.y - lastPoint.y) / this._smooth;
    }
    let lastPointDx;
    let lastPointDy;
    if (!beforeLastPoint) {
      lastPointDx = (point.x - lastPoint.x) / this._smooth;
      lastPointDy = (point.y - lastPoint.y) / this._smooth;
    } else {
      lastPointDx = (point.x - beforeLastPoint.x) / this._smooth;
      lastPointDy = (point.y - beforeLastPoint.y) / this._smooth;
    }
    const p1 = lastPoint.clone().add(lastPointDx, lastPointDy);
    const p2 = point.clone().subtract(pointDx, pointDy);
    return new CubicBezierCurve2(lastPoint, p1, p2, point);
  }
  renderToCanvas(brush3, canvas9, beforeLastControlPoint, lastControlPoint, nextControlPoint, hardness = 1) {
    if (this._drawnCanvases.indexOf(canvas9) !== -1) {
      return;
    }
    const canvasDimensions = new Vector222(canvas9.width, canvas9.height);
    const context = canvas9.getContext("2d");
    const position = this._position.clone().multiply(canvasDimensions);
    const lastPosition = lastControlPoint ? lastControlPoint.getPosition().clone().multiply(canvasDimensions) : null;
    const beforeLastPosition = beforeLastControlPoint ? beforeLastControlPoint.getPosition().clone().multiply(canvasDimensions) : null;
    const nextPosition = nextControlPoint ? nextControlPoint.getPosition().clone().multiply(canvasDimensions) : null;
    const distance = position.clone().subtract(lastPosition).len();
    const step = brush3.width / 10;
    const curve = this.getBezierCurve(beforeLastPosition, lastPosition, position, nextPosition);
    let sample;
    if (!curve) {
      sample = [position];
    } else {
      curve.calculateSegments(20);
      const length = curve.getLength();
      sample = curve.arcLengthApproxSample(Math.ceil(length / step));
    }
    for (let i = 0; i < sample.length; i++) {
      const pos = sample[i];
      let alpha = brush3.width * 0.5 / (step * 2);
      alpha *= 1 - hardness;
      alpha = 1 / (1 + alpha);
      context.globalAlpha = alpha;
      context.drawImage(brush3, pos.x - brush3.width / 2, pos.y - brush3.height / 2, brush3.width, brush3.height);
    }
    context.globalAlpha = 1;
    this._drawnCanvases.push(canvas9);
  }
  setPosition(position) {
    this._position = position;
  }
  getPosition() {
    return this._position.clone();
  }
  setDirty() {
    this._drawnCanvases = [];
  }
}
var control_point_default = ControlPoint;

// engine/sdk/operations/shared/sprites/brush/path.js
class Path extends configurable_default {
  constructor(operation3, options, canvas9) {
    super(options);
    this._operation = operation3;
    this._canvas = canvas9 || utils_default.createCanvas();
    this._context = this._canvas.getContext("2d");
  }
  serializeOption(optionName, toObject = false) {
    if (optionName === "controlPoints") {
      return this._options.controlPoints.map((controlPoint) => {
        const position = controlPoint.getPosition();
        return toObject ? position.toObject() : position.clone();
      });
    }
    return super.serializeOption(optionName, toObject);
  }
  _optionEquals(optionName, value) {
    if (optionName === "controlPoints") {
      const {controlPoints} = this._options;
      for (let i = 0, l = controlPoints.length; i < l; i++) {
        if (!controlPoints[i].getPosition().equals(value[i])) {
          return false;
        }
      }
      return true;
    }
    return super._optionEquals(optionName, value);
  }
  render(inputDimensions) {
    const {controlPoints, size} = this._options;
    if (controlPoints.length < 2) {
      return;
    }
    const brush3 = this.getBrush();
    const hardness = brush3 && brush3.getHardness ? brush3.getHardness() : 1;
    utils_default.ensureCanvasDimensions(this._canvas, inputDimensions);
    if (!this._brush || this._lastBrushSize !== size || !inputDimensions.equals(this._brushInputDimensions)) {
      this._brushInputDimensions = inputDimensions.clone();
      this._lastBrushSize = size;
    }
    let beforeLastControlPoint;
    let lastControlPoint;
    let controlPoint;
    let nextControlPoint;
    for (let i = 0; i < controlPoints.length; i++) {
      beforeLastControlPoint = controlPoints[i - 2];
      lastControlPoint = controlPoints[i - 1];
      controlPoint = controlPoints[i];
      nextControlPoint = controlPoints[i + 1];
      controlPoint.renderToCanvas(this._options.brush.getBrushImage(inputDimensions), this._canvas, beforeLastControlPoint, lastControlPoint, nextControlPoint, hardness);
    }
  }
  _createBrush(inputDimensions) {
    let {size, hardness, color: color6} = this._options;
    const canvas9 = utils_default.createCanvas();
    canvas9.width = canvas9.height = Math.ceil(size * inputDimensions.min());
    const context = canvas9.getContext("2d");
    color6 = color6.clone();
    color6.a = 1;
    if (canvas9.width === 1) {
      context.fillStyle = color6.toRGBA();
      context.fillRect(0, 0, 1, 1);
    } else {
      const gradient = context.createRadialGradient(canvas9.width / 2, canvas9.height / 2, Math.min(canvas9.width / 2 - 1, canvas9.width / 2 * hardness), canvas9.width / 2, canvas9.height / 2, canvas9.width / 2);
      gradient.addColorStop(0, color6.toRGBA());
      const transparentColor = color6.clone();
      transparentColor.a = 0;
      gradient.addColorStop(1, transparentColor.toRGBA());
      context.fillStyle = gradient;
      context.fillRect(0, 0, canvas9.width, canvas9.height);
    }
    return canvas9;
  }
  addControlPoint(position) {
    const controlPoint = new control_point_default(this, position);
    this._options.controlPoints.push(controlPoint);
    this.emit("update", this);
  }
  getCanvas() {
    return this._canvas;
  }
  setCanvas(canvas9) {
    this._canvas = canvas9;
    this._context = canvas9.getContext("2d");
  }
  setDirty() {
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    this._options.controlPoints.forEach((point) => {
      point.setDirty();
    });
  }
  forEachControlPoint(iterator) {
    this._options.controlPoints.forEach(iterator);
  }
  renderToCanvas(canvas9) {
    const context = canvas9.getContext("2d");
    context.save();
    context.globalAlpha = this._options.brush.getColor().a;
    context.drawImage(this._canvas, 0, 0);
    context.restore();
  }
  getCanvasDimensions() {
    return this._canvasDimensions;
  }
}
Path.prototype.availableOptions = {
  id: {type: OptionType.STRING, default: () => utils_default.getUUID()},
  brush: {type: OptionType.OBJECT, required: true},
  controlPoints: {type: OptionType.ARRAY, default: []},
  closed: {type: OptionType.BOOLEAN, default: false}
};
var path_default = Path;

// engine/sdk/operations/shared/sprites/brush-sprite.js
const {Vector2: Vector223} = math_exports;
class BrushSprite extends sprite_default2 {
  constructor(...args) {
    super(...args);
    this._persistedPaths = [];
    this._outputCanvasDirty = true;
    this._outputCanvas = utils_default.createCanvas();
    this._outputContext = this._outputCanvas.getContext("2d");
    this._persistCanvas = utils_default.createCanvas();
    this._persistContext = this._persistCanvas.getContext("2d");
    this._nextCanvas = utils_default.createCanvas();
    this._texture = engine_default.Texture.fromCanvas(this._outputCanvas);
    this._sprite.setTexture(this._texture);
    this._onPathUpdate = this._onPathUpdate.bind(this);
  }
  applyFlip(direction) {
    this._options.paths.forEach((path2) => {
      path2.forEachControlPoint((controlPoint) => {
        const position = controlPoint.getPosition().clone();
        switch (direction) {
          case "horizontal":
            position.x = 1 - position.x;
            break;
          case "vertical":
            position.y = 1 - position.y;
            break;
        }
        controlPoint.setPosition(position);
      });
      path2.setDirty(true);
    });
    this._reset();
  }
  applyRotation(degrees) {
    this._options.paths.forEach((path2) => {
      path2.forEachControlPoint((controlPoint) => {
        const position = controlPoint.getPosition().clone();
        if (degrees === 90) {
          position.flip();
          position.x = 1 - position.x;
        } else if (degrees === -90) {
          position.flip();
          position.y = 1 - position.y;
        }
        controlPoint.setPosition(position);
      });
      path2.setDirty(true);
    });
    this._reset();
  }
  applyTransform(transformChange) {
    let lastBrush = null;
    this._options.paths.forEach((path2) => {
      path2.forEachControlPoint((controlPoint) => {
        controlPoint.setPosition(transformChange.applyToRelativePoint(controlPoint.getPosition()));
      });
      const brush3 = path2.getBrush();
      if (brush3 !== lastBrush) {
        brush3.setSize(transformChange.applyToRelativeSize(brush3.getSize()));
        lastBrush = brush3;
      }
      path2.setDirty(true);
    });
    this._reset();
  }
  clearCanvas() {
    if (!this._outputCanvas) {
      return;
    }
    this._outputCanvasDirty = true;
    const {width, height} = this._outputCanvas;
    this._outputContext.clearRect(0, 0, width, height);
  }
  clearPersistCanvas() {
    if (!this._persistCanvas) {
      return;
    }
    const {width, height} = this._persistCanvas;
    this._persistContext.clearRect(0, 0, width, height);
  }
  serializeOptions(keys, toObject = false) {
    const options = super.serializeOptions(keys, toObject);
    if (!keys)
      options.type = "brush";
    return options;
  }
  serializeOption(optionName, toObject = false) {
    if (optionName === "paths") {
      return this._options.paths.map((path2) => path2.serializeOptions(void 0, toObject));
    }
    return super.serializeOption(optionName, toObject);
  }
  createPath(brush3) {
    const path2 = new path_default(this._operation, {brush: brush3}, this._nextCanvas);
    path2.on("update", this._onPathUpdate);
    this._options.paths.push(path2);
    this.setDirty(true);
    return path2;
  }
  _onPathUpdate() {
    this._operation.setDirty(true);
    this.setDirty(true);
  }
  _onPathPersist(path2) {
    path2.renderToCanvas(this._persistCanvas);
    this._nextCanvas = path2.getCanvas();
    const context = this._nextCanvas.getContext("2d");
    context.clearRect(0, 0, this._nextCanvas.width, this._nextCanvas.height);
    this._persistedPaths.push(path2);
  }
  _getTexture() {
    return this._texture;
  }
  setDirtyForRenderer(dirty, renderer, dimensionsChanged = false) {
    super.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
    if (dirty && dimensionsChanged) {
      this._persistedPaths = [];
      this.clearPersistCanvas();
      this._options.paths.forEach((path2) => {
        path2.setDirty(true);
      });
    }
  }
  setDirty(dirty, dimensionsChanged = false) {
    for (const rendererId in this._dirtiness) {
      this.setDirtyForRenderer(dirty, this._renderers[rendererId], dimensionsChanged);
    }
  }
  render(inputDimensions) {
    const renderer = this._operation.getSDK().getRenderer();
    if (!this.isDirtyForRenderer(renderer)) {
      return;
    }
    utils_default.ensureCanvasDimensions(this._outputCanvas, inputDimensions);
    utils_default.ensureCanvasDimensions(this._persistCanvas, inputDimensions);
    this._options.paths.forEach((path2) => {
      path2.render(inputDimensions);
      if (path2.getClosed() && this._persistedPaths.indexOf(path2) === -1) {
        this._onPathPersist(path2);
      }
    });
    this.clearCanvas();
    this._outputContext.drawImage(this._persistCanvas, 0, 0);
    this._options.paths.forEach((path2) => {
      if (!path2.getClosed()) {
        path2.renderToCanvas(this._outputCanvas);
      }
    });
    this.setDirtyForRenderer(false, renderer);
  }
  update(sdk14, inputDimensions) {
    if (inputDimensions) {
      utils_default.ensureCanvasDimensions(this._outputCanvas, inputDimensions);
      utils_default.ensureCanvasDimensions(this._persistCanvas, inputDimensions);
      this._texture.getBaseTexture().update();
    }
    this.render(inputDimensions);
    const renderer = sdk14.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(this._texture.getBaseTexture());
    }
    super.update(sdk14, inputDimensions);
  }
  _reset() {
    this._persistedPaths = [];
    if (this._operation) {
      this._operation.setDirty(true);
    }
    this.setDirty(true);
    this.clearCanvas();
    this.clearPersistCanvas();
  }
  getCanvas() {
    return this._outputCanvas;
  }
  _createRadialBrush() {
    return new RadialBrush();
  }
  _getTempCanvas() {
    return this._nextCanvas;
  }
  dispose() {
    super.dispose();
    this._texture && this._texture.getBaseTexture().dispose();
  }
}
BrushSprite.prototype.availableOptions = {
  id: {type: OptionType.STRING, default: () => utils_default.getUUID()},
  position: {type: OptionType.VECTOR2, default: new Vector223(0, 0)},
  scale: {type: OptionType.VECTOR2, default: new Vector223(1, 1)},
  anchor: {type: OptionType.VECTOR2, default: new Vector223(0, 0)},
  pivot: {type: OptionType.VECTOR2, default: new Vector223(0, 0)},
  rotation: {type: OptionType.NUMBER, default: 0},
  paths: {
    type: OptionType.ARRAY,
    default: [],
    setter(paths) {
      paths = paths.map((path2) => {
        if (path2 instanceof path_default)
          return path2;
        const {brush: brush3, closed} = path2;
        const newPath = new path_default(this._operation, {brush: brush3, closed}, this._nextCanvas);
        path2.controlPoints.forEach((position) => {
          newPath.addControlPoint(position);
        });
        return newPath;
      });
      this._reset();
      return paths;
    }
  }
};
BrushSprite.type = "brush";
BrushSprite.Brush = Brush;
BrushSprite.Path = path_default;
BrushSprite.Brushes = {
  RadialBrush
};
var brush_sprite_default = BrushSprite;

// engine/sdk/operations/selective-blur-operation/index.js
const {Vector2: Vector224} = math_exports;
class SelectiveBlurOperation extends operation_default {
  constructor(...args) {
    super(...args);
    const renderer = this._sdk.getRenderer();
    this._lastBlurRadius = null;
    this._blurredRenderTexture = new engine_default.RenderTexture(renderer, 100, 100, 1);
    this._maskRenderTexture = new engine_default.RenderTexture(renderer, 100, 100, 1);
    this._brushSprite = new brush_sprite_default(this);
    this._brushSpriteContainer = new engine_default.Container();
    const brushSprite = this._brushSprite.getDisplayObject();
    this._brushSpriteContainer.addChild(brushSprite);
    this._outputSprite = new engine_default.Sprite();
    this._outputContainer = new engine_default.Container();
    this._outputContainer.addChild(this._outputSprite);
    this._maskFilter = new mask_filter_default();
    if (renderer.isOfType(RendererType.WEBGL)) {
      this._horizontalFilter = new blur_filter_default();
      this._verticalFilter = new blur_filter_default();
      this._sprite.setFilters([this._horizontalFilter, this._verticalFilter]);
      this._horizontalFilter.setDelta(new Vector224(1, 1));
      this._verticalFilter.setDelta(new Vector224(-1, 1));
      let baseTexture = this._maskRenderTexture.getBaseTexture();
      baseTexture.setGLUnit(this._maskFilter.getMaskImage());
      renderer.updateTexture(baseTexture, false);
      baseTexture = this._blurredRenderTexture.getBaseTexture();
      baseTexture.setGLUnit(this._maskFilter.getFilterImage());
      renderer.updateTexture(baseTexture, false);
    } else if (renderer.isOfType(RendererType.CANVAS)) {
      this._blurFilter = new blur_filter_default();
      this._sprite.setFilters([this._blurFilter]);
      this._maskFilter.setMaskCanvas(this._maskRenderTexture.getRenderTarget().getCanvas());
      this._maskFilter.setFilterCanvas(this._blurredRenderTexture.getRenderTarget().getCanvas());
    }
    this._outputSprite.setFilters([this._maskFilter]);
  }
  flip(direction) {
    this._brushSprite.applyFlip(direction);
    this.setDirty(true, true);
    this._lastBlurRadius = null;
  }
  rotate(degrees) {
    this._brushSprite.applyRotation(degrees);
    this.setDirty(true, true);
    this._lastBlurRadius = null;
  }
  transform(transformOperation, options) {
    this._brushSprite.applyTransform(transformOperation, options);
    this.setDirty(true, true);
    this._lastBlurRadius = null;
  }
  _render(inputTexture) {
    this._renderBlur(inputTexture);
    this._renderMask(inputTexture);
    this._outputSprite.setTexture(inputTexture);
    this._renderTexture.render(this._outputContainer);
    return promise_default.resolve();
  }
  _renderMask(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const maskDimensions = this._maskRenderTexture.getDimensions();
    if (!maskDimensions.equals(inputDimensions)) {
      this._maskRenderTexture.resizeTo(inputDimensions);
    }
    this._brushSprite.update(this._sdk, inputDimensions);
    this._maskRenderTexture.clear(color_default.BLACK);
    this._maskRenderTexture.render(this._brushSpriteContainer);
    const renderer = this._sdk.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(this._maskRenderTexture.getBaseTexture(), false);
    }
  }
  _renderBlur(inputTexture) {
    const inputDimensions = inputTexture.getDimensions();
    const blurredDimensions = this._blurredRenderTexture.getDimensions();
    if (!blurredDimensions.equals(inputDimensions)) {
      this._blurredRenderTexture.resizeTo(inputDimensions);
    }
    const {blurRadius} = this._options;
    if (this._lastBlurRadius !== blurRadius || !blurredDimensions.equals(inputDimensions)) {
      const renderer2 = this._sdk.getRenderer();
      let blurOptions;
      if (renderer2.isOfType(RendererType.WEBGL)) {
        const shortestSide = inputDimensions.min();
        blurOptions = {
          blurRadius: blurRadius * shortestSide,
          texSize: inputDimensions
        };
        this._horizontalFilter.set(blurOptions);
        this._verticalFilter.set(blurOptions);
      } else if (renderer2.isOfType(RendererType.CANVAS)) {
        blurOptions = {blurRadius};
        this._blurFilter.set(blurOptions);
      }
      this._blurredRenderTexture.render(this._container);
      this._lastBlurRadius = blurRadius;
    }
    const renderer = this._sdk.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(this._blurredRenderTexture.getBaseTexture(), false);
    }
  }
  getBrush() {
    return this._brushSprite;
  }
  createPath(size, hardness = 1) {
    const brush3 = new brush_sprite_default.Brushes.RadialBrush({
      size,
      hardness,
      color: color_default.WHITE
    });
    const path2 = this._brushSprite.createPath(brush3);
    this._options.paths.push(path2);
    this.setDirty(true);
    return path2;
  }
  setDirtyForRenderer(dirty, renderer, dimensionsChanged) {
    super.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
    this._brushSprite.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
  }
  dispose() {
    super.dispose();
    const renderer = this._sdk.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      this._verticalFilter.dispose();
      this._horizontalFilter.dispose();
    } else {
      this._blurFilter.dispose();
    }
    this._brushSprite.dispose();
    this._maskFilter.dispose();
    this._blurredRenderTexture.dispose();
    this._maskRenderTexture.dispose();
  }
  hasChanges() {
    return true;
  }
}
SelectiveBlurOperation.identifier = "selective-blur";
SelectiveBlurOperation.prototype.availableOptions = {
  blurRadius: {type: OptionType.NUMBER, default: 0.05},
  paths: {
    type: OptionType.ARRAY,
    default: [],
    setter(paths) {
      if (this._brushSprite) {
        this._brushSprite.setPaths(paths);
      }
      return paths;
    }
  }
};
exports_default.Operations.SelectiveBlurOperation = SelectiveBlurOperation;
var selective_blur_operation_default = SelectiveBlurOperation;

// engine/sdk/operations/sprite-operation/sprites/sticker-sprite.js
const {Vector2: Vector225, ColorMatrix: ColorMatrix7} = math_exports;
class StickerSprite extends sprite_default2 {
  constructor(...args) {
    super(...args);
    const {image: image5} = this._options;
    const src = image5.src || image5.filePath || image5.toDataUrl && image5.toDataURL();
    this._isSVG = src && !!src.match(/\w+\.svg(?=\?|$)/i);
    if (this._isSVG) {
      this._canvas = utils_default.createCanvas();
      this._context = this._canvas.getContext("2d");
      this._options.smoothDownscaling = false;
    }
    if (image5) {
      this._onImageUpdate();
    }
    this._tintFilter = new engine_default.Filters.TintFilter();
    this._adjustmentsFilter = new adjustments_filter_default();
    this._lastRenderedDimensions = Vector225.NULL;
    this._lastRenderedInputDimensions = Vector225.NULL;
    this._onOptionsChange = this._onOptionsChange.bind(this);
    this._options.adjustments.on("update", this._onOptionsChange);
  }
  applyScale(scale) {
    this.setDimensions(this.getDimensions().multiply(scale));
  }
  serializeOptions(keys, toObject = false) {
    const options = super.serializeOptions(keys, toObject);
    if (!keys)
      options.type = "sticker";
    return options;
  }
  _rendersToRenderTexture(sdk14) {
    const smoothDownscaling = this._options.smoothDownscaling && !this._isSVG && sdk14.getRenderer().isOfType(RendererType.WEBGL);
    return smoothDownscaling || this._hasAdjustments() || this._options.tintMode !== "none";
  }
  _getTexture() {
    return this._inputTexture;
  }
  update(sdk14, inputDimensions) {
    const {dimensions, image: image5} = this._options;
    if (dimensions.equals(Vector225.NULL)) {
      dimensions.set(image5.width, image5.height);
    }
    this._sprite.setSmoothDownscaling(this._isSVG ? false : this.getSmoothDownscaling());
    const isDirty = !this._lastRenderedInputDimensions.equals(inputDimensions) || !this._lastRenderedDimensions.equals(dimensions) || this._lastRenderedImage !== image5;
    if (isDirty && this._isSVG && sdk14.getRenderer().isOfType(RendererType.WEBGL)) {
      image5.width = Math.round(dimensions.x);
      image5.height = Math.round(dimensions.y);
      const maxDimensions = 4096;
      const imgAspect = image5.width / image5.height;
      if (image5.width > maxDimensions) {
        image5.width = maxDimensions;
        image5.height = Math.round(image5.width / imgAspect);
      }
      if (image5.height > maxDimensions) {
        image5.height = maxDimensions;
        image5.width = Math.round(image5.height * imgAspect);
      }
      this._canvas.width = image5.width;
      this._canvas.height = image5.height;
      this._context.clearRect(0, 0, image5.width, image5.height);
      this._context.drawImage(image5, 0, 0, image5.width, image5.height);
      this._inputTexture.getBaseTexture().update();
    }
    if (this._rendersToRenderTexture(sdk14)) {
      this._prepareRenderTexture(sdk14);
    }
    const filters = [];
    if (this._rendersToRenderTexture(sdk14)) {
      if (this._hasAdjustments()) {
        filters.push(this._adjustmentsFilter);
        const {adjustments: adjustments2} = this._options;
        const colorMatrix = new ColorMatrix7();
        colorMatrix.multiply(ColorMatrix7.createBrightnessMatrix(adjustments2.getBrightness()));
        colorMatrix.multiply(ColorMatrix7.createSaturationMatrix(adjustments2.getSaturation()));
        colorMatrix.multiply(ColorMatrix7.createContrastMatrix(adjustments2.getContrast()));
        this._adjustmentsFilter.set({
          colorMatrix
        });
      }
      if (this._options.tintMode && this._options.tintMode !== "none") {
        filters.push(this._tintFilter);
        this._tintFilter.set({
          mode: engine_default.Filters.TintFilter.MODES[this._options.tintMode.toUpperCase()],
          color: this._options.tintColor
        });
        if (this._sprite.getTexture() && this._sprite.getTexture()._baseTexture) {
          this._sprite.getTexture()._baseTexture.setDirty(true);
        }
      }
      this._renderTextureSprite.setFilters(filters);
    }
    if (this._rendersToRenderTexture(sdk14)) {
      this._renderToRenderTexture(sdk14);
    } else {
      this._sprite.setTexture(this._inputTexture);
    }
    this._updateSprite(inputDimensions);
    this._applyFlip();
    this._lastRenderedDimensions.copy(dimensions);
    this._lastRenderedInputDimensions.copy(inputDimensions);
    this._lastRenderedImage = image5;
  }
  _applyFlip() {
    const scale = this._sprite.getScale();
    const {flipHorizontally, flipVertically} = this._options;
    if (flipHorizontally && scale.x > 0 || !flipHorizontally && scale.x < 0) {
      scale.x *= -1;
    }
    if (flipVertically && scale.y > 0 || !flipVertically && scale.y < 0) {
      scale.y *= -1;
    }
    this._sprite.setScale(scale);
  }
  applyFlip(direction) {
    super.applyFlip(direction);
    const options = {
      rotation: this._options.rotation
    };
    const degrees = options.rotation / Math.PI * 180;
    const newDegrees = degrees * -1;
    options.rotation = newDegrees * Math.PI / 180;
    switch (direction) {
      case "horizontal":
        options.flipHorizontally = !this._options.flipHorizontally;
        this.set(options);
        break;
      case "vertical":
        options.flipVertically = !this._options.flipVertically;
        this.set(options);
        break;
    }
  }
  _hasAdjustments() {
    const {adjustments: adjustments2} = this._options;
    return adjustments2.getBrightness() !== 0 || adjustments2.getSaturation() !== 1 || adjustments2.getContrast() !== 1;
  }
  _onImageUpdate() {
    let textureImage = this._options.image;
    const renderer = this._operation.getSDK().getRenderer();
    if (this._isSVG && renderer.isOfType(RendererType.WEBGL)) {
      textureImage = this._canvas;
    }
    if (this._inputTexture) {
      this._inputTexture.dispose();
      this._inputTexture = null;
    }
    this._inputTexture = engine_default.Texture.fromImage(textureImage);
    this._identitySprite.setTexture(this._inputTexture);
    this._sprite.setTexture(this._inputTexture);
    if (this._renderTexture) {
      this._renderTextureSprite.setTexture(this._inputTexture);
      this._renderTexture.resizeTo(this._inputTexture.getDimensions());
    }
    this.setDirty(true);
  }
  scalesUniformly() {
    return this._options.resizeMode === "keepAspect";
  }
  setOption(optionName, value, update = true) {
    super.setOption(optionName, value, update);
    if (optionName === "image" && this._identitySprite) {
      this._onImageUpdate();
    }
  }
  _onOptionsChange() {
    const dirtiness = this._dirtiness;
    for (const id in dirtiness) {
      dirtiness[id] = true;
    }
  }
  dispose() {
    super.dispose();
    if (this._inputTexture) {
      this._inputTexture.dispose();
      this._inputTexture = null;
    }
    this._tintFilter.dispose();
    this._adjustmentsFilter.dispose();
    this._options.adjustments.off("updated", this._onOptionsChange);
  }
}
StickerSprite.prototype.availableOptions = {
  id: {type: OptionType.STRING, default: () => utils_default.getUUID()},
  identifier: {type: OptionType.STRING, default: ""},
  image: {type: OptionType.IMAGE, required: true},
  position: {type: OptionType.VECTOR2, default: Vector225.NULL},
  dimensions: {type: OptionType.VECTOR2, default: Vector225.NULL},
  anchor: {type: OptionType.VECTOR2, default: new Vector225(0, 0)},
  pivot: {type: OptionType.VECTOR2, default: new Vector225(0.5, 0.5)},
  rotation: {type: OptionType.NUMBER, default: 0},
  flipHorizontally: {type: OptionType.BOOLEAN, default: false},
  flipVertically: {type: OptionType.BOOLEAN, default: false},
  smoothDownscaling: {type: OptionType.BOOLEAN, default: false},
  tintColor: {type: OptionType.COLOR, default: color_default.WHITE},
  tintMode: {
    type: OptionType.STRING,
    default: "none",
    available: ["none", "solid", "colorized"]
  },
  resizeMode: {
    type: OptionType.STRING,
    default: "keepAspect",
    available: ["keepAspect", "unrestricted"]
  },
  alpha: {type: OptionType.NUMBER, default: 1},
  adjustments: {
    type: OptionType.CONFIGURABLE,
    structure: {
      brightness: {type: OptionType.NUMBER, default: 0},
      saturation: {type: OptionType.NUMBER, default: 1},
      contrast: {type: OptionType.NUMBER, default: 1}
    }
  }
};
StickerSprite.type = "sticker";
var sticker_sprite_default = StickerSprite;

// engine/sdk/operations/sprite-operation/sprites/text-design/models/randomizer.js
class Randomizer {
  constructor(seed) {
    this._seed = seed === void 0 ? Randomizer.TimeSeed() : seed;
  }
  seed(value) {
    this._seed = value === void 0 ? Randomizer.TimeSeed() : value;
  }
  next() {
    let seed = this._seed | 0;
    const highPass = seed / Randomizer.SEED_DIVIDER | 0;
    const lowPass = seed % Randomizer.SEED_DIVIDER | 0;
    seed = Randomizer.SEED_LOW_MULTIPLY * lowPass - Randomizer.SEED_HIGH_MULTIPLY * highPass;
    if (seed <= 0) {
      seed += Randomizer.MAX;
    }
    if (seed === -1) {
      seed = Randomizer.MAX - 1;
    }
    this._seed = seed;
    return seed;
  }
  nextInRange(min, max) {
    if (max === void 0) {
      max = min;
      min = 0;
    }
    return min + this.next() % (max - min + 1);
  }
  nextBool(falseChance = 1, trueChance = 1) {
    return this.nextInRange(falseChance + trueChance - 1) >= falseChance;
  }
  static TimeSeed() {
    return Date.now();
  }
  pickNext(array) {
    if (!Array.isArray(array)) {
      return null;
    }
    return array[this.next() % array.length];
  }
}
Randomizer.MAX = 2147483647;
Randomizer.SEED_DIVIDER = 127773;
Randomizer.SEED_LOW_MULTIPLY = 16807;
Randomizer.SEED_HIGH_MULTIPLY = 2836;

// engine/sdk/operations/sprite-operation/sprites/text-design/models/size-value.js
const {Rectangle: Rectangle3} = math_exports;
class SizeValue {
  constructor(width = 0, height = 0) {
    this.width = width;
    this.height = height;
  }
  set(width, height) {
    this.width = width;
    this.height = height;
  }
  aspect() {
    return this.width / this.height;
  }
  rectangle(x, y) {
    return new Rectangle3(x, y, this.width, this.height);
  }
  clone() {
    return new SizeValue(this.width, this.height);
  }
  scale(sx, sy) {
    if (sy === void 0) {
      sy = sx;
    }
    this.width *= sx;
    this.height *= sy;
    return this;
  }
  copy(size) {
    this.width = size.width;
    this.height = size.height;
    return this;
  }
  fitInWidthWithOther(width, otherSizeValue = new SizeValue()) {
    this.copy(SizeValue.fitTwoInWidth(width, this, otherSizeValue)[0]);
    return this;
  }
  static fitTwoInWidth(width, size1, size2) {
    const crossRatio = size1.width * size2.height + size1.height * size2.width;
    const a = size2.height * width / crossRatio;
    const newWidth1 = size1.width * a;
    const newHeight = size1.height * a;
    return [
      new SizeValue(newWidth1, newHeight),
      new SizeValue(width - newWidth1, newHeight)
    ];
  }
}

// engine/sdk/operations/sprite-operation/sprites/text-design/text-design-asset-manager.js
const p_map = __toModule(require("p-map"));
class TextDesignAssetManager extends configurable_default {
  loadImages(images) {
    return __async(this, null, function* () {
      return p_map.default(images, (image5) => __async(this, null, function* () {
        return this.addImage(image5.path, image5.fullPath, image5.image);
      }));
    });
  }
  addImage(path2, fullPath, image5, crossOrigin = "anonymous") {
    const images = this.getImages();
    if (!image5) {
      return new Promise((resolve, reject) => {
        image5 = new image_default();
        image5.onload = () => {
          images[path2] = {fullPath, image: image5};
          resolve({fullPath, image: image5});
        };
        image5.crossOrigin = utils_default.getCrossOriginValue(crossOrigin);
        image5.onerror = reject;
        image5.src = fullPath;
      });
    }
    images[path2] = {fullPath, image: image5};
    return Promise.resolve({fullPath, image: image5});
  }
  getImage(path2) {
    const images = this.getImages();
    const image5 = images[path2];
    return image5 ? image5.image : null;
  }
  getVariation(identifier) {
    return this.getFonts()[identifier];
  }
  addFont(identifier, fontVariation) {
    const fonts2 = this.getFonts();
    fonts2[identifier] = fontVariation;
    return fontVariation;
  }
}
TextDesignAssetManager.prototype.availableOptions = {
  images: {type: OptionType.OBJECT, default: {}},
  fonts: {type: OptionType.OBJECT, default: {}}
};
const AssetManager = new TextDesignAssetManager();

// engine/sdk/operations/sprite-operation/sprites/text-design/text/text-design-font.js
class TextDesignFont extends configurable_default {
  constructor(options) {
    super(options);
    const fontVariation = AssetManager.getVariation(this.getFontIdentifier());
    if (!fontVariation) {
      log_default.warn(`TextDesignFont: Unable to find font '${this._fontIdentifier}'`);
    }
    this.set({fontVariation});
    this._metrics = null;
    this._canvas = utils_default.createCanvas();
    this._context = this._canvas.getContext("2d");
    this._isDirty = true;
  }
  _onOptionsChange() {
    this._isDirty = true;
  }
  setOption(optionName, value, update = true, initial = false) {
    super.setOption(optionName, value, update, initial);
    if (optionName === "fontIdentifier" && !initial) {
      this.updateFontVariation();
    }
  }
  updateFontVariation() {
    const fontVariation = AssetManager.getVariation(this.getFontIdentifier());
    if (!fontVariation) {
      log_default.warn(`TextDesignFont: Unable to find font '${this._fontIdentifier}'`);
    }
    this.setFontVariation(fontVariation);
    return fontVariation;
  }
  setOptions(options = {}) {
    this._options = __assign(__assign({}, this._options), options);
    this._isDirty = true;
  }
  _applyTextOptions(ctx = this._context, options = {}) {
    const {fontSize, fontVariation, lineHeight, textColor, alignment} = __assign(__assign({}, this._options), options);
    const {
      fontStyle,
      fontWeight,
      fontFamily
    } = fontVariation.serializeOptions();
    if (!process.env.REACT_APP_BROWSER) {
      ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
    }
    if (process.env.REACT_APP_BROWSER) {
      ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px / ${lineHeight} ${fontFamily}`;
    }
    ctx.fillStyle = textColor;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = alignment || "left";
  }
  getTextMetrics() {
    if (!this._metrics || this._isDirty) {
      this._calculateTextMetrics();
    }
    return __assign({}, this._metrics);
  }
  getSizeValue() {
    if (!this._metrics || this._isDirty) {
      this._calculateTextMetrics();
    }
    return new SizeValue(this._metrics.width, this._metrics.height);
  }
  fitWidth(width) {
    const variation = this.getFontVariation();
    if (!variation) {
      log_default.warn("TextDesignFont#fitText: missing font variation");
      return;
    }
    this._applyTextOptions(this._context, {fontSize: 50});
    const measuredWidth = this._context.measureText(this.getText()).width;
    const scale = width / measuredWidth;
    const fontSize = Math.floor(scale * 50);
    this.setFontSize(fontSize);
    this._calculateTextMetrics();
    return this.getTextMetrics();
  }
  fitHeight(height) {
    const variation = this.getFontVariation();
    if (!variation) {
      log_default.warn("TextDesignFont#fitText: missing font variation");
      return;
    }
    const measuredHeight = this._calculateTextMetrics({fontSize: 50}).height;
    const scale = height / measuredHeight;
    const fontSize = Math.floor(scale * 50);
    this.setFontSize(fontSize);
    this._calculateTextMetrics();
    return this.getTextMetrics();
  }
  _calculateTextMetrics(overrideOptions = {}) {
    const canvas9 = this._canvas;
    const ctx = this._context;
    const options = __assign(__assign({}, this._options), overrideOptions);
    const text = this.getText();
    this._applyTextOptions(ctx, options);
    const textWidth = Math.ceil(ctx.measureText(text).width);
    const canvasWidth = Math.floor(textWidth + options.fontSize * 2);
    const canvasHeight = Math.floor(options.fontSize * 3);
    canvas9.width = canvasWidth;
    canvas9.height = canvasHeight;
    const xPos = Math.floor(options.fontSize);
    const yPos = Math.floor(canvasHeight * (3 / 5));
    this._applyTextOptions(ctx, options);
    ctx.fillText(text, xPos, yPos);
    const pixels = ctx.getImageData(0, 0, canvas9.width, canvas9.height).data;
    const ascender = getAscender(pixels, canvasWidth, canvasHeight, yPos, this._options.excludeAccents);
    const descender = getDescender(pixels, canvasWidth, canvasHeight, yPos, this._options.excludeAccents);
    const width = textWidth;
    const height = ascender + descender;
    this._metrics = {
      width,
      height,
      ascender,
      descender
    };
    this._isDirty = false;
    return __assign({}, this._metrics);
  }
  draw(ctx = this._context, x = 0, y = 0, options, debug = false) {
    ctx.save();
    if (!this._metrics || this._isDirty) {
      this._calculateTextMetrics();
    }
    this._applyTextOptions(ctx, options);
    ctx.fillText(this.getText(), x, y + this._metrics.ascender);
    if (debug) {
      drawRect(ctx, x, y, this._metrics.width, this._metrics.height);
      hLine(ctx, y + this._metrics.ascender, x, x + this._metrics.width);
    }
    ctx.restore();
  }
}
const getPixel = (data, x, y, width) => {
  const index = y * (width * 4) + x * 4;
  const pixel = {
    r: data[index],
    g: data[index + 1],
    b: data[index + 2],
    a: data[index + 3]
  };
  return pixel;
};
const isTransparent = (pixel) => pixel.a <= 254;
const isBlankScanline = (data, y, width) => {
  let isBlank = true;
  for (let x = 0; x < width; x++) {
    const pixel = getPixel(data, x, y, width);
    if (!isTransparent(pixel)) {
      isBlank = false;
      break;
    }
  }
  return isBlank;
};
const getDescender = (pixels, width, height, startY, exitOnFirstBlank = false) => {
  let descender = 0;
  for (let y = startY + 1; y < height; y++) {
    if (!isBlankScanline(pixels, y, width)) {
      descender = y - startY + 1;
    } else if (exitOnFirstBlank) {
      break;
    }
  }
  return descender;
};
const getAscender = (pixels, width, height, startY, exitOnFirstBlank = false) => {
  let ascender = 0;
  for (let y = startY - 1; y >= 0; y--) {
    if (!isBlankScanline(pixels, y, width)) {
      ascender = startY - y;
    } else if (exitOnFirstBlank) {
      break;
    }
  }
  return ascender;
};
const strokeLine = (ctx, fromX, fromY, toX, toY) => {
  ctx.beginPath();
  ctx.moveTo(fromX, fromY);
  ctx.lineTo(toX, toY);
  ctx.stroke();
};
const hLine = (ctx, y, xmin, xmax, color6 = "red") => {
  ctx.save();
  ctx.strokeStyle = color6;
  strokeLine(ctx, xmin, y, xmax, y);
  ctx.restore();
};
const drawRect = (ctx, x, y, width, height, color6 = "blue") => {
  ctx.save();
  ctx.strokeStyle = color6;
  ctx.strokeRect(x, y, width, height);
  ctx.restore();
};
TextDesignFont.prototype.availableOptions = {
  text: {type: OptionType.STRING, default: ""},
  fontIdentifier: {
    type: OptionType.STRING,
    default: "imgly_font_open_sans_bold"
  },
  fontVariation: {type: OptionType.OBJECT, default: null},
  lineHeight: {type: OptionType.NUMBER, default: 1},
  fontSize: {type: OptionType.NUMBER, default: 22},
  textColor: {type: OptionType.STRING, default: "black"},
  strokeStyle: {type: OptionType.STRING, default: "black"},
  outlineWidth: {type: OptionType.NUMBER, default: 0},
  textBaseline: {type: OptionType.STRING, default: "alphabetic"},
  excludeAccents: {type: OptionType.BOOLEAN, default: false}
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-element.js
class TextDesignElement extends configurable_default {
}
TextDesignElement.prototype.availableOptions = {
  text: {type: OptionType.STRING, default: ""},
  frame: {type: OptionType.OBJECT, default: null},
  font: {type: OptionType.OBJECT, default: null}
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-attributes.js
class TextDesignAttributes extends configurable_default {
}
TextDesignAttributes.prototype.availableOptions = {
  tintColor: {type: OptionType.COLOR, default: color_default.BLACK},
  textColor: {type: OptionType.COLOR, default: color_default.BLACK},
  alignment: {
    type: OptionType.STRING,
    default: "left",
    available: ["left", "center", "right"]
  },
  lineSpacing: {type: OptionType.NUMBER, default: 1},
  fontIdentifier: {
    type: OptionType.STRING,
    default: "imgly_font_open_sans_bold"
  }
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/default/text-design-row.js
const {Rectangle: Rectangle4} = math_exports;
class TextDesignRow extends configurable_default {
  constructor(options) {
    super(options);
    this.setSize(new SizeValue(this.getWidth(), 0));
    this.serverImageSmoothingFix = false;
  }
  _getFrame() {
    const size = this.getSize();
    return new Rectangle4(0, 0, size.width, size.height);
  }
  _getTextFrame() {
    return this._getFrame();
  }
  _getTextFrameForElement(element) {
    return element.getFrame().clone();
  }
  _calculateLayoutElements() {
    log_default.warn("TextDesignRow is an abstract class.");
  }
  _getLayoutElements() {
    if (this._options.elements.length <= 0) {
      this.layout();
    }
    return this.getElements();
  }
  _fontSize(element) {
    log_default.warn("TextDesignRow#_fontSize not implemented. @TODO: Is it necessary?");
    return 0;
  }
  layout() {
    this.setElements(this._calculateLayoutElements());
    return this;
  }
  textFrame(element, fontSize) {
    return element.getFrame().clone();
  }
  willRender(context) {
  }
  didRender(context) {
  }
  render(context) {
    context.save();
    this._getLayoutElements().forEach((element) => {
      const {text, frame: frame2, font: font2} = element.serializeOptions();
      const attributes = this.getAttributes();
      font2.draw(context, frame2.x, frame2.y, {
        textColor: attributes.getTextColor().toRGBA(),
        alignment: attributes.getAlignment()
      });
    });
    context.restore();
  }
}
TextDesignRow.prototype.availableOptions = {
  words: {type: OptionType.OBJECT, default: null},
  width: {type: OptionType.NUMBER, default: 100},
  attributes: {
    type: OptionType.CONFIGURABLE,
    default: new TextDesignAttributes()
  },
  shearingAngle: {type: OptionType.NUMBER, default: 0},
  elements: {type: OptionType.ARRAY, default: []},
  size: {type: OptionType.OBJECT, default: null}
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/blocks/text-design-row-triple.js
const {Rectangle: Rectangle5} = math_exports;
class TextDesignRowTriple extends TextDesignRow {
  _calculateLayoutElements() {
    if (this.getWords().size() <= 0) {
      return [];
    }
    const {
      orientation,
      width,
      size,
      relativeRowOffset,
      attributes
    } = this.serializeOptions();
    const {fontIdentifier} = attributes;
    const wordGroups = this.getWords().joined(3);
    const lines = orientation === TextDesignRowTriple.Orientations.Left ? [wordGroups[0], wordGroups[1], wordGroups[2]] : [wordGroups[1], wordGroups[2], wordGroups[0]];
    const dummyFonts = utils_default.Array.range(0, 2).map((i) => new TextDesignFont({
      text: lines[i],
      fontIdentifier,
      fontSize: 60
    }));
    const dummySizes = dummyFonts.map((font2) => font2.getSizeValue());
    const largestWidthIndex = dummySizes[0].width > dummySizes[1].width ? 0 : 1;
    const smallestWidthIndex = (largestWidthIndex + 1) % 2;
    dummyFonts[smallestWidthIndex].fitWidth(dummySizes[largestWidthIndex].width);
    dummySizes[smallestWidthIndex] = dummyFonts[smallestWidthIndex].getSizeValue();
    const dummyHeight = (dummySizes[smallestWidthIndex].height + dummySizes[largestWidthIndex].height) / (1 - relativeRowOffset);
    const dummySingleRowFont = new TextDesignFont({
      text: lines[2],
      fontIdentifier
    });
    dummySingleRowFont.fitHeight(dummyHeight);
    const dummySingleRowWidth = dummySingleRowFont.getSizeValue().width;
    const dummyDoubleRowWidth = dummySizes[largestWidthIndex].width;
    const scale = width / (dummySingleRowWidth + dummyDoubleRowWidth);
    const singleRowWidth = scale * dummySingleRowWidth;
    const doubleRowWidth = scale * dummyDoubleRowWidth;
    const rowHeight = scale * dummyHeight;
    const offset = relativeRowOffset * rowHeight;
    size.set(width, rowHeight);
    const fonts2 = utils_default.Array.range(0, 3).map((i) => new TextDesignFont({text: lines[i], fontIdentifier}));
    fonts2[0].fitWidth(doubleRowWidth);
    fonts2[1].fitWidth(doubleRowWidth);
    fonts2[2].fitWidth(singleRowWidth);
    const doubleRowX = orientation === TextDesignRowTriple.Orientations.Left ? 0 : singleRowWidth;
    const singleRowX = orientation === TextDesignRowTriple.Orientations.Left ? doubleRowWidth : 0;
    const xOffsets = [doubleRowX, doubleRowX, singleRowX];
    const yOffsets = [0, fonts2[0].getSizeValue().height + offset, 0];
    const frames = fonts2.map((font2, i) => new Rectangle5(xOffsets[i], yOffsets[i], font2.getSizeValue().width, font2.getSizeValue().height));
    return fonts2.map((font2, i) => new TextDesignElement({
      text: lines[i],
      font: fonts2[i],
      frame: frames[i]
    }));
  }
}
TextDesignRowTriple.Orientations = {
  Right: "RIGHT",
  Left: "LEFT"
};
TextDesignRowTriple.prototype.availableOptions = __assign(__assign({}, TextDesignRow.prototype.availableOptions), {
  orientation: {
    type: OptionType.STRING,
    default: TextDesignRowTriple.Orientations.Left,
    available: [
      TextDesignRowTriple.Orientations.Right,
      TextDesignRowTriple.Orientations.Left
    ]
  },
  relativeRowOffset: {type: OptionType.NUMBER, default: 0.05}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rectangle-insets.js
const {Rectangle: Rectangle6} = math_exports;
class RectangleInsets {
  constructor(top = 0, left = 0, bottom = 0, right = 0) {
    this.top = top;
    this.left = left;
    this.bottom = bottom;
    this.right = right;
  }
  multiply(a) {
    this.top *= a;
    this.left *= a;
    this.bottom *= a;
    this.right *= a;
  }
  toObject() {
    return __assign({}, this);
  }
  equals(r, eps = 0) {
    return Math.abs(r.top - this.top) <= eps && Math.abs(r.left - this.left) <= eps && Math.abs(r.bottom - this.bottom) <= eps && Math.abs(r.right - this.right) <= eps;
  }
  scale(sx = 1, sy) {
    if (sy === void 0) {
      sy = sx;
    }
    this.top *= sy;
    this.bottom *= sy;
    this.left *= sx;
    this.right *= sx;
    return this;
  }
  clone() {
    return new RectangleInsets(this.top, this.left, this.bottom, this.right);
  }
  applyToRectangle(rect) {
    return new Rectangle6(rect.x + this.left, rect.y + this.top, rect.width - this.left - this.right, rect.height - this.top - this.bottom);
  }
  static get ZERO() {
    return new RectangleInsets(0, 0, 0, 0);
  }
}

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/default/text-design-row-single.js
class TextDesignRowSingle extends TextDesignRow {
  _calculateLayoutElements() {
    const {attributes, imageInsets, size, width} = this.serializeOptions();
    const text = this.getWords().joined(1)[0] || "";
    const {fontIdentifier} = attributes;
    const font2 = new TextDesignFont({text, fontIdentifier});
    font2.fitWidth(this._getTextFrame().width);
    const height = font2.getTextMetrics().height + imageInsets.top + imageInsets.bottom;
    size.height = height;
    const frame2 = this._getTextFrame();
    const layoutElement = new TextDesignElement({text, frame: frame2, font: font2});
    return [layoutElement];
  }
}
TextDesignRowSingle.prototype.availableOptions = __assign(__assign({}, TextDesignRow.prototype.availableOptions), {
  imageInsets: {type: OptionType.OBJECT, default: new RectangleInsets()}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/utils/canvas.js
const {Rectangle: Rectangle7, Vector2: Vector226} = math_exports;
const drawImageRect = (context, image5, srcRect, destRect) => {
  context.drawImage(image5, srcRect.x, srcRect.y, srcRect.width, srcRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
};
const fillRect = (context, rect, color6, compositeOperation = "source-over", stroke = false) => {
  context.save();
  context.fillStyle = color6.toRGBA();
  context.globalCompositeOperation = compositeOperation;
  context.fillRect(rect.x, rect.y, rect.width, rect.height);
  if (stroke) {
    context.strokeStyle = color6.toRGBA();
    context.strokeWith = 1;
    context.strokeRect(rect.x, rect.y, rect.width, rect.height);
  }
  context.restore();
};
const drawRoundedRect = (context, rect, radius, color6, compositeOperation = "source-over", stroke = false) => {
  context.save();
  context.fillStyle = color6.toRGBA();
  context.globalCompositeOperation = compositeOperation;
  radius = Math.min(Math.max(radius, 0), Math.min(rect.height, rect.width) * 0.5);
  const left = rect.x;
  const right = rect.x + rect.width;
  const top = rect.y;
  const bottom = rect.y + rect.height;
  context.beginPath();
  context.moveTo(left + radius, top);
  context.arcTo(right, top, right, bottom, radius);
  context.arcTo(right, bottom, left, bottom, radius);
  context.arcTo(left, bottom, left, top, radius);
  context.arcTo(left, top, right, top, radius);
  context.closePath();
  context.fill();
  if (stroke) {
    context.stroke();
  }
  context.restore();
};
const strokeRect = (context, rect, color6, lineWidth = 4) => {
  context.save();
  context.strokeStyle = color6.toRGBA();
  context.lineWidth = lineWidth;
  context.strokeRect(rect.x, rect.y, rect.width, rect.height);
  context.restore();
};
const fillRectPunctuated = (context, rect, color6, compositeOperation = "source-over") => {
  context.save();
  const radius = rect.height / 2;
  const centerY = rect.y + radius;
  let centerX = rect.x + radius;
  const endX = rect.x + rect.width;
  context.fillStyle = color6.toRGBA();
  context.globalCompositeOperation = compositeOperation;
  while (centerX < endX) {
    context.beginPath();
    context.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    context.fill();
    centerX += radius * 4;
  }
  context.restore();
};
const buildCapRectangle = (rectangle3, capInsets) => {
  const center = capInsets.applyToRectangle(rectangle3);
  const {x, y, width, height} = rectangle3;
  const corners = [
    Rectangle7.FromDiagonalPoints(new Vector226(0, 0), new Vector226(center.x, center.y)),
    Rectangle7.FromDiagonalPoints(new Vector226(0, center.y + center.height), new Vector226(center.x, height)),
    Rectangle7.FromDiagonalPoints(new Vector226(center.x + center.width, center.y + center.height), new Vector226(width, height)),
    Rectangle7.FromDiagonalPoints(new Vector226(center.x + center.width, 0), new Vector226(width, center.y))
  ].map((r) => r.translate(x, y));
  const bars = [
    Rectangle7.FromDiagonalPoints(new Vector226(center.x, 0), new Vector226(center.x + center.width, center.y)),
    Rectangle7.FromDiagonalPoints(new Vector226(0, center.y), new Vector226(center.x, center.y + center.height)),
    Rectangle7.FromDiagonalPoints(new Vector226(center.x, center.y + center.height), new Vector226(center.x + center.width, height)),
    Rectangle7.FromDiagonalPoints(new Vector226(center.x + center.width, center.y), new Vector226(width, center.y + center.height))
  ].map((r) => r.translate(x, y));
  return {corners, bars, center};
};
const drawImageWithCapInsets = (context, image5, destRect, capInsets) => {
  const imageWidth = image5.naturalWidth || image5.width;
  const imageHeight = image5.naturalHeight || image5.height;
  const capSource = buildCapRectangle(new Rectangle7(0, 0, imageWidth, imageHeight), capInsets);
  const capDest = buildCapRectangle(destRect, capInsets);
  drawImageRect(context, image5, capSource.center, capDest.center);
  utils_default.Array.zip(capSource.corners, capDest.corners).forEach(([src, dst]) => drawImageRect(context, image5, src, dst));
  utils_default.Array.zip(capSource.bars, capDest.bars).forEach(([src, dst]) => drawImageRect(context, image5, src, dst));
};
const drawImageFrame = (context, image5, frame2, color6, compositeMode = "source-atop") => {
  context.save();
  if (color6) {
    context.globalAlpha = color6.a;
  }
  context.drawImage(image5, frame2.x, frame2.y, frame2.width, frame2.height);
  if (color6) {
    context.globalAlpha = 1;
  }
  if (color6) {
    const c = color6.clone();
    c.a = 1;
    fillRect(context, frame2, c, compositeMode);
  }
  context.restore();
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/masked/text-design-row-masked.js
class TextDesignRowMasked extends TextDesignRowSingle {
  _getTextColor() {
    if (this.getAutoAdjustTextColor() && !this.getIsMasked()) {
      if (this.getBackgroundColor().equals(color_default.WHITE)) {
        return color_default.BLACK;
      }
      return color_default.WHITE;
    }
    return this.getAttributes().getTextColor().clone();
  }
  _getTextFrame() {
    return this.getImageInsets().applyToRectangle(this._getFrame());
  }
  _getTextFrameForElement(element) {
    const frame2 = super._getTextFrameForElement(element);
    const imageInsets = this.getImageInsets();
    if (this.getIsMasked() || this.getIsUsedInInvertedLayout()) {
      frame2.y -= imageInsets.top;
    }
    return frame2;
  }
  willRender(context) {
    if (!process.env.REACT_APP_BROWSER) {
      if (this.serverImageSmoothingFix) {
        context.imageSmoothingEnabled = true;
      }
    }
    const attributes = this.getAttributes();
    attributes.setTextColor(this._getTextColor());
    const image5 = this.getImage();
    if (image5) {
      const capInsets = this.getCapInsets();
      const frame2 = this._getFrame();
      if (capInsets && !capInsets.equals(RectangleInsets.ZERO)) {
        drawImageWithCapInsets(context, image5, frame2, capInsets);
      } else {
        context.drawImage(image5, frame2.x, frame2.y, frame2.width, frame2.height);
      }
      fillRect(context, frame2, this.getBackgroundColor(), "source-atop", true);
    }
    if ((this.getIsMasked() || this.getIsUsedInInvertedLayout()) && image5) {
      context.save();
      context.globalCompositeOperation = "destination-out";
    }
  }
  didRender(context) {
    super.didRender(context);
    if (this.getIsMasked() || this.getIsUsedInInvertedLayout()) {
      context.restore();
    }
  }
}
TextDesignRowMasked.prototype.availableOptions = __assign(__assign({}, TextDesignRowSingle.prototype.availableOptions), {
  image: {type: OptionType.IMAGE, default: null},
  capInsets: {type: OptionType.OBJECT, default: new RectangleInsets()},
  backgroundColor: {type: OptionType.COLOR, default: color_default.WHITE},
  autoAdjustTextColor: {type: OptionType.BOOLEAN, default: true},
  isMasked: {type: OptionType.BOOLEAN, default: true},
  isUsedInInvertedLayout: {type: OptionType.BOOLEAN, default: false}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-banderole.js
class TextDesignBanderole extends configurable_default {
  insetsForWidth(width) {
    return this.getRelativeInsets().clone().scale(width);
  }
  static get Small() {
    return new TextDesignBanderole({
      imagePath: "text-design/images/imgly_text_design_asset_banderole_small.png",
      fontIdentifier: "imgly_font_campton_bold",
      relativeInsets: new RectangleInsets(0.05, 0.2, 0.05, 0.2)
    });
  }
  static get Rectangle() {
    return new TextDesignBanderole({
      imagePath: "text-design/images/imgly_text_design_asset_black_background.png",
      fontIdentifier: "imgly_font_campton_bold",
      relativeInsets: new RectangleInsets(0.05, 0.05, 0.05, 0.05),
      needsImageSmoothingFix: true
    });
  }
  static get Celebrate1() {
    return new TextDesignBanderole({
      imagePath: "text-design/images/imgly_text_design_asset_celebrate_01.png",
      fontIdentifier: "imgly_font_rasa_500",
      relativeInsets: new RectangleInsets(0.05, 0.2, 0.05, 0.2)
    });
  }
  static get Celebrate2() {
    return new TextDesignBanderole({
      imagePath: "text-design/images/imgly_text_design_asset_celebrate_02.png",
      fontIdentifier: "imgly_font_rasa_500",
      relativeInsets: new RectangleInsets(0.05, 0.2, 0.05, 0.2)
    });
  }
}
TextDesignBanderole.prototype.availableOptions = {
  image: {type: OptionType.IMAGE, default: null},
  imagePath: {type: OptionType.STRING, default: null},
  relativeInsets: {type: OptionType.OBJECT, default: new RectangleInsets()},
  fontIdentifier: {
    type: OptionType.STRING,
    default: "imgly_font_open_sans_bold"
  },
  needsImageSmoothingFix: {type: OptionType.BOOLEAN, default: false}
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/text-design-layout-data.js
class TextDesignLayoutData extends configurable_default {
  getSize() {
    const rows = this.getRows();
    const width = this.getWidth();
    const lineCount = rows.length - 1;
    let height = rows.reduce((acc, row) => acc + row.getSize().height, 0);
    height += (lineCount + 1) * this.getRelativeLineSpacing() * width;
    const insets = this.getRelativeInsets().clone().scale(width);
    height += insets.top + insets.bottom;
    return new SizeValue(width, height);
  }
}
TextDesignLayoutData.prototype.availableOptions = {
  text: {type: OptionType.STRING, default: ""},
  lines: {type: OptionType.ARRAY, default: []},
  relativeInsets: {type: OptionType.OBJECT, default: new RectangleInsets()},
  relativeLineSpacing: {type: OptionType.NUMBER, default: 0},
  rows: {type: OptionType.OBJECT, default: []},
  background: {type: OptionType.OBJECT, default: null},
  width: {type: OptionType.NUMBER, default: 0}
};

// engine/sdk/operations/sprite-operation/sprites/text-design/text/words.js
class Words {
  constructor(text) {
    this.words = [];
    if (text) {
      this.splitIntoWords(text);
    }
  }
  splitIntoWords(text) {
    this.words = text.match(/\S+/g) || [];
    return [...this.words];
  }
  get() {
    return [...this.words];
  }
  getWord(index) {
    return this.words[index];
  }
  set(words8) {
    this.words = [...words8];
    return this;
  }
  slice(start, end) {
    return Words.fromWords(this.words.slice(start, end));
  }
  getLowerCase() {
    return this.words.map((w) => w.toLowerCase());
  }
  getUpperCase() {
    return this.words.map((w) => w.toUpperCase());
  }
  size() {
    return this.words.length;
  }
  countNumberOfCharacters() {
    return this.words.reduce((acc, s) => acc + s.length, 0);
  }
  joined(numberOfLines) {
    const numberOfWords = this.size();
    const wordsPerLine = Math.floor(numberOfWords / numberOfLines);
    const extraWords = numberOfWords % numberOfLines;
    let lineStartPos = 0;
    let lineEndPos = 0;
    return utils_default.Array.range(0, numberOfLines).map((i) => {
      lineStartPos = lineEndPos;
      const numOfWordsInLine = wordsPerLine + (i < extraWords ? 1 : 0);
      lineEndPos = Math.min(lineStartPos + numOfWordsInLine, numberOfWords);
      return utils_default.Array.range(lineStartPos, lineEndPos).reduce((line, j) => line + (j === lineStartPos ? "" : " ") + this.words[j], "");
    });
  }
  static fromWords(words8) {
    const result = new Words();
    result.words = [...words8];
    return result;
  }
}

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design.js
const MAXIMUM_NUMBER_OF_TRIES = 10;
const MIN_LINE_COUNT_OF_RANDOM = 4;
const RANDOM_ADDITIONAL_LINE_PERCENTAGE = 0.4;
class TextDesign extends configurable_default {
  constructor(options) {
    super(options);
    this._relativeInsets = new RectangleInsets();
    this._background = null;
    this._fontRandomizer = new Randomizer(0);
    this._lineNumberRandomizer = new Randomizer(0);
    this._wordsPerLineRandomizer = new Randomizer(0);
    this._seedPool = [
      this._fontRandomizer,
      this._lineNumberRandomizer,
      this._wordsPerLineRandomizer
    ];
  }
  seed(value) {
    this._seedPool.forEach((s) => s.seed(value));
  }
  getImagePaths() {
    return [];
  }
  onImagesLoaded() {
  }
  getMaximumNumberOfTries() {
    return MAXIMUM_NUMBER_OF_TRIES;
  }
  getMinLineCountOfRandom() {
    return MIN_LINE_COUNT_OF_RANDOM;
  }
  getRandomAdditionalLinePercentage() {
    return RANDOM_ADDITIONAL_LINE_PERCENTAGE;
  }
  _fontForRow(index, words8) {
    return this._fontRandomizer.pickNext(this.getFontIdentifiers());
  }
  _modifiedText(text) {
    return text.replace("\n", " ").replace("	", " ");
  }
  _minimumNumberOfLines(words8) {
    return Math.ceil(Math.sqrt(words8.size()));
  }
  _maximumNumberOfLines(words8) {
    return words8.size();
  }
  _calculatedNumberOfLines(words8) {
    let lineCount = this._minimumNumberOfLines(words8);
    if (words8.size() >= this.getMinLineCountOfRandom()) {
      const max = Math.floor(Math.max(1, lineCount * this.getRandomAdditionalLinePercentage()));
      lineCount += this._lineNumberRandomizer.nextInRange(0, max);
    }
    return Math.min(lineCount, this._maximumNumberOfLines(words8));
  }
  _randomizedNumberOfWordsPerLine(numberOfLines, numberOfWords) {
    if (numberOfLines > numberOfWords) {
      log_default.warn("TextDesign#_randomizedNumberOfWordsPerLine: Invalid number of lines");
      return numberOfWords;
    }
    const wordsPerLine = utils_default.Array.repeat(1, numberOfLines);
    utils_default.Array.range(numberOfLines, numberOfWords).forEach((_) => {
      const index = this._wordsPerLineRandomizer.nextInRange(0, numberOfLines - 1);
      wordsPerLine[index] += 1;
    });
    return wordsPerLine;
  }
  _textLines(text) {
    const words8 = new Words(text);
    const numberOfLines = this._calculatedNumberOfLines(words8);
    const numberOfWordsPerLine = this._randomizedNumberOfWordsPerLine(numberOfLines, words8.size());
    return numberOfWordsPerLine.reduce((acc, numOfWordsInLine) => ({
      index: acc.index + numOfWordsInLine,
      lines: [
        ...acc.lines,
        words8.slice(acc.index, Math.min(acc.index + numOfWordsInLine, words8.size()))
      ]
    }), {index: 0, lines: []}).lines;
  }
  _validTextLines(text) {
    let textLines = this._textLines(text);
    let indexOfLineWithLassThan3Chars = 0;
    do {
      indexOfLineWithLassThan3Chars = utils_default.Array.findIndex(textLines, (words8) => words8.countNumberOfCharacters() < 3);
      if (indexOfLineWithLassThan3Chars >= 0) {
        const lineBefore = textLines[indexOfLineWithLassThan3Chars - 1];
        const lineAfter = textLines[indexOfLineWithLassThan3Chars + 1];
        const charCountOfLineBefore = lineBefore ? lineBefore.countNumberOfCharacters() : Number.MAX_SAFE_INTEGER;
        const charCountOfLineAfter = lineAfter ? lineAfter.countNumberOfCharacters() : Number.MAX_SAFE_INTEGER;
        if (charCountOfLineBefore < charCountOfLineAfter && lineBefore) {
          lineBefore.words = [
            ...lineBefore.words,
            ...textLines[indexOfLineWithLassThan3Chars].words
          ];
          textLines = [
            ...textLines.slice(0, indexOfLineWithLassThan3Chars),
            ...textLines.slice(indexOfLineWithLassThan3Chars + 1)
          ];
        } else if (lineAfter) {
          lineAfter.words = [
            ...textLines[indexOfLineWithLassThan3Chars].words,
            ...lineAfter.words
          ];
          textLines = [
            ...textLines.slice(0, indexOfLineWithLassThan3Chars),
            ...textLines.slice(indexOfLineWithLassThan3Chars + 1)
          ];
        }
      }
    } while (indexOfLineWithLassThan3Chars > -1 && textLines.length > 1);
    return textLines;
  }
  _modifiedLines(lines) {
    return lines;
  }
  _getBackground() {
    return this._background;
  }
  generateLayoutData(text, width) {
    const updatedText = this._modifiedText(text);
    const lines = this._modifiedLines(this._validTextLines(updatedText));
    const insetWidth = width * (1 - this._relativeInsets.left - this._relativeInsets.right);
    const rows = this._layoutRows(lines, insetWidth);
    return new TextDesignLayoutData({
      text: updatedText,
      relativeInsets: this._relativeInsets.clone(),
      relativeLineSpacing: this.getRelativeLineSpacing(),
      background: this._background || this._getBackground(),
      lines,
      rows,
      width
    });
  }
  _layoutRows(lines, width) {
    return lines.map((line, index) => this._randomLayoutRow(line, index, width, new TextDesignAttributes({
      fontIdentifier: this._fontForRow(index, line)
    })).layout());
  }
  _randomLayoutRow(words8, index, width, attributes) {
    return new TextDesignRowSingle({words: words8, width, attributes});
  }
}
TextDesign.defaultFontIdentifiers = [];
TextDesign.identifier = "textdesign";
TextDesign.prototype.availableOptions = {
  fontIdentifiers: {type: OptionType.ARRAY, default: []},
  relativeLineSpacing: {type: OptionType.NUMBER, default: 0}
};

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks.js
class TextDesignBlocks extends TextDesign {
  constructor(...args) {
    super(...args);
    this.getImagePaths = () => {
      const banderoles = this.getBanderoles();
      return banderoles && banderoles.map((b) => b.getImagePath()) || [];
    };
    this.onImagesLoaded = () => {
      const banderoles = this.getBanderoles();
      if (banderoles) {
        banderoles.forEach((b) => {
          const image5 = AssetManager.getImage(b.getImagePath());
          if (!image5) {
            log_default.warn(`TextDesignBlocks#onImagesLoaded: Image not found '${b.getImagePath()}'`);
            return;
          }
          b.setImage(image5);
        });
      }
    };
    this._rowTypeLessThan3WordsRandomizer = new Randomizer(0);
    this._rowTypeMoreThan3WordsRandomizer = new Randomizer(0);
    this._banderolesRandomizer = new Randomizer(0);
    this._seedPool = [
      ...this._seedPool,
      this._rowTypeLessThan3WordsRandomizer,
      this._rowTypeMoreThan3WordsRandomizer,
      this._banderolesRandomizer
    ];
  }
  _modifiedText(text) {
    return super._modifiedText(text).toUpperCase();
  }
  generateLayoutData(text, width) {
    this._options.hasMaskedText = false;
    return super.generateLayoutData(text, width);
  }
  _randomLayoutRow(words8, index, width, attributes) {
    if (words8.size() < 3) {
      const isMasked = this._rowTypeLessThan3WordsRandomizer.nextInRange(0, 2) === 0;
      return this._layoutRow(words8, width, attributes, isMasked);
    }
    const randomValue = this._rowTypeMoreThan3WordsRandomizer.nextInRange(0, 3);
    switch (randomValue) {
      case 0:
        return new TextDesignRowTriple({
          words: words8,
          width,
          attributes,
          orientation: TextDesignRowTriple.Orientations.Left
        });
      case 1:
        return new TextDesignRowTriple({
          words: words8,
          width,
          attributes,
          orientation: TextDesignRowTriple.Orientations.Right
        });
      case 2:
        return this._layoutRow(words8, width, attributes, true);
      case 3:
        return new TextDesignRowSingle({words: words8, width, attributes});
      default:
        throw new Error(`TextDesignBlocks#_randomLayoutRow: Invalid randomValue generated: ${randomValue}.`);
    }
  }
  _layoutRow(words8, width, attributes, isMasked) {
    if (this.getHasMaskedText()) {
      isMasked = false;
    }
    if (isMasked) {
      this.setHasMaskedText(true);
      const banderole = this._banderolesRandomizer.pickNext(this.getBanderoles());
      const row = new TextDesignRowMasked({
        words: words8,
        width,
        attributes: new TextDesignAttributes({
          alignment: "left",
          fontIdentifier: banderole.getFontIdentifier()
        }),
        image: banderole.getImage(),
        imageInsets: banderole.insetsForWidth(width),
        capInsets: null,
        backgroundColor: color_default.WHITE
      });
      if (banderole.getNeedsImageSmoothingFix()) {
        row.serverImageSmoothingFix = true;
      }
      return row;
    }
    return new TextDesignRowSingle({words: words8, width, attributes});
  }
}
TextDesignBlocks.defaultFontIdentifiers = ["imgly_font_campton_bold"];
TextDesignBlocks.identifier = "imgly_text_design_blocks";
TextDesignBlocks.defaultBanderoles = [
  TextDesignBanderole.Rectangle,
  TextDesignBanderole.Small
];
TextDesignBlocks.prototype.availableOptions = __assign(__assign({}, TextDesign.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignBlocks.defaultFontIdentifiers
  },
  relativeLineSpacing: {type: OptionType.NUMBER, default: 0.025 / 3},
  hasMaskedText: {type: OptionType.BOOLEAN, default: false},
  banderoles: {
    type: OptionType.ARRAY,
    default: TextDesignBlocks.defaultBanderoles
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-condensed.js
class TextDesignBlocksCondensed extends TextDesignBlocks {
  constructor(...args) {
    super(...args);
    this._exclusiveFont = null;
  }
  generateLayoutData(text, width) {
    this._exclusiveFont = this._fontRandomizer.pickNext(this.getFontIdentifiers());
    return super.generateLayoutData(text, width);
  }
  _fontForRow(index, words8) {
    return this._exclusiveFont || super._fontForRow(index, words8);
  }
  _layoutRow(words8, width, attributes, isMasked) {
    return new TextDesignRowSingle({words: words8, width, attributes});
  }
}
TextDesignBlocksCondensed.defaultFontIdentifiers = [
  "imgly_font_ostrich_sans_heavy",
  "imgly_font_ostrich_sans_bold",
  "imgly_font_ostrich_sans_black"
];
TextDesignBlocksCondensed.identifier = "imgly_text_design_blocks_condensed";
TextDesignBlocksCondensed.prototype.availableOptions = __assign(__assign({}, TextDesignBlocks.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignBlocksCondensed.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/shearing/text-design-row-form.js
const {Rectangle: Rectangle8} = math_exports;
class TextDesignRowForm extends TextDesignRow {
  constructor(...args) {
    super(...args);
    this.setSize(new SizeValue(this.getWidth(), this.getHeight()));
  }
  _calculateLayoutElements() {
    return [new TextDesignElement({frame: this._getTextFrame()})];
  }
  render(context) {
    const frame2 = this._getFrame();
    const type = this.getType();
    const attributes = this.getAttributes();
    const color6 = attributes.getTextColor();
    const rectHeight = frame2.height / 3;
    let firstRect = new Rectangle8(frame2.x, frame2.y, frame2.width, rectHeight);
    let secondRect = new Rectangle8(frame2.x, frame2.y + rectHeight * 2, frame2.width, rectHeight);
    switch (type) {
      case TextDesignRowForm.FormType.Rect:
        fillRect(context, frame2, color6);
        break;
      case TextDesignRowForm.FormType.DoubleRect:
        fillRect(context, firstRect, color6);
        fillRect(context, secondRect, color6);
        break;
      case TextDesignRowForm.FormType.DoubleRectFirstPunctuated:
        fillRectPunctuated(context, firstRect, color6);
        fillRect(context, secondRect, color6);
        break;
      case TextDesignRowForm.FormType.DoubleRectSecondPunctuated:
        fillRect(context, firstRect, color6);
        fillRectPunctuated(context, secondRect, color6);
        break;
      case TextDesignRowForm.FormType.LongLine: {
        const lineHeight = frame2.height / 2;
        const rect = new Rectangle8(frame2.x, frame2.y, frame2.width, lineHeight);
        drawRoundedRect(context, rect, rect.height * 0.5, color6);
        break;
      }
      case TextDesignRowForm.FormType.LongAndShortLine: {
        const firstLineHeight = frame2.height * 0.2;
        const secondLineHeight = firstLineHeight * 0.75;
        firstRect = new Rectangle8(frame2.x, frame2.y + firstLineHeight, frame2.width, firstLineHeight);
        const secondRectX = frame2.x + frame2.width * 0.25;
        const secondRectY = frame2.y + frame2.height - secondLineHeight;
        secondRect = new Rectangle8(secondRectX, secondRectY, frame2.width * 0.5, secondLineHeight);
        drawRoundedRect(context, firstRect, firstRect.height * 0.5, color6);
        drawRoundedRect(context, secondRect, secondRect.height * 0.5, color6);
        break;
      }
      default:
        break;
    }
  }
}
TextDesignRowForm.FormType = {
  Rect: "RECT",
  DoubleRect: "DOUBLE_RECT",
  DoubleRectFirstPunctuated: "DOUBLE_RECT_FIRST_PUNCTUATED",
  DoubleRectSecondPunctuated: "DOUBLE_RECT_SECOND_PUNCTUATED",
  LongLine: "LONG_LINE",
  LongAndShortLine: "LONG_AND_SHORT_LINE"
};
TextDesignRowForm.prototype.availableOptions = __assign(__assign({}, TextDesignRow.prototype.availableOptions), {
  height: {type: OptionType.NUMBER, default: 100},
  type: {
    type: OptionType.STRING,
    default: TextDesignRowForm.FormType.Rect,
    available: utils_default.values(TextDesignRowForm.FormType)
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-light.js
class TextDesignBlocksLight extends TextDesignBlocks {
  _layoutRow(words8, width, attributes, isMasked) {
    return new TextDesignRowSingle({words: words8, width, attributes});
  }
  _layoutRows(lines, width) {
    const elements = super._layoutRows(lines, width);
    const firstFormHeight = 0.032 * width;
    const lastFormHeight = 0.08 * width;
    const firstRow = new TextDesignRowForm({
      width,
      height: firstFormHeight,
      type: TextDesignRowForm.FormType.LongLine,
      shearingAngle: 0
    }).layout();
    const lastRow = new TextDesignRowForm({
      width,
      height: lastFormHeight,
      type: TextDesignRowForm.FormType.LongAndShortLine,
      shearingAngle: 0
    }).layout();
    return [firstRow, ...elements, lastRow];
  }
}
TextDesignBlocksLight.defaultFontIdentifiers = ["imgly_font_sue_ellen_francisco"];
TextDesignBlocksLight.identifier = "imgly_text_design_blocks_light";
TextDesignBlocksLight.prototype.availableOptions = __assign(__assign({}, TextDesignBlocks.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignBlocksLight.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-blocks-light-v3_1_0.js
class TextDesignBlocksLightV310 extends TextDesignBlocksLight {
  _layoutRows(lines, width) {
    return lines.map((line, index) => this._randomLayoutRow(line, index, width, new TextDesignAttributes({
      fontIdentifier: this._fontForRow(index, line)
    })).layout());
  }
  _layoutRow(words8, width, attributes, isMasked) {
    return new TextDesignRowSingle({words: words8, width, attributes});
  }
}
TextDesignBlocksLightV310.defaultFontIdentifiers = ["imgly_font_sue_ellen_francisco"];
TextDesignBlocksLightV310.identifier = "imgly_text_design_blocks_light-v3_1_0";
TextDesignBlocksLightV310.prototype.availableOptions = __assign(__assign({}, TextDesignBlocksLight.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignBlocksLightV310.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/image/text-design-row-image.js
const {Rectangle: Rectangle9} = math_exports;
class TextDesignRowImage extends TextDesignRowSingle {
  getImageSize() {
    const leftImage = this.getLeftImage();
    const rightImage = this.getRightImage();
    const words8 = this.getWords();
    const attributes = this.getAttributes();
    const fontIdentifier = attributes.getFontIdentifier();
    const imageSize = leftImage ? new SizeValue(leftImage.width, leftImage.height) : new SizeValue();
    const text = words8.joined(1)[0];
    if (!text) {
      return imageSize;
    }
    const font2 = new TextDesignFont({text, fontIdentifier, fontSize: 50});
    const textSize = font2.getSizeValue();
    const imageCount = rightImage ? 2 : 1;
    imageSize.scale(imageCount, 1);
    const newImageSize = imageSize.clone().fitInWidthWithOther(this._getFrame().width, textSize);
    newImageSize.scale(1 / imageCount, 1);
    return newImageSize;
  }
  _getTextFrame() {
    const textFrame = super._getTextFrame().clone();
    const imageSize = this.getImageSize();
    const rightImage = this.getRightImage();
    const imagePosition = this.getImagePosition();
    if (!rightImage) {
      if (imagePosition === TextDesignRowImage.ImagePosition.Left) {
        textFrame.x += imageSize.width;
      }
    } else {
      textFrame.x += imageSize.width;
      textFrame.width -= 2 * imageSize.width;
    }
    return textFrame;
  }
  _calculateLayoutElements() {
    const elements = super._calculateLayoutElements();
    const frame2 = this._getFrame();
    const rightImage = this.getRightImage();
    const imageSize = this.getImageSize();
    const imagePosition = this.getImagePosition();
    const textFrame = this._getTextFrame();
    const attributes = this.getAttributes();
    const fontIdentifier = attributes.getFontIdentifier();
    const font2 = new TextDesignFont({text: "stickerClock", fontIdentifier});
    font2.fitWidth(this._getTextFrame().width);
    const leftImageRect = new Rectangle9().set(frame2.x, frame2.y, imageSize.width, imageSize.height);
    if (!rightImage && imagePosition === TextDesignRowImage.ImagePosition.Right) {
      leftImageRect.x += textFrame.width;
    }
    elements.push(new TextDesignElement({
      text: "stickerClock",
      frame: leftImageRect,
      font: font2
    }));
    if (rightImage) {
      const firstElement = elements[0];
      if (firstElement) {
        const rightImageRect = leftImageRect.clone();
        rightImageRect.translate(firstElement.getFrame().width + rightImageRect.width, 0);
        elements.push(new TextDesignElement({
          text: "stickerClock",
          frame: rightImageRect,
          font: font2
        }));
      }
    }
    return elements;
  }
  render(context) {
    const elements = this._getLayoutElements();
    const attributes = this.getAttributes();
    const textColor = attributes.getTextColor();
    const leftImage = this.getLeftImage();
    const rightImage = this.getRightImage();
    const layoutElement = elements[0];
    const secondElement = elements[1];
    const {font: font2} = layoutElement.serializeOptions();
    const textFrame = this._getTextFrameForElement(layoutElement);
    font2.draw(context, textFrame.x, textFrame.y, {
      textColor: attributes.getTextColor().toRGBA(),
      alignment: attributes.getAlignment()
    });
    if (leftImage) {
      const dest = secondElement.getFrame();
      context.drawImage(leftImage, dest.x, dest.y, dest.width, dest.height);
      fillRect(context, dest, textColor, "source-atop");
    }
    if (elements.length > 2) {
      const rightElement = elements[2];
      const rightElementFrame = rightElement.getFrame().clone();
      context.drawImage(rightImage, rightElementFrame.x, rightElementFrame.y, rightElementFrame.width, rightElementFrame.height);
      fillRect(context, rightElementFrame, textColor, "source-atop");
    }
  }
}
TextDesignRowImage.ImagePosition = {
  Left: "LEFT",
  right: "RIGHT"
};
TextDesignRowImage.prototype.availableOptions = __assign(__assign({}, TextDesignRowSingle.prototype.availableOptions), {
  leftImage: {type: OptionType.IMAGE, default: null},
  rightImage: {type: OptionType.IMAGE, default: null},
  imagePosition: {
    type: OptionType.STRING,
    default: TextDesignRowImage.ImagePosition.Left,
    available: [
      TextDesignRowImage.ImagePosition.Left,
      TextDesignRowImage.ImagePosition.Right
    ]
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-celebrate.js
class TextDesignCelebrate extends TextDesignBlocks {
  _fontForRow(index, words8) {
    const fonts2 = this.getFontIdentifiers();
    return fonts2[index % fonts2.length];
  }
  _minimumNumberOfLines(words8) {
    return Math.max(Math.floor(super._minimumNumberOfLines(words8) * 0.7), 1);
  }
  _maximumNumberOfLines(words8) {
    return Math.max(Math.floor(words8.countNumberOfCharacters() / 5), 1);
  }
  _randomLayoutRow(words8, index, width, attributes) {
    return this._createSingleRow(TextDesignCelebrate.RowType.Single, words8, width, attributes);
  }
  _createSingleRow(rowType, words8, width, attributes) {
    const fontIdentifier = attributes.getFontIdentifier();
    const updatedWords = fontIdentifier === "imgly_font_amberlight" || fontIdentifier === "imgly_font_handycheera_regular" ? new Words().set(words8.getLowerCase()) : words8;
    switch (rowType) {
      case TextDesignCelebrate.RowType.Single:
        return new TextDesignRowSingle({
          words: updatedWords,
          width,
          attributes
        });
      case TextDesignCelebrate.RowType.SingleImage:
        return new TextDesignRowImage({
          words: updatedWords,
          width,
          attributes
        });
      default:
        log_default.warn(`TextDesignCelebrate#_createSingleRow: Invalid row type '${rowType}'`);
        return null;
    }
  }
}
TextDesignCelebrate.defaultFontIdentifiers = [
  "imgly_font_handycheera_regular",
  "imgly_font_rasa_regular"
];
TextDesignCelebrate.defaultBanderoles = [
  TextDesignBanderole.Celebrate1,
  TextDesignBanderole.Celebrate2
];
TextDesignCelebrate.identifier = "imgly_text_design_celebrate";
TextDesignCelebrate.RowType = {
  Single: "SINGLE",
  SingleImage: "SINGLE_IMAGE"
};
TextDesignCelebrate.prototype.availableOptions = __assign(__assign({}, TextDesignBlocks.prototype.availableOptions), {
  relativeLineSpacing: {type: OptionType.NUMBER, default: 0.01875},
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignCelebrate.defaultFontIdentifiers
  },
  banderoles: {
    type: OptionType.ARRAY,
    default: TextDesignCelebrate.defaultBanderoles
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/image/text-design-row-single-image.js
class TextDesignRowSingleImage extends TextDesignRow {
  constructor(...args) {
    super(...args);
    this.setSize(new SizeValue(this.getWidth(), this.getHeight()));
  }
  _getImageFrame() {
    const imageRect = this._getTextFrame().clone();
    const image5 = this.getImage();
    if (this.getDrawingModeAspectFit() && image5) {
      const ratio = Math.min(imageRect.width / image5.width, imageRect.height / image5.height);
      const newWidth = image5.width * ratio;
      const newHeight = image5.height * ratio;
      imageRect.x += (imageRect.width - newWidth) / 2;
      imageRect.y += (imageRect.height - newHeight) / 2;
      imageRect.width = newWidth;
      imageRect.height = newHeight;
    }
    return imageRect;
  }
  _calculateLayoutElements() {
    return [
      new TextDesignElement({
        text: "",
        frame: this._getImageFrame(),
        font: new TextDesignFont()
      })
    ];
  }
  render(context) {
    const image5 = this.getImage();
    const imageFrame = this._getImageFrame();
    const attributes = this.getAttributes();
    const textColor = attributes.getTextColor();
    drawImageFrame(context, image5, imageFrame, textColor);
  }
}
TextDesignRowSingleImage.RowImages = {
  decorative1: "text-design/images/imgly_text_design_asset_decorative_01.png",
  decorative2: "text-design/images/imgly_text_design_asset_decorative_02.png",
  decorative3: "text-design/images/imgly_text_design_asset_decorative_05.png",
  decorative4: "text-design/images/imgly_text_design_asset_decorative_06.png",
  celebrate1: "text-design/images/imgly_text_design_asset_celebrate_03.png",
  celebrate2: "text-design/images/imgly_text_design_asset_celebrate_04.png",
  celebrate3: "text-design/images/imgly_text_design_asset_celebrate_05.png"
};
TextDesignRowSingleImage.prototype.availableOptions = __assign(__assign({}, TextDesignRow.prototype.availableOptions), {
  words: {type: OptionType.OBJECT, default: new Words()},
  height: {type: OptionType.NUMBER, default: 0},
  image: {type: OptionType.IMAGE, default: null},
  imagePath: {
    type: OptionType.STRING,
    default: TextDesignRowSingleImage.RowImages.decorative1
  },
  drawingModeAspectFit: {type: OptionType.BOOLEAN, default: false},
  attributes: {
    type: OptionType.CONFIGURABLE,
    default: new TextDesignAttributes()
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-celebrate-simple.js
class TextDesignCelebrateSimple extends TextDesignCelebrate {
  constructor(...args) {
    super(...args);
    this.getImagePaths = () => {
      const banderoles = this.getBanderoles();
      return [
        ...banderoles && banderoles.map((b) => b.getImagePath()) || [],
        ...this._celebrateTypes
      ];
    };
    this.onImagesLoaded = () => {
      const banderoles = this.getBanderoles();
      if (banderoles) {
        banderoles.forEach((b) => {
          const image5 = AssetManager.getImage(b.getImagePath());
          if (!image5) {
            log_default.warn(`TextDesignBlocks#onImagesLoaded: Image not found '${b.getImagePath()}'`);
            return;
          }
          b.setImage(image5);
        });
      }
    };
    this._celebrateTypes = [
      TextDesignRowSingleImage.RowImages.celebrate1,
      TextDesignRowSingleImage.RowImages.celebrate2,
      TextDesignRowSingleImage.RowImages.celebrate3
    ];
    this._exclusiveFont = null;
    this._typeRandomizer = new Randomizer(0);
    this._useMaskedRandomizer = new Randomizer(0);
    this._seedPool.push(this._typeRandomizer);
    this._seedPool.push(this._useMaskedRandomizer);
  }
  _fontForRow(index, words8) {
    const fonts2 = this.getFontIdentifiers();
    return fonts2[index % (fonts2.length - 1)];
  }
  _layoutRows(lines, width) {
    const imagePath = this._typeRandomizer.pickNext(this._celebrateTypes);
    const image5 = AssetManager.getImage(imagePath);
    if (!image5) {
      log_default.warn(`TextDesignCelebrateSimple#_layoutRows: Image not fount '${imagePath}'`);
    }
    const firstRow = new TextDesignRowSingleImage({
      width,
      height: width * 0.5,
      drawingModeAspectFit: true,
      image: image5
    }).layout();
    const rows = super._layoutRows(lines, width);
    return [firstRow, ...rows];
  }
  _randomLayoutRow(words8, index, width, attributes) {
    const numberOfCharacters = words8.countNumberOfCharacters();
    const maximumNumberOfCharacters = 13;
    const minimumNumberOfCharacters = 4;
    if (numberOfCharacters < minimumNumberOfCharacters) {
      attributes.setFontIdentifier("imgly_font_rasa_regular");
    }
    const isMasked = this._useMaskedRandomizer.nextBool(2, 1);
    if (numberOfCharacters < maximumNumberOfCharacters && isMasked && !this.getHasMaskedText()) {
      return this._layoutRow(words8, width, attributes, true);
    }
    return super._randomLayoutRow(words8, index, width, attributes);
  }
}
TextDesignCelebrateSimple.identifier = "imgly_text_design_celebrate_simple";
TextDesignCelebrateSimple.defaultFontIdentifiers = [
  "imgly_font_amberlight",
  "imgly_font_rasa_regular",
  "imgly_font_rasa_500"
];
TextDesignCelebrateSimple.prototype.availableOptions = __assign(__assign({}, TextDesignCelebrate.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignCelebrateSimple.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-background.js
class TextDesignBackground extends configurable_default {
  render(context, size, relativeInsets, color6, randomizer13) {
    log_default.warn("TextDesignBackground#render: Abstract class");
  }
}
TextDesignBackground.prototype.availableOptions = {};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-equal-width-background.js
const {Rectangle: Rectangle10} = math_exports;
class TextDesignEqualWidthBackground extends TextDesignBackground {
  getImagePaths() {
    const {
      topImagePath,
      bottomImagePath,
      leftImagePath,
      rightImagePath
    } = this._options;
    return [
      topImagePath,
      bottomImagePath,
      leftImagePath,
      rightImagePath
    ].filter((path2) => path2 !== "");
  }
  render(context, size, relativeInsets, color6, randomizer13) {
    const absoluteInsets = relativeInsets.clone().scale(size.width);
    const frame2 = size.rectangle(0, 0);
    const topImage = AssetManager.getImage(this.getTopImagePath());
    const leftImage = AssetManager.getImage(this.getLeftImagePath());
    const rightImage = AssetManager.getImage(this.getRightImagePath());
    const bottomImage = AssetManager.getImage(this.getBottomImagePath());
    if (topImage) {
      const aspect = topImage.width / topImage.height;
      const destHeight = absoluteInsets.top * this.getTopImageFillRate();
      const destWidth = destHeight * aspect;
      const xCenter = frame2.width / 2;
      const xOrigin = xCenter - destWidth / 2;
      const topFrame = new Rectangle10(xOrigin, 0, destWidth, destHeight);
      drawImageFrame(context, topImage, topFrame, color6);
    }
    if (bottomImage) {
      const aspect = bottomImage.width / bottomImage.height;
      const destHeight = absoluteInsets.bottom * this.getBottomImageFillRate();
      const destWidth = destHeight * aspect;
      const xCenter = frame2.width / 2;
      const xOrigin = xCenter - destWidth / 2;
      const bottomFrame = new Rectangle10(xOrigin, frame2.height - destHeight, destWidth, destHeight);
      drawImageFrame(context, bottomImage, bottomFrame, color6);
    }
    if (leftImage) {
      const aspect = leftImage.width / leftImage.height;
      const destWidth = absoluteInsets.left * this.getLeftImageFillRate();
      const destHeight = destWidth / aspect;
      const yCenter = frame2.height / 2;
      const yOrigin = yCenter - destHeight / 2;
      const leftFrame = new Rectangle10(0, yOrigin, destWidth, destHeight);
      drawImageFrame(context, leftImage, leftFrame, color6);
    }
    if (rightImage) {
      const aspect = rightImage.width / rightImage.height;
      const destWidth = absoluteInsets.right * this.getRightImageFillRate();
      const destHeight = destWidth / aspect;
      const yCenter = frame2.height / 2;
      const yOrigin = yCenter - destHeight / 2;
      const rightFrame = new Rectangle10(frame2.width - destWidth, yOrigin, destWidth, destHeight);
      drawImageFrame(context, rightImage, rightFrame, color6);
    }
  }
}
TextDesignEqualWidthBackground.prototype.availableOptions = {
  topImagePath: {type: OptionType.STRING, default: ""},
  leftImagePath: {type: OptionType.STRING, default: ""},
  bottomImagePath: {type: OptionType.STRING, default: ""},
  rightImagePath: {type: OptionType.STRING, default: ""},
  topImageFillRate: {type: OptionType.NUMBER, default: 1},
  leftImageFillRate: {type: OptionType.NUMBER, default: 1},
  bottomImageFillRate: {type: OptionType.NUMBER, default: 1},
  rightImageFillRate: {type: OptionType.NUMBER, default: 1}
};
TextDesignEqualWidthBackground.Backgrounds = [
  new TextDesignEqualWidthBackground({
    topImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_1.png",
    leftImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_2.png",
    rightImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_2.png",
    bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background1_3.png",
    topImageFillRate: 0.8,
    leftImageFillRate: 0.6,
    rightImageFillRate: 0.6,
    bottomImageFillRate: 0.8
  }),
  new TextDesignEqualWidthBackground({
    leftImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background2_1.png",
    rightImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background2_1.png",
    bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background2_2.png",
    leftImageFillRate: 0.6,
    rightImageFillRate: 0.6,
    bottomImageFillRate: 0.6
  }),
  new TextDesignEqualWidthBackground({
    topImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background3_1.png",
    bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background3_2.png",
    topImageFillRate: 0.6,
    bottomImageFillRate: 0.6
  }),
  new TextDesignEqualWidthBackground({
    topImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_1.png",
    leftImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_3.png",
    rightImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_3.png",
    bottomImagePath: "text-design/images/imgly_xib_image_text_design_equal_width_background4_2.png",
    topImageFillRate: 0.1,
    leftImageFillRate: 0.6,
    rightImageFillRate: 0.6,
    bottomImageFillRate: 0.6
  })
];

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-equal-width.js
class TextDesignEqualWidth extends TextDesign {
  constructor(...args) {
    super(...args);
    this._relativeInsets = new RectangleInsets(0.1, 0.1, 0.1, 0.1);
    this._alreadyContainsARowWithScriptFont = false;
    this._backgroundsRandomizer = new Randomizer(0);
    this._seedPool.push(this._backgroundsRandomizer);
  }
  getImagePaths() {
    return utils_default.Array.flatten(TextDesignEqualWidthBackground.Backgrounds.map((b) => b.getImagePaths()));
  }
  _getBackground() {
    return this._backgroundsRandomizer.pickNext(TextDesignEqualWidthBackground.Backgrounds);
  }
  generateLayoutData(text, width) {
    this._alreadyContainsARowWithScriptFont = false;
    this._background = this._getBackground();
    return super.generateLayoutData(text, width);
  }
  _modifiedText(text) {
    return super._modifiedText(text).toUpperCase();
  }
  _fontForRow(index, words8) {
    let fontIdentifier = super._fontForRow(index, words8);
    if (fontIdentifier === "imgly_font_petit_formal_script") {
      if (this._alreadyContainsARowWithScriptFont) {
        fontIdentifier = "imgly_font_bungee_inline";
      }
      this._alreadyContainsARowWithScriptFont = true;
    }
    return fontIdentifier;
  }
  _randomLayoutRow(words8, index, width, attributes) {
    const lowercase = attributes.getFontIdentifier() === "imgly_font_petit_formal_script";
    return new TextDesignRowSingle({
      words: lowercase ? new Words().set(words8.getLowerCase()) : words8,
      width,
      attributes
    });
  }
}
TextDesignEqualWidth.identifier = "imgly_text_design_equal_width";
TextDesignEqualWidth.defaultFontIdentifiers = [
  "imgly_font_ultra",
  "imgly_font_bungee_inline",
  "imgly_font_petit_formal_script"
];
TextDesignEqualWidth.prototype.availableOptions = __assign(__assign({}, TextDesign.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignEqualWidth.defaultFontIdentifiers
  },
  relativeLineSpacing: {type: OptionType.NUMBER, default: 0.025}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-equal-width-fat.js
class TextDesignEqualWidthFat extends TextDesignEqualWidth {
  constructor(...args) {
    super(...args);
    this._relativeInsets = new RectangleInsets();
  }
  _getBackground() {
    return null;
  }
}
TextDesignEqualWidthFat.defaultFontIdentifiers = ["imgly_font_ultra"];
TextDesignEqualWidthFat.identifier = "imgly_text_design_equal_width_fat";
TextDesignEqualWidthFat.prototype.availableOptions = __assign(__assign({}, TextDesignEqualWidth.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignEqualWidthFat.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/masked-row-type.js
class RowType extends configurable_default {
  insetsForWidth(width) {
    const insets = this.getRelativeInsets().clone();
    return insets.scale(width);
  }
}
RowType.prototype.availableOptions = {
  imagePath: {type: OptionType.STRING, default: ""},
  minimumHeightRatio: {type: OptionType.NUMBER, default: 0},
  sizeToFitContent: {type: OptionType.BOOLEAN, default: true},
  capInsets: {type: OptionType.OBJECT, default: new RectangleInsets()},
  relativeInsets: {type: OptionType.OBJECT, default: new RectangleInsets()}
};
RowType.Box = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_black_background.png",
  relativeInsets: new RectangleInsets(0.1, 0.1, 0.1, 0.1)
});
RowType.Badge1 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_badge1.png",
  relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
});
RowType.Badge2 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_badge2.png",
  relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
});
RowType.Badge3 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_badge3.png",
  relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
});
RowType.Badge4 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_badge4.png",
  relativeInsets: new RectangleInsets(0.3, 0.18, 0.2, 0.18)
});
RowType.SpeechBubble1 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_speech_bubble_small2.png",
  relativeInsets: new RectangleInsets(0.04, 0.07, 0.12, 0.07),
  capInsets: new RectangleInsets(19 * 3, 57 * 3, 41 * 3, 17 * 3)
});
RowType.SpeechBubble2 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_speech_bubble3.png",
  relativeInsets: new RectangleInsets(0.04, 0.07, 0.12, 0.07),
  capInsets: new RectangleInsets(2 * 3, 35 * 3, 29 * 3, 5 * 3)
});
RowType.SpeechBubble3 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_speech_bubble_small.png",
  relativeInsets: new RectangleInsets(0.165664675, 0.2, 0.165664675, 0.2),
  minimumHeightRatio: 0.7
});
RowType.SpeechBubble4 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_speech_bubble4.png",
  relativeInsets: new RectangleInsets(0.124800224, 0.2, 0.291200523, 0.2),
  minimumHeightRatio: 0.7
});
RowType.SpeechBubble5 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_speech_bubble5.png",
  relativeInsets: new RectangleInsets(0.114892823, 0.27, 0.15984926, 0.27)
});
RowType.Watercolor1 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_watercolor_01.png",
  minimumHeightRatio: 0.7,
  relativeInsets: new RectangleInsets(0.2, 0.25, 0.2, 0.25)
});
RowType.Watercolor2 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_watercolor_02.png",
  minimumHeightRatio: 0.7,
  relativeInsets: new RectangleInsets(0.08, 0.25, 0.3, 0.25)
});
RowType.Watercolor3 = new RowType({
  imagePath: "text-design/images/imgly_text_design_asset_watercolor_03.png",
  minimumHeightRatio: 0.7,
  relativeInsets: new RectangleInsets(0.1, 0.2, 0.15, 0.2)
});

// engine/sdk/operations/sprite-operation/sprites/text/text-splitter.js
class TextSplitter {
  constructor(context) {
    this._context = context;
    this._lastFontStyle = {};
  }
  getLines() {
    let lines = [];
    let newLineWords = [];
    const linesCount = this._lines.length;
    for (let l = 0; l < linesCount; l++) {
      const line = this._lines[l];
      const words8 = this._buildWords(line);
      const wordsCount = words8.length;
      for (let w = 0; w < wordsCount; w++) {
        const word = words8[w];
        const currentLine = newLineWords.concat(word).join("").replace(/\s+$/i, "");
        const width = this._getWidth(currentLine);
        if (width > this._maxWidth) {
          if (newLineWords.length > 0) {
            lines.push(newLineWords.join(""));
            newLineWords = [word];
          }
          const _word = word.replace(/\s+$/i, "");
          if (this._getWidth(_word) > this._maxWidth) {
            const splitWord = this._splitWord(word);
            lines = lines.concat(splitWord.lines);
            if (splitWord.rest) {
              newLineWords = [splitWord.rest];
            }
          }
        } else {
          newLineWords.push(word);
        }
      }
      lines.push(newLineWords.join(""));
      newLineWords = [];
    }
    return lines.map((line) => this._trimLine(line, this._context.textAlign));
  }
  _trimLine(line, alignment) {
    return line;
  }
  _buildWords(line) {
    const words8 = [];
    let word = "";
    const len = line.length;
    for (let i = 0; i < len; i++) {
      const char = line[i];
      word += char;
      if (char === " " || char === "-" || i === len - 1) {
        words8.push(word);
        word = "";
      }
    }
    return words8;
  }
  _splitWord(word) {
    const response = {
      lines: [],
      rest: null
    };
    const wordLength = word.length;
    let chars = [];
    for (let c = 0; c < wordLength; c++) {
      const char = word[c];
      if (this._getWidth(chars.concat(char).join("")) > this._maxWidth) {
        if (chars.length > 0) {
          response.lines.push(chars.join(""));
        }
        chars = [char];
      } else {
        chars.push(char);
      }
      if (c === wordLength - 1 && chars.length > 0) {
        response.rest = chars.join("");
      }
    }
    return response;
  }
  _fontStyleChanged() {
    if (this._context.font !== this._lastFontStyle) {
      this._lastFontStyle = this._context.font;
      return true;
    }
    return false;
  }
  _getWidth(string) {
    return this._context.measureText(string).width;
  }
  setText(text) {
    this._text = text;
    this._lines = text.split("\n");
  }
  setMaxWidth(maxWidth) {
    this._maxWidth = maxWidth;
  }
}
var text_splitter_default = TextSplitter;

// engine/sdk/operations/sprite-operation/sprites/text/text-renderer.js
const {Vector2: Vector227} = math_exports;
class TextRenderer {
  constructor(text, operation3) {
    this._text = text;
    this._operation = operation3;
    this._textOptions = {};
    this.rotation = 0;
    this._createCanvas();
    this._createTexture();
  }
  _createCanvas() {
    this._canvas = utils_default.createCanvas();
    this._context = this._canvas.getContext("2d");
    this._textSplitter = new text_splitter_default(this._context);
    this._finalCanvas = utils_default.createCanvas();
    this._finalContext = this._finalCanvas.getContext("2d");
  }
  _createTexture() {
    this._texture = engine_default.Texture.fromCanvas(this._canvas);
    this._finalTexture = engine_default.Texture.fromCanvas(this._finalCanvas);
  }
  _applyTextOptions(textOptions, context) {
    context.font = `${this._text.getFontStyle()} ${this._text.getFontWeight()} ${textOptions.fontSize}px "${this._text.getFontFamily()}"`;
    if (this._text.getTextMetrics()) {
      context.textBaseline = "alphabetic";
    } else {
      context.textBaseline = "top";
    }
    context.textAlign = this._text.getAlignment();
    context.fillStyle = this._text.getColor().toRGBA();
    context.strokeStyle = this._text.getOutlineColor().toRGBA();
    const outlineWidth = this._text.getOutlineWidth();
    if (outlineWidth > 0) {
      context.lineWidth = outlineWidth;
    }
  }
  _buildOutputLines(maxWidth) {
    this._textSplitter.setText(this._text.getText());
    this._textSplitter.setMaxWidth(maxWidth);
    return this._textSplitter.getLines().map((line) => {
      return line.replace(/\s+$/i, "");
    });
  }
  _renderTextLine(text, y, padding) {
    const textAlignment = this._text.getAlignment();
    const drawPosition = new Vector227(0, y);
    switch (textAlignment) {
      case "left":
        drawPosition.x = padding;
        break;
      case "center":
        drawPosition.x = this._canvas.width / 2;
        break;
      case "right":
        drawPosition.x = this._canvas.width - padding;
        break;
    }
    this._context.save();
    this._context.translate(drawPosition.x, drawPosition.y);
    this._context.fillText(text, 0, 0);
    this._context.restore();
    const outlineWidth = this._text.getOutlineWidth();
    if (outlineWidth > 0) {
      this._context.miterLimit = 2;
      this._context.strokeText(text, drawPosition.x, drawPosition.y);
    }
  }
  update(sdk14, inputDimensions) {
    const textOptions = this.calculateFontStyles(sdk14, inputDimensions);
    if (textOptions) {
      const {dimensions, lines} = this._calculateText(sdk14, textOptions, inputDimensions);
      this._renderText(sdk14, dimensions, lines, textOptions, inputDimensions);
      this._updateFinalTexture();
    }
  }
  _updateFinalTexture() {
    const {width, height} = this._canvas;
    const {rotation} = this;
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    const finalDimensions = new Vector227(Math.abs(width * cos) + Math.abs(height * sin), Math.abs(width * sin) + Math.abs(height * cos));
    this._finalCanvas.width = finalDimensions.x;
    this._finalCanvas.height = finalDimensions.y;
    this._finalContext.save();
    this._finalContext.translate(this._finalCanvas.width / 2, this._finalCanvas.height / 2);
    this._finalContext.rotate(rotation);
    this._finalContext.drawImage(this._canvas, -width / 2, -height / 2);
    this._finalContext.restore();
  }
  _renderText(sdk14, dimensions, lines, textOptions, inputDimensions) {
    this._canvas.width = dimensions.x;
    this._canvas.height = dimensions.y;
    if (this._text.getMaxHeight()) {
      this._canvas.height = Math.min(this._text.getMaxHeight() * inputDimensions.y, this._canvas.height);
    }
    this._context = this._canvas.getContext("2d");
    this._context.fillStyle = this._text.getBackgroundColor().toRGBA();
    this._context.fillRect(0, 0, dimensions.x, dimensions.y);
    this._applyTextOptions(textOptions, this._context);
    const padding = this._padding(inputDimensions);
    const metrics = this._text.getTextMetrics();
    const absoluteFontSize = this._text.getFontSize() * inputDimensions.y;
    const scale = 1 / metrics.unitsPerEm * absoluteFontSize;
    const ascender = metrics.ascender * scale;
    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];
      this._renderTextLine(line, textOptions.topPadding + textOptions.lineHeight * lineNum + padding + ascender, padding);
    }
  }
  calculateFontStyles(sdk14, inputDimensions) {
    const fontFamily = this._text.getFontFamily();
    const fontSize = this._text.getFontSize() * inputDimensions.y;
    const textHeight = this._text.getAbsoluteTextHeight(inputDimensions);
    const lineHeight = textHeight * this._text.getLineHeight();
    const topPadding = textHeight * (this._text.getLineHeight() - 1) / 2;
    const textOptions = {fontFamily, fontSize, lineHeight, topPadding};
    if (this._textOptions.fontFamily !== fontFamily || this._textOptions.fontSize !== fontSize || this._textOptions.lineHeight !== lineHeight) {
      this._textOptions = textOptions;
    }
    return textOptions;
  }
  _calculateText(sdk14, textOptions, inputDimensions) {
    const maxWidth = this._text.getMaxWidth() * inputDimensions.x;
    this._applyTextOptions(textOptions, this._context);
    const dimensions = new Vector227();
    let lines = this._text.getText().split("\n");
    if (typeof maxWidth !== "undefined") {
      dimensions.x = maxWidth;
      lines = this._buildOutputLines(maxWidth);
    }
    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];
      dimensions.x = Math.max(dimensions.x, this._context.measureText(line).width);
    }
    const {lineHeight} = textOptions;
    dimensions.y = lines.length * lineHeight;
    const padding = this._padding(inputDimensions);
    dimensions.y += padding * 2;
    dimensions.x += padding * 2;
    return {dimensions, lines};
  }
  _padding(inputDimensions) {
    const textHeight = this._text.getAbsoluteTextHeight(inputDimensions);
    const relativePadding = 0.2;
    return textHeight * relativePadding;
  }
  getTexture() {
    return this._texture;
  }
  getFinalTexture() {
    return this._finalTexture;
  }
  getDimensions(sdk14, inputDimensions) {
    const textOptions = this.calculateFontStyles(sdk14, inputDimensions);
    const {dimensions} = this._calculateText(sdk14, textOptions, inputDimensions);
    return dimensions;
  }
  dispose() {
    if (this._measurementElement) {
      document.body.removeChild(this._measurementElement);
    }
    if (this._texture) {
      this._texture.dispose();
      this._texture = null;
    }
    if (this._finalTexture) {
      this._finalTexture.dispose();
      this._finalTexture = null;
    }
  }
}
var text_renderer_default = TextRenderer;

// engine/sdk/operations/sprite-operation/sprites/text-design/text/text-design-font-multiline.js
const {Vector2: Vector228} = math_exports;
class TextDesignFontMultiline extends configurable_default {
  constructor(options) {
    super(options);
    this._textOptions = {};
    this._createCanvas();
  }
  _createCanvas() {
    this._canvas = utils_default.createCanvas();
    this._context = this._canvas.getContext("2d");
    this._textSplitter = new text_splitter_default(this._context);
    this._finalCanvas = utils_default.createCanvas();
    this._finalContext = this._finalCanvas.getContext("2d");
    this.updateFontVariation();
  }
  setOption(optionName, value, update = true, initial = false) {
    super.setOption(optionName, value, update, initial);
    if (optionName === "fontIdentifier" && !initial) {
      this.updateFontVariation();
    }
  }
  updateFontVariation() {
    const fontVariation = AssetManager.getVariation(this.getFontIdentifier());
    if (!fontVariation) {
      log_default.warn(`TextDesignFont: Unable to find font '${this._fontIdentifier}'`);
    }
    this.setFontVariation(fontVariation);
    return fontVariation;
  }
  _applyTextOptions(options = {}, ctx = this._context) {
    const {fontSize, fontVariation, lineHeight, textColor, alignment} = __assign(__assign({}, this._options), options);
    const {
      fontStyle,
      fontWeight,
      fontFamily
    } = fontVariation.serializeOptions();
    ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px "${fontFamily}"`;
    ctx.fillStyle = textColor;
    ctx.textBaseline = "top";
    ctx.textAlign = alignment || "left";
  }
  _buildOutputLines(maxWidth) {
    this._textSplitter.setText(this.getText());
    this._textSplitter.setMaxWidth(maxWidth);
    return this._textSplitter.getLines();
  }
  _renderTextLine(text, y) {
    const textAlignment = this.getAlignment();
    const drawPosition = new Vector228(0, y);
    switch (textAlignment) {
      case "center":
        drawPosition.x = this._canvas.width / 2;
        break;
      case "right":
        drawPosition.x = this._canvas.width;
        break;
    }
    this._context.fillText(text, drawPosition.x, drawPosition.y);
  }
  update() {
    const textOptions = this.calculateFontStyles();
    if (textOptions) {
      const {dimensions, lines} = this._calculateText(textOptions);
      this._dimensions = dimensions;
      this._renderText(dimensions, lines, textOptions);
    }
  }
  draw(ctx, x = 0, y = 0) {
    this.update();
    ctx.drawImage(this._canvas, x, y, this._dimensions.x, this._dimensions.y);
  }
  _renderText(dimensions, lines, textOptions) {
    this._canvas.width = dimensions.x;
    this._canvas.height = dimensions.y;
    this._context = this._canvas.getContext("2d");
    this._applyTextOptions(textOptions, this._context);
    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];
      this._renderTextLine(line, textOptions.topPadding + textOptions.lineHeight * lineNum);
    }
  }
  getFontFamily() {
    const variation = this.getFontVariation();
    return variation.getFontFamily();
  }
  calculateFontStyles() {
    const fontFamily = this.getFontFamily();
    const fontSize = this.getFontSize();
    const textHeight = this.getAbsoluteTextHeight();
    const lineHeight = textHeight * this.getLineHeight();
    const topPadding = textHeight * (this.getLineHeight() - 1) / 2;
    const textOptions = {
      fontFamily,
      fontSize,
      textHeight,
      lineHeight,
      topPadding
    };
    this._textOptions = __assign({}, textOptions);
    return textOptions;
  }
  getTextMetrics() {
    const variation = this.getFontVariation();
    return variation.getTextMetrics();
  }
  getAbsoluteTextHeight() {
    const actualFontSize = this.getFontSize();
    const textMetrics = this.getTextMetrics();
    if (textMetrics) {
      const scale = 1 / textMetrics.unitsPerEm * actualFontSize;
      const ascent = textMetrics.ascender * scale;
      const descent = textMetrics.descender * scale;
      return ascent + Math.abs(descent);
    }
    return actualFontSize * this.getLineHeight() * 1.1;
  }
  _calculateText(textOptions) {
    this._applyTextOptions(textOptions, this._context);
    const dimensions = new Vector228();
    let lines = this.getText().split("\n");
    let maxWidth;
    if (typeof maxWidth !== "undefined") {
      dimensions.x = maxWidth;
      lines = this._buildOutputLines(maxWidth);
    } else {
      for (let lineNum = 0; lineNum < lines.length; lineNum++) {
        const line = lines[lineNum];
        dimensions.x = Math.max(dimensions.x, this._context.measureText(line).width);
      }
    }
    const {lineHeight} = textOptions;
    dimensions.y = lines.length * lineHeight;
    return {dimensions, lines};
  }
  getDimensions() {
    const textOptions = this.calculateFontStyles();
    const {dimensions} = this._calculateText(textOptions);
    return dimensions;
  }
  fitMaxHeight() {
    this.update();
    const dimensions = this.getDimensions();
    const lines = this.getText().split("\n");
    const scale = this.getMaxHeight() / dimensions.y;
  }
  fitMaxWidth() {
    const width = this.getDimensions().x;
    const scale = this.getMaxWidth() / width;
    this.setFontSize(this.getFontSize() * scale);
    this._textOptions.fontSize = this.getFontSize();
  }
  fitInFrame(frame2) {
    this.setMaxWidth(frame2.width);
    this.setMaxHeight(frame2.height);
    this.fitMaxWidth();
    this.fitMaxHeight();
  }
  getSize() {
    const dimensions = this.getDimensions();
    return new SizeValue(dimensions.x, dimensions.y);
  }
}
TextDesignFontMultiline.prototype.availableOptions = {
  text: {type: OptionType.STRING, default: ""},
  fontIdentifier: {
    type: OptionType.STRING,
    default: "imgly_font_open_sans_bold"
  },
  fontVariation: {type: OptionType.OBJECT, default: null},
  lineHeight: {type: OptionType.NUMBER, default: 1},
  fontSize: {type: OptionType.NUMBER, default: 22},
  textColor: {type: OptionType.STRING, default: "black"},
  strokeStyle: {type: OptionType.STRING, default: "black"},
  outlineWidth: {type: OptionType.NUMBER, default: 0},
  textBaseline: {type: OptionType.STRING, default: "alphabetic"},
  excludeAccents: {type: OptionType.BOOLEAN, default: true},
  maxWidth: {type: OptionType.NUMBER, default: 100},
  maxHeight: {type: OptionType.NUMBER, default: 0},
  alignment: {
    type: OptionType.STRING,
    default: "left",
    available: ["left", "center", "right"]
  }
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/rows/masked/text-design-row-multiline.js
class TextDesignRowMultiline extends TextDesignRowMasked {
  _calculateLayoutElements() {
    const words8 = this.getWords();
    const textFrame = this._getTextFrame();
    const attributes = this.getAttributes();
    const fontIdentifier = attributes.getFontIdentifier();
    const imageInsets = this.getImageInsets();
    const font2 = new TextDesignFont({text: words8.getWord(0), fontIdentifier});
    font2.fitWidth(textFrame.width);
    const element = new TextDesignElement({
      text: words8.getWord(0),
      frame: textFrame,
      font: font2
    });
    element.setFrame(this._getTextFrameForElement(element));
    const size = this.getSize();
    if (this.getSizeToFitContent() || size.height <= 1) {
      size.height = imageInsets.top + element.getFrame().height + imageInsets.bottom;
    }
    size.height = Math.max(size.height, this.getMinimumHeight());
    return [element];
  }
  _getTextFrameForElement(element) {
    const words8 = this.getWords();
    const text = words8.getWord(0);
    const attributes = this.getAttributes();
    const fontIdentifier = attributes.getFontIdentifier();
    const imageInsets = this.getImageInsets();
    const insettedRect = this.getImageInsets().applyToRectangle(this._getFrame()).scale(this.getTextScaleFactor());
    const font2 = new TextDesignFontMultiline({
      text,
      fontIdentifier,
      alignment: attributes.getAlignment(),
      lineHeight: 1
    });
    font2.fitInFrame(insettedRect);
    const textSize = font2.getSize();
    insettedRect.height = textSize.height;
    let stringHeight = textSize.height * this.getRowScaleFactor();
    if (this.getSizeToFitContent()) {
      stringHeight += imageInsets.top + imageInsets.bottom;
    }
    const frame2 = this._getFrame();
    const alignment = attributes.getAlignment();
    if (this.getCenteredVertically()) {
      insettedRect.y = frame2.height / 2 - stringHeight / 2 + imageInsets.top;
    } else {
      switch (alignment) {
        case "left":
          insettedRect.y = frame2.height - stringHeight - imageInsets.bottom;
          break;
        case "center":
          insettedRect.y = frame2.height / 2 - stringHeight / 2 + stringHeight * this.getCenterOffset();
          insettedRect.x = (frame2.width - insettedRect.width) / 2;
          break;
        case "right":
          insettedRect.x = frame2.width - insettedRect.width - imageInsets.right;
          break;
        default:
          break;
      }
    }
    return insettedRect;
  }
  render(context) {
    context.save();
    this._getLayoutElements().forEach((element) => {
      let {text, frame: frame2} = element.serializeOptions();
      const attributes = this.getAttributes();
      const fontIdentifier = attributes.getFontIdentifier();
      const fontMultiline = new TextDesignFontMultiline({
        text,
        fontIdentifier,
        alignment: attributes.getAlignment(),
        lineHeight: 1,
        textColor: attributes.getTextColor().toRGBA()
      });
      frame2 = this._getTextFrameForElement(element);
      fontMultiline.fitInFrame(frame2);
      fontMultiline.draw(context, frame2.x, frame2.y);
    });
    context.restore();
  }
}
TextDesignRowMultiline.prototype.availableOptions = __assign(__assign({}, TextDesignRowMasked.prototype.availableOptions), {
  centerOffset: {type: OptionType.NUMBER, default: 0},
  sizeToFitContent: {type: OptionType.BOOLEAN, default: false},
  textScaleFactor: {type: OptionType.NUMBER, default: 0.95},
  rowScaleFactor: {type: OptionType.NUMBER, default: 1},
  minimumHeight: {type: OptionType.NUMBER, default: 0},
  centeredVertically: {type: OptionType.BOOLEAN, default: false}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked.js
class TextDesignMasked extends TextDesign {
  constructor(...args) {
    super(...args);
    this._rowType = RowType.Box;
    this._alignmentRandomizer = new Randomizer(0);
    this._isMaskedRandomizer = new Randomizer(0);
    this._seedPool.push(this._alignmentRandomizer);
    this._seedPool.push(this._isMaskedRandomizer);
  }
  getImagePaths() {
    return [RowType.Box.getImagePath()];
  }
  _modifiedText(text) {
    return super._modifiedText(text).toLowerCase();
  }
  _modifiedLines(lines) {
    const words8 = new Words();
    words8.set([
      lines.reduce((acc, line) => `${acc}${acc === "" ? "" : "\n"}${line.joined(1)[0]}`, "")
    ]);
    return [words8];
  }
  _layoutRows(lines, width) {
    const rows = super._layoutRows(lines, width);
    const firstRow = rows[0];
    if (firstRow && this.getSquareLayout()) {
      const size = firstRow.getSize();
      size.height = size.width;
    }
    return rows;
  }
  getAlignment() {
    return this._alignmentRandomizer.pickNext(this.constructor.ValidAlignments || TextDesignMasked.ValidAlignments);
  }
  _randomLayoutRow(words8, index, width, attributes) {
    const alignment = this.getAlignment();
    const rowType = this._rowType;
    const image5 = AssetManager.getImage(rowType.getImagePath());
    attributes.setAlignment(alignment);
    const row = new TextDesignRowMultiline({
      words: words8,
      width,
      attributes,
      image: image5,
      imageInsets: rowType.insetsForWidth(width),
      capInsets: rowType.getCapInsets(),
      backgroundColor: color_default.WHITE,
      centerOffset: 0,
      textScaleFactor: 0.7,
      isMasked: this._isMaskedRandomizer.nextBool()
    });
    if (this._rowType === RowType.Box) {
      row.serverImageSmoothingFix = true;
    }
    const rowSize = row.getSize();
    if (this.getSquareLayout()) {
      rowSize.height = rowSize.width;
    } else {
      rowSize.height = Math.max(rowSize.height, rowSize.width * rowType.getMinimumHeightRatio());
    }
    return row;
  }
}
TextDesignMasked.defaultFontIdentifiers = ["imgly_font_galano_grotesque_bold"];
TextDesignMasked.Alignment = {
  Left: "left",
  Center: "center",
  Right: "right"
};
TextDesignMasked.ValidAlignments = [
  TextDesignMasked.Alignment.Left,
  TextDesignMasked.Alignment.Center,
  TextDesignMasked.Alignment.Right
];
TextDesignMasked.identifier = "imgly_text_design_masked";
TextDesignMasked.prototype.availableOptions = __assign(__assign({}, TextDesign.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignMasked.defaultFontIdentifiers
  },
  squareLayout: {type: OptionType.BOOLEAN, default: true}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-badge.js
class TextDesignMaskedBadge extends TextDesignMasked {
  constructor(...args) {
    super(...args);
    this._possibleRowTypes = [
      RowType.Badge1,
      RowType.Badge2,
      RowType.Badge3,
      RowType.Badge4
    ];
    this._rowTypesRandomizer = new Randomizer(0);
    this._isMaskedRandomizer = new Randomizer(0);
    this._seedPool.push(this._rowTypesRandomizer);
    this._seedPool.push(this._isMaskedRandomizer);
  }
  getImagePaths() {
    return this._possibleRowTypes.map((rowType) => rowType.getImagePath());
  }
  _randomLayoutRow(words8, index, width, attributes) {
    this._rowType = this._rowTypesRandomizer.pickNext(this._possibleRowTypes);
    attributes.setLineSpacing(0.9);
    const row = super._randomLayoutRow(words8, index, width, attributes);
    row.set({textScaleFactor: 0.9});
    return row;
  }
}
TextDesignMaskedBadge.defaultFontIdentifiers = ["imgly_font_campton_bold"];
TextDesignMaskedBadge.identifier = "imgly_text_design_masked_badge";
TextDesignMaskedBadge.ValidAlignments = [TextDesignMasked.Alignment.Center];
TextDesignMaskedBadge.prototype.availableOptions = __assign(__assign({}, TextDesignMasked.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignMaskedBadge.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-speech-bubble.js
class TextDesignMaskedSpeechBubble extends TextDesignMasked {
  constructor(...args) {
    super(...args);
    this._possibleRowTypes = [RowType.SpeechBubble1, RowType.SpeechBubble3];
    this._rowTypesRandomizer = new Randomizer(0);
    this._isMaskedRandomizer = new Randomizer(0);
    this._seedPool.push(this._rowTypesRandomizer);
    this._seedPool.push(this._isMaskedRandomizer);
  }
  getImagePaths() {
    return this._possibleRowTypes.map((rowType) => rowType.getImagePath());
  }
  _rowTypes(words8) {
    return this._possibleRowTypes;
  }
  _randomLayoutRow(words8, index, width, attributes) {
    this._rowType = this._rowTypesRandomizer.pickNext(this._rowTypes(words8));
    attributes.setLineSpacing(0.9);
    const row = super._randomLayoutRow(words8, index, width, attributes);
    row.set({
      textScaleFactor: 1,
      minimumHeight: width * this._rowType.getMinimumHeightRatio(),
      sizeToFitContent: this._rowType.getSizeToFitContent(),
      centeredVertically: true
    });
    return row;
  }
}
TextDesignMaskedSpeechBubble.defaultFontIdentifiers = [
  "imgly_font_roboto_black_italic",
  "imgly_font_roboto_light_italic",
  "imgly_font_roboto_black",
  "imgly_font_roboto_light"
];
TextDesignMaskedSpeechBubble.identifier = "imgly_text_design_masked_speech_bubble";
TextDesignMaskedSpeechBubble.prototype.availableOptions = __assign(__assign({}, TextDesignMasked.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignMaskedSpeechBubble.defaultFontIdentifiers
  },
  squareLayout: {type: OptionType.BOOLEAN, default: false},
  alignment: {
    type: OptionType.STRING,
    default: "left",
    available: TextDesignMasked.ValidAlignments
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-masked-speech-bubble-comic.js
class TextDesignMaskedSpeechBubbleComic extends TextDesignMaskedSpeechBubble {
  constructor(...args) {
    super(...args);
    this._possibleRowTypes = [
      RowType.SpeechBubble2,
      RowType.SpeechBubble4,
      RowType.SpeechBubble2,
      RowType.SpeechBubble4,
      RowType.SpeechBubble5
    ];
    this._possibleRowTypesForMin15 = this._possibleRowTypes.slice(0, 2);
    this._possibleRowTypesForMax14 = this._possibleRowTypes.slice(2);
  }
  _rowTypes(words8) {
    return words8.countNumberOfCharacters() < 15 ? this._possibleRowTypesForMax14 : this._possibleRowTypesForMin15;
  }
}
TextDesignMaskedSpeechBubbleComic.defaultFontIdentifiers = ["imgly_font_permanent_marker"];
TextDesignMaskedSpeechBubbleComic.identifier = "imgly_text_design_masked_speech_bubble_comic";
TextDesignMaskedSpeechBubbleComic.prototype.availableOptions = __assign(__assign({}, TextDesignMaskedSpeechBubble.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignMaskedSpeechBubbleComic.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-multiline.js
class TextDesignMultiline extends TextDesignMasked {
  _modifiedText(text) {
    return super._modifiedText(text).toUpperCase();
  }
  _randomLayoutRow(words8, index, width, attributes) {
    const alignment = this._alignmentRandomizer.pickNext(TextDesignMasked.ValidAlignments);
    attributes.setAlignment(alignment);
    return new TextDesignRowMultiline({
      words: words8,
      width,
      attributes,
      image: null,
      backgroundColor: color_default.WHITE,
      centerOffset: 0,
      sizeToFitContent: true,
      isMasked: false,
      autoAdjustTextColor: false
    });
  }
}
TextDesignMultiline.defaultFontIdentifiers = ["imgly_font_abril_fatface_regular"];
TextDesignMultiline.identifier = "imgly_text_design_multiline";
TextDesignMultiline.prototype.availableOptions = __assign(__assign({}, TextDesignMasked.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignMultiline.defaultFontIdentifiers
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particle.js
const {Rectangle: Rectangle11} = math_exports;
class TextDesignParticle extends configurable_default {
  getContentFrame() {
    const frame2 = this.getFrame().clone();
    const inset = frame2.width * 0.1;
    return frame2.insetBy(inset, inset);
  }
  intersects(particle) {
    return this.getFrame().intersects(particle.getFrame());
  }
}
TextDesignParticle.prototype.availableOptions = {
  frame: {type: OptionType.OBJECT, default: new Rectangle11()}
};

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background.js
const {Rectangle: Rectangle12} = math_exports;
class TextDesignParticlesBackground extends TextDesignBackground {
  constructor(...args) {
    super(...args);
    this._MAX_TRIES = 1e3;
    this._PRECISION = 1e3;
  }
  render(context, size, relativeInsets, color6, randomizer13) {
    const {imagePaths, relativeParticleSize} = this._options;
    if (imagePaths.length <= 0) {
      return;
    }
    const aspect = size.width / size.height;
    const textRect = new Rectangle12(Math.round(relativeInsets.left * this._PRECISION), Math.round(relativeInsets.top * this._PRECISION * aspect), this._PRECISION, this._PRECISION);
    textRect.width -= textRect.x + Math.round(relativeInsets.right * this._PRECISION);
    textRect.height -= textRect.y + Math.round(relativeInsets.bottom * this._PRECISION * aspect);
    const particles = [];
    let count = 0;
    let tryCount = 0;
    while (count < this.getParticleCount() && tryCount < this._MAX_TRIES) {
      const radius = relativeParticleSize / 2;
      const minX = Math.round(radius * this._PRECISION);
      const minY = Math.round(radius * this._PRECISION * aspect);
      const maxX = Math.floor(this._PRECISION) - minX;
      const maxY = Math.floor(this._PRECISION) - minY;
      const randomValueX = randomizer13.nextInRange(minX, maxX);
      const randomValueY = randomizer13.nextInRange(minY, maxY);
      const frame2 = new Rectangle12(randomValueX - minX, randomValueY - minY, 2 * minX, 2 * minY);
      if (!frame2.intersects(textRect) && !this.hasCollision(particles, frame2)) {
        particles.push(new TextDesignParticle({frame: frame2}));
        count += 1;
      }
      tryCount += 1;
    }
    for (let i = 0; i < particles.length; i++) {
      const particle = particles[i];
      const randomImagePath = randomizer13.pickNext(imagePaths);
      const randomImage = AssetManager.getImage(randomImagePath);
      const opacity = randomizer13.nextInRange(140, 230) / 255;
      const scaleX = size.width / this._PRECISION;
      const scaleY = size.height / this._PRECISION;
      const destination = particle.getContentFrame();
      destination.x *= scaleX;
      destination.y *= scaleY;
      destination.width *= scaleX;
      destination.height *= scaleY;
      const finalColor = color6.clone();
      finalColor.a = opacity;
      drawImageFrame(context, randomImage, destination, finalColor, "source-atop");
    }
  }
  hasCollision(particles, rect) {
    for (let i = 0; i < particles.length; i++) {
      if (rect.intersects(particles[i].getFrame())) {
        return true;
      }
    }
    return false;
  }
}
TextDesignParticlesBackground.prototype.availableOptions = __assign(__assign({}, TextDesignBackground.prototype.availableOptions), {
  particleCount: {type: OptionType.NUMBER, default: 50},
  relativeParticleSize: {type: OptionType.NUMBER, default: 0.08},
  imagePaths: {type: OptionType.ARRAY, default: []}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-brush.js
class TextDesignParticlesBackgroundBrush extends TextDesignParticlesBackground {
}
TextDesignParticlesBackgroundBrush.Images = [
  "text-design/images/imgly_text_design_particle_brush_01.png",
  "text-design/images/imgly_text_design_particle_brush_02.png",
  "text-design/images/imgly_text_design_particle_brush_03.png",
  "text-design/images/imgly_text_design_particle_brush_04.png",
  "text-design/images/imgly_text_design_particle_brush_05.png",
  "text-design/images/imgly_text_design_particle_brush_06.png",
  "text-design/images/imgly_text_design_particle_brush_07.png",
  "text-design/images/imgly_text_design_particle_brush_08.png",
  "text-design/images/imgly_text_design_particle_brush_09.png",
  "text-design/images/imgly_text_design_particle_brush_10.png"
];
TextDesignParticlesBackgroundBrush.prototype.availableOptions = __assign(__assign({}, TextDesignParticlesBackground.prototype.availableOptions), {
  imagePaths: {
    type: OptionType.ARRAY,
    default: [...TextDesignParticlesBackgroundBrush.Images]
  },
  relativeParticleSize: {type: OptionType.NUMBER, default: 0.12}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-circle.js
class TextDesignParticlesBackgroundCircle extends TextDesignParticlesBackground {
}
TextDesignParticlesBackgroundCircle.Images = [
  "text-design/images/imgly_text_design_particle_circle_01.png",
  "text-design/images/imgly_text_design_particle_circle_02.png",
  "text-design/images/imgly_text_design_particle_circle_03.png",
  "text-design/images/imgly_text_design_particle_circle_04.png",
  "text-design/images/imgly_text_design_particle_circle_05.png",
  "text-design/images/imgly_text_design_particle_circle_06.png",
  "text-design/images/imgly_text_design_particle_circle_07.png",
  "text-design/images/imgly_text_design_particle_circle_08.png",
  "text-design/images/imgly_text_design_particle_circle_09.png",
  "text-design/images/imgly_text_design_particle_circle_10.png"
];
TextDesignParticlesBackgroundCircle.prototype.availableOptions = __assign(__assign({}, TextDesignParticlesBackground.prototype.availableOptions), {
  imagePaths: {
    type: OptionType.ARRAY,
    default: [...TextDesignParticlesBackgroundCircle.Images]
  },
  relativeParticleSize: {type: OptionType.NUMBER, default: 0.12}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/models/background/text-design-particles-background-triangle.js
class TextDesignParticlesBackgroundTriangle extends TextDesignParticlesBackground {
}
TextDesignParticlesBackgroundTriangle.Images = [
  "text-design/images/imgly_text_design_particle_triangle_01.png",
  "text-design/images/imgly_text_design_particle_triangle_02.png",
  "text-design/images/imgly_text_design_particle_triangle_03.png",
  "text-design/images/imgly_text_design_particle_triangle_04.png",
  "text-design/images/imgly_text_design_particle_triangle_05.png",
  "text-design/images/imgly_text_design_particle_triangle_06.png",
  "text-design/images/imgly_text_design_particle_triangle_07.png",
  "text-design/images/imgly_text_design_particle_triangle_08.png",
  "text-design/images/imgly_text_design_particle_triangle_09.png",
  "text-design/images/imgly_text_design_particle_triangle_10.png"
];
TextDesignParticlesBackgroundTriangle.prototype.availableOptions = __assign(__assign({}, TextDesignParticlesBackground.prototype.availableOptions), {
  imagePaths: {
    type: OptionType.ARRAY,
    default: [...TextDesignParticlesBackgroundTriangle.Images]
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-sunshine.js
class TextDesignSunshine extends TextDesign {
  constructor(...args) {
    super(...args);
    this._relativeInsets = new RectangleInsets(0, 0, 0, 0);
    this._INVALID_FONTS_IF_LESS_THEN_5_CHARS = ["imgly_font_montserrat_light"];
    this._INVALID_FONTS_IF_LESS_THEN_4_CHARS = [
      "imgly_font_montserrat_light",
      "imgly_font_wolesbro"
    ];
    this._lineCount = 0;
    this._decorativeRowCreated = false;
    this._useImageRowRandomizer = new Randomizer(0);
    this._rowTypeRandomizer = new Randomizer(0);
    this._lineDecorativeTypeRandomizer = new Randomizer(0);
    this._seedPool.push(this._useImageRowRandomizer);
    this._seedPool.push(this._rowTypeRandomizer);
    this._seedPool.push(this._lineDecorativeTypeRandomizer);
  }
  getImagePaths() {
    return [
      ...TextDesignSunshine.DecoratorImages,
      ...TextDesignSunshine.RowImages
    ];
  }
  _fontForRow(index, words8) {
    const numOfCharacters = words8.countNumberOfCharacters();
    let fonts2 = this.getFontIdentifiers();
    if (numOfCharacters < 4) {
      fonts2 = fonts2.filter((font2) => this._INVALID_FONTS_IF_LESS_THEN_4_CHARS.indexOf(font2) < 0);
    } else if (numOfCharacters < 5) {
      fonts2 = fonts2.filter((font2) => this._INVALID_FONTS_IF_LESS_THEN_5_CHARS.indexOf(font2) < 0);
    }
    return fonts2[index % fonts2.length];
  }
  _modifiedText(text) {
    return super._modifiedText(text).toUpperCase();
  }
  _modifiedLines(lines) {
    this._lineCount = lines.length;
    return lines;
  }
  generateLayoutData(text, width) {
    this._decorativeRowCreated = false;
    return super.generateLayoutData(text, width);
  }
  _randomLayoutRow(words8, index, width, attributes) {
    const fontIdentifier = attributes.getFontIdentifier();
    let modifiedWords = words8;
    switch (fontIdentifier) {
      case "imgly_font_wolesbro":
        modifiedWords = new Words().set(words8.getLowerCase());
        break;
      case "imgly_font_permanent_marker":
        modifiedWords = new Words().set(words8.getUpperCase());
        break;
      default:
        break;
    }
    const noDecorations = this.getDecorativeRowsInTheMiddleOnly() && (index === 0 || index === this._lineCount - 1);
    if (this._useImageRowRandomizer.nextBool() || this._decorativeRowCreated || noDecorations) {
      return new TextDesignRowSingle({
        words: modifiedWords,
        width,
        attributes
      });
    }
    this._decorativeRowCreated = true;
    const [leftImage, rightImage] = this._randomDecoratorImages();
    return new TextDesignRowImage({
      words: words8,
      width,
      attributes,
      leftImage,
      rightImage
    });
  }
  _layoutRows(lines, width) {
    const elements = super._layoutRows(lines, width);
    if (!this.getDecorationsVisible()) {
      return elements;
    }
    const formHeight = 0.0625 * width;
    const firstRow = new TextDesignRowSingleImage({
      width,
      height: formHeight,
      image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(TextDesignSunshine.RowImages))
    }).layout();
    const lastRow = new TextDesignRowSingleImage({
      width,
      height: formHeight,
      image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(TextDesignSunshine.RowImages))
    }).layout();
    return [firstRow, ...elements, lastRow];
  }
  _randomDecoratorImages() {
    if (this._lineDecorativeTypeRandomizer.nextInRange(0, 1)) {
      return TextDesignSunshine.DecoratorImages.slice(0, 2).map((path2) => AssetManager.getImage(path2));
    }
    return TextDesignSunshine.DecoratorImages.slice(2).map((path2) => AssetManager.getImage(path2));
  }
}
TextDesignSunshine.defaultFontIdentifiers = [
  "imgly_font_permanent_marker",
  "imgly_font_wolesbro",
  "imgly_font_wolesbro",
  "imgly_font_montserrat_light"
];
TextDesignSunshine.identifier = "imgly_text_design_sunshine";
TextDesignSunshine.RowImages = [
  TextDesignRowSingleImage.RowImages.decorative1,
  TextDesignRowSingleImage.RowImages.decorative2,
  TextDesignRowSingleImage.RowImages.decorative3,
  TextDesignRowSingleImage.RowImages.decorative4
];
TextDesignSunshine.DecoratorImages = [
  "text-design/images/imgly_text_design_asset_decorative_03.png",
  "text-design/images/imgly_text_design_asset_decorative_04.png",
  "text-design/images/imgly_text_design_asset_decorative_07.png",
  "text-design/images/imgly_text_design_asset_decorative_08.png"
];
TextDesignSunshine.prototype.availableOptions = __assign(__assign({}, TextDesign.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignSunshine.defaultFontIdentifiers
  },
  relativeLineSpacing: {type: OptionType.NUMBER, default: 0.025 / 3 * 4},
  decorationsVisible: {type: OptionType.BOOLEAN, default: true},
  decorativeRowsInTheMiddleOnly: {type: OptionType.BOOLEAN, default: false}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-particles.js
class TextDesignParticles extends TextDesignSunshine {
  constructor(...args) {
    super(...args);
    this._relativeInsets = new RectangleInsets(0.3, 0.3, 0.3, 0.3);
    this._backgroundRandomizer = new Randomizer(0);
    this._decoTypeRandomizer = new Randomizer(0);
    this._seedPool.push(this._backgroundRandomizer);
    this._seedPool.push(this._decoTypeRandomizer);
  }
  getImagePaths() {
    return [
      ...TextDesignSunshine.RowImages,
      ...utils_default.Array.flatten(TextDesignParticles.Backgrounds.map((b) => b.getImagePaths())),
      ...TextDesignParticles.DecoratorImages
    ];
  }
  _getBackground() {
    return this._backgroundRandomizer.pickNext(TextDesignParticles.Backgrounds);
  }
  _randomDecoratorImages() {
    switch (this._decoTypeRandomizer.nextInRange(0, 2)) {
      case 0:
        return TextDesignParticles.DecoratorImages.slice(0, 2).map((path2) => AssetManager.getImage(path2));
      case 1:
      case 2:
        return TextDesignParticles.DecoratorImages.slice(2).map((path2) => AssetManager.getImage(path2));
      default:
        log_default.warn("TextDesignParticles#_randomDecoratorImages: Number generated not in valid range.");
        return TextDesignParticles.DecoratorImages.slice(2).map((path2) => AssetManager.getImage(path2));
    }
  }
}
TextDesignParticles.defaultFontIdentifiers = [
  "imgly_font_permanent_marker",
  "imgly_font_wolesbro",
  "imgly_font_wolesbro",
  "imgly_font_montserrat_light"
];
TextDesignParticles.identifier = "imgly_text_design_particles";
TextDesignParticles.Backgrounds = [
  new TextDesignParticlesBackgroundBrush(),
  new TextDesignParticlesBackgroundCircle(),
  new TextDesignParticlesBackgroundTriangle()
];
TextDesignParticles.DecoratorImages = [
  "text-design/images/imgly_text_design_particle_holder_01.png",
  "text-design/images/imgly_text_design_particle_holder_02.png",
  "text-design/images/imgly_text_design_particle_holder_03.png",
  "text-design/images/imgly_text_design_particle_holder_04.png"
];
TextDesignParticles.prototype.availableOptions = __assign(__assign({}, TextDesignSunshine.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignParticles.defaultFontIdentifiers
  },
  decorationsVisible: {type: OptionType.BOOLEAN, default: false},
  decorativeRowsInTheMiddleOnly: {type: OptionType.BOOLEAN, default: true}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-rotated.js
class TextDesignRotated extends TextDesign {
  constructor(...args) {
    super(...args);
    this._relativeInsets = new RectangleInsets(0.1, 0, 0, 0);
    this._rowTypeRandomizer = new Randomizer(0);
    this._seedPool.push(this._rowTypeRandomizer);
  }
  _modifiedText(text) {
    return super._modifiedText(text).toUpperCase();
  }
  _randomLayoutRow(words8, index, width, attributes) {
    const row = super._randomLayoutRow(words8, index, width, attributes);
    row.setShearingAngle(this.getShearingAngle());
    return row;
  }
  _layoutRows(lines, width) {
    const elements = super._layoutRows(lines, width);
    const types = utils_default.values(TextDesignRowForm.FormType);
    const formHeight = 30;
    const firstRow = new TextDesignRowForm({
      width,
      height: formHeight,
      type: this._rowTypeRandomizer.pickNext(types),
      shearingAngle: this.getShearingAngle()
    }).layout();
    const lastRow = new TextDesignRowForm({
      width,
      height: formHeight,
      type: this._rowTypeRandomizer.pickNext(types),
      shearingAngle: this.getShearingAngle()
    }).layout();
    return [firstRow, ...elements, lastRow];
  }
}
TextDesignRotated.defaultFontIdentifiers = ["imgly_font_campton_bold"];
TextDesignRotated.identifier = "imgly_text_design_rotated";
TextDesignRotated.prototype.availableOptions = __assign(__assign({}, TextDesign.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignRotated.defaultFontIdentifiers
  },
  relativeLineSpacing: {type: OptionType.NUMBER, default: 0.025 / 3},
  shearingAngle: {type: OptionType.NUMBER, default: -0.1}
});

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-sunshine-v3_1_0.js
class TextDesignSunshineV310 extends TextDesignSunshine {
  constructor(...args) {
    super(...args);
    this._relativeInsets = new RectangleInsets(0, 0.3, 0, 0.3);
  }
  _layoutRows(lines, width) {
    const elements = super._layoutRows(lines, width);
    if (!this.getDecorationsVisible()) {
      return elements;
    }
    const formHeight = 25;
    const firstRow = new TextDesignRowSingleImage({
      width,
      height: formHeight,
      image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(TextDesignSunshine.RowImages))
    }).layout();
    const lastRow = new TextDesignRowSingleImage({
      width,
      height: formHeight,
      image: AssetManager.getImage(this._rowTypeRandomizer.pickNext(TextDesignSunshine.RowImages))
    }).layout();
    return [firstRow, ...elements, lastRow];
  }
}
TextDesignSunshineV310.identifier = "imgly_text_design_sunshine-v3_1_0";

// engine/sdk/operations/sprite-operation/sprites/text-design/layout/text-design-watercolor.js
class TextDesignWatercolor extends TextDesignMaskedSpeechBubble {
  constructor(...args) {
    super(...args);
    this._possibleRowTypes = [
      RowType.Watercolor1,
      RowType.Watercolor2,
      RowType.Watercolor3
    ];
  }
}
TextDesignWatercolor.defaultFontIdentifiers = [
  "imgly_font_permanent_marker",
  "imgly_font_wolesbro",
  "imgly_font_wolesbro"
];
TextDesignWatercolor.identifier = "imgly_text_design_watercolor";
TextDesignWatercolor.prototype.availableOptions = __assign(__assign({}, TextDesignMaskedSpeechBubble.prototype.availableOptions), {
  fontIdentifiers: {
    type: OptionType.ARRAY,
    default: TextDesignWatercolor.defaultFontIdentifiers
  },
  alignment: {
    type: OptionType.STRING,
    default: TextDesignMasked.Alignment.Center,
    available: TextDesignMasked.ValidAlignments
  }
});

// engine/sdk/operations/sprite-operation/sprites/text-design/text-design-renderer.js
const {Rectangle: Rectangle13} = math_exports;
const REFERENCE_WIDTH = 1e3;
class TextDesignRenderer {
  constructor() {
    this._layoutData = null;
    this._layout = null;
    this._text = "";
    this._seed = 0;
    this._debugMode = false;
    this.randomizer = new Randomizer();
  }
  createLayout(layout, text, seed) {
    this._layout = layout;
    this._text = text;
    this._seed = seed;
    layout.seed(seed);
    this._layoutData = layout.generateLayoutData(text, REFERENCE_WIDTH);
  }
  calculateAspect() {
    if (!this._layoutData) {
      log_default.warn("TextDesignRenderer#calculateAspect: No layout data");
      return 1;
    }
    return this._layoutData.getSize().aspect();
  }
  draw(context, destinationSize, color6, isInverted) {
    const layoutData = this._layoutData;
    if (this._layoutData) {
      const renderSize = new SizeValue(REFERENCE_WIDTH, REFERENCE_WIDTH / destinationSize.aspect());
      const scale = destinationSize.width / REFERENCE_WIDTH;
      const insets = layoutData.getRelativeInsets().clone().scale(renderSize.width);
      const lineSpacing = layoutData.getRelativeLineSpacing() * renderSize.width;
      let yOrigin = insets.top;
      context.save();
      this.randomizer.seed(this._seed);
      const background = layoutData.getBackground();
      if (background) {
        background.render(context, destinationSize, layoutData.getRelativeInsets(), isInverted ? color_default.WHITE : color6, this.randomizer);
      }
      context.scale(scale, scale);
      layoutData.getRows().forEach((row) => {
        context.save();
        const attributes = row.getAttributes();
        context.transform(1, row.getShearingAngle(), 0, 1, insets.left, yOrigin);
        attributes.setTextColor(isInverted ? color_default.WHITE : color6.clone());
        attributes.setTintColor(isInverted ? color_default.WHITE : color6.clone());
        if (row instanceof TextDesignRowMasked || row instanceof TextDesignRowMultiline) {
          row.setBackgroundColor(isInverted ? color_default.WHITE : color6.clone());
          row.setIsUsedInInvertedLayout(isInverted);
        }
        if (this._debugMode) {
          row._debugMode = true;
        }
        row.willRender(context);
        row.render(context);
        row.didRender(context);
        if (this._debugMode) {
          const frame2 = row._getFrame();
          const textFrame = row._getTextFrame();
          strokeRect(context, frame2, color_default.GREEN);
          strokeRect(context, textFrame, color_default.BLUE);
          row._getLayoutElements().forEach((element) => {
            const frame3 = element.getFrame();
            const textFrame2 = row._getTextFrameForElement(element);
            strokeRect(context, frame3, new color_default(1, 1, 0));
            strokeRect(context, textFrame2, new color_default(0, 1, 1));
          });
        }
        yOrigin += row.getSize().height + lineSpacing;
        context.restore();
      });
      if (this._debugMode) {
        strokeRect(context, new Rectangle13(0, 0, renderSize.width, renderSize.height), color_default.RED);
      }
      context.restore();
    }
  }
}

// engine/sdk/operations/sprite-operation/sprites/text-design-sprite.js
const {Vector2: Vector229} = math_exports;
class TextDesignSprite extends sprite_default2 {
  constructor(operation3, options) {
    super(operation3, options);
    this._isDisposed = false;
    this._renderer = new TextDesignRenderer();
    this._canvas = utils_default.createCanvas();
    this._context = this._canvas.getContext("2d");
    this._texture = engine_default.Texture.fromCanvas(this._canvas);
    this._sprite.setTexture(this._texture);
    this._aspect = 1;
    this._isLayoutDirty = true;
    if (this.getSeed() < 0) {
      this.setSeed(Randomizer.TimeSeed());
    }
  }
  seed(value) {
    this.setSeed(value || Randomizer.TimeSeed());
    this._isLayoutDirty = true;
  }
  _updateLayout() {
    const layout = this.getLayout();
    if (!layout) {
      return null;
    }
    this._renderer.createLayout(layout, this.getText(), this.getSeed());
    this._aspect = this._renderer.calculateAspect();
    this._isLayoutDirty = false;
    return true;
  }
  applyTransform(transformChange) {
    super.applyTransform(transformChange);
    const newOptions = {};
    if (this._options.dimensions) {
      newOptions.width = transformChange.applyToRelativeSize(this.getWidth());
    }
    this.set(newOptions, false);
  }
  applyFlip(direction) {
    super.applyFlip(direction);
    let {rotation} = this._options;
    switch (direction) {
      case "horizontal":
        rotation += (Math.PI - rotation) * 2;
        this.setRotation(rotation);
        break;
      case "vertical":
        rotation += (Math.PI / 2 - rotation) * 2;
        this.setRotation(rotation);
        break;
    }
  }
  update(sdk14, inputDimensions) {
    const contentNeedUpdate = this._isLayoutDirty;
    if (this._isDisposed || contentNeedUpdate && !this._updateLayout()) {
      return;
    }
    const width = this.getWidth() * inputDimensions.min() / sdk14.getTextureScale();
    const height = width / this._aspect;
    const spriteDimensions = new Vector229(width, height);
    const renderDimensions = new Vector229(Math.round(width * 2), Math.round(height * 2)).clamp(new Vector229(1, 1), new Vector229(Infinity, Infinity));
    const renderer = sdk14.getRenderer();
    const maxDimensions = renderer.getMaxDimensions() || Infinity;
    if (renderDimensions.x > maxDimensions) {
      renderDimensions.x = maxDimensions;
      renderDimensions.y = Math.round(renderDimensions.x / this._aspect);
    }
    if (renderDimensions.y > maxDimensions) {
      renderDimensions.y = maxDimensions;
      renderDimensions.x = Math.round(renderDimensions.y * this._aspect);
    }
    const sizeChanged = utils_default.ensureCanvasDimensions(this._canvas, renderDimensions);
    if (contentNeedUpdate || sizeChanged) {
      this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
      this._renderer.draw(this._context, new SizeValue(renderDimensions.x, renderDimensions.y), this.getColor(), this.getInverted());
      this.setDimensions(spriteDimensions);
      this._texture.getBaseTexture().update();
      if (renderer.isOfType(RendererType.WEBGL)) {
        renderer.updateTexture(this._texture.getBaseTexture());
      }
    }
    super.update(sdk14, inputDimensions);
    this._applyFlip();
  }
  _applyFlip() {
    const scale = this._sprite.getScale();
    const {flipHorizontally, flipVertically} = this._options;
    if (flipHorizontally && scale.x > 0 || !flipHorizontally && scale.x < 0) {
      scale.x *= -1;
    }
    if (flipVertically && scale.y > 0 || !flipVertically && scale.y < 0) {
      scale.y *= -1;
    }
    this._sprite.setScale(scale);
  }
  _optionEquals(optionName, value) {
    if (optionName === "layout") {
      const {layout} = this._options;
      if (!layout && value || !value && layout) {
        return false;
      }
      if (!value.constructor || !layout.constructor) {
        return false;
      }
      if (layout.constructor.identifier !== value.constructor.identifier) {
        return false;
      }
      return true;
    }
    return super._optionEquals(optionName, value);
  }
  serializeOptions(keys, toObject = false) {
    if (keys && this.getPadding() < 0) {
      const index = keys.indexOf("padding");
      if (index > -1) {
        keys.splice(index, 1);
      }
    }
    const options = super.serializeOptions(keys, toObject);
    if (!keys)
      options.type = "textdesign";
    return options;
  }
  _getTexture() {
    return this._texture;
  }
  canBeFlippedHorizontally() {
    return false;
  }
  canBeDuplicated() {
    return true;
  }
  canMaskCanvas() {
    return true;
  }
  canAdjustPadding() {
    return true;
  }
  dispose() {
    this._isDisposed = true;
    this._texture.dispose();
    this._sprite.dispose();
  }
}
TextDesignSprite.Layouts = {
  TextDesignBlocks,
  TextDesignBlocksCondensed,
  TextDesignBlocksLight,
  TextDesignCelebrate,
  TextDesignCelebrateSimple,
  TextDesignEqualWidth,
  TextDesignEqualWidthFat,
  TextDesignMasked,
  TextDesignMaskedBadge,
  TextDesignMaskedSpeechBubble,
  TextDesignMaskedSpeechBubbleComic,
  TextDesignMultiline,
  TextDesignWatercolor,
  TextDesignSunshine,
  TextDesignParticles,
  TextDesignRotated
};
TextDesignSprite.LegacyLayouts = {
  TextDesignBlocksLightV310,
  TextDesignSunshineV310
};
TextDesignSprite.AssetManager = AssetManager;
TextDesignSprite.prototype.availableOptions = {
  id: {type: OptionType.STRING, default: () => utils_default.getUUID()},
  position: {type: OptionType.VECTOR2, default: new Vector229(0.5, 0.5)},
  dimensions: {type: OptionType.VECTOR2, default: Vector229.NULL},
  anchor: {type: OptionType.VECTOR2, default: new Vector229(0, 0)},
  pivot: {type: OptionType.VECTOR2, default: new Vector229(0.5, 0.5)},
  rotation: {type: OptionType.NUMBER, default: 0},
  flipHorizontally: {type: OptionType.BOOLEAN, default: false},
  flipVertically: {type: OptionType.BOOLEAN, default: false},
  layout: {
    type: OptionType.OBJECT,
    default: null,
    setter(layout) {
      this._isLayoutDirty = true;
      return layout;
    }
  },
  text: {
    type: OptionType.STRING,
    default: "",
    setter(text) {
      this._isLayoutDirty = true;
      return text;
    }
  },
  color: {
    type: OptionType.COLOR,
    default: color_default.BLACK,
    setter(color6) {
      this._isLayoutDirty = true;
      return color6;
    }
  },
  padding: {type: OptionType.NUMBER, default: 0.01, minValue: 0.01},
  width: {
    type: OptionType.NUMBER,
    default: 0.8
  },
  inverted: {
    type: OptionType.BOOLEAN,
    default: false,
    setter(value) {
      this._isLayoutDirty = true;
      return value;
    }
  },
  seed: {type: OptionType.NUMBER, default: -1}
};
var text_design_sprite_default = TextDesignSprite;

// engine/sdk/operations/sprite-operation/sprites/text-sprite.js
const {Vector2: Vector230} = math_exports;
class TextSprite extends sprite_default2 {
  constructor(...args) {
    super(...args);
    this._textRenderer = new text_renderer_default(this, this._operation);
    this._textRenderer.rotation = this.getRotation();
    this._sprite.setTexture(this._textRenderer.getFinalTexture());
    this._hitTestSprite.setTexture(this._textRenderer.getTexture());
  }
  serializeOptions(keys, toObject = false) {
    const options = super.serializeOptions(keys, toObject);
    if (!keys)
      options.type = "text";
    return options;
  }
  getDOMStyle(sdk14, inputDimensions) {
    const actualFontSize = this.getFontSize() * inputDimensions.y;
    return {
      fontWeight: this._options.fontWeight,
      fontSize: `${actualFontSize}px`,
      fontStyle: this._options.fontStyle,
      fontFamily: this._options.fontFamily,
      lineHeight: `${this.getAbsoluteTextHeight(inputDimensions) * this.getLineHeight()}px`,
      color: this._options.color.toRGBA(),
      backgroundColor: this._options.backgroundColor.toRGBA(),
      textAlign: this._options.alignment
    };
  }
  getAbsoluteTextHeight(inputDimensions) {
    const actualFontSize = this.getFontSize() * inputDimensions.y;
    const textMetrics = this.getTextMetrics();
    if (textMetrics) {
      const scale = 1 / textMetrics.unitsPerEm * actualFontSize;
      const ascent = textMetrics.ascender * scale;
      const descent = textMetrics.descender * scale;
      return ascent + Math.abs(descent);
    }
    return actualFontSize * this.getLineHeight() * 1.1;
  }
  getDimensions(sdk14, inputDimensions) {
    return this._textRenderer.getDimensions(sdk14, inputDimensions);
  }
  applyFlip(direction) {
    super.applyFlip(direction);
    let {rotation} = this._options;
    switch (direction) {
      case "horizontal":
        rotation += (Math.PI - rotation) * 2;
        this.setRotation(rotation);
        break;
      case "vertical":
        rotation += (Math.PI / 2 - rotation) * 2;
        this.setRotation(rotation);
        break;
    }
  }
  applyTransform(transformChange) {
    super.applyTransform(transformChange);
    this.set({
      fontSize: transformChange.scaleSize(this.getFontSize(), "y"),
      maxWidth: transformChange.scaleSize(this.getMaxWidth(), "x")
    }, false);
  }
  applyRotation(degrees) {
    super.applyRotation(degrees);
    const actualDegrees = (degrees + 360) % 360;
    const inputDimensions = this._operation.getInputDimensions();
    if (actualDegrees === 90 || actualDegrees === 270) {
      this.setMaxWidth(this.getMaxWidth() / inputDimensions.x * inputDimensions.y);
      this.setFontSize(this.getFontSize() / inputDimensions.y * inputDimensions.x);
    }
  }
  setOption(key, value) {
    const {flipHorizontally, flipVertically} = this._options;
    if (key === "rotation") {
      let rotation = value;
      if (flipHorizontally) {
        rotation = Math.PI * 2 - rotation;
      }
      if (flipVertically) {
        rotation = Math.PI * 2 - rotation;
      }
      this._options.rotation = rotation;
      if (this._textRenderer) {
        this._textRenderer.rotation = rotation;
      }
      this._rotation = rotation;
      this.emit("update");
      return;
    }
    super.setOption(key, value);
  }
  getOption(key) {
    if (key === "rotation") {
      return this._rotation;
    }
    return super.getOption(key);
  }
  getHitTestDisplayObject() {
    return this._hitTestSprite;
  }
  update(sdk14, inputDimensions) {
    this._sprite.setVisible(this._options.visible);
    if (!this._options.visible)
      return;
    this._textRenderer.update(sdk14, inputDimensions);
    const textTexture = this._textRenderer.getFinalTexture();
    const baseTexture = textTexture.getBaseTexture();
    baseTexture.update();
    const renderer = sdk14.getRenderer();
    if (renderer.isOfType(RendererType.WEBGL)) {
      renderer.updateTexture(textTexture.getBaseTexture());
    }
    super.update(sdk14, inputDimensions);
    this._sprite.setRotation(0);
    this._textRenderer.getTexture().getBaseTexture().update();
    this._hitTestSprite.setRotation(this._rotation);
    this._hitTestSprite.updateTransform();
    this._applyFlip();
  }
  _applyFlip() {
    const scale = this._sprite.getScale();
    const {flipHorizontally, flipVertically} = this._options;
    if (flipHorizontally && scale.x > 0 || !flipHorizontally && scale.x < 0) {
      scale.x *= -1;
      this.setRotation(this._rotation);
    }
    if (flipVertically && scale.y > 0 || !flipVertically && scale.y < 0) {
      scale.y *= -1;
      this.setRotation(this._rotation);
    }
    this._sprite.setScale(scale);
  }
  _getTexture() {
    return this._textRenderer.getFinalTexture();
  }
  dispose() {
    super.dispose();
    this._textRenderer.dispose();
    this._hitTestSprite.dispose();
    this._sprite.dispose();
  }
  canBeFlippedHorizontally() {
    return false;
  }
  canAdjustPadding() {
    return false;
  }
}
TextSprite.prototype.availableOptions = {
  id: {type: OptionType.STRING, default: () => utils_default.getUUID()},
  fontSize: {type: OptionType.NUMBER, default: 0.1},
  characterSpacing: {type: OptionType.NUMBER, default: 0},
  lineHeight: {type: OptionType.NUMBER, default: 1.1},
  fontIdentifier: {type: OptionType.STRING},
  fontFamily: {type: OptionType.STRING, default: "Times New Roman"},
  fontWeight: {type: OptionType.ALL, default: "normal"},
  fontStyle: {type: OptionType.STRING, default: "normal"},
  textMetrics: {type: OptionType.OBJECT, default: null},
  outlineWidth: {type: OptionType.NUMBER, default: 0},
  outlineColor: {type: OptionType.COLOR, default: color_default.BLACK},
  alignment: {
    type: OptionType.STRING,
    default: "left",
    available: ["left", "center", "right"]
  },
  verticalAlignment: {
    type: OptionType.STRING,
    default: "top",
    available: ["top", "center", "bottom"]
  },
  color: {type: OptionType.COLOR, default: new color_default(1, 0, 0, 1)},
  backgroundColor: {type: OptionType.COLOR, default: color_default.TRANSPARENT},
  position: {type: OptionType.VECTOR2, default: new Vector230(0.5, 0.5)},
  anchor: {type: OptionType.VECTOR2, default: new Vector230(0, 0)},
  pivot: {type: OptionType.VECTOR2, default: new Vector230(0.5, 0.5)},
  rotation: {type: OptionType.NUMBER, default: 0},
  text: {type: OptionType.STRING, required: true},
  maxWidth: {type: OptionType.NUMBER, default: 0.5},
  maxHeight: {type: OptionType.NUMBER, default: 0},
  visible: {type: OptionType.BOOLEAN, default: true},
  flipHorizontally: {type: OptionType.BOOLEAN, default: false},
  flipVertically: {type: OptionType.BOOLEAN, default: false}
};
TextSprite.type = "text";
var text_sprite_default = TextSprite;

// engine/sdk/operations/sprite-operation/index.js
const {Vector2: Vector231} = math_exports;
class SpriteOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this.setSmoothDownscaling(this._sdk.getOptions().smoothDownscaling);
    this._onSpriteUpdate = this._onSpriteUpdate.bind(this);
    this._maskCanvas = utils_default.createCanvas();
    const sprites = this._options.sprites.slice();
    sprites.forEach((sprite7) => {
      this.removeSprite(sprite7);
      this.addSprite(sprite7);
    });
  }
  getSpritesOfType(Klass) {
    return this._options.sprites.filter((sprite7) => sprite7 instanceof Klass);
  }
  rotate(degrees) {
    this._options.sprites.forEach((sprite7) => {
      sprite7.applyRotation(degrees);
    });
  }
  flip(direction) {
    this._options.sprites.forEach((sprite7) => {
      sprite7.applyFlip(direction);
    });
  }
  _onSpriteUpdate(sprite7, options) {
    this.emit("update", this);
    this.setDirty(true);
  }
  _applyRotation(operation3, options) {
    this._options.sprites.forEach((sprite7) => sprite7.applyRotation(operation3, options));
  }
  transform(transformChange) {
    this._options.sprites.forEach((sprite7) => sprite7.applyTransform(transformChange));
  }
  scale(scale) {
    this._options.sprites.forEach((sprite7) => sprite7.applyScale(scale));
  }
  serializeOption(optionName, toObject = false) {
    if (optionName === "sprites") {
      return this._options.sprites.map((sprite7) => {
        return sprite7.serializeOptions(void 0, toObject);
      });
    }
    return super.serializeOption(optionName, toObject);
  }
  createSticker(options) {
    return new sticker_sprite_default(this, options);
  }
  createText(options) {
    return new text_sprite_default(this, options);
  }
  createBrush(options) {
    return new brush_sprite_default(this, options);
  }
  createTextDesign(options) {
    return new text_design_sprite_default(this, options);
  }
  addSprite(sprite7) {
    this._options.sprites.push(sprite7);
    const smoothDownscaling = this.getSmoothDownscaling();
    if (sprite7.setSmoothDownscaling)
      sprite7.setSmoothDownscaling(smoothDownscaling);
    this._container.addChild(sprite7.getDisplayObject());
    this.setDirty(true);
    sprite7.on("update", this._onSpriteUpdate);
    this.emit("update", this, this._options.sprites);
  }
  removeSprite(sprite7) {
    const {sprites} = this._options;
    const index = sprites.indexOf(sprite7);
    if (index !== -1) {
      sprite7.off("update", this._onSpriteUpdate);
      this._container.removeChild(sprite7.getDisplayObject());
      sprites.splice(index, 1);
      this.setDirty(true);
      return true;
    }
    return false;
  }
  _getOrientatedStageSize() {
    const frame2 = this._sdk.getSprite().getTexture().getFrame();
    const orientationOperation = this._sdk.getOperationsStack().getByIdentifier("orientation");
    if (orientationOperation) {
      const rotation = orientationOperation ? orientationOperation.getRotation() : 0;
      const hasSwappedSize = rotation === 270 || rotation === 90;
      return hasSwappedSize ? new Vector231(frame2.height, frame2.width) : new Vector231(frame2.width, frame2.height);
    }
    const outputOperation = this._sdk.getOperationsStack().getByIdentifier("output");
    if (outputOperation) {
      return outputOperation.getOutputResolution();
    }
    return new Vector231(frame2.width, frame2.height);
  }
  _render(inputTexture) {
    const container3 = this._container;
    const {sprites} = this._options;
    const inputDimensions = inputTexture.getDimensions().clone().floor();
    let currentContainer = new engine_default.Container();
    currentContainer.addChild(this._sprite);
    return promise_default.all(sprites.map((s) => s.validateSettings())).then(() => {
      sprites.forEach((sprite7) => sprite7.update(this._sdk, inputDimensions));
    }).then(() => {
      this._renderTexture.clear();
      sprites.forEach((sprite7) => {
        if (sprite7.getInverted && sprite7.getInverted()) {
          this._renderTexture.render(currentContainer);
          this._renderTexture.render(this._renderMaskedSprite(sprite7.getDisplayObject(), sprite7.getColor ? sprite7.getColor() : color_default.WHITE, sprite7.getPadding ? sprite7.getPadding() : -1));
          currentContainer = new engine_default.Container();
        } else {
          currentContainer.addChild(sprite7.getDisplayObject());
        }
      });
      this._renderTexture.render(currentContainer);
      container3.addChild(this._sprite);
      sprites.forEach((s) => container3.addChild(s.getDisplayObject()));
    });
  }
  _renderMaskedSprite(displayObject, color6, padding) {
    const canvas9 = this._maskCanvas;
    const worldTransform = displayObject.getWorldTransform();
    const canvasSize = this._getOrientatedStageSize();
    utils_default.ensureCanvasDimensions(canvas9, canvasSize);
    const ctx = canvas9.getContext("2d");
    ctx.clearRect(0, 0, canvas9.width, canvas9.height);
    ctx.save();
    ctx.fillStyle = color6.toRGBA();
    if (padding < 0) {
      ctx.fillRect(0, 0, canvasSize.x, canvasSize.y);
    } else {
      const spriteWidth = Math.abs(displayObject.getWidth() / displayObject.getScale().x);
      const spriteHeight = Math.abs(displayObject.getHeight() / displayObject.getScale().y);
      const absolutePadding = spriteWidth * padding;
      ctx.transform(worldTransform.a, worldTransform.b, worldTransform.c, worldTransform.d, worldTransform.tx, worldTransform.ty);
      ctx.fillRect(-absolutePadding, -absolutePadding, spriteWidth + absolutePadding * 2, spriteHeight + absolutePadding * 2);
    }
    ctx.restore();
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    displayObject._renderCanvas({
      getCurrentRenderTarget: () => {
        return {
          getPixelRatio: () => 1
        };
      },
      beforeDraw: (canvas10) => {
        const centerX = displayObject.getWidth();
        const centerY = displayObject.getHeight();
        const scale = displayObject.getScale();
        const isFlippedHorizontal = scale.x < 0;
        const isFlippedVertically = scale.y < 0;
        canvas10.translate(centerX, centerY);
        canvas10.scale(isFlippedHorizontal ? -1 : 1, isFlippedVertically ? -1 : 1);
        canvas10.translate(-centerX, -centerY);
      },
      getContext: () => ctx
    });
    ctx.restore();
    const container3 = new engine_default.Container();
    const newSprite = new engine_default.Sprite(engine_default.Texture.fromCanvas(canvas9));
    container3.addChild(newSprite);
    return container3;
  }
  takeSpriteToFront(sprite7) {
    const {sprites} = this._options;
    const spriteIndex = sprites.indexOf(sprite7);
    if (spriteIndex === -1)
      return;
    utils_default.moveArrayItem(sprites, spriteIndex, sprites.length - 1);
    const displayObject = sprite7.getDisplayObject();
    this._container.removeChild(displayObject);
    this._container.addChild(displayObject);
    this.setDirty(true);
  }
  getSpritesAtPosition(position, inputDimensions) {
    const intersectingSprites = [];
    this._options.sprites.forEach((s) => s.update(this._sdk, inputDimensions));
    const outputSprite = this._sdk.getSprite();
    const actualPosition = outputSprite.getWorldTransform().applyInverseToVector(position);
    const {width, height} = outputSprite.getTexture().getFrame();
    const anchorOffset = outputSprite.getAnchor().clone().multiply(-width, -height);
    actualPosition.subtract(anchorOffset);
    const sprites = this._options.sprites.slice(0).reverse();
    for (let i = 0, c = sprites.length; i < c; i++) {
      const sprite7 = sprites[i];
      if (sprite7.getHitTestDisplayObject().isAtPosition(actualPosition)) {
        intersectingSprites.push(sprite7);
      }
    }
    return intersectingSprites;
  }
  setDirtyForRenderer(dirty, renderer, dimensionsChanged) {
    super.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
    this._options.sprites.forEach((sprite7) => {
      sprite7.setDirtyForRenderer(dirty, renderer, dimensionsChanged);
    });
  }
  dispose() {
    super.dispose();
    this._options.sprites.forEach((sprite7) => {
      sprite7.dispose();
    });
  }
}
SpriteOperation.StickerSprite = sticker_sprite_default;
SpriteOperation.TextSprite = text_sprite_default;
SpriteOperation.BrushSprite = brush_sprite_default;
SpriteOperation.TextDesignSprite = text_design_sprite_default;
SpriteOperation.identifier = "sprite";
SpriteOperation.prototype.availableOptions = {
  sprites: {
    type: OptionType.ARRAY,
    default: [],
    setter(sprites, initial) {
      sprites = sprites.map((sprite7, i) => {
        if (sprite7 instanceof sprite_default2) {
          return sprite7;
        }
        const spriteData = __assign({}, sprite7);
        delete spriteData.type;
        switch (sprite7.type) {
          case "text":
            return new text_sprite_default(this, spriteData);
          case "sticker":
            return new sticker_sprite_default(this, spriteData);
          case "brush":
            return new brush_sprite_default(this, spriteData);
          case "textdesign":
            return new text_design_sprite_default(this, spriteData);
          default: {
            log_default.error(this.constructor.name, `Invalid sprite type: ${sprite7.type}`);
            return null;
          }
        }
      });
      if (!initial) {
        if (this._options.sprites) {
          const spritesToRemove = this._options.sprites.slice();
          spritesToRemove.forEach((sprite7) => {
            sprite7.dispose();
            this.removeSprite(sprite7);
          });
        }
        sprites.forEach((sprite7) => {
          this.addSprite(sprite7);
        });
      }
      return sprites;
    }
  },
  smoothDownscaling: {type: OptionType.BOOLEAN, default: false}
};
exports_default.Operations.SpriteOperation = SpriteOperation;
var sprite_operation_default = SpriteOperation;

// engine/sdk/operations/transform-operation/transform-change.js
const {Vector2: Vector232} = math_exports;
class TransformChange {
  constructor(operation3, options) {
    this._options = options;
    this._oldOptions = {
      start: operation3.getStart().clone(),
      end: operation3.getEnd().clone(),
      rotation: operation3.getRotation(),
      textureScale: operation3.getTextureScale()
    };
    this._inputDimensions = operation3.getInputDimensions(false);
    this._rotationDelta = options.rotation - operation3.getRotation();
    this._deltaCos = Math.cos(this._rotationDelta);
    this._deltaSin = Math.sin(this._rotationDelta);
    this._oldAbsoluteSize = this._oldOptions.end.clone().subtract(this._oldOptions.start).multiply(this._inputDimensions);
    this._newAbsoluteSize = options.end.clone().subtract(options.start).multiply(this._inputDimensions);
    this._absoluteStartDiff = this._oldOptions.start.clone().subtract(options.start).multiply(this._inputDimensions);
    this._scaleRatio = operation3.calculateScale(options.rotation) / operation3.calculateScale();
    this._sizeFactor = this._newAbsoluteSize.clone().divide(this._oldAbsoluteSize);
    this._textureScaleFactor = this._options.textureScale / operation3.getTextureScale();
  }
  applyToRelativePoint(point) {
    const oldStart = this._oldOptions.start;
    const oldEnd = this._oldOptions.end;
    const cropCenter = oldStart.clone().add(oldEnd.clone().subtract(oldStart).divide(2));
    const pixelCropCenter = cropCenter.multiply(this._inputDimensions);
    const pointPixelDistanceToCropCenter = point.clone().multiply(this._oldAbsoluteSize).subtract(this._oldAbsoluteSize.clone().divide(2));
    const pointPixelPositionOnImage = pixelCropCenter.clone().add(pointPixelDistanceToCropCenter);
    const pointPixelDistanceToImageCenter = pointPixelPositionOnImage.clone().subtract(this._inputDimensions.clone().divide(2));
    const rotatedPointPixelDistanceToImageCenter = new Vector232(pointPixelDistanceToImageCenter.x * this._deltaCos - pointPixelDistanceToImageCenter.y * this._deltaSin, pointPixelDistanceToImageCenter.x * this._deltaSin + pointPixelDistanceToImageCenter.y * this._deltaCos);
    const rotatedPointPixelPositionOnImage = this._inputDimensions.clone().divide(2).add(rotatedPointPixelDistanceToImageCenter);
    const newAbsoluteStart = this._options.start.clone().multiply(this._inputDimensions);
    return rotatedPointPixelPositionOnImage.clone().subtract(newAbsoluteStart).divide(this._newAbsoluteSize);
  }
  applyToRelativeSize(size) {
    return size * this._oldAbsoluteSize.min() / this._newAbsoluteSize.min();
  }
  applyToDimensions(dimensions) {
    dimensions = dimensions.clone().multiply(this._scaleRatio);
    if (this._options.textureScale) {
      dimensions.multiply(this._textureScaleFactor);
    }
    return dimensions;
  }
  scaleSize(size, side = "y") {
    return size / this._sizeFactor[side];
  }
  applyToRotation(rotation) {
    return (rotation + this._rotationDelta) % (Math.PI * 2);
  }
  invert() {
    const newStart = this._options.start.clone();
    const newEnd = this._options.end.clone();
    const newInputDimensions = this._inputDimensions;
    const invRotationDelta = -this._rotationDelta;
    const invDeltaCos = Math.cos(invRotationDelta);
    const invDeltaSin = Math.sin(invRotationDelta);
    const newAbsoluteSize = this._oldAbsoluteSize;
    const oldAbsoluteSize = this._newAbsoluteSize;
    const invAbsoluteStartDiff = newStart.clone().subtract(newEnd).multiply(newInputDimensions);
    const invScaleRatio = 1 / this._scaleRatio;
    const invSizeFactor = new Vector232(1 / this._sizeFactor.x, 1 / this._sizeFactor.y);
    const invTextureScaleFactor = 1 / this._textureScaleFactor;
    const newOptions = this._oldOptions;
    this._oldOptions = this._options;
    this._options = newOptions;
    this._inputDimensions = newInputDimensions;
    this._rotationDelta = invRotationDelta;
    this._deltaCos = invDeltaCos;
    this._deltaSin = invDeltaSin;
    this._oldAbsoluteSize = oldAbsoluteSize;
    this._newAbsoluteSize = newAbsoluteSize;
    this._absoluteStartDiff = invAbsoluteStartDiff;
    this._scaleRatio = invScaleRatio;
    this._sizeFactor = invSizeFactor;
    this._textureScaleFactor = invTextureScaleFactor;
    return this;
  }
}
var transform_change_default = TransformChange;

// engine/sdk/operations/transform-operation/index.js
const {Vector2: Vector233} = math_exports;
class TransformOperation extends operation_default {
  _render(inputTexture) {
    this._sprite.setRotation(0);
    const inputDimensions = inputTexture.getDimensions();
    const {start, end, rotation, textureScale} = this._options;
    const size = end.clone().subtract(start);
    const offset = size.clone().divide(2);
    const middle = start.clone().add(offset);
    const scale = this.calculateScale();
    const finalScale = scale * textureScale;
    const outputMiddle = inputDimensions.clone().multiply(finalScale).multiply(offset);
    this._sprite.setAnchor(middle);
    this._sprite.setRotation(rotation);
    this._sprite.setScale(finalScale, finalScale);
    this._sprite.setPosition(outputMiddle);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  calculateScale(rotation = this._options.rotation) {
    const inputDimensions = this.getInputDimensions(false);
    const rotatedDimensions = new Vector233(Math.abs(inputDimensions.x * Math.cos(rotation)) + Math.abs(inputDimensions.y * Math.sin(rotation)), Math.abs(inputDimensions.x * Math.sin(rotation)) + Math.abs(inputDimensions.y * Math.cos(rotation)));
    const distanceToCorner = inputDimensions.clone().subtract(rotatedDimensions.clone()).divide(2).abs();
    let scale = 1;
    if (distanceToCorner.y > distanceToCorner.x) {
      scale = distanceToCorner.y * 2 / inputDimensions.y + 1;
    } else {
      scale = distanceToCorner.x * 2 / inputDimensions.x + 1;
    }
    return scale;
  }
  getNewDimensions(inputDimensions) {
    const {start, end, textureScale} = this._options;
    const scale = this.calculateScale();
    const newDimensions = inputDimensions.clone().multiply(textureScale * scale).multiply(end.clone().subtract(start));
    return newDimensions.round();
  }
  flip(direction) {
    const {start, end} = this._options;
    const tmpStart = start.clone();
    if (direction === "horizontal") {
      start.set(1 - end.x, start.y);
      end.set(1 - tmpStart.x, end.y);
    } else if (direction === "vertical") {
      start.set(start.x, 1 - end.y);
      end.set(end.x, 1 - tmpStart.y);
    }
  }
  rotate(degrees) {
    const {start, end} = this._options;
    const degreesDifference = (degrees + 360) % 360;
    const steps = Math.floor(degreesDifference / 90);
    for (let i = 0; i < steps; i++) {
      const tempStart = start.clone();
      start.set(1 - end.y, tempStart.x);
      end.set(1 - tempStart.y, end.x);
    }
  }
  _onBeforeExport() {
    this._wasEnabledBeforeExport = this.getEnabled();
    this.setEnabled(true);
  }
  _onAfterExport() {
    this.setEnabled(this._wasEnabledBeforeExport, true);
  }
}
TransformOperation.identifier = "transform";
TransformOperation.prototype.availableOptions = {
  start: {type: OptionType.VECTOR2, default: new Vector233(0, 0)},
  end: {type: OptionType.VECTOR2, default: new Vector233(1, 1)},
  textureScale: {type: OptionType.NUMBER, default: 1},
  rotation: {type: OptionType.NUMBER, default: 0}
};
TransformOperation.TransformChange = transform_change_default;
exports_default.Operations.TransformOperation = TransformOperation;
var transform_operation_default = TransformOperation;

// engine/sdk/operations/watermark-operation/index.js
const {Vector2: Vector234} = math_exports;
class WatermarkOperation extends operation_default {
  constructor(...args) {
    super(...args);
    this._watermarkSprite = new engine_default.Sprite();
    this._watermarkSprite.setAnchor(0.5, 0.5);
    this._container.addChild(this._watermarkSprite);
  }
  _render(inputTexture) {
    if (!this._watermarkTexture) {
      this._watermarkTexture = engine_default.Texture.fromImage(this._options.image);
      this._watermarkSprite.setTexture(this._watermarkTexture);
    }
    const textureDimensions = inputTexture.getDimensions();
    const {width, height} = this._options.image;
    const dimensions = utils_default.resizeVectorToFit(new Vector234(width, height), textureDimensions);
    this._watermarkSprite.setPosition(textureDimensions.clone().divide(2));
    this._watermarkSprite.setWidth(dimensions.x);
    this._watermarkSprite.setHeight(dimensions.y);
    this._renderTexture.render(this._container);
    return promise_default.resolve();
  }
  dispose() {
    super.dispose();
    this._watermarkSprite.dispose();
  }
}
WatermarkOperation.identifier = "watermark";
WatermarkOperation.prototype.availableOptions = {
  image: {type: OptionType.OBJECT, required: true}
};
exports_default.Operations.WatermarkOperation = WatermarkOperation;
var watermark_operation_default = WatermarkOperation;

// engine/sdk/operations/index.js
const Operations = [
  adjustments_operation_default,
  blur_operation_default,
  filter_operation_default,
  frame_operation_default,
  license_watermark_operation_default,
  linear_focus_operation_default,
  mirrored_focus_operation_default,
  orientation_operation_default,
  overlay_operation_default,
  radial_focus_operation_default,
  selective_blur_operation_default,
  sprite_operation_default,
  transform_operation_default,
  watermark_operation_default,
  output_operation_default,
  flip_operation_default
];
exports_default.AllOperations = Operations;

// engine/sdk/index.js

// engine/headless/lib/constants/defaults/fonts.js
var fonts_default = [
  {
    fontFamily: "Open Sans",
    variations: [
      {
        identifier: "imgly_font_open_sans_bold",
        fontWeight: "bold",
        provider: "file",
        filePath: "fonts/imgly_font_open_sans_bold.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2189,
          descender: -600
        }
      }
    ]
  },
  {
    fontFamily: "Aleo",
    variations: [
      {
        identifier: "imgly_font_aleo_bold",
        fontWeight: "bold",
        provider: "file",
        filePath: "fonts/imgly_font_aleo_bold.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 805,
          descender: -195
        }
      }
    ]
  },
  {
    fontFamily: "Amatic SC",
    variations: [
      {
        identifier: "imgly_font_amaticsc",
        fontWeight: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_amaticsc.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1016,
          descender: -245
        }
      }
    ]
  },
  {
    fontFamily: "Archivo",
    variations: [
      {
        identifier: "imgly_font_archivo_black",
        fontWeight: "normal",
        filePath: "fonts/imgly_font_archivo_black.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 878,
          descender: -210
        }
      }
    ]
  },
  {
    fontFamily: "Bungee Inline",
    variations: [
      {
        identifier: "imgly_font_bungee_inline",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_bungee_inline.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 860,
          descender: -140
        }
      }
    ]
  },
  {
    fontFamily: "Campton Book",
    variations: [
      {
        identifier: "imgly_font_campton_bold",
        fontWeight: "bold",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_campton_bold.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 770,
          descender: -294
        }
      }
    ]
  },
  {
    fontFamily: "Carter",
    variations: [
      {
        identifier: "imgly_font_carter_one",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_carter_one.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2264,
          descender: -890
        }
      }
    ]
  },
  {
    fontFamily: "Codystar",
    variations: [
      {
        identifier: "imgly_font_codystar",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_codystar.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1024,
          ascender: 953,
          descender: -255
        }
      }
    ]
  },
  {
    fontFamily: "Fira Sans",
    variations: [
      {
        identifier: "imgly_font_fira_sans_regular",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_fira_sans_regular.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 935,
          descender: -265
        }
      }
    ]
  },
  {
    fontFamily: "Galano Grotesque",
    variations: [
      {
        identifier: "imgly_font_galano_grotesque_bold",
        fontWeight: "bold",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_galano_grotesque_bold.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 800,
          descender: -200
        }
      }
    ]
  },
  {
    fontFamily: "Krona One",
    variations: [
      {
        identifier: "imgly_font_krona_one",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_krona_one.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2030,
          descender: -530
        }
      }
    ]
  },
  {
    fontFamily: "Kumar One Outline",
    variations: [
      {
        identifier: "imgly_font_kumar_one_outline",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_kumar_one_outline.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1137,
          descender: -642
        }
      }
    ]
  },
  {
    fontFamily: "Lobster",
    variations: [
      {
        identifier: "imgly_font_lobster",
        fontWeight: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_lobster.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1e3,
          descender: -250
        }
      }
    ]
  },
  {
    fontFamily: "Molle",
    variations: [
      {
        identifier: "imgly_font_molle",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_molle.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1852,
          descender: -701
        }
      }
    ]
  },
  {
    fontFamily: "Monoton",
    variations: [
      {
        identifier: "imgly_font_monoton",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_monoton.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2366,
          descender: -822
        }
      }
    ]
  },
  {
    fontFamily: "Nixie One",
    variations: [
      {
        identifier: "imgly_font_nixie_one",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_nixie_one.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 926,
          descender: -210
        }
      }
    ]
  },
  {
    fontFamily: "Notable",
    variations: [
      {
        identifier: "imgly_font_notable",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_notable.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1143,
          descender: -157
        }
      }
    ]
  },
  {
    fontFamily: "Ostrich",
    variations: [
      {
        identifier: "imgly_font_ostrich_sans_black",
        fontWeight: 800,
        provider: "file",
        filePath: "fonts/imgly_font_ostrich_sans_black.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 950,
          descender: -250
        }
      },
      {
        identifier: "imgly_font_ostrich_sans_bold",
        fontWeight: "bold",
        provider: "file",
        filePath: "fonts/imgly_font_ostrich_sans_bold.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 950,
          descender: -250
        }
      }
    ]
  },
  {
    fontFamily: "Oswald SemiBold",
    variations: [
      {
        identifier: "imgly_font_oswald_semi_bold",
        fontWeight: 600,
        fontStyle: "normal",
        filePath: "fonts/imgly_font_oswald_semi_bold.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1193,
          descender: -289
        }
      }
    ]
  },
  {
    fontFamily: "Palanquin Dark SemiBold",
    variations: [
      {
        identifier: "imgly_font_palanquin_dark_semi_bold",
        fontWeight: "bold",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_palanquin_dark_semi_bold.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1320,
          descender: -491
        }
      }
    ]
  },
  {
    fontFamily: "Poppins",
    variations: [
      {
        identifier: "imgly_font_poppins",
        fontWeight: "bold",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_poppins.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1050,
          descender: -350
        }
      }
    ]
  },
  {
    fontFamily: "Permanent Marker",
    variations: [
      {
        identifier: "imgly_font_permanent_marker",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_permanent_marker.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1024,
          ascender: 1136,
          descender: -325
        }
      }
    ]
  },
  {
    fontFamily: "Roboto Black",
    variations: [
      {
        identifier: "imgly_font_roboto_black_italic",
        fontWeight: "normal",
        fontStyle: "italic",
        filePath: "fonts/imgly_font_roboto_black_italic.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1900,
          descender: -500
        }
      }
    ]
  },
  {
    fontFamily: "Roboto Light",
    variations: [
      {
        identifier: "imgly_font_roboto_light_italic",
        fontWeight: "normal",
        fontStyle: "italic",
        filePath: "fonts/imgly_font_roboto_light_italic.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1900,
          descender: -500
        }
      }
    ]
  },
  {
    fontFamily: "Sancreek",
    variations: [
      {
        identifier: "imgly_font_sancreek",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_sancreek.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2104,
          descender: -738
        }
      }
    ]
  },
  {
    fontFamily: "Stint Ultra Expanded",
    variations: [
      {
        identifier: "imgly_font_stint_ultra_expanded",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_stint_ultra_expanded.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1853,
          descender: -483
        }
      }
    ]
  },
  {
    fontFamily: "Trashhand",
    variations: [
      {
        identifier: "imgly_font_trash_hand",
        fontWeight: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_trash_hand.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 759,
          descender: -304
        }
      }
    ]
  },
  {
    fontFamily: "VT323",
    variations: [
      {
        identifier: "imgly_font_vt323",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_vt323.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 800,
          descender: -200
        }
      }
    ]
  },
  {
    fontFamily: "Yeseva One",
    variations: [
      {
        identifier: "imgly_font_yeseva_one",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_yeseva_one.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 915,
          descender: -240
        }
      }
    ]
  }
];

// engine/headless/lib/constants/defaults/text-design-fonts.js
var text_design_fonts_default = [
  {
    fontFamily: "Open Sans",
    variations: [
      {
        identifier: "imgly_font_open_sans_bold",
        fontWeight: "bold",
        provider: "file",
        filePath: "fonts/imgly_font_open_sans_bold.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2189,
          descender: -600
        }
      }
    ]
  },
  {
    fontFamily: "Abril Fatface",
    variations: [
      {
        identifier: "imgly_font_abril_fatface_regular",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_abril_fatface_regular.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 1058,
          descender: -291
        }
      }
    ]
  },
  {
    fontFamily: "Amberlight",
    variations: [
      {
        identifier: "imgly_font_amberlight",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_amberlight.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 750,
          descender: -250
        }
      }
    ]
  },
  {
    fontFamily: "Bungee Inline",
    variations: [
      {
        identifier: "imgly_font_bungee_inline",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_bungee_inline.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 860,
          descender: -140
        }
      }
    ]
  },
  {
    fontFamily: "Campton Book",
    variations: [
      {
        identifier: "imgly_font_campton_bold",
        fontWeight: "bold",
        provider: "file",
        filePath: "fonts/imgly_font_campton_bold.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 770,
          descender: -294
        }
      }
    ]
  },
  {
    fontFamily: "Galano Grotesque",
    variations: [
      {
        identifier: "imgly_font_galano_grotesque_bold",
        fontWeight: "bold",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_galano_grotesque_bold.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 800,
          descender: -200
        }
      }
    ]
  },
  {
    fontFamily: "Handycheera",
    variations: [
      {
        identifier: "imgly_font_handycheera_regular",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_handycheera_regular.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2199,
          descender: -808
        }
      }
    ]
  },
  {
    fontFamily: "Montserrat Light",
    variations: [
      {
        identifier: "imgly_font_montserrat_light",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_montserrat_light.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 968,
          descender: -251
        }
      }
    ]
  },
  {
    fontFamily: "Ostrich",
    variations: [
      {
        identifier: "imgly_font_ostrich_sans_black",
        fontWeight: 800,
        provider: "file",
        filePath: "fonts/imgly_font_ostrich_sans_black.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 950,
          descender: -250
        }
      },
      {
        identifier: "imgly_font_ostrich_sans_bold",
        fontWeight: "bold",
        provider: "file",
        filePath: "fonts/imgly_font_ostrich_sans_bold.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 950,
          descender: -250
        }
      },
      {
        identifier: "imgly_font_ostrich_sans_heavy",
        fontWeight: 900,
        provider: "file",
        filePath: "fonts/imgly_font_ostrich_sans_heavy.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 674,
          descender: 0
        }
      }
    ]
  },
  {
    fontFamily: "Permanent Marker",
    variations: [
      {
        identifier: "imgly_font_permanent_marker",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_permanent_marker.woff",
        textMetrics: {
          unitsPerEm: 1024,
          ascender: 1136,
          descender: -325
        }
      }
    ]
  },
  {
    fontFamily: "Petit Formal Script",
    variations: [
      {
        identifier: "imgly_font_petit_formal_script",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_petit_formal_script.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2033,
          descender: -527
        }
      }
    ]
  },
  {
    fontFamily: "Rasa",
    variations: [
      {
        identifier: "imgly_font_rasa_regular",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_rasa_regular.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 2750,
          ascender: 2300,
          descender: -1050
        }
      },
      {
        identifier: "imgly_font_rasa_500",
        fontWeight: 500,
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_rasa_500.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 2750,
          ascender: 2300,
          descender: -1050
        }
      }
    ]
  },
  {
    fontFamily: "Roboto Black",
    variations: [
      {
        identifier: "imgly_font_roboto_black",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_roboto_black.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1900,
          descender: -500
        }
      },
      {
        identifier: "imgly_font_roboto_black_italic",
        fontWeight: "normal",
        fontStyle: "italic",
        filePath: "fonts/imgly_font_roboto_black_italic.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1900,
          descender: -500
        }
      }
    ]
  },
  {
    fontFamily: "Roboto Light",
    variations: [
      {
        identifier: "imgly_font_roboto_light",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_roboto_light.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1900,
          descender: -500
        }
      },
      {
        identifier: "imgly_font_roboto_light_italic",
        fontWeight: "normal",
        fontStyle: "italic",
        filePath: "fonts/imgly_font_roboto_light_italic.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 1900,
          descender: -500
        }
      }
    ]
  },
  {
    fontFamily: "Sue Ellen Francisco",
    variations: [
      {
        identifier: "imgly_font_sue_ellen_francisco",
        fontWeight: "normal",
        fontStyle: "normal",
        filePath: "fonts/imgly_font_sue_ellen_francisco.woff",
        provider: "file",
        textMetrics: {
          unitsPerEm: 1024,
          ascender: 1362,
          descender: -634
        }
      }
    ]
  },
  {
    fontFamily: "Ultra",
    variations: [
      {
        identifier: "imgly_font_ultra",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_ultra.woff",
        default: true,
        textMetrics: {
          unitsPerEm: 2048,
          ascender: 2066,
          descender: -561
        }
      }
    ]
  },
  {
    fontFamily: "Wolesbro",
    variations: [
      {
        identifier: "imgly_font_wolesbro",
        fontWeight: "normal",
        fontStyle: "normal",
        provider: "file",
        filePath: "fonts/imgly_font_wolesbro.woff",
        textMetrics: {
          unitsPerEm: 1e3,
          ascender: 925,
          descender: -575
        }
      }
    ]
  }
];

// engine/headless/lib/constants/defaults/transform-ratio-categories.js
var transform_ratio_categories_default = [
  {
    identifier: "imgly_transforms_common",
    defaultName: "Common Ratios",
    ratios: [
      {
        identifier: "imgly_transform_common_custom",
        defaultName: "Custom",
        ratio: "*",
        selected: true
      },
      {
        identifier: "imgly_transform_common_square",
        defaultName: "Square",
        ratio: 1
      },
      {
        identifier: "imgly_transform_common_4-3",
        defaultName: "4:3",
        ratio: 4 / 3
      },
      {
        identifier: "imgly_transform_common_16-9",
        defaultName: "16:9",
        ratio: 16 / 9
      }
    ]
  },
  {
    identifier: "imgly_transforms_facebook",
    defaultName: "Facebook",
    ratios: [
      {
        identifier: "imgly_transform_facebook_profile",
        defaultName: "Profile Pic",
        dimensions: {x: 300, y: 300},
        forceDimensions: false,
        lockDimensions: true
      },
      {
        identifier: "imgly_transform_facebook_ad",
        defaultName: "Ad",
        dimensions: {x: 1200, y: 627}
      },
      {
        identifier: "imgly_transform_facebook_post",
        defaultName: "Post",
        dimensions: {x: 940, y: 788}
      },
      {
        identifier: "imgly_transform_facebook_cover",
        defaultName: "Cover",
        dimensions: {x: 851, y: 315}
      }
    ]
  }
];

// engine/headless/lib/constants/defaults/index.js
const BRUSHES = [];
if (typeof exports_default.Operations.SpriteOperation !== "undefined") {
  BRUSHES.push(exports_default.Operations.SpriteOperation.BrushSprite.Brushes.RadialBrush);
}
var defaults_default = {
  TRANSFORM_RATIO_CATEGORIES: transform_ratio_categories_default,
  FONTS: fonts_default,
  TEXT_DESIGN_FONTS: text_design_fonts_default,
  BRUSHES
};

// engine/headless/lib/constants/events.js
const Events3 = __assign(__assign({}, Events), {
  LOAD: "load",
  SAVE: "save",
  EDITOR_RESIZE: "editor:resize",
  ZOOM: "editor:zoom",
  ZOOM_CHANGED: "editor:zoom_changed",
  HISTORY_REDO: "history:redo",
  HISTORY_BEFORE_REDO: "history:before-redo",
  TEXT_SCALED: "editor:text:scaled",
  TRANSFORM_RESIZE: "transform:resize",
  TRANSFORM_AFTER_EDIT: "transform:after-edit",
  ADDED_STICKER: "sticker:added-sticker",
  SPRITES_DESELECTED: "editor:sprite:deselected-all",
  CANVAS_FOCUS: "canvas:focus"
});
var events_default = Events3;

// engine/headless/lib/constants/index.js
var constants_default3 = {
  EVENTS: events_default,
  DEFAULTS: defaults_default
};

// engine/headless/lib/browser.js
function getIEVersion() {
  const {userAgent, appVersion} = navigator;
  if (appVersion.indexOf("MSIE") !== -1) {
    return appVersion.match(/MSIE\s+?([0-9]+)/i)[1];
  }
  if (userAgent.indexOf("Trident") !== -1) {
    return userAgent.match(/rv:([0-9]+)/i)[1];
  }
  return false;
}
var browser_default = {
  getIEVersion
};

// engine/headless/lib/utils.js
const SDKUtils = exports_default.Utils;
const {Vector2: Vector235} = exports_default.Math;
const UIUtils = {
  getInnerDimensionsForElement(element) {
    const size = new Vector235(element.offsetWidth, element.offsetHeight);
    const computedStyle = window.getComputedStyle(element, null);
    size.x -= parseInt(computedStyle.getPropertyValue("padding-left"), 10);
    size.x -= parseInt(computedStyle.getPropertyValue("padding-right"), 10);
    size.y -= parseInt(computedStyle.getPropertyValue("padding-top"), 10);
    size.y -= parseInt(computedStyle.getPropertyValue("padding-bottom"), 10);
    return size;
  },
  getEventPosition(e) {
    let x = e.clientX;
    let y = e.clientY;
    if (e.type.indexOf("touch") !== -1) {
      if (!e.touches.length)
        return;
      x = e.touches[0].clientX;
      y = e.touches[0].clientY;
    }
    return new Vector235(x, y);
  },
  createTransparentPatternCanvas() {
    const canvas9 = document.createElement("canvas");
    const context = canvas9.getContext("2d");
    canvas9.width = 10;
    canvas9.height = 10;
    context.fillStyle = "white";
    context.fillRect(0, 0, canvas9.width, canvas9.height);
    context.fillStyle = "#cccccc";
    context.fillRect(0, 0, canvas9.width / 2, canvas9.height / 2);
    context.fillRect(canvas9.width / 2, canvas9.height / 2, canvas9.width, canvas9.height);
    return canvas9;
  },
  supportsMSBlob() {
    const canvas9 = document.createElement("canvas");
    return typeof canvas9.msToBlob !== "undefined";
  },
  translate(phrases, key, interpolationOptions = {}) {
    let response = this.fetch(phrases, key);
    if (!response) {
      log_default.info("Utils#translate", `Unable to translate \`${key}\``);
      return null;
    }
    for (const key2 in interpolationOptions) {
      response = response.replace(`\${${key2}}`, interpolationOptions[key2]);
    }
    return response;
  },
  fetch(object, path2, defaultValue) {
    path2 = path2.replace(/\[(\w+)]/g, ".$1");
    path2 = path2.replace(/^\./, "");
    const pathSegments = path2.split(".");
    for (let i = 0; i < pathSegments.length; i++) {
      const segment = pathSegments[i];
      object = object[segment];
      if (!object) {
        break;
      }
    }
    if (typeof object === "undefined") {
      return false;
    }
    return object;
  },
  isMobile() {
    const a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
  },
  select(items, selectedItems, selector = null) {
    if (!selector)
      selector = (i) => i;
    const newItems = [];
    selectedItems.forEach((selectedItem) => {
      items.forEach((item) => {
        const itemIdentifier = selector(item);
        if (itemIdentifier === selectedItem) {
          newItems.push(item);
        }
      });
    });
    return newItems;
  },
  getJSONP(url2) {
    const loader = new JSONLoader(url2);
    return loader.load();
  },
  cloneCategories(categories, itemsProperty) {
    return categories.map((category) => {
      category = SDKUtils.clone(category);
      category[itemsProperty] = category[itemsProperty].slice(0);
      return category;
    });
  },
  mergeCategories(categories, newCategories, itemsProperty) {
    categories = this.cloneCategories(categories, itemsProperty);
    let existingCategory = null;
    newCategories.forEach((newCategory) => {
      categories.forEach((category) => {
        if (newCategory.identifier === category.identifier) {
          existingCategory = category;
        }
      });
      if (!existingCategory) {
        categories.push(newCategory);
      } else {
        existingCategory[itemsProperty] = existingCategory[itemsProperty].concat(newCategory[itemsProperty]);
      }
    });
    return categories;
  },
  wrapFiltersInCategories(categories, itemsProperty) {
    return categories.map((item) => {
      let category = item;
      if (!(itemsProperty in category)) {
        category = {
          identifier: `imgly_filters_wrapped-${item.identifier}`,
          displayFlat: true,
          [itemsProperty]: [item]
        };
      }
      return category;
    });
  },
  getStyleObject(el) {
    const styleProperties = window.getComputedStyle(el);
    const styleObject = {};
    for (const property in styleProperties) {
      const value = styleProperties.getPropertyValue(property);
      const camelizedAttr = property.replace(/-([a-z])/g, (a, b) => b.toUpperCase());
      if (value !== "") {
        styleObject[camelizedAttr] = value;
      }
    }
    return styleObject;
  },
  styleElement(element, styles) {
    for (const prop in styles) {
      element.style[prop] = styles[prop];
    }
  },
  debounce(fn, wait, immediate) {
    let timeout;
    return function(...args) {
      const later = () => {
        timeout = null;
        if (!immediate)
          fn.apply(this, args);
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow)
        fn.apply(this, args);
    };
  },
  getScrollbarWidth() {
    const outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.msOverflowStyle = "scrollbar";
    document.body.appendChild(outer);
    const widthNoScroll = outer.offsetWidth;
    outer.style.overflow = "scroll";
    const inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    const widthWithScroll = inner.offsetWidth;
    outer.parentNode.removeChild(outer);
    return widthNoScroll - widthWithScroll;
  },
  findIntegerFraction(ratio, maxIterations = 100) {
    let bestDelta = Number.MAX_VALUE;
    let bestX = 0;
    let bestY = 0;
    let x = 1;
    let y = 1;
    for (let iterations = 0; iterations < maxIterations; iterations++) {
      const delta = x / y - ratio;
      if (delta < 0) {
        x++;
      } else if (delta > 0) {
        y++;
      } else {
        return new Vector235(x, y);
      }
      const newDelta = Math.abs(x / y - ratio);
      if (newDelta < bestDelta) {
        bestDelta = newDelta;
        bestX = x;
        bestY = y;
      }
    }
    return new Vector235(bestX, bestY);
  },
  toFixed(number, decimals = 2) {
    const fixed = number.toFixed(decimals);
    return parseFloat(fixed);
  },
  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  },
  flipObject(obj) {
    const newObj = {};
    for (const key in obj) {
      newObj[obj[key]] = key;
    }
    return newObj;
  },
  Browser: browser_default
};
var utils_default3 = UIUtils;

// engine/headless/globals.js
const {Base64: Base643} = exports_default;
const {Color: Color3} = exports_default;
const {ColorMatrix: ColorMatrix8} = exports_default.Math;
const {EventEmitter: EventEmitter3} = exports_default;
const {EXIF: EXIF2} = exports_default;
const {OptionType: OptionType7} = exports_default;
const {Promise: Promise2} = exports_default;
const SDKUtils2 = exports_default.Utils;
const {RenderType: RenderType3} = exports_default;
const {ImageFormat: ImageFormat3} = exports_default;
const SDK = exports_default;
const {UniformType: UniformType7} = exports_default;
const {Vector2: Vector236} = exports_default.Math;
const {Rectangle: Rectangle14} = exports_default.Math;
const {Range: Range2} = exports_default.Math;
const now3 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();

// engine/shared/assets/asset-library.js
class AssetLibrary {
  constructor() {
    this._assetsByGroupId = {};
  }
  addAsset(groupID, asset, atBeginning = false) {
    if (!this._assetsByGroupId[groupID]) {
      this._assetsByGroupId[groupID] = [asset];
    } else if (atBeginning) {
      this._assetsByGroupId[groupID].unshift(asset);
    } else {
      this._assetsByGroupId[groupID].push(asset);
    }
  }
  setAssets(groupID, assets) {
    this._assetsByGroupId[groupID] = assets;
  }
  getAssets(groupID) {
    this._assetsByGroupId[groupID] = this._assetsByGroupId[groupID] || [];
    return this._assetsByGroupId[groupID];
  }
}
var asset_library_default = AssetLibrary;

// engine/shared/downloader/file-downloader.js
class FileDownloader {
  static downloadDataURL(data, baseName = "photoeditorsdk-export") {
    const url2 = this.createBlobURLFromDataURL(data);
    const extension = this.getExtensionFromDataURL(data);
    const link = document.createElement("a");
    link.download = `${baseName}.${extension}`;
    link.href = url2;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
  static downloadMSBlob(data, baseName = "photoeditorsdk-export") {
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(data, `${baseName}.png`);
    }
  }
  static getExtensionFromDataURL(data) {
    const mimeString = data.split(",")[0].split(":")[1].split(";")[0];
    return mimeString.split("/").pop();
  }
  static createBlobURLFromDataURL(data) {
    if (!window.Blob || !window.URL || !ArrayBuffer || !Uint8Array) {
      return data;
    }
    const rawData = Base643.decode(data.split(",")[1]);
    const mimeString = data.split(",")[0].split(":")[1].split(";")[0];
    const arrayBuffer = new ArrayBuffer(rawData.length);
    const intArray = new Uint8Array(arrayBuffer);
    for (let i = 0; i < rawData.length; i++) {
      intArray[i] = rawData[i];
    }
    const blob = new window.Blob([arrayBuffer], {
      type: mimeString
    });
    return window.URL.createObjectURL(blob);
  }
}

// engine/shared/exporter.js
class Exporter {
  constructor(sdk14, options, download) {
    this._sdk = sdk14;
    this._options = options;
    this._download = download;
  }
  export() {
    const renderType = this._getRenderType();
    return this._sdk.export(renderType, this._options.format, this._options.quality).then((data) => {
      if (this._download) {
        this._downloadData(renderType, data);
      }
      return data;
    });
  }
  _downloadData(renderType, data) {
    switch (renderType) {
      case RenderType3.DATAURL:
        FileDownloader.downloadDataURL(data, this._options.fileBasename);
        break;
      case RenderType3.MSBLOB:
        FileDownloader.downloadMSBlob(data, this._options.fileBasename);
        break;
    }
  }
  _getRenderType() {
    const options = this._options;
    if (options.type !== RenderType3.IMAGE || !this._download) {
      return options.type;
    }
    if (utils_default3.supportsMSBlob()) {
      return RenderType3.MSBLOB;
    }
    return RenderType3.DATAURL;
  }
}

// engine/shared/assets/font.js
class Font extends configurable_default {
}
Font.prototype.availableOptions = {
  fontFamily: {type: OptionType.STRING, required: true},
  variations: {type: OptionType.ARRAY, required: true}
};

// engine/shared/assets/font-variation.js
const FONT_WEIGHTS = {
  100: "Extra Light",
  200: "Light",
  300: "Book",
  400: "Regular",
  500: "Medium",
  600: "Semibold",
  700: "Bold",
  800: "Black",
  900: "Extra Black",
  bold: "Bold",
  normal: "Regular"
};
class FontVariation extends configurable_default {
  getLabel() {
    let label = FONT_WEIGHTS[this._options.fontWeight];
    switch (this._options.fontStyle) {
      case "italic":
        label += " Italic";
        break;
    }
    return label;
  }
}
FontVariation.prototype.availableOptions = {
  identifier: {type: OptionType.STRING, required: true},
  fontFamily: {type: OptionType.STRING, required: true},
  fontWeight: {type: OptionType.ALL, default: 400},
  fontStyle: {type: OptionType.STRING, default: "normal"},
  textMetrics: {type: OptionType.OBJECT, default: null},
  provider: {type: OptionType.STRING, available: ["google", "file"]},
  filePath: {type: OptionType.STRING},
  default: {type: OptionType.BOOLEAN, default: false},
  font: {type: OptionType.OBJECT}
};

// engine/shared/utils/legacyFontHandler.js
const legacyFontIdentifierMap = {
  imgly_font_bernier_regular: "imgly_font_sancreek",
  imgly_font_cheque_regular: "imgly_font_kumar_one_outline",
  imgly_font_gagalin_regular: "imgly_font_permanent_marker",
  imgly_font_hagin_caps_thin: "imgly_font_nixie_one",
  imgly_font_intro_inline: "imgly_font_bungee_inline",
  imgly_font_nexa_script: "imgly_font_molle",
  imgly_font_panton_blackitalic_caps: "imgly_font_roboto_black_italic",
  imgly_font_panton_lightitalic_caps: "imgly_font_roboto_light_italic",
  imgly_font_perfograma: "imgly_font_codystar",
  imgly_font_panton_black_caps: "imgly_font_roboto_black",
  imgly_font_panton_light_caps: "imgly_font_roboto_light",
  imgly_font_summer_font_light: "imgly_font_sue_ellen_francisco"
};
const legacyFontHandler = (fontId, displayWarning = false) => {
  if (legacyFontIdentifierMap[fontId]) {
    if (displayWarning) {
      console.warn(`Font ${fontId} was deprecated. Please use ${legacyFontIdentifierMap[fontId]} instead.`);
    }
    return legacyFontIdentifierMap[fontId];
  }
  return fontId;
};

// engine/shared/managers/font-manager.js
class FontManager {
  constructor(ui, options) {
    this._ui = ui;
    this._options = options;
    this._fonts = [];
    this._variationsByIdentifier = {};
    this._fontsByFontFamily = {};
    this._initFonts();
  }
  _initFonts() {
    const {
      fonts: additionalFonts,
      replaceFonts,
      availableVariations,
      isTextDesign
    } = this._options;
    let customAssetsAllowed = true;
    if (process.env.REACT_APP_BROWSER) {
      customAssetsAllowed = this._ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
    }
    if (additionalFonts && customAssetsAllowed) {
      additionalFonts.forEach(({variations}, index) => {
        if (variations) {
          variations.forEach((variation, variationIndex) => {
            if (legacyFontIdentifierMap[variation.identifier]) {
              const correctedIdentifier = legacyFontHandler(variation.identifier, true);
              additionalFonts[index].variations[variationIndex].identifier = correctedIdentifier;
              const {fontFamily} = constants_default3.DEFAULTS.FONTS.find((family) => family.variations.some((font2) => font2.identifier === correctedIdentifier));
              additionalFonts[index].fontFamily = fontFamily;
            }
          });
        }
      });
    }
    let fonts2 = isTextDesign ? constants_default3.DEFAULTS.TEXT_DESIGN_FONTS : constants_default3.DEFAULTS.FONTS;
    if (customAssetsAllowed) {
      if (replaceFonts) {
        fonts2 = additionalFonts;
      } else {
        fonts2 = fonts2.concat(additionalFonts || []);
      }
    }
    let defaultVariation;
    fonts2 = fonts2.map((font2) => {
      const {fontFamily} = font2;
      let {variations} = font2;
      if (customAssetsAllowed && availableVariations) {
        variations = variations.filter((variation) => availableVariations.indexOf(variation.identifier) !== -1);
      }
      if (variations.length === 0)
        return null;
      const fontInstance = new Font({
        fontFamily
      });
      variations = variations.map((variation) => {
        const variationInstance = new FontVariation(variation);
        variationInstance.setFontFamily(fontFamily);
        variationInstance.setFont(fontInstance);
        if (variation.default && !defaultVariation) {
          defaultVariation = variationInstance;
        }
        if (variationInstance.getTextMetrics() == null) {
          log_default.warn(`Missing font metrics for ${variationInstance.getIdentifier()}. The SDK will fall back to basic font rendering, which may lead to layout issues. Please provide font metrics for your custom fonts. See https://docs.photoeditorsdk.com/guides/html5/ for more details.`);
        }
        this._variationsByIdentifier[variationInstance.getIdentifier()] = variationInstance;
        return variationInstance;
      });
      fontInstance.setVariations(variations);
      this._fontsByFontFamily[fontFamily] = fontInstance;
      return fontInstance;
    }).filter((f) => f);
    if (!defaultVariation) {
      [defaultVariation] = fonts2[0].getVariations();
    }
    this._defaultVariation = defaultVariation;
    this._fonts = fonts2;
  }
  getFonts() {
    return this._fonts;
  }
  getFontByFontFamily(fontFamily) {
    return this._fontsByFontFamily[fontFamily];
  }
  getVariationByIdentifier(identifier) {
    return this._variationsByIdentifier[legacyFontHandler(identifier)];
  }
  getVariationsByIdentifier() {
    return __assign({}, this._variationsByIdentifier);
  }
  getDefaultVariation() {
    return this._defaultVariation;
  }
}

// packages/shared/assets/font/metadata.ts
const metadata = [
  {
    identifier: "imgly_font_open_sans_bold",
    fontFamily: "Open Sans",
    fontWeight: "bold",
    fontURI: "./fonts/imgly_font_open_sans_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2189,
      descender: -600
    }
  },
  {
    identifier: "imgly_font_aleo_bold",
    fontFamily: "Aleo",
    fontWeight: "bold",
    fontURI: "./fonts/imgly_font_aleo_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 805,
      descender: -195
    }
  },
  {
    identifier: "imgly_font_amaticsc",
    fontFamily: "Amatic SC",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_amaticsc.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1016,
      descender: -245
    }
  },
  {
    identifier: "imgly_font_archivo_black",
    fontFamily: "Archivo",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_archivo_black.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 878,
      descender: -210
    }
  },
  {
    identifier: "imgly_font_bungee_inline",
    fontFamily: "Bungee Inline",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_bungee_inline.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 860,
      descender: -140
    }
  },
  {
    identifier: "imgly_font_fira_sans_regular",
    fontFamily: "Fira Sans",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_fira_sans_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 935,
      descender: -265
    }
  },
  {
    identifier: "imgly_font_campton_bold",
    fontFamily: "Campton Book",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_campton_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 770,
      descender: -294
    }
  },
  {
    identifier: "imgly_font_carter_one",
    fontFamily: "Carter One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_carter_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2264,
      descender: -890
    }
  },
  {
    identifier: "imgly_font_codystar",
    fontFamily: "Codystar",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_codystar.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1024,
      ascender: 953,
      descender: -255
    }
  },
  {
    identifier: "imgly_font_galano_grotesque_bold",
    fontFamily: "Galano Grotesque",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_galano_grotesque_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 800,
      descender: -200
    }
  },
  {
    identifier: "imgly_font_krona_one",
    fontFamily: "Krona One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_krona_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2030,
      descender: -530
    }
  },
  {
    identifier: "imgly_font_kumar_one_outline",
    fontFamily: "Kumar One Outline",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_kumar_one_outline.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1137,
      descender: -642
    }
  },
  {
    identifier: "imgly_font_lobster",
    fontFamily: "Lobster",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_lobster.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1e3,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_molle",
    fontFamily: "Molle",
    fontWeight: "normal",
    fontStyle: "italic",
    fontURI: "./fonts/imgly_font_molle.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1852,
      descender: -701
    }
  },
  {
    identifier: "imgly_font_monoton",
    fontFamily: "Monoton",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_monoton.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2366,
      descender: -822
    }
  },
  {
    identifier: "imgly_font_nixie_one",
    fontFamily: "Nixie One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_nixie_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 926,
      descender: -210
    }
  },
  {
    identifier: "imgly_font_notable",
    fontFamily: "Notable",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_notable.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1143,
      descender: -157
    }
  },
  {
    identifier: "imgly_font_ostrich_sans_black",
    fontFamily: "Ostrich",
    fontWeight: 800,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ostrich_sans_black.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 950,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_ostrich_sans_bold",
    fontFamily: "Ostrich",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ostrich_sans_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 950,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_oswald_semi_bold",
    fontFamily: "Oswald SemiBold",
    googleFamily: "Oswald",
    fontWeight: 600,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_oswald_semi_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1193,
      descender: -289
    }
  },
  {
    identifier: "imgly_font_palanquin_dark_semi_bold",
    fontFamily: "Palanquin Dark SemiBold",
    googleFamily: "Palanquin Dark",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_palanquin_dark_semi_bold.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1320,
      descender: -491
    }
  },
  {
    identifier: "imgly_font_poppins",
    fontFamily: "Poppins",
    fontWeight: "bold",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_poppins.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1050,
      descender: -350
    }
  },
  {
    identifier: "imgly_font_permanent_marker",
    fontFamily: "Permanent Marker",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_permanent_marker.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1024,
      ascender: 1136,
      descender: -325
    }
  },
  {
    identifier: "imgly_font_roboto_black_italic",
    fontFamily: "Roboto Black",
    fontWeight: "bold",
    fontStyle: "italic",
    googleFamily: "Roboto",
    fontURI: "./fonts/imgly_font_roboto_black_italic.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_roboto_light_italic",
    fontFamily: "Roboto Light",
    googleFamily: "Roboto",
    fontWeight: 300,
    fontStyle: "italic",
    fontURI: "./fonts/imgly_font_roboto_light_italic.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_sancreek",
    fontFamily: "Sancreek",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_sancreek.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2104,
      descender: -738
    }
  },
  {
    identifier: "imgly_font_stint_ultra_expanded",
    fontFamily: "Stint Ultra Expanded",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_stint_ultra_expanded.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1853,
      descender: -483
    }
  },
  {
    identifier: "imgly_font_trash_hand",
    fontFamily: "Trash Hand",
    fontWeight: "normal",
    fontURI: "./fonts/imgly_font_trash_hand.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 759,
      descender: -304
    }
  },
  {
    identifier: "imgly_font_vt323",
    fontFamily: "VT323",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_vt323.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 800,
      descender: -200
    }
  },
  {
    identifier: "imgly_font_yeseva_one",
    fontFamily: "Yeseva One",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_yeseva_one.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 915,
      descender: -240
    }
  },
  {
    identifier: "imgly_font_abril_fatface_regular",
    fontFamily: "Abril Fatface",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_abril_fatface_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 1058,
      descender: -291
    }
  },
  {
    identifier: "imgly_font_amberlight",
    fontFamily: "Amberlight",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_amberlight.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 750,
      descender: -250
    }
  },
  {
    identifier: "imgly_font_montserrat_light",
    fontFamily: "Montserrat Light",
    googleFamily: "Montserrat",
    fontWeight: 300,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_montserrat_light.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 968,
      descender: -251
    }
  },
  {
    identifier: "imgly_font_handycheera_regular",
    fontFamily: "Handycheera",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_handycheera_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2199,
      descender: -808
    }
  },
  {
    identifier: "imgly_font_ostrich_sans_heavy",
    fontFamily: "Ostrich",
    fontWeight: 900,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ostrich_sans_heavy.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 674,
      descender: 0
    }
  },
  {
    identifier: "imgly_font_petit_formal_script",
    fontFamily: "Petit Formal Script",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_petit_formal_script.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2033,
      descender: -527
    }
  },
  {
    identifier: "imgly_font_rasa_500",
    fontFamily: "Rasa",
    fontWeight: 500,
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_rasa_500.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2750,
      ascender: 2300,
      descender: -1050
    }
  },
  {
    identifier: "imgly_font_rasa_regular",
    fontFamily: "Rasa",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_rasa_regular.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2750,
      ascender: 2300,
      descender: -1050
    }
  },
  {
    identifier: "imgly_font_roboto_black",
    fontFamily: "Roboto Black",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_roboto_black.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_roboto_light",
    fontFamily: "Roboto Light",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_roboto_light.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 1900,
      descender: -500
    }
  },
  {
    identifier: "imgly_font_sue_ellen_francisco",
    fontFamily: "Sue Ellen Francisco",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_sue_ellen_francisco.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1024,
      ascender: 1362,
      descender: -634
    }
  },
  {
    identifier: "imgly_font_ultra",
    fontFamily: "Ultra",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_ultra.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 2048,
      ascender: 2066,
      descender: -561
    }
  },
  {
    identifier: "imgly_font_wolesbro",
    fontFamily: "Wolesbro",
    fontWeight: "normal",
    fontStyle: "normal",
    fontURI: "./fonts/imgly_font_wolesbro.woff",
    format: "woff",
    textMetrics: {
      unitsPerEm: 1e3,
      ascender: 925,
      descender: -575
    }
  }
];
var metadata_default = metadata;

// engine/server/lib/constants/index.js
const brushes = [];
if (typeof exports_default.Operations.SpriteOperation !== "undefined") {
  brushes.push(exports_default.Operations.SpriteOperation.BrushSprite.Brushes.RadialBrush);
}
var constants_default4 = {
  EVENTS: {
    EXPORT: "export",
    OPERATION_CREATED: "operation:created",
    OPERATION_UPDATED: "operation:updated",
    OPERATION_REMOVED: "operation:removed"
  },
  DEFAULTS: {
    TRANSFORM_RATIO_CATEGORIES: [
      {
        identifier: "imgly_transforms_common",
        defaultName: "Common Ratios",
        ratios: [
          {
            identifier: "imgly_transform_common_custom",
            defaultName: "Custom",
            ratio: "*",
            selected: true
          },
          {
            identifier: "imgly_transform_common_square",
            defaultName: "Square",
            ratio: 1
          },
          {
            identifier: "imgly_transform_common_4-3",
            defaultName: "4:3",
            ratio: 4 / 3
          },
          {
            identifier: "imgly_transform_common_16-9",
            defaultName: "16:9",
            ratio: 16 / 9
          }
        ]
      },
      {
        identifier: "imgly_transforms_facebook",
        defaultName: "Facebook",
        ratios: [
          {
            identifier: "imgly_transform_facebook_profile",
            defaultName: "Profile Pic",
            ratio: 1 / 1
          },
          {
            identifier: "imgly_transform_facebook_ad",
            defaultName: "Ad",
            dimensions: new exports_default.Math.Vector2(1200, 627)
          },
          {
            identifier: "imgly_transform_facebook_post",
            defaultName: "Post",
            dimensions: new exports_default.Math.Vector2(940, 788)
          },
          {
            identifier: "imgly_transform_facebook_cover",
            defaultName: "Cover",
            dimensions: new exports_default.Math.Vector2(851, 315)
          }
        ]
      }
    ],
    FONTS: metadata_default,
    BRUSHES: brushes,
    TEXT_DESIGN_FONTS: metadata_default
  }
};

// engine/server/lib/utils.js
const {Utils: SDKUtils3} = exports_default;
const {Vector2: Vector237} = exports_default.Math;

// engine/server/globals.js
const {Base64: Base644} = exports_default;
const {Color: Color4} = exports_default;
const {ColorMatrix: ColorMatrix9} = exports_default.Math;
const {EventEmitter: EventEmitter4} = exports_default;
const {EXIF: EXIF3} = exports_default;
const {OptionType: OptionType8} = exports_default;
const {Promise: Promise3} = exports_default;
const SDKUtils4 = exports_default.Utils;
const {RenderType: RenderType4} = exports_default;
const {ImageFormat: ImageFormat4} = exports_default;
const SDK2 = exports_default;
const {UniformType: UniformType8} = exports_default;
const {Vector2: Vector238} = exports_default.Math;
const {Rectangle: Rectangle15} = exports_default.Math;
const {Range: Range3} = exports_default.Math;
const now4 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();

// engine/server/lib/editor/operations.js
class EditorOperations {
  constructor(editor2, sdk14, mediator) {
    this._editor = editor2;
    this._sdk = sdk14;
    this._mediator = mediator;
    this._available = this._sdk.getOperations();
    this._map = {};
    this._stack = this._sdk.getOperationsStack();
    this._preferredOrder = this._editor.getOptions().editor.operationsOrder;
    this._fixStack();
  }
  exists(identifier) {
    return !!this._map[identifier];
  }
  add(operation3) {
    const {identifier} = operation3.constructor;
    operation3.on("update", () => {
      this._mediator.emit(constants_default4.EVENTS.OPERATION_UPDATED, operation3);
    });
    const index = this._preferredOrder.indexOf(identifier);
    if (index === -1) {
      throw new Error(`EditorOperations#add: \`${identifier}\` does not appear in \`operationsOrder\``);
    }
    this._stack.set(index, operation3);
    this._map[identifier] = operation3;
    this._mediator.emit(constants_default4.EVENTS.OPERATION_CREATED, operation3);
  }
  remove(operation3, broadcast = true) {
    const identifier = typeof operation3 === "object" ? operation3.constructor.identifier : operation3;
    const stack = this._stack.getStack();
    operation3 = this.get(identifier);
    delete this._map[identifier];
    const index = stack.map((op) => op.constructor.identifier).indexOf(identifier);
    if (index !== -1) {
      this._stack.removeAt(index);
      for (let i = index + 1; i < stack.length; i++) {
        const operation4 = stack[i];
        if (!operation4)
          continue;
        operation4.setDirty(true);
      }
      if (broadcast) {
        this._mediator.emit(constants_default4.EVENTS.OPERATION_REMOVED, operation3);
      }
    }
  }
  get(identifier) {
    return this._map[identifier];
  }
  getOrCreate(identifier, options = {}) {
    if (this._map[identifier]) {
      const operation4 = this._map[identifier];
      operation4.set(options, false);
      return operation4;
    }
    const Operation2 = this._available[identifier];
    const operation3 = new Operation2(this._sdk, options);
    this.add(operation3);
    return operation3;
  }
  getStack() {
    return this._stack;
  }
  reset() {
    for (const key in this._map) {
      const operation3 = this._map[key];
      operation3.dispose();
    }
    this._map = {};
  }
  _fixStack() {
    const stack = this._stack.getStack().slice();
    this._stack.clear();
    stack.forEach((s) => {
      this.add(s);
    });
  }
}

// engine/server/lib/image-resizer.js
class ImageResizer {
  constructor(image5, maxPixels, maxDimensions) {
    this._image = image5;
    this._maxPixels = maxPixels;
    this._maxDimensions = maxDimensions;
  }
  needsResize() {
    const dimensions = new Vector238(this._image.width, this._image.height);
    const pixels = dimensions.x * dimensions.y;
    const exceedsMaxPixels = this._maxPixels !== null && pixels > this._maxPixels;
    const exceedsMaxDimensions = this._maxDimensions !== null && (dimensions.x > this._maxDimensions || dimensions.y > this._maxDimensions);
    return exceedsMaxPixels || exceedsMaxDimensions;
  }
  resize() {
    let reason = null;
    let canvas9 = null;
    const maxDimensions = this._maxDimensions;
    return new Promise3((resolve, reject) => {
      setTimeout(() => {
        const initialDimensions = new Vector238(this._image.width, this._image.height);
        const dimensions = initialDimensions.clone();
        if (this._maxPixels !== null && dimensions.x * dimensions.y > this._maxPixels) {
          dimensions.copy(this._getDimensionsByMaxPixels());
          reason = "maxMegaPixels";
        }
        if (maxDimensions !== null && (dimensions.x > maxDimensions || dimensions.y > maxDimensions)) {
          const scale = Math.min(maxDimensions / dimensions.x, maxDimensions / dimensions.y);
          dimensions.multiply(scale);
          reason = "maxDimensions";
        }
        dimensions.floor();
        canvas9 = this._createResizedImageCanvas(dimensions);
        resolve({canvas: canvas9, dimensions, reason});
      }, 1e3);
    });
  }
  _createResizedImageCanvas(dimensions, imageDimensions = dimensions) {
    const image5 = this._image;
    const canvas9 = SDKUtils4.createCanvas();
    canvas9.width = dimensions.x;
    canvas9.height = dimensions.y;
    const offset = dimensions.clone().subtract(imageDimensions).divide(2);
    const context = canvas9.getContext("2d");
    context.drawImage(image5, 0, 0, image5.width, image5.height, offset.x, offset.y, imageDimensions.x, imageDimensions.y);
    return canvas9;
  }
  _getDimensionsByMaxPixels() {
    const image5 = this._image;
    const maxPixels = this._maxPixels;
    const ratioHV = image5.width / image5.height;
    const ratioVH = image5.height / image5.width;
    return new Vector238(Math.sqrt(maxPixels * ratioHV), Math.sqrt(maxPixels * ratioVH)).floor();
  }
}

// engine/headless/lib/font-loader/font-ruler.js
const FONT_SIZE = 30;
const CHARACTERS = "abcdefghijklmnopqrstuvwxzy";
class FontRuler {
  constructor(fontVariation) {
    this._fontVariation = fontVariation || new FontVariation({
      fontFamily: "Times New Roman",
      fontWeight: "normal",
      fontStyle: "normal"
    });
    this._createRuler();
  }
  _createRuler() {
    this._ruler = document.createElement("div");
    this._ruler.innerText = CHARACTERS;
    document.body.appendChild(this._ruler);
    this._setRulerStyle();
  }
  _setRulerStyle() {
    this._ruler.style.cssText = `
      position: absolute;
      top: -9999px;
      left: -9999px;
      opacity: 0;
      display: inline-block;
      font: ${this._fontVariation.getFontStyle()} ${this._fontVariation.getFontWeight()} ${FONT_SIZE}px ${this._fontVariation.getFontFamily()};
    `;
  }
  setFontVariation(fontVariation) {
    this._fontVariation = fontVariation;
    this._setRulerStyle();
  }
  getWidth() {
    return !this._ruler ? -1 : this._ruler.offsetWidth;
  }
  dispose() {
    if (this._ruler) {
      this._ruler.parentNode.removeChild(this._ruler);
      this._ruler = null;
    }
  }
}

// engine/headless/lib/font-loader/font-observer.js
const now5 = typeof window !== "undefined" && window.performance && window.performance.now ? window.performance.now.bind(window.performance) : require_performance_now();
const OBSERVE_INTERVAL = 50;
const OBSERVE_TIMEOUT = 5e3;
class FontObserver {
  constructor(fontVariation) {
    this._fontVariation = fontVariation;
    this._defaultFontRuler = new FontRuler();
    this._customFontRuler = new FontRuler(this._fontVariation);
  }
  observe() {
    const startedAt = now5();
    return new Promise((resolve, reject) => {
      const interval = window.setInterval(() => {
        const changed = this._defaultFontRuler.getWidth() !== this._customFontRuler.getWidth();
        if (changed) {
          window.clearInterval(interval);
          return resolve();
        }
        if (now5() - startedAt >= OBSERVE_TIMEOUT) {
          const error = new Error(`Failed to load font ${this._fontVariation.getFontFamily()}.`);
          error.font = this._fontVariation;
          return reject(error);
        }
      }, OBSERVE_INTERVAL);
    });
  }
  dispose() {
    this._defaultFontRuler.dispose();
    this._customFontRuler.dispose();
  }
}

// engine/headless/lib/font-loader/loaders/base-font-loader.js
class BaseFontLoader {
  constructor(ui) {
    this._ui = ui;
    this._fonts = [];
    this._observers = [];
  }
  add(variation) {
    this._fonts.push(variation);
  }
  load() {
    if (this._fonts.length === 0) {
      return Promise.resolve();
    }
    this._observers = [];
    this._fonts.forEach((variation) => {
      this._observers.push(new FontObserver(variation));
    });
    return utils_default.executePromises(this._observers.map((observer) => observer.observe()));
  }
  dispose() {
    this._observers.forEach((observer) => observer.dispose());
  }
}

// engine/headless/lib/font-loader/loaders/file-font-loader.js
class FileFontLoader extends BaseFontLoader {
  load() {
    return Promise.resolve();
  }
}

// engine/headless/lib/font-loader/loaders/google-font-loader.js
const FONT_STYLES = {
  italic: "i"
};
class GoogleFontLoader extends BaseFontLoader {
  load() {
    if (this._fonts.length) {
      this._addStylesheetTag();
    }
    return super.load();
  }
  _addStylesheetTag() {
    const families = this._getFamiliesString();
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = `https://fonts.googleapis.com/css?family=${families}`;
    const head = document.getElementsByTagName("head")[0];
    head.appendChild(link);
  }
  _getFamiliesString() {
    const families = {};
    this._fonts.forEach((font2) => {
      const fontFamily = font2.getFontFamily();
      const fontStyle = font2.getFontStyle();
      const fontWeight = font2.getFontWeight();
      families[fontFamily] = families[fontFamily] || [];
      if (typeof fontWeight !== "undefined") {
        families[fontFamily].push(`${fontWeight}${FONT_STYLES[fontStyle] || ""}`);
      } else {
        families[fontFamily].push(400);
      }
    });
    const familyStrings = [];
    for (const name in families) {
      const variants = families[name];
      const variantsString = variants.length ? `:${variants.join(",")}` : "";
      const nameString = name.replace(" ", "+") + variantsString;
      familyStrings.push(nameString);
    }
    return familyStrings.join("|");
  }
}

// engine/headless/lib/font-loader/index.js
class FontLoader {
  constructor(ui, fonts2) {
    this._ui = ui;
    this._fonts = fonts2;
    this._loadedFonts = [];
  }
  setFonts(fonts2) {
    this._fonts = fonts2;
  }
  needsToLoad() {
    for (let i = 0; i < this._fonts.length; i++) {
      let provider;
      this._fonts[i].getVariations().forEach((variation) => {
        provider = provider || variation.getProvider();
      });
      if (!provider)
        continue;
      return true;
    }
  }
  fontLoaded(font2) {
    const identifier = font2.getFontFamily();
    return this._loadedFonts.indexOf(identifier) !== -1;
  }
  setFontLoaded(font2) {
    if (!this.fontLoaded(font2)) {
      const identifier = font2.getFontFamily();
      this._loadedFonts.push(identifier);
    }
  }
  load() {
    const fonts2 = this._fonts;
    const loaders = {
      google: new GoogleFontLoader(this._ui),
      file: new FileFontLoader(this._ui)
    };
    const disposeLoaders = () => {
      for (const identifier in loaders) {
        const loader = loaders[identifier];
        loader.dispose();
      }
    };
    fonts2.filter((font2) => !this.fontLoaded(font2)).forEach((font2) => {
      font2.getVariations().forEach((variation) => {
        const provider = variation.getProvider();
        if (!provider)
          return;
        const loader = loaders[provider];
        loader.add(variation);
      });
    });
    const promises = [];
    for (const name in loaders) {
      promises.push(loaders[name].load());
    }
    return Promise.all(promises).then(() => {
      disposeLoaders();
      fonts2.forEach((font2) => {
        this.setFontLoaded(font2);
      });
    }).catch((e) => {
      disposeLoaders();
      throw e;
    });
  }
}

// engine/shared/managers/brush-manager.js
class BrushManager {
  constructor(ui, options) {
    this._ui = ui;
    this._options = options;
    this._brushes = [];
    this._brushesById = {};
    this._addBrushes(constants_default3.DEFAULTS.BRUSHES);
    const {brushes: brushes2, replaceBrushes, availableBrushes} = this._options;
    if (this._options.brushes) {
      this._addBrushes(brushes2, replaceBrushes);
    }
    if (availableBrushes) {
      this._brushes = this._brushes.filter((brush3) => availableBrushes.indexOf(brush3.identifier) !== -1);
    }
  }
  _addBrushes(brushes2, replaceBrushes) {
    if (replaceBrushes) {
      this._brushes = [];
      this._brushesById = {};
    }
    brushes2.forEach((brush3) => {
      this._brushes.push(brush3);
      this._brushesById[brush3.identifier] = brush3;
    });
  }
  getBrushByIdentifier(identifier) {
    return this._brushesById[identifier];
  }
  getBrushes() {
    return this._brushes;
  }
  getFirstBrush() {
    return this._brushes[0];
  }
}

// engine/shared/managers/filter-manager.js
class FilterManager {
  constructor(ui, options, isPreloading = false) {
    this._ui = ui;
    this._options = options;
    this._categoriesById = {};
    this._filtersByIdentifier = {
      identity: SDK.Operations.FilterOperation.Filters.IdentityFilter
    };
    this._categories = utils_default3.wrapFiltersInCategories(constants_default.DEFAULTS.FILTERS.slice(0), FilterManager.CATEGORY_ITEMS_PROPERTY);
    this._customAssetsAllowed = isPreloading || ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
    if (this._customAssetsAllowed && this._options.categories) {
      this._options.categories = utils_default3.wrapFiltersInCategories(this._options.categories, FilterManager.CATEGORY_ITEMS_PROPERTY);
    }
    this._initCategories();
  }
  instantiateFilterWithIdentifier(identifier) {
    const crossOrigin = {value: this._ui._options.crossOrigin, cors: true};
    const Filter3 = this.getFilterByIdentifier(identifier);
    if (!Filter3) {
      return Promise.reject(new Error(`Unknown filter with identifier \`${identifier}\`!`));
    }
    if (!(Filter3.prototype instanceof SDK.Operations.FilterOperation.Filter)) {
      const {
        lutImage,
        resolution,
        horizontalTileCount,
        verticalTileCount
      } = Filter3;
      let {lightColor, darkColor} = Filter3;
      if (lightColor && darkColor) {
        lightColor = Color3.fromHex(lightColor);
        darkColor = Color3.fromHex(darkColor);
        return Promise.resolve(new SDK.Operations.FilterOperation.Filters.DuoToneFilter({
          lightColor,
          darkColor
        }));
      }
      let preloadedImage;
      if (this._ui.getPreloader) {
        preloadedImage = this._ui.getPreloader().getAsset(lutImage);
      }
      let loadPromise;
      if (preloadedImage) {
        loadPromise = Promise.resolve(preloadedImage);
      } else {
        loadPromise = image_loader_default.loadImage(this._ui.getAssetPath(lutImage), crossOrigin);
      }
      return loadPromise.then(() => {
        return image_loader_default.loadImage(this._ui.getAssetPath(lutImage), crossOrigin).then((image5) => {
          return new SDK.Operations.FilterOperation.Filters.ThreeDLUTFilter({
            image: image5,
            resolution,
            horizontalTileCount,
            verticalTileCount
          });
        });
      });
    }
    return Promise.resolve(new Filter3());
  }
  _initCategories() {
    if (this._customAssetsAllowed && this._options.categories) {
      if (this._options.replaceCategories) {
        this._categories = utils_default3.wrapFiltersInCategories(this._options.categories, FilterManager.CATEGORY_ITEMS_PROPERTY);
      } else {
        this._categories = utils_default3.mergeCategories(this._categories, this._options.categories, FilterManager.CATEGORY_ITEMS_PROPERTY);
      }
    }
    if (this._customAssetsAllowed && this._options.availableFilters) {
      const newCategories = [];
      this._categories.forEach((category) => {
        const filters = category.filters.filter((f) => this._options.availableFilters.indexOf(f.identifier) !== -1);
        if (filters.length > 0) {
          newCategories.push({
            identifier: category.identifier,
            defaultName: category.defaultName,
            filters
          });
        }
      });
      this._categories = newCategories;
    }
    const allCategory = {
      identifier: "all",
      defaultName: "All",
      visible: false,
      filters: this._categories.length <= 0 ? [] : this._categories.map((c) => c.filters).reduce((a, b) => a.concat(b))
    };
    this._categories.unshift(allCategory);
    this._categoriesById.all = allCategory;
    this._categories.forEach((c) => {
      this._categoriesById[c.identifier] = c;
    });
    allCategory.filters.forEach((filter40) => {
      this._filtersByIdentifier[filter40.identifier] = filter40;
    });
  }
  getFiltersForCategory(categoryIdentifier) {
    if (!this._categoriesById[categoryIdentifier]) {
      throw new Error(`Unknown filter category '${categoryIdentifier}'`);
    }
    return this._categoriesById[categoryIdentifier].filters;
  }
  getItemsByCategory(categoryIdentifier) {
    return this.getFiltersForCategory(categoryIdentifier);
  }
  getFilterByIdentifier(identifier) {
    return this._filtersByIdentifier[identifier];
  }
  getCategories() {
    return this._categories;
  }
  getCategoryByIdentifier(identifier) {
    return this._categoriesById[identifier];
  }
}
FilterManager.CATEGORY_ITEMS_PROPERTY = "filters";

// engine/shared/managers/sticker-manager.js
const CUSTOM_CATEGORY_ID = "imgly_sticker_custom";
class StickerManager {
  constructor(ui, options, dynamicAssetsLibrary) {
    this._ui = ui;
    this._options = options;
    this._dynamicAssetsLibrary = dynamicAssetsLibrary || this._ui.getEditor().getDynamicAssetsLibrary() || new asset_library_default();
    this._categoriesById = {};
    this._categories = [];
    this._stickersById = {};
    this._customStickerCanvas = utils_default.createCanvas();
    this.reload();
  }
  reload() {
    this._categoriesById = {};
    this._categories = [];
    this._stickersById = {};
    const customAssetsAllowed = this._ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
    this._addCategories(constants_default.DEFAULTS.STICKER_CATEGORIES);
    const {categories, replaceCategories} = this._options;
    if (customAssetsAllowed && this._options.categories) {
      this._addCategories(categories, replaceCategories);
    } else {
      this._updateCategoriesMap();
      this._updateAllCategory();
    }
    if (customAssetsAllowed) {
      const customStickers = this._dynamicAssetsLibrary.getAssets("sticker");
      if (customStickers.length > 0) {
        const customCategory = this._createCustomStickerCategory(customStickers);
        this._addCategories([customCategory], false, true);
      }
    }
  }
  loadExternal(url2) {
    const loader = new JSONLoader(url2);
    return loader.load().then((result) => {
      this._addCategories(result.categories, this._options.replaceCategories);
    });
  }
  _addCategories(categories, replace = false, insertAtBeginning = false) {
    if (replace) {
      this._categories = categories.slice(0);
    } else if (insertAtBeginning) {
      this._categories = this._mergeCategories(categories, this._categories);
    } else {
      this._categories = this._mergeCategories(this._categories, categories);
    }
    this._updateCategoriesMap();
    this._updateAllCategory();
  }
  _mergeCategories(categories, newCategories) {
    categories = utils_default3.cloneCategories(categories, "stickers");
    for (const newCategory of newCategories) {
      let duplicateCategory = false;
      for (const existingCategory of categories) {
        if (newCategory.identifier === existingCategory.identifier) {
          for (const newSticker of newCategory.stickers) {
            let duplicateSticker = false;
            for (const existingSticker of existingCategory.stickers) {
              if (newSticker.identifier === existingSticker.identifier) {
                Object.assign(existingSticker, newSticker);
                duplicateSticker = true;
                break;
              }
            }
            if (!duplicateSticker) {
              existingCategory.stickers.push(newSticker);
            }
          }
          duplicateCategory = true;
          break;
        }
      }
      if (!duplicateCategory) {
        categories.push(newCategory);
      }
    }
    return categories;
  }
  _updateCategoriesMap() {
    this._categoriesById = {};
    this._categories.forEach((c) => {
      this._categoriesById[c.identifier] = c;
    });
    this._categories.forEach((c) => {
      c.stickers.forEach((s) => {
        this._stickersById[s.identifier] = s;
      });
    });
    if (typeof this._options.availableStickers !== "undefined" && this._options.availableStickers !== null) {
      this._categories.forEach((category) => {
        if (category.identifier !== CUSTOM_CATEGORY_ID) {
          category.stickers = category.stickers.filter((sticker) => this._options.availableStickers.indexOf(sticker.identifier) !== -1);
        }
      });
      this._categories = this._categories.filter((category) => category.stickers.length > 0);
    }
    this._updateAllCategory();
  }
  _updateAllCategory() {
    this._allCategory = {
      identifier: "all",
      defaultName: "All",
      stickers: this._categories.map((c) => c.stickers).reduce((a, b) => a.concat(b), [])
    };
    this._categoriesById.all = this._allCategory;
  }
  renderStickerThumbnailFromImage(image5) {
    const canvas9 = this._customStickerCanvas;
    const context = canvas9.getContext("2d");
    context.save();
    const thumbWidth = 62;
    const scale = thumbWidth / image5.width;
    const thumbHeight = scale * image5.height;
    canvas9.width = thumbWidth;
    canvas9.height = thumbWidth;
    context.clearRect(0, 0, image5.width, image5.height);
    context.translate(0, 0.5 * (canvas9.height - thumbHeight));
    context.scale(scale, scale);
    context.drawImage(image5, 0, 0);
    const thumbURL = canvas9.toDataURL("image/png");
    context.restore();
    return {
      data: thumbURL,
      width: thumbWidth,
      height: thumbHeight
    };
  }
  addCustomStickerFromImage(image5, name, tintMode = "none") {
    const needsResize = (image6) => {
      const sdk15 = this._ui.getEditor().getSDK();
      const renderer = sdk15.getRenderer();
      const dimensions = new Vector236(image6.width, image6.height);
      const maxPixels = this._ui.getEditor().getMaxMegapixels() * 1e6;
      let maxDimensions = renderer.getMaxDimensions();
      const exceedsMaxPixels = dimensions.x * dimensions.y > maxPixels;
      const exceedsMaxDimensions = maxDimensions !== null && (dimensions.x > maxDimensions || dimensions.y > maxDimensions);
      if (exceedsMaxPixels) {
        const ratioHV = image6.width / image6.height;
        const ratioVH = image6.height / image6.width;
        maxDimensions = new Vector236(Math.sqrt(maxPixels * ratioHV), Math.sqrt(maxPixels * ratioVH)).floor().max();
      }
      const safeDimensions2 = dimensions.clone();
      if (exceedsMaxPixels || exceedsMaxDimensions) {
        if (dimensions.x / dimensions.y > 1) {
          safeDimensions2.x = maxDimensions;
          safeDimensions2.y = maxDimensions / dimensions.x * dimensions.y;
        } else {
          safeDimensions2.x = maxDimensions / dimensions.y * dimensions.x;
          safeDimensions2.y = maxDimensions;
        }
      }
      return safeDimensions2;
    };
    const scaledSizeWithLongerSide = (imageSize, maxDimension) => {
      const aspect = imageSize.x / imageSize.y;
      if (aspect > 1) {
        return new Vector236(maxDimension, maxDimension / aspect);
      }
      return new Vector236(maxDimension * aspect, maxDimension);
    };
    const isSVG = image5.src.substring(0, 14) === "data:image/svg";
    const sdk14 = this._ui.getEditor().getSDK();
    image5 = sdk14.correctExifOrientation(image5);
    const svgSize = scaledSizeWithLongerSide(new Vector236(image5.width, image5.height), 2048);
    const safeDimensions = isSVG ? svgSize : needsResize(image5);
    const canvas9 = this._customStickerCanvas;
    const context = canvas9.getContext("2d");
    context.save();
    const thumb = this.renderStickerThumbnailFromImage(image5);
    if (isSVG) {
      if (image5.width > image5.height) {
        canvas9.width = 2048;
        canvas9.height = 2048 / image5.width * image5.height;
      } else {
        canvas9.height = 2048;
        canvas9.width = 2048 / image5.height * image5.width;
      }
      image5.width = canvas9.width;
      image5.height = canvas9.height;
    } else {
      canvas9.width = safeDimensions.x;
      canvas9.height = safeDimensions.y;
      context.scale(safeDimensions.x / image5.width, safeDimensions.y / image5.height);
    }
    context.drawImage(image5, 0, 0, image5.width, image5.height);
    const baseURL = canvas9.toDataURL();
    context.restore();
    const sticker = {
      identifier: utils_default.generateUUID(),
      defaultName: name || "",
      tintMode,
      images: {
        mediaThumb: {
          uris: [thumb.data],
          rawData: true,
          width: thumb.width,
          height: thumb.height
        },
        mediaBase: {
          uris: isSVG ? [baseURL, image5.src] : [baseURL],
          rawData: true,
          isSVG,
          width: safeDimensions.x,
          height: safeDimensions.y
        }
      }
    };
    const assetsLibrary = this._dynamicAssetsLibrary;
    assetsLibrary.addAsset("sticker", sticker, true);
    const customStickers = assetsLibrary.getAssets("sticker");
    if (customStickers.length === 1) {
      const customCategory = this._createCustomStickerCategory(customStickers);
      this._addCategories([customCategory], false, true);
    } else {
      this.getCategory(CUSTOM_CATEGORY_ID).stickers = customStickers;
      this._updateAllCategory();
    }
    this._updateCategoriesMap();
  }
  _createCustomStickerCategory(stickers) {
    return {
      identifier: CUSTOM_CATEGORY_ID,
      defaultName: "Custom",
      metaData: {
        backgroundImage: stickers[stickers.length - 1].images.mediaBase.uris[0],
        rawData: true
      },
      stickers
    };
  }
  getStickersForCategory(categoryName) {
    if (!this._categoriesById[categoryName]) {
      throw new Error(`Unknown sticker category '${categoryName}'`);
    }
    return this._categoriesById[categoryName].stickers;
  }
  getStickerByIdentifier(identifier) {
    return this._stickersById[identifier];
  }
  getCategories(includeAllCategory = false) {
    if (includeAllCategory) {
      return [this._allCategory].concat(this._categories);
    }
    return this._categories;
  }
  getCategory(id) {
    return this._categoriesById[id];
  }
  static getURLForSticker(sticker, size = "base") {
    const {images} = sticker;
    const media = size === "base" ? images.mediaBase || images.mediaThumb : images.mediaThumb;
    const uris = media.uris || [media.uri];
    if (process.env.REACT_APP_BROWSER) {
      if (!utils_default3.Browser.getIEVersion()) {
        const svgs = uris.filter((f) => /\.svg$/i.test(f));
        return svgs.length ? svgs[0] : uris[0];
      }
    }
    const notSvgs = uris.filter((f) => !/\.svg$/i.test(f));
    return notSvgs.length ? notSvgs[0] : uris[0];
  }
}

// engine/shared/serialization/1.0.0/deserializer.js
const p_map2 = __toModule(require("p-map"));
let Brush2;
if (typeof SDK.Operations.SpriteOperation !== "undefined") {
  Brush2 = SDK.Operations.SpriteOperation.BrushSprite;
}
class v100Deserializer {
  constructor(editor2, data) {
    this._editor = editor2;
    this._ui = this._editor.getUI();
    this._data = data;
    this._filterManager = new FilterManager(this._ui, this._getOptions("filter"));
    this._stickerManager = new StickerManager(this._ui, this._getOptions("sticker"));
    this._brushManager = new BrushManager(this._ui, this._getOptions("brush"));
    this._fontManager = new FontManager(this._ui, this._getOptions("text"));
  }
  _getOptions(control) {
    const {controls} = this._editor;
    let defaultOptions = {};
    if (controls && controls.get(control)) {
      defaultOptions = controls.get(control).defaultOptions;
    }
    const editorOptions = this._editor.getOptions();
    return SDKUtils2.deepDefaults({}, editorOptions.editor.controlsOptions[control] || {}, defaultOptions);
  }
  deserialize() {
    return this._validateVersion().then(() => this._deserializeInputImage()).then(() => this._deserializeOperations());
  }
  _validateVersion() {
    if (this._data.version !== this.constructor.version) {
      return Promise.reject(new Error(`Invalid version ${this._data.version}, expected ${this.constructor.version}`));
    }
    return Promise.resolve();
  }
  _deserializeInputImage() {
    return new Promise((resolve, reject) => {
      const {data, type} = this._data.inputImage;
      if (data && type) {
        const image5 = new window.Image();
        image5.addEventListener("load", () => {
          this._editor.setImage(image5);
          resolve();
        });
        image5.src = `data:${type};base64,${data}`;
      } else {
        resolve();
      }
    });
  }
  _deserializeOperations() {
    return __async(this, null, function* () {
      const {operations: operations3} = this._data;
      return p_map2.default(operations3, (operation3) => __async(this, null, function* () {
        return this._deserializeOperation(operation3);
      }));
    });
  }
  _deserializeOperation(operation3) {
    switch (operation3.type) {
      case "crop":
        return this._deserializeCropOperation(operation3);
      case "orientation":
        return this._deserializeOrientationOperation(operation3);
      case "filter":
        return this._deserializeFilterOperation(operation3);
      case "adjustments":
        return this._deserializeAdjustmentsOperation(operation3);
      case "sprite":
        return this._deserializeSpriteOperation(operation3);
      case "focus":
        return this._deserializeFocusOperation(operation3);
    }
  }
  _deserializeCropOperation(operation3) {
    const {options} = operation3;
    let {rotation} = options;
    const start = Vector236.fromObject(options.start);
    const end = Vector236.fromObject(options.end);
    if (rotation > Math.PI) {
      rotation -= Math.PI * 2;
    }
    const cropOptions = {start, end};
    if (typeof rotation !== "undefined") {
      cropOptions.rotation = rotation;
    }
    const transformOperation = this._editor.operations.getOrCreate("transform");
    this._editor.broadcastTransform(transformOperation, cropOptions);
    transformOperation.set(cropOptions);
    return Promise.resolve(transformOperation);
  }
  _deserializeOrientationOperation(operation3) {
    const {options} = operation3;
    const orientationOperation = this._editor.operations.getOrCreate("orientation");
    if (!orientationOperation)
      return Promise.resolve();
    orientationOperation.set(options);
    return Promise.resolve(orientationOperation);
  }
  _deserializeFilterOperation(operation3) {
    const {options} = operation3;
    if (!this._filterManager.getFilterByIdentifier(options.name)) {
      log_default.warn("Deserializer", `Unknown filter \`${options.name}\``);
      return Promise.resolve();
    }
    return this._filterManager.instantiateFilterWithIdentifier(options.name).then((filter40) => {
      const filterOperation = this._editor.operations.getOrCreate("filter");
      filterOperation.set({
        identifier: options.name,
        filter: filter40,
        intensity: options.intensity
      });
      return filterOperation;
    });
  }
  _deserializeAdjustmentsOperation(operation3) {
    const {AdjustmentsOperation: AdjustmentsOperation2} = SDK.Operations;
    const {options} = operation3;
    const knownOptions = [
      "brightness",
      "saturation",
      "contrast",
      "exposure",
      "shadows",
      "highlights",
      "clarity"
    ];
    const operationOptions = {};
    knownOptions.forEach((optionName) => {
      if (typeof options[optionName] === "undefined")
        return;
      const {
        minValue,
        midValue,
        maxValue
      } = AdjustmentsOperation2.prototype.availableOptions[optionName];
      let value = options[optionName];
      value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
      operationOptions[optionName] = value;
    });
    return Promise.resolve(this._editor.operations.getOrCreate("adjustments", operationOptions));
  }
  _deserializeSpriteOperation(operation3) {
    const {options} = operation3;
    const spriteOperation = this._editor.operations.getOrCreate("sprite");
    if (!spriteOperation)
      return Promise.resolve();
    const promises = options.sprites.map((sprite7) => {
      return this._deserializeSprite(spriteOperation, sprite7);
    }).filter((p) => p);
    return Promise.all(promises).then((sprites) => {
      spriteOperation.setSprites(sprites.filter((s) => s));
      return spriteOperation;
    });
  }
  _deserializeSprite(spriteOperation, sprite7) {
    switch (sprite7.type) {
      case "sticker":
        return this._deserializeSticker(spriteOperation, sprite7);
      case "text":
        return this._deserializeText(spriteOperation, sprite7);
      case "brush":
        return this._deserializeBrush(spriteOperation, sprite7);
      case "textdesign":
        return this._deserializeTextDesign && this._deserializeTextDesign(spriteOperation, sprite7);
    }
  }
  _deserializeSticker(operation3, sprite7) {
    const {SpriteOperation: SpriteOperation2} = SDK.Operations;
    const {options} = sprite7;
    const sticker = this._stickerManager.getStickerByIdentifier(options.name);
    const url2 = this._stickerManager.getURLForSticker(sticker);
    if (!sticker) {
      log_default.warn("Deserializer", `Unknown sticker '${options.name}'. Skipping sprite.`);
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      const image5 = new window.Image();
      image5.addEventListener("load", () => {
        const adjustments2 = SpriteOperation2.StickerSprite.prototype.availableOptions.adjustments.structure;
        const {rotation, flipHorizontally, flipVertically} = options;
        const stickerOptions = {
          identifier: options.name,
          image: image5,
          position: Vector236.fromObject(options.position),
          dimensions: Vector236.fromObject(options.dimensions),
          rotation,
          flipHorizontally,
          flipVertically,
          adjustments: {}
        };
        if (typeof options.adjustments !== "undefined") {
          ["brightness", "contrast", "saturation"].forEach((option) => {
            if (typeof options.adjustments[option] !== "undefined") {
              stickerOptions.adjustments[option] = options.adjustments[option] + adjustments2[option].default;
            }
          });
        }
        resolve(operation3.createSticker(stickerOptions));
      });
      image5.crossOrigin = this._editor.getCrossOrigin();
      image5.src = this._editor.getUI().getAssetPath(url2);
    });
  }
  _deserializeText(operation3, text) {
    const {options} = text;
    const {
      fontSize,
      lineHeight,
      fontFamily,
      fontWeight,
      alignment,
      rotation,
      maxWidth,
      color: color6,
      backgroundColor
    } = options;
    const fontLoader = new FontLoader(this._ui);
    let font2 = this._fontManager.getFontByFontFamily(fontFamily);
    if (!font2)
      font2 = this._fontManager.getDefaultFont();
    fontLoader.setFonts([font2]);
    return fontLoader.load().then(() => {
      const sprite7 = operation3.createText({
        fontSize,
        lineHeight,
        fontFamily,
        fontWeight,
        alignment,
        rotation,
        maxWidth,
        text: options.text,
        color: Color3.fromArray(color6),
        backgroundColor: Color3.fromArray(backgroundColor),
        position: Vector236.fromObject(options.position)
      });
      sprite7._edited = true;
      return sprite7;
    });
  }
  _deserializeBrush(operation3, brush3) {
    const {options} = brush3;
    const {paths} = options;
    const brushSprite = operation3.createBrush();
    paths.forEach((path2) => {
      this._deserializeBrushPath(brushSprite, path2);
    });
    return Promise.resolve(brushSprite);
  }
  _deserializeBrushPath(brushSprite, path2) {
    const {points} = path2;
    const brushInstance = this._createBrushForPath(path2);
    const pathObject = brushSprite.createPath(brushInstance);
    pathObject.setClosed(true);
    points.forEach((point) => {
      pathObject.addControlPoint(Vector236.fromObject(point));
    });
  }
  _createBrushForPath(path2) {
    const {color: color6, size} = path2;
    const colorObject = Color3.fromArray(color6);
    const brushOptions = {
      color: colorObject,
      size
    };
    const rawBrush = this._brushManager.getFirstBrush();
    if (rawBrush.prototype && rawBrush.prototype instanceof Brush2) {
      const BrushClass2 = rawBrush;
      return new BrushClass2(brushOptions);
    }
    const _brush = SDKUtils2.extend({}, rawBrush);
    delete _brush.image;
    class BrushClass extends Brush2 {
    }
    BrushClass.identifier = rawBrush.identifier;
    return new BrushClass(SDKUtils2.extend({}, _brush, brushOptions));
  }
  _deserializeFocusOperation(operation3) {
    const {options} = operation3.options;
    switch (operation3.options.type) {
      case "radial": {
        const {position, radius, gradientRadius, blurRadius} = options;
        return Promise.resolve(this._editor.operations.getOrCreate("radial-focus", {
          position: Vector236.fromObject(position),
          radius,
          gradientRadius,
          blurRadius
        }));
      }
      case "linear": {
        const {start, end, size, gradientSize, blurRadius} = options;
        return Promise.resolve(this._editor.operations.getOrCreate("mirrored-focus", {
          start: Vector236.fromObject(start),
          end: Vector236.fromObject(end),
          size,
          gradientSize,
          blurRadius
        }));
      }
    }
  }
  _getInputDimensionsForOperation(operation3) {
    let operationFound = false;
    let inputDimensions = this._editor.getInputDimensions();
    this._editor.operations.getStack().forEach((op) => {
      if (op === operation3)
        operationFound = true;
      if (operationFound)
        return;
      inputDimensions = op.getNewDimensions(inputDimensions);
    });
    return inputDimensions;
  }
}
v100Deserializer.version = "1.0.0";

// engine/shared/serialization/1.0.0/serializer.js
const TWICE_PI = Math.PI * 2;
class v100Serializer {
  constructor(editor2) {
    this._editor = editor2;
    this._serializeOperations = this._serializeOperations.bind(this);
  }
  serialize(options = {}) {
    this._options = SDKUtils2.defaults(options, {
      image: true
    });
    const data = {
      version: this.constructor.version
    };
    return this._serializeInputImage(data).then(this._serializeOperations);
  }
  _serializeInputImage(data) {
    const image5 = this._editor.getImage();
    const {width, height} = image5;
    if (!this._options.image) {
      data.inputImage = {width, height};
      return Promise.resolve(data);
    }
    const canvas9 = SDKUtils2.createCanvas();
    canvas9.width = image5.width;
    canvas9.height = image5.height;
    const context = canvas9.getContext("2d");
    context.drawImage(image5, 0, 0);
    const dataUrl = canvas9.toDataURL(ImageFormat3.PNG);
    data.inputImage = {
      type: ImageFormat3.PNG,
      data: dataUrl.replace(/^data:image\/(.*?);base64,/, ""),
      width,
      height
    };
    return Promise.resolve(data);
  }
  _serializeOperations(data) {
    const operations3 = [];
    const stack = this._editor.operations.getStack();
    stack.forEach((operation3) => {
      const data2 = this._serializeOperation(operation3, operations3);
      if (data2) {
        operations3.push(data2);
      }
    });
    data.operations = operations3.filter((o) => o);
    return Promise.resolve(data);
  }
  _serializeOperation(operation3, operations3) {
    switch (operation3.constructor.identifier) {
      case "transform":
        return this._serializeTransformOperation(operation3);
      case "orientation":
        return this._serializeOrientationOperation(operation3);
      case "filter":
        return this._serializeFilterOperation(operation3);
      case "adjustments":
        return this._serializeAdjustmentsOperation(operation3);
      case "sprite":
        return this._serializeSpriteOperation(operation3, operations3);
      case "radial-focus":
        return this._serializeRadialFocusOperation(operation3);
      case "mirrored-focus":
        return this._serializeLinearFocusOperation(operation3);
      default:
        log_default.warn(`Unable to serialize operation of type ${operation3.constructor.identifier}`);
    }
  }
  _serializeTransformOperation(operation3) {
    const options = operation3.serializeOptions(["start", "end", "rotation"], true);
    options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
    return {
      type: "crop",
      options
    };
  }
  _serializeOrientationOperation(operation3) {
    return {
      type: "orientation",
      options: operation3.serializeOptions(["flipVertically", "flipHorizontally", "rotation"], true)
    };
  }
  _serializeFilterOperation(operation3) {
    if (operation3.getIdentifier() === "identity")
      return null;
    return {
      type: "filter",
      options: {
        intensity: operation3.getIntensity(),
        name: operation3.getIdentifier()
      }
    };
  }
  _serializeAdjustmentsOperation(operation3) {
    const {availableOptions} = operation3;
    const optionNames = [
      "brightness",
      "saturation",
      "contrast",
      "exposure",
      "shadows",
      "highlights",
      "clarity"
    ];
    const options = {};
    optionNames.forEach((optionName) => {
      const option = availableOptions[optionName];
      const value = operation3.getOption(optionName);
      const {minValue, midValue, maxValue} = option;
      options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
    });
    return {
      type: "adjustments",
      options
    };
  }
  _serializeSpriteOperation(operation3, operations3) {
    const spriteOperations = operations3.filter((o) => o.type === "sprite");
    let spriteOperation;
    let returnOperation = true;
    if (spriteOperations.length) {
      spriteOperation = spriteOperations.pop();
      returnOperation = false;
    } else {
      spriteOperation = {
        type: "sprite",
        options: {
          sprites: []
        }
      };
    }
    operation3.getSprites().forEach((sprite7) => {
      let spriteItem = null;
      if (sprite7 instanceof operation3.constructor.StickerSprite) {
        spriteItem = this._serializeSticker(operation3, sprite7);
      } else if (sprite7 instanceof operation3.constructor.TextSprite) {
        spriteItem = this._serializeText(operation3, sprite7);
      } else if (sprite7 instanceof operation3.constructor.BrushSprite) {
        spriteItem = this._serializeBrush(operation3, sprite7);
      } else if (sprite7 instanceof operation3.constructor.TextDesignSprite) {
        spriteItem = this._serializeTextDesign && this._serializeTextDesign(operation3, sprite7);
      }
      if (spriteItem) {
        spriteOperation.options.sprites.push(spriteItem);
      }
    });
    if (returnOperation) {
      return spriteOperation;
    }
  }
  _serializeSticker(operation3, sprite7) {
    const adjustments2 = sprite7.getAdjustments();
    const options = sprite7.serializeOptions([
      "identifier",
      "position",
      "dimensions",
      "flipVertically",
      "flipHorizontally",
      "rotation"
    ], true);
    options.name = options.identifier;
    delete options.identifier;
    options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
    const adjustmentsOptions = adjustments2.availableOptions;
    options.adjustments = {
      brightness: adjustments2.getBrightness() - adjustmentsOptions.brightness.default,
      saturation: adjustments2.getSaturation() - adjustmentsOptions.saturation.default,
      contrast: adjustments2.getContrast() - adjustmentsOptions.contrast.default
    };
    return {
      type: "sticker",
      options
    };
  }
  _serializeText(operation3, sprite7) {
    const options = sprite7.serializeOptions([
      "fontSize",
      "lineHeight",
      "fontFamily",
      "fontWeight",
      "alignment",
      "color",
      "backgroundColor",
      "position",
      "rotation",
      "text",
      "maxWidth"
    ], true);
    options.rotation = (options.rotation + TWICE_PI) % TWICE_PI;
    return {
      type: "text",
      options
    };
  }
  _serializeBrush(operation3, sprite7) {
    return {
      type: "brush",
      options: {
        paths: sprite7.getPaths().map((path2) => this._serializePath(path2))
      }
    };
  }
  _serializePath(path2) {
    const options = path2.getBrush().serializeOptions(["color", "size"], true);
    options.points = path2.getControlPoints().map((point) => point.getPosition().toObject());
    return options;
  }
  _serializeRadialFocusOperation(operation3) {
    return {
      type: "focus",
      options: {
        type: "radial",
        options: operation3.serializeOptions(["position", "radius", "gradientRadius", "blurRadius"], true)
      }
    };
  }
  _serializeLinearFocusOperation(operation3) {
    return {
      type: "focus",
      options: {
        type: "linear",
        options: operation3.serializeOptions(["start", "end", "blurRadius", "size", "gradientSize"], true)
      }
    };
  }
  _getInputDimensionsForOperation(operation3) {
    let operationFound = false;
    let inputDimensions = this._editor.getInputDimensions();
    this._editor.operations.getStack().forEach((op) => {
      if (op === operation3)
        operationFound = true;
      if (operationFound)
        return;
      inputDimensions = op.getNewDimensions(inputDimensions);
    });
    return inputDimensions;
  }
}
v100Serializer.version = "1.0.0";

// engine/shared/serialization/1.0.1/deserializer.js
class v101Deserializer extends v100Deserializer {
  _deserializeOperation(operation3) {
    if (operation3.type === "selective-blur") {
      return this._deserializeSelectiveBlurOperation(operation3);
    }
    return super._deserializeOperation(operation3);
  }
  _deserializeCropOperation(operation3) {
    const {options} = operation3;
    let {rotation} = options;
    const start = Vector236.fromObject(options.start);
    const end = Vector236.fromObject(options.end);
    const dimensions = options.dimensions ? Vector236.fromObject(options.dimensions) : null;
    if (end.x - start.x <= 0 || end.y - start.y <= 0) {
      throw new Error(`A crop should not result in negative or zero dimensions - start: ${start} - end: ${end}`);
    }
    if (rotation > Math.PI) {
      rotation -= Math.PI * 2;
    }
    const cropOptions = {
      start,
      end
    };
    if (typeof rotation !== "undefined")
      cropOptions.rotation = rotation;
    const transformOperation = this._editor.operations.getOrCreate("transform");
    if (!transformOperation)
      return Promise.resolve();
    this._editor.broadcastTransform(transformOperation, cropOptions);
    transformOperation.set(cropOptions);
    if (dimensions) {
      const size = end.clone().subtract(start);
      const transformDimensions = transformOperation.getInputDimensions(false).multiply(size);
      transformOperation.setTextureScale(dimensions.x / transformDimensions.x);
    }
    return Promise.resolve(transformOperation);
  }
}
v101Deserializer.version = "1.0.1";

// engine/shared/serialization/1.0.1/serializer.js
const TWICE_PI2 = Math.PI * 2;
class v101Serializer extends v100Serializer {
  _serializeTransformOperation(operation3) {
    const options = operation3.serializeOptions(["start", "end", "rotation", "textureScale"], true);
    options.rotation = (options.rotation + TWICE_PI2) % TWICE_PI2;
    if (options.textureScale !== 1) {
      options.dimensions = operation3.getNewDimensions(operation3.getInputDimensions(false));
    }
    delete options.textureScale;
    return {
      type: "crop",
      options
    };
  }
}
v101Serializer.version = "1.0.1";

// engine/headless/lib/frame.js
const {OptionType: OptionType9} = SDK;
class Frame extends SDK.Configurable {
  constructor(ui, options = {}) {
    super(options);
    this._loaded = false;
    this._loading = false;
    this._ui = ui;
    this._frame = SDK.Utils.deepClone(this._options);
  }
  load() {
    if (this._loaded)
      return Promise.resolve();
    if (this._loading)
      return Promise.reject(new Error("Called Frame#load while it's already loading"));
    this._loading = true;
    const {imageGroups} = this._frame;
    const promises = [];
    ["top", "left", "right", "bottom"].forEach((groupName) => {
      if (!(groupName in imageGroups))
        return;
      const group = imageGroups[groupName];
      ["start", "mid", "end"].forEach((partName) => {
        if (!(partName in group))
          return;
        promises.push(this._loadPart(groupName, partName));
      });
    });
    return Promise.all(promises).then(() => {
      this._loaded = true;
      this._loading = false;
    }).catch((e) => {
      this._loaded = false;
      this._loading = false;
    });
  }
  _loadPart(groupName, partName) {
    const {imageGroups} = this._frame;
    const part = imageGroups[groupName][partName];
    let imageUrl = part;
    if (typeof part !== "string" && "image" in part) {
      imageUrl = part.image;
    }
    return image_loader_default.load(this._ui.getAssetPath(imageUrl)).then((image5) => {
      if (typeof part !== "string") {
        this._frame.imageGroups[groupName][partName].image = image5;
      } else {
        this._frame.imageGroups[groupName][partName] = image5;
      }
      return image5;
    });
  }
  getFrame() {
    return this._frame;
  }
}
Frame.prototype.availableOptions = {
  identifier: {type: OptionType9.STRING, required: true},
  defaultName: {type: OptionType9.STRING},
  thumbnail: {type: OptionType9.STRING},
  tintable: {type: OptionType9.BOOLEAN, default: false},
  layoutMode: {
    type: OptionType9.STRING,
    default: "horizontal-inside",
    available: ["horizontal-inside", "vertical-inside"]
  },
  imageGroups: {type: OptionType9.OBJECT, required: true}
};

// engine/shared/managers/frame-manager.js
class FrameManager {
  constructor(ui, options) {
    this._ui = ui;
    this._options = options;
    this._categoriesById = {};
    this._categories = [];
    this._framesById = {};
    this._addCategories(constants_default.DEFAULTS.FRAME_CATEGORIES);
    this._customAssetsAllowed = ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
    const {categories, replaceCategories} = this._options;
    if (this._customAssetsAllowed && this._options.categories) {
      this._addCategories(categories, replaceCategories);
    } else {
      this._updateAllCategory();
    }
  }
  _addCategories(categories, replace = false) {
    if (replace) {
      this._categories = categories.slice(0);
    } else {
      this._categories = utils_default3.mergeCategories(this._categories, categories, "frames");
    }
    this._categoriesById = {};
    this._categories.forEach((c) => {
      this._categoriesById[c.identifier] = c;
    });
    const {availableFrames} = this._options;
    if (this._customAssetsAllowed && availableFrames) {
      this._categories.forEach((c) => {
        c.frames = c.frames.filter((f) => availableFrames.indexOf(f.identifier) !== -1);
      });
    }
    this._categories.forEach((c) => {
      c.frames.forEach((s) => {
        this._framesById[s.identifier] = s;
      });
    });
    this._updateAllCategory();
  }
  _updateAllCategory() {
    this._allCategory = {
      identifier: "all",
      defaultName: "All",
      frames: this._categories.map((c) => c.frames).reduce((a, b) => a.concat(b), [])
    };
    this._categoriesById.all = this._allCategory;
  }
  getFramesForCategory(categoryName) {
    if (!this._categoriesById[categoryName]) {
      throw new Error(`Unknown frame category '${categoryName}'`);
    }
    return this._categoriesById[categoryName].frames;
  }
  getFrameByIdentifier(identifier) {
    return this._framesById[identifier];
  }
  getCategories() {
    return this._categories;
  }
  getCategory(id) {
    return this._categoriesById[id];
  }
}

// engine/shared/managers/overlay-manager.js
class OverlayManager {
  constructor(ui, options) {
    this._ui = ui;
    this._options = options;
    this._overlays = constants_default.DEFAULTS.OVERLAYS.slice(0);
    this._overlaysByIdentifier = {};
    const customAssetsAllowed = ui.getEditor().getSDK()._l.areCustomAssetsAllowed();
    if (customAssetsAllowed && options.overlays) {
      if (options.replaceOverlays) {
        this._overlays = options.overlays;
      } else {
        this._overlays = this._overlays.concat(options.overlays);
      }
    }
    if (customAssetsAllowed && options.availableOverlays) {
      this._overlays = this._overlays.filter((o) => options.availableOverlays.indexOf(o.identifier) !== -1);
    }
    this._overlays.forEach((overlay2) => {
      this._overlaysByIdentifier[overlay2.identifier] = overlay2;
    });
  }
  getOverlays() {
    return this._overlays;
  }
  getOverlayByIdentifier(identifier) {
    return this._overlaysByIdentifier[identifier];
  }
}

// engine/shared/serialization/2.0.0/blend-modes.js
const {OverlayFilter: OverlayFilter3} = SDK.Engine.Filters;
var blend_modes_default = {
  [OverlayFilter3.BLEND_MODES.NORMAL]: "normal",
  [OverlayFilter3.BLEND_MODES.OVERLAY]: "overlay",
  [OverlayFilter3.BLEND_MODES.HARD_LIGHT]: "hard light",
  [OverlayFilter3.BLEND_MODES.SOFT_LIGHT]: "soft light",
  [OverlayFilter3.BLEND_MODES.MULTIPLY]: "multiply",
  [OverlayFilter3.BLEND_MODES.DARKEN]: "darken",
  [OverlayFilter3.BLEND_MODES.LIGHTEN]: "lighten",
  [OverlayFilter3.BLEND_MODES.SCREEN]: "screen",
  [OverlayFilter3.BLEND_MODES.COLOR_BURN]: "color burn"
};

// engine/shared/serialization/2.0.0/deserializer.js
const blendModeByName = SDKUtils2.flipObject(blend_modes_default);
class v200Deserializer extends v101Deserializer {
  constructor(...args) {
    super(...args);
    this._frameManager = new FrameManager(this._ui, this._getOptions("frame"));
    const overlayOptions = this._getOptions("overlay");
    if (overlayOptions) {
      this._overlayManager = new OverlayManager(this._ui, overlayOptions);
    }
  }
  _deserializeSprite(spriteOperation, sprite7) {
    if (sprite7.type === "frame") {
      return this._deserializeFrame(spriteOperation, sprite7);
    }
    if (sprite7.type === "overlay") {
      return this._deserializeOverlay(spriteOperation, sprite7);
    }
    return super._deserializeSprite(spriteOperation, sprite7);
  }
  _deserializeOperation(operation3) {
    if (operation3.type === "transform") {
      return this._deserializeTransformOperation(operation3);
    }
    return super._deserializeOperation(operation3);
  }
  _deserializeOrientationOperation(operationData) {
    if (this._data.meta && this._data.meta.platform !== "html5") {
      return super._deserializeOrientationOperation(operationData);
    }
    const {
      rotation,
      flipHorizontally,
      flipVertically
    } = operationData.options;
    let shouldFlip = rotation === 90 && !flipHorizontally && !flipVertically;
    shouldFlip |= rotation === 90 && flipHorizontally && flipVertically;
    shouldFlip |= rotation === 270 && !flipHorizontally && !flipVertically;
    shouldFlip |= rotation === 270 && flipHorizontally && flipVertically;
    if (shouldFlip) {
      operationData.options.flipHorizontally = !operationData.options.flipHorizontally;
      operationData.options.flipVertically = !operationData.options.flipVertically;
    }
    return super._deserializeOrientationOperation(operationData);
  }
  _deserializeTransformOperation(operationData) {
    return super._deserializeCropOperation(operationData).then((operation3) => {
      if (!operation3)
        return;
      const orientationData = SDKUtils2.Array.find(this._data.operations, (op) => op.type === "orientation");
      if (orientationData) {
        const {options} = orientationData;
        let {rotation, flipHorizontally, flipVertically} = options;
        if (rotation === 90 || rotation === 270) {
          if (!flipHorizontally && flipVertically || flipHorizontally && !flipVertically) {
            flipHorizontally = !flipHorizontally;
            flipVertically = !flipVertically;
          }
        }
        operation3.rotate(options.rotation);
        if (flipHorizontally) {
          operation3.flip("horizontal");
          operation3.setRotation(operation3.getRotation() * -1);
        }
        if (flipVertically) {
          operation3.flip("vertical");
          operation3.setRotation(operation3.getRotation() * -1);
        }
      }
      return operation3;
    });
  }
  _deserializeFrame(spriteOperation, frame2) {
    const {identifier} = frame2.options;
    const frameData = this._frameManager.getFrameByIdentifier(identifier);
    if (!frameData) {
      log_default.warn("Deserializer", `Unknown frame \`${identifier}\`. Skipping frame.`);
      return Promise.resolve();
    }
    const frameInstance = new Frame(this._ui, frameData);
    return frameInstance.load().then(() => {
      this._editor.operations.getOrCreate("frame", {
        frame: frameInstance.getFrame()
      });
    });
  }
  _deserializeOverlay(spriteOperation, overlay2) {
    const {blendMode, intensity, identifier} = overlay2.options;
    const overlayData = this._overlayManager.getOverlayByIdentifier(identifier);
    if (!overlayData) {
      log_default.warn("Deserializer", `Unknown overlay \`${identifier}\`. Skipping overlay.`);
      return Promise.resolve();
    }
    const overlayPath = this._editor.getUI().getAssetPath(overlayData.image);
    return image_loader_default.load(overlayPath).then((image5) => {
      this._editor.operations.getOrCreate("overlay", {
        alpha: intensity,
        identifier,
        blendMode: parseInt(blendModeByName[blendMode || overlayData.blendMode], 10),
        image: image5
      });
    });
  }
  _createBrushForPath(path2) {
    const brush3 = super._createBrushForPath(path2);
    if (typeof path2.hardness !== "undefined" && brush3.hasOption("hardness")) {
      brush3.setHardness(path2.hardness);
    }
    return brush3;
  }
  _deserializeSticker(operation3, sprite7) {
    const {SpriteOperation: SpriteOperation2} = SDK.Operations;
    const {options} = sprite7;
    const sticker = this._stickerManager.getStickerByIdentifier(options.identifier);
    const url2 = StickerManager.getURLForSticker(sticker, "base");
    if (!sticker) {
      log_default.warn("Deserializer", `Unknown sticker \`${options.identifier}\`. Skipping sprite.`);
      return Promise.resolve();
    }
    const inputDimensions = operation3.getInputDimensions(false);
    return new Promise((resolve, reject) => {
      const image5 = new window.Image();
      image5.addEventListener("load", () => {
        const adjustments2 = SpriteOperation2.StickerSprite.prototype.availableOptions.adjustments.structure;
        const {rotation, flipHorizontally, flipVertically} = options;
        const stickerOptions = {
          identifier: options.identifier,
          image: image5,
          position: Vector236.fromObject(options.position),
          dimensions: Vector236.fromObject(options.dimensions).multiply(inputDimensions.min()),
          rotation,
          flipHorizontally,
          flipVertically,
          adjustments: {}
        };
        if (typeof options.adjustments !== "undefined") {
          ["brightness", "contrast", "saturation"].forEach((option) => {
            if (typeof options.adjustments[option] !== "undefined") {
              stickerOptions.adjustments[option] = options.adjustments[option] + adjustments2[option].default;
            }
          });
        }
        if (typeof options.tintColor !== "undefined" && typeof sticker.tintMode !== "undefined") {
          stickerOptions.tintColor = Color3.fromArray(options.tintColor);
          stickerOptions.tintMode = sticker.tintMode;
        }
        resolve(operation3.createSticker(stickerOptions));
      });
      image5.crossOrigin = this._editor.getCrossOrigin();
      image5.src = this._editor.getUI().getAssetPath(url2);
    });
  }
  _deserializeFilterOperation(operation3) {
    const {options} = operation3;
    if (!this._filterManager.getFilterByIdentifier(options.identifier)) {
      log_default.warn("Deserializer", `Unknown filter \`${options.identifier}\``);
      return Promise.resolve();
    }
    return this._filterManager.instantiateFilterWithIdentifier(options.identifier).then((filter40) => {
      const filterOperation = this._editor.operations.getOrCreate("filter");
      if (!filterOperation)
        return;
      filterOperation.set({
        identifier: options.identifier,
        filter: filter40,
        intensity: options.intensity
      });
      return filterOperation;
    });
  }
  _deserializeFocusOperation(operation3) {
    const {options, type} = operation3.options;
    if (type !== "radial")
      return super._deserializeFocusOperation(operation3);
    const image5 = this._editor.getImage();
    const imageAspect = image5.width / image5.height;
    const {start, end, gradientRadius, blurRadius} = options;
    const radius = Vector236.fromObject(end).subtract(Vector236.fromObject(start)).multiply(imageAspect, 1).len();
    return Promise.resolve(this._editor.operations.getOrCreate("radial-focus", {
      position: Vector236.fromObject(start),
      radius,
      gradientRadius,
      blurRadius
    }));
  }
  _deserializeText(operation3, text) {
    const {options} = text;
    const {
      fontSize,
      lineHeight,
      fontIdentifier,
      alignment,
      rotation,
      maxWidth,
      color: color6,
      backgroundColor
    } = options;
    const fontLoader = new FontLoader(this._ui);
    let variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
    if (!variation) {
      variation = this._fontManager.getDefaultFont();
    } else {
      fontLoader.setFonts([variation.getFont()]);
    }
    return fontLoader.load().then(() => {
      const inputDimensions = operation3.getInputDimensions(false);
      const fixedMaxWidth = maxWidth * inputDimensions.min() / inputDimensions.x;
      const sprite7 = operation3.createText({
        fontSize,
        lineHeight,
        fontFamily: variation.getFontFamily(),
        fontWeight: variation.getFontWeight(),
        fontIdentifier: variation.getIdentifier(),
        alignment,
        rotation,
        maxWidth: fixedMaxWidth,
        text: options.text,
        color: Color3.fromArray(color6),
        backgroundColor: Color3.fromArray(backgroundColor),
        position: Vector236.fromObject(options.position)
      });
      sprite7._edited = true;
      return sprite7;
    });
  }
}
v200Deserializer.version = "2.0.0";

// engine/shared/serialization/2.0.0/serializer.js
class v200Serializer extends v101Serializer {
  _serializeSticker(operation3, sprite7) {
    const inputDimensions = operation3.getInputDimensions(false);
    const response = super._serializeSticker(operation3, sprite7);
    if (sprite7.getTintMode() !== "none") {
      response.options.tintColor = sprite7.serializeOption("tintColor", true);
    }
    response.options.dimensions = sprite7.getDimensions().clone().divide(inputDimensions.min()).toObject();
    response.options.identifier = response.options.name;
    delete response.options.name;
    return response;
  }
  _serializePath(path2) {
    const response = super._serializePath(path2);
    const brush3 = path2.getBrush();
    if (brush3.hasOption("hardness")) {
      response.hardness = brush3.getOption("hardness");
    }
    return response;
  }
  _serializeOperation(operation3, operations3) {
    if (operation3.constructor.identifier === "frame") {
      this._serializeFrameOperation(operation3, operations3);
      return null;
    }
    if (operation3.constructor.identifier === "overlay") {
      this._serializeOverlayOperation(operation3, operations3);
      return null;
    }
    return super._serializeOperation(operation3, operations3);
  }
  _serializeFrameOperation(operation3, operations3) {
    const spriteOperations = operations3.filter((o) => o.type === "sprite");
    let spriteOperation;
    if (spriteOperations.length) {
      spriteOperation = spriteOperations.pop();
    } else {
      spriteOperation = {
        type: "sprite",
        options: {
          sprites: []
        }
      };
      operations3.push(spriteOperation);
    }
    spriteOperation.options.sprites.push({
      type: "frame",
      options: this._getFrameOptions(operation3)
    });
  }
  _serializeOverlayOperation(operation3, operations3) {
    if (!operation3.getIdentifier())
      return;
    const spriteOperations = operations3.filter((o) => o.type === "sprite");
    let spriteOperation;
    if (spriteOperations.length) {
      spriteOperation = spriteOperations.pop();
    } else {
      spriteOperation = {
        type: "sprite",
        options: {
          sprites: []
        }
      };
      operations3.push(spriteOperation);
    }
    spriteOperation.options.sprites.push({
      type: "overlay",
      options: {
        identifier: operation3.getIdentifier(),
        intensity: operation3.getAlpha(),
        blendMode: blend_modes_default[operation3.getBlendMode()]
      }
    });
  }
  _getFrameOptions(operation3) {
    return {
      identifier: operation3.getFrame().identifier
    };
  }
  _serializeOrientationOperation(operation3) {
    const response = super._serializeOrientationOperation(operation3);
    if (response.options.rotation === 90 || response.options.rotation === 270) {
      response.options.flipHorizontally = !response.options.flipHorizontally;
      response.options.flipVertically = !response.options.flipVertically;
    }
    return response;
  }
  _serializeTransformOperation(operation3) {
    const {operations: operations3} = this._editor;
    if (operations3.exists("orientation")) {
      operation3 = operation3.clone();
      const orientationOperation = operations3.get("orientation");
      operation3.rotate(-orientationOperation.getRotation());
      if (orientationOperation.getFlipVertically()) {
        operation3.flip("vertical");
        operation3.setRotation(operation3.getRotation() * -1);
      }
      if (orientationOperation.getFlipHorizontally()) {
        operation3.flip("horizontal");
        operation3.setRotation(operation3.getRotation() * -1);
      }
    }
    const response = super._serializeTransformOperation(operation3);
    response.type = "transform";
    return response;
  }
  _serializeText(operation3, sprite7) {
    const response = super._serializeText(operation3, sprite7);
    const inputDimensions = operation3.getInputDimensions(false);
    response.options.fontIdentifier = sprite7.getFontIdentifier();
    response.options.maxWidth = response.options.maxWidth * inputDimensions.x / inputDimensions.min();
    delete response.options.fontFamily;
    return response;
  }
  _serializeFilterOperation(operation3) {
    const response = super._serializeFilterOperation(operation3);
    if (!response)
      return null;
    response.options.identifier = response.options.name;
    delete response.options.name;
    return response;
  }
  _serializeRadialFocusOperation(operation3) {
    const response = super._serializeRadialFocusOperation(operation3);
    const focusOptions = response.options.options;
    focusOptions.start = focusOptions.position;
    delete focusOptions.position;
    focusOptions.end = {
      x: focusOptions.start.x + focusOptions.radius,
      y: focusOptions.start.y
    };
    delete focusOptions.radius;
    return response;
  }
}
v200Serializer.version = "2.0.0";

// engine/shared/managers/text-design-manager.js
class TextDesignManager {
  constructor(ui, options = {}) {
    this._ui = ui;
    this._options = options;
    this._defaultLayouts = SDK.Operations.SpriteOperation.TextDesignSprite.Layouts;
    this._legacyLayouts = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts;
    this._layouts = [];
    this._init();
  }
  _init() {
    const {availableLayouts} = this._options;
    const allLayouts = __assign(__assign({}, this._defaultLayouts), this._legacyLayouts);
    this._layouts = Object.keys(allLayouts).map((k) => ({
      identifier: allLayouts[k].identifier,
      layout: allLayouts[k]
    }));
    if (availableLayouts) {
      availableLayouts.push(...Object.values(this._legacyLayouts).map((i) => i.identifier));
      this._layouts = this._layouts.filter((item) => availableLayouts.indexOf(item.identifier) >= 0);
    }
  }
  getLayoutByIdentifier(identifier) {
    const item = SDKUtils2.Array.find(this._layouts, (l) => l.identifier === identifier);
    return item && item.layout;
  }
  getLayouts() {
    return [...this._layouts];
  }
  getDefaultLayout() {
    return this.getLayouts()[0];
  }
}

// engine/shared/serialization/3.0.0/deserializer.js
let Brush3;
if (typeof SDK.Operations.SpriteOperation !== "undefined") {
  Brush3 = SDK.Operations.SpriteOperation.BrushSprite.Brush;
}
class v300Deserializer extends v200Deserializer {
  _deserializeSticker(operation3, sprite7) {
    const {SpriteOperation: SpriteOperation2} = SDK.Operations;
    const {options} = sprite7;
    const sticker = this._stickerManager.getStickerByIdentifier(options.identifier);
    if (!sticker) {
      log_default.warn("Deserializer", `Unknown sticker \`${options.identifier}\`. Skipping sprite.`);
      return Promise.resolve();
    }
    const {mediaBase} = sticker.images;
    const url2 = StickerManager.getURLForSticker(sticker, "base");
    const resolvedUrl = mediaBase.rawData ? mediaBase.uris[0] : this._editor.getUI().getAssetPath(url2);
    const inputDimensions = operation3.getInputDimensions(false);
    return image_loader_default.load(resolvedUrl).then((image5) => {
      const adjustments2 = SpriteOperation2.StickerSprite.prototype.availableOptions.adjustments.structure;
      const {rotation, flipHorizontally, flipVertically} = options;
      const stickerOptions = {
        identifier: options.identifier,
        image: image5,
        position: Vector236.fromObject(options.position),
        dimensions: Vector236.fromObject(options.dimensions).multiply(inputDimensions.min()),
        rotation: rotation || 0,
        flipHorizontally,
        flipVertically,
        resizeMode: sticker.resizeMode || "keepAspect",
        adjustments: {}
      };
      if (typeof options.adjustments !== "undefined") {
        ["brightness", "contrast", "saturation"].forEach((option) => {
          if (typeof options.adjustments[option] !== "undefined") {
            stickerOptions.adjustments[option] = options.adjustments[option] + adjustments2[option].default;
          }
        });
      }
      if (typeof options.tintMode !== "undefined" && typeof options.tintColor !== "undefined") {
        stickerOptions.tintColor = Color3.fromArray(options.tintColor.rgba);
        stickerOptions.tintMode = options.tintMode;
      } else if (typeof options.tintColor !== "undefined" && typeof sticker.tintMode !== "undefined") {
        stickerOptions.tintColor = Color3.fromArray(options.tintColor.rgba);
        stickerOptions.tintMode = sticker.tintMode;
      }
      if (typeof options.alpha !== "undefined") {
        stickerOptions.alpha = options.alpha;
      }
      return operation3.createSticker(stickerOptions);
    });
  }
  _deserializeTransformOperation(operationData) {
    return super._deserializeTransformOperation(operationData).then((operation3) => {
      if (!operation3)
        return;
      operation3._ratio = null;
      return operation3;
    });
  }
  _deserializeInputImage() {
    let {data, type, uri} = this._data.image;
    if (data && type) {
      uri = `data:${type};base64,${data}`;
    }
    if (uri) {
      return image_loader_default.load(uri).then((image5) => {
        this._editor.setImage(image5);
      });
    }
    return Promise.resolve();
  }
  _deserializeAdjustmentsOperation(operationData) {
    const {AdjustmentsOperation: AdjustmentsOperation2} = SDK.Operations;
    return super._deserializeAdjustmentsOperation(operationData).then((operation3) => {
      if (!operation3)
        return null;
      const {options} = operationData;
      const knownOptions = ["gamma", "whites", "blacks", "temperature"];
      const operationOptions = {};
      knownOptions.forEach((optionName) => {
        if (typeof options[optionName] === "undefined")
          return;
        const {
          minValue,
          midValue,
          maxValue
        } = AdjustmentsOperation2.prototype.availableOptions[optionName];
        let value = options[optionName];
        value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
        operationOptions[optionName] = value;
      });
      operation3.set(operationOptions);
      return operation3;
    });
  }
  _deserializeFocusOperation(operationData) {
    const {options} = operationData.options;
    switch (operationData.options.type) {
      case "radial":
        return super._deserializeFocusOperation(operationData);
      case "linear": {
        const {start, end, blurRadius} = options;
        return Promise.resolve(this._editor.operations.getOrCreate("linear-focus", {
          controlPoint1: Vector236.fromObject(start),
          controlPoint2: Vector236.fromObject(end),
          blurRadius
        }));
      }
      case "mirrored": {
        const {start, end, size, gradientSize, blurRadius} = options;
        return Promise.resolve(this._editor.operations.getOrCreate("mirrored-focus", {
          start: Vector236.fromObject(start),
          end: Vector236.fromObject(end),
          size,
          gradientSize,
          blurRadius
        }));
      }
      case "gaussian": {
        const {blurRadius} = options;
        return Promise.resolve(this._editor.operations.getOrCreate("blur", {
          blurRadius
        }));
      }
    }
  }
  _deserializeText(operation3, text) {
    const {options} = text;
    const {
      fontSize,
      lineHeight,
      fontIdentifier,
      alignment,
      rotation,
      maxWidth,
      color: color6,
      backgroundColor
    } = options;
    const fontLoader = this._ui.getFontLoader();
    let variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
    if (!variation) {
      variation = this._fontManager.getDefaultVariation();
    } else {
      fontLoader.setFonts([variation.getFont()]);
    }
    return fontLoader.load().then(() => {
      const inputDimensions = operation3.getInputDimensions(false);
      const fixedMaxWidth = maxWidth * inputDimensions.min() / inputDimensions.x;
      const sprite7 = operation3.createText({
        fontSize,
        lineHeight,
        fontFamily: variation.getFontFamily(),
        fontWeight: variation.getFontWeight(),
        fontIdentifier: variation.getIdentifier(),
        textMetrics: variation.getTextMetrics(),
        alignment,
        rotation,
        maxWidth: fixedMaxWidth,
        text: options.text,
        color: Color3.fromArray(color6.rgba),
        backgroundColor: Color3.fromArray(backgroundColor.rgba),
        position: Vector236.fromObject(options.position)
      });
      sprite7._edited = true;
      return sprite7;
    });
  }
  _createBrushForPath(path2) {
    const {identifier, color: color6, size, hardness} = path2.brush;
    const colorObject = Color3.fromArray(color6.rgba);
    const brushOptions = {
      color: colorObject,
      size
    };
    if (typeof hardness !== "undefined") {
      brushOptions.hardness = hardness;
    }
    let rawBrush = this._brushManager.getBrushByIdentifier(identifier);
    if (!rawBrush) {
      rawBrush = this._brushManager.getFirstBrush();
    }
    if (rawBrush.prototype && rawBrush.prototype instanceof Brush3) {
      const BrushClass2 = rawBrush;
      return new BrushClass2(brushOptions);
    }
    const _brush = SDKUtils2.extend({}, rawBrush);
    delete _brush.image;
    class BrushClass extends Brush3 {
    }
    BrushClass.identifier = rawBrush.identifier;
    return new BrushClass(SDKUtils2.extend({}, _brush, brushOptions));
  }
  _deserializeFrame(spriteOperation, frame2) {
    return super._deserializeFrame(spriteOperation, frame2).then(() => {
      const frameOperation = this._editor.operations.get("frame");
      const {size, alpha, tintColor} = frame2.options;
      const options = {};
      if (typeof size !== "undefined") {
        options.scale = size;
      }
      if (typeof alpha !== "undefined") {
        options.alpha = alpha;
      }
      if (typeof tintColor !== "undefined") {
        options.tintColor = Color3.fromArray(tintColor.rgba);
      }
      frameOperation.set(options);
    });
  }
  _deserializeTextDesign(operation3, sprite7) {
    const {options} = sprite7;
    const {
      position,
      rotation,
      flipHorizontally,
      flipVertically,
      text,
      color: color6,
      width,
      seed,
      inverted
    } = options;
    let {identifier} = options;
    if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignBlocksLight.identifier) {
      identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignBlocksLightV310.identifier;
    } else if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignSunshine.identifier) {
      identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignSunshineV310.identifier;
    }
    const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
    const fontManager = new FontManager(this._ui, {
      fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
      replaceFonts: true
    });
    const {AssetManager: AssetManager2} = operation3.constructor.TextDesignSprite;
    const fontLoader = this._ui.getFontLoader();
    const Layout = textDesignManager.getLayoutByIdentifier(identifier);
    const layout = new Layout();
    fontLoader.setFonts(fontManager.getFonts());
    AssetManager2.setFonts(__assign(__assign({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
    return fontLoader.load().then(() => {
      const images = layout.getImagePaths().map((path2) => ({
        path: path2,
        fullPath: this._ui.getAssetPath(path2),
        image: null
      }));
      return AssetManager2.loadImages(images).then(() => {
        layout.onImagesLoaded();
        return operation3.createTextDesign({
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color: Color3.fromArray(color6.rgba),
          width,
          seed,
          inverted,
          layout
        });
      });
    });
  }
}
v300Deserializer.version = "3.0.0";

// engine/shared/assets/transform-ratio.js
class TransformRatio extends configurable_default {
}
TransformRatio.prototype.availableOptions = {
  identifier: {type: OptionType.STRING, required: true},
  defaultName: {type: OptionType.STRING, required: true},
  ratio: {type: OptionType.ALL, required: false, default: null},
  selected: {type: OptionType.BOOLEAN, required: false},
  dimensions: {type: OptionType.VECTOR2, required: false},
  lockDimensions: {type: OptionType.BOOLEAN, required: false, default: null},
  forceDimensions: {type: OptionType.BOOLEAN, required: false, default: null}
};

// engine/shared/serialization/3.0.0/serializer.js
class v300Serializer extends v200Serializer {
  serialize(options = {}) {
    return super.serialize(options).then((data) => {
      data.meta = {
        platform: "html5",
        version: this._editor.getSDK().version,
        createdAt: SDKUtils2.ISODateString(new Date())
      };
      data.image = data.inputImage;
      delete data.inputImage;
      return data;
    });
  }
  _serializeSticker(operation3, sprite7) {
    const response = super._serializeSticker(operation3, sprite7);
    response.options.alpha = sprite7.getAlpha();
    if (response.options.tintColor) {
      response.options.tintColor = {
        rgba: response.options.tintColor
      };
    }
    return response;
  }
  _serializeText(operation3, sprite7) {
    const response = super._serializeText(operation3, sprite7);
    response.options.color = {
      rgba: response.options.color
    };
    response.options.backgroundColor = {
      rgba: response.options.backgroundColor
    };
    response.options.flipHorizontally = false;
    response.options.flipVertically = false;
    delete response.options.fontWeight;
    return response;
  }
  _serializePath(path2) {
    const response = super._serializePath(path2);
    delete response.hardness;
    delete response.size;
    delete response.color;
    const brush3 = path2.getBrush();
    response.brush = brush3.serializeOptions(["identifier", "size", "color"], true);
    if (typeof response.brush.identifier === "undefined") {
      delete response.brush.identifier;
    }
    response.brush.color = {
      rgba: response.brush.color
    };
    const hardness = brush3.getOption("hardness");
    if (hardness !== "undefined") {
      response.brush.hardness = hardness;
    }
    return response;
  }
  _serializeFrameOperation(operation3, operations3) {
    super._serializeFrameOperation(operation3, operations3);
    const spriteOperations = operations3.filter((o) => o.type === "sprite");
    let spriteOperation;
    if (spriteOperations.length) {
      spriteOperation = spriteOperations.pop();
      const frame2 = spriteOperation.options.sprites.filter((s) => s.type === "frame")[0];
      const tintColor = operation3.getTintColor();
      if (!tintColor.equals(new Color3(1, 1, 1, 0))) {
        frame2.options.tintColor = {
          rgba: operation3.serializeOption("tintColor", true)
        };
      }
      const options = operation3.serializeOptions(["scale", "alpha"], true);
      frame2.options = SDKUtils2.extend(frame2.options, options);
      frame2.options.size = frame2.options.scale;
      delete frame2.options.scale;
    }
  }
  _serializeTransformOperation(operation3) {
    const response = super._serializeTransformOperation(operation3);
    if (operation3._ratio) {
      let identifier;
      if (operation3._ratio instanceof TransformRatio) {
        identifier = operation3._ratio.getIdentifier();
      } else {
        identifier = operation3._ratio.identifier;
      }
      response.options.meta = {
        identifier
      };
    }
    delete response.options.scale;
    return response;
  }
  _serializeAdjustmentsOperation(operation3) {
    const response = super._serializeAdjustmentsOperation(operation3);
    const optionNames = ["gamma", "whites", "blacks", "temperature"];
    const {availableOptions} = operation3;
    const options = {};
    optionNames.forEach((optionName) => {
      const option = availableOptions[optionName];
      const value = operation3.getOption(optionName);
      const {minValue, midValue, maxValue} = option;
      options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
    });
    response.options = __assign(__assign({}, response.options), options);
    return response;
  }
  _serializeOperation(operation3, operations3) {
    switch (operation3.constructor.identifier) {
      case "mirrored-focus":
        return this._serializeMirroredFocusOperation(operation3);
      case "linear-focus":
        return this._serializeLinearFocusOperation(operation3);
      case "blur":
        return this._serializeBlurOperation(operation3);
      default:
        return super._serializeOperation(operation3, operations3);
    }
  }
  _serializeMirroredFocusOperation(operation3) {
    return {
      type: "focus",
      options: {
        type: "mirrored",
        options: operation3.serializeOptions(["start", "end", "blurRadius", "size", "gradientSize"], true)
      }
    };
  }
  _serializeLinearFocusOperation(operation3) {
    const options = operation3.serializeOptions(["controlPoint1", "controlPoint2", "blurRadius"], true);
    options.start = options.controlPoint1;
    delete options.controlPoint1;
    options.end = options.controlPoint2;
    delete options.controlPoint2;
    return {
      type: "focus",
      options: {
        type: "linear",
        options
      }
    };
  }
  _serializeBlurOperation(operation3) {
    return {
      type: "focus",
      options: {
        type: "gaussian",
        options: operation3.serializeOptions(["blurRadius"], true)
      }
    };
  }
}
v300Serializer.version = "3.0.0";

// engine/shared/serialization/3.1.0/deserializer.js
class v310Deserializer extends v300Deserializer {
  _deserializeTextDesign(operation3, sprite7) {
    const {options} = sprite7;
    const {
      position,
      rotation,
      flipHorizontally,
      flipVertically,
      text,
      color: color6,
      width,
      seed,
      inverted
    } = options;
    let {identifier} = options;
    if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignBlocksLight.identifier) {
      identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignBlocksLightV310.identifier;
    } else if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignSunshine.identifier) {
      identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignSunshineV310.identifier;
    }
    const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
    const fontManager = new FontManager(this._ui, {
      fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
      replaceFonts: true
    });
    const {AssetManager: AssetManager2} = operation3.constructor.TextDesignSprite;
    const fontLoader = this._ui.getFontLoader();
    const Layout = textDesignManager.getLayoutByIdentifier(identifier);
    const layout = new Layout();
    fontLoader.setFonts(fontManager.getFonts());
    AssetManager2.setFonts(__assign(__assign({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
    return fontLoader.load().then(() => {
      const images = layout.getImagePaths().map((path2) => ({
        path: path2,
        fullPath: this._ui.getAssetPath(path2),
        image: null
      }));
      return AssetManager2.loadImages(images).then(() => {
        layout.onImagesLoaded();
        return operation3.createTextDesign({
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color: Color3.fromArray(color6.rgba),
          width,
          seed,
          inverted,
          layout
        });
      });
    });
  }
}
v310Deserializer.version = "3.1.0";

// engine/shared/serialization/3.1.0/serializer.js
class v310Serializer extends v300Serializer {
  _serializeTextDesign(operation3, sprite7) {
    const options = sprite7.serializeOptions([
      "position",
      "rotation",
      "flipHorizontally",
      "flipVertically",
      "text",
      "color",
      "width",
      "seed",
      "inverted"
    ], true);
    options.color = {
      rgba: options.color
    };
    const layout = sprite7.getLayout();
    if (layout) {
      options.identifier = layout.constructor.identifier;
    }
    return {
      type: "textdesign",
      options
    };
  }
}
v310Serializer.version = "3.1.0";

// engine/shared/serialization/3.2.0/deserializer.js
class v320Deserializer extends v310Deserializer {
  _deserializeTextDesign(operation3, sprite7) {
    const {options} = sprite7;
    const {
      position,
      rotation,
      flipHorizontally,
      flipVertically,
      text,
      color: color6,
      width,
      seed,
      inverted
    } = options;
    let {identifier} = options;
    if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignBlocksLight.identifier) {
      identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignBlocksLightV310.identifier;
    } else if (identifier === SDK.Operations.SpriteOperation.TextDesignSprite.Layouts.TextDesignSunshine.identifier) {
      identifier = SDK.Operations.SpriteOperation.TextDesignSprite.LegacyLayouts.TextDesignSunshineV310.identifier;
    }
    const padding = "padding" in options ? options.padding / width : -1;
    const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
    const fontManager = new FontManager(this._ui, {
      fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
      replaceFonts: true
    });
    const {AssetManager: AssetManager2} = operation3.constructor.TextDesignSprite;
    const fontLoader = this._ui.getFontLoader();
    const Layout = textDesignManager.getLayoutByIdentifier(identifier);
    const layout = new Layout();
    fontLoader.setFonts(fontManager.getFonts());
    AssetManager2.setFonts(__assign(__assign({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
    return fontLoader.load().then(() => {
      const images = layout.getImagePaths().map((path2) => ({
        path: path2,
        fullPath: this._ui.getAssetPath(path2),
        image: null
      }));
      return AssetManager2.loadImages(images).then(() => {
        layout.onImagesLoaded();
        return operation3.createTextDesign({
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color: Color3.fromArray(color6.rgba),
          width,
          seed,
          inverted,
          layout,
          padding
        });
      });
    });
  }
}
v320Deserializer.version = "3.2.0";

// engine/shared/serialization/3.2.0/serializer.js
class v320Serializer extends v310Serializer {
  _serializeTextDesign(operation3, sprite7) {
    const options = sprite7.serializeOptions([
      "position",
      "rotation",
      "flipHorizontally",
      "flipVertically",
      "text",
      "color",
      "width",
      "seed",
      "inverted",
      "padding"
    ], true);
    options.color = {
      rgba: options.color
    };
    const layout = sprite7.getLayout();
    if (layout) {
      options.identifier = layout.constructor.identifier;
    }
    options.padding *= options.width;
    return {
      type: "textdesign",
      options
    };
  }
}
v320Serializer.version = "3.2.0";

// engine/shared/serialization/3.4.0/deserializer.js
class v340Deserializer extends v320Deserializer {
  _deserializeOperation(operation3) {
    return super._deserializeOperation(operation3);
  }
  _deserializeOrientationOperation(operation3) {
    const {options} = operation3;
    const orientationOperation = this._editor.operations.getOrCreate("orientation");
    if (!orientationOperation)
      return Promise.resolve();
    orientationOperation.set(options);
    return Promise.resolve(orientationOperation);
  }
}
v340Deserializer.version = "3.4.0";

// engine/shared/serialization/3.4.0/serializer.js
class v340Serializer extends v320Serializer {
  _serializeOperation(operation3, operations3) {
    switch (operation3.constructor.identifier) {
      case "artfilter":
        return this._serializeStyle(operation3);
      default:
        return super._serializeOperation(operation3, operations3);
    }
  }
  _serializeOrientationOperation(operation3) {
    return {
      type: "orientation",
      options: operation3.serializeOptions(["flipVertically", "flipHorizontally", "rotation"], true)
    };
  }
  _serializeStyle(operation3) {
    const {identifier, intensity, blendMode} = operation3.getOptions();
    const {
      tileEdgeLength,
      overlappingFactor
    } = operation3.getStyleTransferModel().getOptions();
    return {
      type: "artFilter",
      options: {
        identifier,
        intensity,
        blendMode: blend_modes_default[blendMode],
        tileEdgeLength,
        overlappingFactor
      }
    };
  }
}
v340Serializer.version = "3.4.0";

// engine/shared/serialization/3.5.0/deserializer.js
class v350Deserializer extends v340Deserializer {
  _deserializeTextDesign(operation3, sprite7) {
    const {options} = sprite7;
    const {
      position,
      rotation,
      flipHorizontally,
      flipVertically,
      text,
      color: color6,
      width,
      seed,
      inverted,
      identifier
    } = options;
    const padding = "padding" in options ? options.padding / width : -1;
    const textDesignManager = new TextDesignManager(this._ui, this._getOptions("textdesign"));
    const fontManager = new FontManager(this._ui, {
      fonts: constants_default3.DEFAULTS.TEXT_DESIGN_FONTS,
      replaceFonts: true
    });
    const {AssetManager: AssetManager2} = operation3.constructor.TextDesignSprite;
    const fontLoader = this._ui.getFontLoader();
    const Layout = textDesignManager.getLayoutByIdentifier(identifier);
    const layout = new Layout();
    fontLoader.setFonts(fontManager.getFonts());
    AssetManager2.setFonts(__assign(__assign({}, AssetManager2.getFonts()), fontManager.getVariationsByIdentifier()));
    return fontLoader.load().then(() => {
      const images = layout.getImagePaths().map((path2) => ({
        path: path2,
        fullPath: this._ui.getAssetPath(path2),
        image: null
      }));
      return AssetManager2.loadImages(images).then(() => {
        layout.onImagesLoaded();
        return operation3.createTextDesign({
          position,
          rotation,
          flipHorizontally,
          flipVertically,
          text,
          color: Color3.fromArray(color6.rgba),
          width,
          seed,
          inverted,
          layout,
          padding
        });
      });
    });
  }
}
v350Deserializer.version = "3.5.0";

// engine/shared/serialization/3.5.0/serializer.js
class v350Serializer extends v340Serializer {
}
v350Serializer.version = "3.5.0";

// engine/shared/serialization/3.6.0/deserializer.js
class v360Deserializer extends v350Deserializer {
  _deserializeAdjustmentsOperation(operationData) {
    const {AdjustmentsOperation: AdjustmentsOperation2} = SDK.Operations;
    return super._deserializeAdjustmentsOperation(operationData).then((operation3) => {
      if (!operation3)
        return null;
      const {options} = operationData;
      const optionName = "sharpness";
      const operationOptions = {};
      if (typeof options[optionName] === "undefined")
        return;
      const {
        minValue,
        midValue,
        maxValue
      } = AdjustmentsOperation2.prototype.availableOptions[optionName];
      let value = options[optionName];
      value = value < 0 ? midValue + (midValue - minValue) * value : midValue + (maxValue - midValue) * value;
      operationOptions[optionName] = value;
      operation3.set(operationOptions);
      return operation3;
    });
  }
}
v360Deserializer.version = "3.6.0";

// engine/shared/serialization/3.6.0/serializer.js
class v360Serializer extends v350Serializer {
  _serializeAdjustmentsOperation(operation3) {
    const response = super._serializeAdjustmentsOperation(operation3);
    const optionName = "sharpness";
    const {availableOptions} = operation3;
    const options = {};
    const option = availableOptions[optionName];
    const value = operation3.getOption(optionName);
    const {minValue, midValue, maxValue} = option;
    options[optionName] = value <= midValue ? (value - minValue) / (midValue - minValue) - 1 : (value - midValue) / (maxValue - midValue);
    response.options = __assign(__assign({}, response.options), options);
    return response;
  }
}
v360Serializer.version = "3.6.0";

// engine/shared/serialization/3.7.0/deserializer.js
class v370Deserializer extends v360Deserializer {
  deserialize() {
    return this._validateVersion().then(() => this._deserializeAssetLibrary()).then(() => this._deserializeInputImage()).then(() => this._deserializeOperations());
  }
  _deserializeAssetLibrary() {
    return new Promise((resolve, reject) => {
      const data = this._data;
      if (!data.assetLibrary) {
        resolve();
        return;
      }
      const {assets} = data.assetLibrary;
      const promises = [];
      for (const assetType in assets) {
        promises.push(this._deserializeCustomAssets(assetType, assets[assetType]));
      }
      return Promise.all(promises).then(() => {
        resolve();
      }).catch((err) => {
        console.error(err);
        reject(err);
      });
    });
  }
  _deserializeCustomAssets(type, data) {
    switch (type) {
      case "stickers":
        return this._deserializeCustomStickerAssets(data);
      default:
        return Promise.reject(new Error(`Unknown asset type: ${type}`));
    }
  }
  _deserializeCustomStickerAssets(serializedStickers) {
    let defaultTintMode = "none";
    const editorOptions = this._editor.getOptions().editor;
    if (editorOptions && editorOptions.controlsOptions && editorOptions.controlsOptions.sticker) {
      defaultTintMode = editorOptions.controlsOptions.sticker.customStickerTintMode || "none";
    }
    const promises = serializedStickers.map((serializedSticker) => {
      return new Promise((resolve, reject) => {
        const {identifier, raster} = serializedSticker;
        const isSVG = serializedSticker.svg !== void 0;
        let rasterBase64 = `data:${raster.type};base64,${raster.data}`;
        let image5 = new image_default();
        image5.onload = () => {
          const sdk14 = this._editor.getSDK();
          image5 = sdk14.correctExifOrientation(image5);
          if (image5.toDataURL) {
            rasterBase64 = image5.toDataURL();
          }
          let thumb = {data: "", width: 1, height: 1};
          if (process.env.REACT_APP_BROWSER) {
            thumb = this._stickerManager.renderStickerThumbnailFromImage(image5);
          }
          const customSticker = {
            identifier,
            defaultName: serializedSticker.name || "",
            tintMode: defaultTintMode,
            images: {
              mediaBase: {
                uris: [rasterBase64],
                rawData: true,
                isSVG,
                width: image5.width,
                height: image5.height
              },
              mediaThumb: {
                uris: [thumb.data],
                rawData: true,
                width: thumb.width,
                height: thumb.height
              }
            }
          };
          if (isSVG) {
            const svgBase64 = `data:image/svg+xml;base64,${serializedSticker.svg.data}`;
            customSticker.images.mediaBase.uris.push(svgBase64);
          }
          resolve(customSticker);
        };
        image5.onerror = () => {
          reject(new Error(`Invalid base64 data: ${rasterBase64}`));
        };
        image5.src = rasterBase64;
      });
    });
    return Promise.all(promises).then((stickers) => {
      const assetsLibrary = this._editor.getDynamicAssetsLibrary();
      assetsLibrary.setAssets("sticker", stickers);
      this._stickerManager.reload();
    });
  }
}
v370Deserializer.version = "3.7.0";

// engine/shared/serialization/3.7.0/serializer.js
class v370Serializer extends v360Serializer {
  serialize(options = {}) {
    return super.serialize(options).then((data) => {
      return this._serializeAssetLibrary(data).then((data2) => {
        return data2;
      });
    });
  }
  _serializeAssetLibrary(data) {
    if (!this._editor.getDynamicAssetsLibrary) {
      return Promise.resolve(data);
    }
    const assetLibrary = this._editor.getDynamicAssetsLibrary();
    const serializedStickers = this._serializeCustomStickerAssets(data, assetLibrary);
    if (serializedStickers.length === 0) {
      return Promise.resolve(data);
    }
    data.assetLibrary = {
      assets: {
        stickers: serializedStickers
      }
    };
    return Promise.resolve(data);
  }
  _serializeCustomStickerAssets(data, assetLibrary) {
    const customStickers = assetLibrary.getAssets("sticker");
    if (customStickers.length === 0) {
      return [];
    }
    const usedStickerIDs = data.operations.filter((operation3) => {
      return operation3.type === "sprite";
    }).flatMap((operation3) => operation3.options.sprites).filter((sprite7) => sprite7.type === "sticker").map((sprite7) => sprite7.options.identifier);
    const usedIDMap = {};
    usedStickerIDs.forEach((id) => {
      usedIDMap[id] = true;
    });
    const usedCustomStickers = customStickers.filter((sticker) => {
      return usedIDMap[sticker.identifier];
    });
    return usedCustomStickers.map((sticker) => {
      const {identifier, defaultName: name, images} = sticker;
      const data2 = images.mediaBase.uris[0];
      const {isSVG} = images.mediaBase;
      const regex = /^data:(image\/(jpeg|png));base64,(.*)$/g;
      const matches = regex.exec(data2);
      const rasterType = matches[1];
      const onlyBase64 = matches[3];
      const serialized = {
        identifier,
        name,
        raster: {
          type: rasterType,
          data: onlyBase64
        }
      };
      if (name) {
        serialized.name = name;
      }
      if (isSVG) {
        serialized.svg = {
          data: images.mediaBase.uris[1].replace(/^data:image\/svg\+xml;base64,/g, "")
        };
      }
      return serialized;
    });
  }
}
v370Serializer.version = "3.7.0";

// engine/shared/serialization/3.8.0/deserializer.js
class v380Deserializer extends v370Deserializer {
}
v380Deserializer.version = "3.8.0";

// engine/shared/serialization/3.8.0/serializer.js
class v380Serializer extends v370Serializer {
  _serializeSticker(operation3, sprite7) {
    const response = super._serializeSticker(operation3, sprite7);
    response.options.tintMode = sprite7.getTintMode();
    return response;
  }
}
v380Serializer.version = "3.8.0";

// engine/shared/serialization/3.9.0/deserializer.js
class v390Deserializer extends v380Deserializer {
  _deserializeTransformOperation(operationData) {
    return super._deserializeCropOperation(operationData).then((operation3) => {
      if (!operation3)
        return;
      const orientationData = SDKUtils2.Array.find(this._data.operations, (op) => op.type === "orientation");
      if (orientationData) {
        const {options} = orientationData;
        operation3.rotate(options.rotation);
        if (options.flipHorizontally) {
          operation3.flip("horizontal");
          operation3.setRotation(operation3.getRotation() * -1);
        }
        if (options.flipVertically) {
          operation3.flip("vertical");
          operation3.setRotation(operation3.getRotation() * -1);
        }
      }
      operation3._ratio = null;
      return operation3;
    });
  }
  _deserializeText(operation3, text) {
    const {options} = text;
    const {
      fontSize,
      lineHeight,
      fontIdentifier,
      alignment,
      rotation,
      maxWidth,
      color: color6,
      backgroundColor
    } = options;
    const fontLoader = this._ui.getFontLoader();
    let variation = this._fontManager.getVariationByIdentifier(fontIdentifier);
    if (!variation) {
      variation = this._fontManager.getDefaultVariation();
    } else {
      fontLoader.setFonts([variation.getFont()]);
    }
    return fontLoader.load().then(() => {
      const inputDimensions = operation3.getInputDimensions(false);
      const minSide = inputDimensions.min();
      const width = inputDimensions.x;
      const height = inputDimensions.y;
      const internalMaxWidth = maxWidth * minSide / width;
      const internalFont = fontSize * minSide / height;
      const sprite7 = operation3.createText({
        fontSize: internalFont,
        lineHeight,
        fontFamily: variation.getFontFamily(),
        fontWeight: variation.getFontWeight(),
        fontIdentifier: variation.getIdentifier(),
        textMetrics: variation.getTextMetrics(),
        alignment,
        rotation,
        maxWidth: internalMaxWidth,
        text: options.text,
        color: Color3.fromArray(color6.rgba),
        backgroundColor: Color3.fromArray(backgroundColor.rgba),
        position: Vector236.fromObject(options.position)
      });
      sprite7._edited = true;
      return sprite7;
    });
  }
}
v390Deserializer.version = "3.9.0";

// engine/shared/serialization/3.9.0/serializer.js
const TWICE_PI3 = Math.PI * 2;
class v390Serializer extends v380Serializer {
  _serializeTransformOperation(operation3) {
    const {operations: operations3} = this._editor;
    if (operations3.exists("orientation")) {
      operation3 = operation3.clone();
      const orientationOperation = operations3.get("orientation");
      if (orientationOperation.getFlipVertically()) {
        operation3.flip("vertical");
        operation3.setRotation(operation3.getRotation() * -1);
      }
      if (orientationOperation.getFlipHorizontally()) {
        operation3.flip("horizontal");
        operation3.setRotation(operation3.getRotation() * -1);
      }
      operation3.rotate(-orientationOperation.getRotation());
    }
    const options = operation3.serializeOptions(["start", "end", "rotation", "textureScale"], true);
    options.rotation = (options.rotation + TWICE_PI3) % TWICE_PI3;
    if (options.textureScale !== 1) {
      options.dimensions = operation3.getNewDimensions(operation3.getInputDimensions(false));
    }
    delete options.textureScale;
    const response = {type: "transform", options};
    if (operation3._ratio) {
      let identifier;
      if (operation3._ratio instanceof TransformRatio) {
        identifier = operation3._ratio.getIdentifier();
      } else {
        identifier = operation3._ratio.identifier;
      }
      response.options.meta = {
        identifier
      };
    }
    delete response.options.scale;
    return response;
  }
  _serializeText(operation3, sprite7) {
    const inputDimensions = operation3.getInputDimensions(false);
    const response = super._serializeText(operation3, sprite7);
    response.options.fontSize = response.options.fontSize * inputDimensions.y / inputDimensions.min();
    return response;
  }
}
v390Serializer.version = "3.9.0";

// engine/server/lib/editor.js
class Editor extends EventEmitter4 {
  constructor(ui, options, mediator, shallow = false) {
    super();
    this._ui = ui;
    this._options = options;
    this._mediator = mediator;
    this._shallow = shallow;
    this._initFonts();
    if (!shallow) {
      this._initSDK();
      this.operations = new EditorOperations(this, this._sdk, this._mediator);
      this._initSerializers();
    }
    this._dynamicAssetsLibrary = new asset_library_default();
  }
  _initFonts() {
    const options = SDKUtils4.defaults(this._options.editor.controlsOptions.text, {
      additionalFonts: [],
      replaceFonts: false,
      availableVariations: null
    });
    this._fontManager = new FontManager(this._ui, options);
    const fonts2 = this._fontManager.getFonts();
    const fontLoader = this._ui.getFontLoader();
    fontLoader.setFonts(fonts2);
    fontLoader.load();
  }
  setImage(image5 = this._options.editor.image, resetEditor = true) {
    if (resetEditor) {
      this.reset();
    }
    let exif4 = null;
    exif4 = this._sdk.parseExif(image5);
    this._setImage(image5, exif4);
    this._initWatermark();
  }
  _initWatermark() {
    if (this._options.editor.watermarkImage) {
      this._watermarkOperation = this.operations.getOrCreate("watermark", {
        image: this._options.editor.watermarkImage
      });
    }
  }
  _initSDK() {
    const {
      logLevel,
      displayWelcomeMessage,
      debug,
      license,
      crossOrigin
    } = this._options;
    const {
      smoothDownscaling,
      smoothUpscaling,
      preferredRenderer,
      pixelRatio,
      transparent,
      clearColor
    } = this._options.editor;
    let clearColorInstance;
    if (Array.isArray(clearColor)) {
      clearColorInstance = Color4.fromArray(clearColor);
    } else if (typeof clearColor === "string") {
      clearColorInstance = Color4.fromHex(clearColor);
    } else if (clearColor instanceof Color4) {
      clearColorInstance = clearColor.clone();
    }
    const rendererOptions = {
      logLevel,
      debug,
      displayWelcomeMessage,
      pixelRatio,
      smoothDownscaling,
      smoothUpscaling,
      transparent,
      crossOrigin,
      clearColor: clearColorInstance,
      license
    };
    this._sdk = new SDK2(preferredRenderer, rendererOptions);
  }
  getMaxMegapixels() {
    const {maxMegaPixels} = this._options.editor;
    return maxMegaPixels;
  }
  getCrossOrigin() {
    return SDKUtils4.getCrossOriginValue(this._options.crossOrigin || "anonymous");
  }
  getOutputDimensions(incorporateSpriteScale = false) {
    return this._sdk.getOutputDimensions(incorporateSpriteScale);
  }
  getOutputTextureDimensions(incorporateSpriteScale = false) {
    return this._sdk.getOutputTextureDimensions(incorporateSpriteScale);
  }
  getFinalDimensions(incorporateSpriteScale = false) {
    return this._sdk.getFinalDimensions(incorporateSpriteScale);
  }
  _setImage(image5 = this._options.editor.image, exif4 = null) {
    this._sdk.setAllOperationsToDirty();
    this._options.editor.image = image5;
    this._sdk.setImage(image5, exif4);
  }
  _ensureImageIsResized() {
    const inputImage = this._sdk.getImage();
    const renderer = this._sdk.getRenderer();
    const maxMegaPixels = this.getMaxMegapixels();
    const maxPixels = maxMegaPixels ? maxMegaPixels * 1e6 : null;
    const maxDimensions = renderer.getMaxDimensions();
    const imageResizer = new ImageResizer(inputImage, maxPixels, maxDimensions);
    if (!this._resizedImage && imageResizer.needsResize()) {
      return imageResizer.resize().then(({canvas: canvas9, dimensions, reason}) => {
        this._resizedImage = canvas9;
        this._sdk.setImage(canvas9);
        return canvas9;
      });
    }
    return Promise3.resolve(inputImage);
  }
  export(download = false, options = {}) {
    if (this._watermarkOperation) {
      this._watermarkOperation.setEnabled(false);
    }
    this._sdk.setAllOperationsToDirty();
    return this._ensureImageIsResized().then((image5) => {
      const exportOptions = __assign(__assign({}, this._options.editor.export), options);
      const exporter2 = new Exporter(this._sdk, exportOptions, false);
      return exporter2.export().then((output) => {
        this.emit("export", output);
        this._mediator.emit(constants_default4.EVENTS.EXPORT, output, this);
        if (this._watermarkOperation) {
          this._watermarkOperation.setEnabled(true);
          this._sdk.render();
        }
        this._sdk.setAllOperationsToDirty();
        return output;
      });
    });
  }
  broadcastTransform(transformOperation, options) {
    const transformChange = new SDK2.Operations.TransformOperation.TransformChange(transformOperation, options);
    const transformableOperations = [
      "sprite",
      "selective-blur",
      "radial-focus",
      "mirrored-focus",
      "linear-focus",
      "blur"
    ];
    transformableOperations.forEach((identifier) => {
      const operation3 = this.operations.get(identifier);
      if (!operation3) {
        return;
      }
      operation3.transform(transformChange);
    });
  }
  broadcastFlip(direction) {
    const flippableOperations = [
      "mirrored-focus",
      "radial-focus",
      "linear-focus",
      "sprite",
      "selective-blur"
    ];
    flippableOperations.forEach((identifier) => {
      const operation3 = this.operations.get(identifier);
      if (!operation3) {
        return;
      }
      operation3.flip(direction);
    });
  }
  broadcastRotate(degrees) {
    const flippableOperations = [
      "transform",
      "mirrored-focus",
      "linear-focus",
      "radial-focus",
      "sprite",
      "selective-blur"
    ];
    flippableOperations.forEach((identifier) => {
      const operation3 = this.operations.get(identifier);
      if (!operation3) {
        return;
      }
      operation3.rotate(degrees);
    });
  }
  _initSerializers() {
    this._serializers = {
      "1.0.0": require__().default,
      "1.0.1": require__2().default,
      "2.0.0": require__3().default,
      "3.0.0": require__4().default,
      "3.1.0": require__5().default,
      "3.2.0": require__6().default,
      "3.4.0": require__7().default,
      "3.5.0": require__8().default,
      "3.6.0": require__9().default,
      "3.7.0": require__10().default,
      "3.8.0": require__11().default,
      "3.9.0": require__12().default
    };
  }
  serialize(options = {}, version = "3.9.0") {
    const Serializer = this._serializers[version];
    if (!Serializer) {
      return Promise3.reject(new Error(`No serializer for version ${version} found.`));
    }
    const serializer12 = new Serializer(this);
    return serializer12.serialize(options);
  }
  deserialize(data) {
    const Serializer = this._serializers[data.version];
    if (!Serializer) {
      return Promise3.reject(new Error(`No serializer for version ${data.version} found.`));
    }
    const serializer12 = new Serializer(this);
    return serializer12.deserialize(data);
  }
  reset() {
    this._sdk.reset();
    this.operations.reset();
  }
  dispose() {
    this.stop();
    this._sdk.dispose();
  }
  getRenderer() {
    return this._sdk.getRenderer();
  }
  getSDK() {
    return this._sdk;
  }
  getInputDimensions() {
    return this._sdk.getInputDimensions();
  }
  getImage() {
    return this._options.editor.image;
  }
  getOptions() {
    return this._options;
  }
  getUI() {
    return this._ui;
  }
  getMediator() {
    return this._mediator;
  }
  getDynamicAssetsLibrary() {
    return this._dynamicAssetsLibrary;
  }
}
var editor_default = Editor;

// engine/server/lib/font-loader/loaders/base-font-loader.js
class BaseFontLoader2 {
  constructor(ui) {
    this._ui = ui;
    this._fonts = [];
  }
  add(variation) {
    this._fonts.push(variation);
  }
  load() {
    return Promise.resolve();
  }
  dispose() {
  }
}

// engine/server/lib/font-loader/loaders/file-fonts-loader.js
const canvas8 = __toModule(require("canvas"));
class FileFontLoader2 extends BaseFontLoader2 {
  load() {
    this._fonts.forEach((variation) => {
      const fontPath = this._ui.getAssetPath(variation.getFilePath(), false, true);
      canvas8.registerFont(fontPath, {
        family: variation.getFont().getFontFamily(),
        weight: variation.getFontWeight(),
        style: variation.getFontStyle()
      });
    });
    return super.load();
  }
}

// engine/server/lib/font-loader/index.js
class FontLoader2 {
  constructor(ui, fonts2) {
    this._ui = ui;
    this._fonts = fonts2;
    this._loadedFonts = [];
  }
  setFonts(fonts2) {
    this._fonts = fonts2;
  }
  needsToLoad() {
    for (let i = 0; i < this._fonts.length; i++) {
      let provider;
      this._fonts[i].getVariations().forEach((variation) => {
        provider = provider || variation.getProvider();
      });
      if (!provider)
        continue;
      return true;
    }
  }
  fontLoaded(font2) {
    const identifier = font2.getFontFamily();
    return this._loadedFonts.indexOf(identifier) !== -1;
  }
  setFontLoaded(font2) {
    if (!this.fontLoaded(font2)) {
      const identifier = font2.getFontFamily();
      this._loadedFonts.push(identifier);
    }
  }
  load() {
    const fonts2 = this._fonts;
    const loaders = {
      file: new FileFontLoader2(this._ui)
    };
    const disposeLoaders = () => {
      for (const identifier in loaders) {
        const loader = loaders[identifier];
        loader.dispose();
      }
    };
    fonts2.filter((font2) => !this.fontLoaded(font2)).forEach((font2) => {
      font2.getVariations().forEach((variation) => {
        const provider = variation.getProvider();
        if (!provider)
          return;
        const loader = loaders[provider];
        if (!loader)
          return log_default.warn(`No font loader for provider \`${provider}\` found.`);
        loader.add(variation);
      });
    });
    const promises = [];
    for (const name in loaders) {
      promises.push(loaders[name].load());
    }
    return Promise.all(promises).then(() => {
      disposeLoaders();
      fonts2.forEach((font2) => {
        this.setFontLoaded(font2);
      });
    }).catch((e) => {
      disposeLoaders();
      throw e;
    });
  }
}

// engine/server/index.js
__export(exports, {
  default: () => server_default
});
const bd3 = (str) => SDKUtils2.byteArrayToString(Base643.decode(str));
class Server extends EventEmitter3 {
  constructor(options = {}) {
    super();
    this._mediator = new EventEmitter3();
    this._fontLoader = new FontLoader2(this);
    this._options = options;
    this._initOptions();
    this._initEvents();
    this._disposed = false;
    this._editor = new editor_default(this, this._options, this._mediator);
    if (this._options.editor.image) {
      this._editor.setImage(this._options.editor.image);
    }
    log_default.setLevel(this._options.logLevel);
    this._v();
  }
  export(...args) {
    return this._editor.export(...args);
  }
  serialize(...args) {
    return this._editor.serialize(...args);
  }
  deserialize(data) {
    return this._editor.deserialize(data);
  }
  getEditor() {
    return this._editor;
  }
  _initOptions() {
    this._options = SDKUtils2.defaults(this._options, {
      logLevel: "warn",
      crossOrigin: "Anonymous",
      editor: {},
      assets: {},
      responsive: false,
      preloader: true
    });
    this._options.editor = SDKUtils2.defaults(this._options.editor || {}, {
      preferredRenderer: "webgl",
      displayResizeMessage: true,
      controlsOptions: {},
      operationsOrder: [
        "exif-orientation",
        "orientation",
        "transform",
        "filter",
        "adjustments",
        "radial-focus",
        "mirrored-focus",
        "linear-focus",
        "blur",
        "selective-blur",
        "overlay",
        "sprite",
        "frame",
        "watermark"
      ],
      maxMegaPixels: null
    });
    this._options.editor.export = SDKUtils2.defaults(this._options.editor.export || {}, {
      format: "image/png",
      type: RenderType3.IMAGE,
      download: true,
      fileBasename: "photoeditorsdk-export",
      quality: 0.8
    });
    this._options.assets = SDKUtils2.defaults(this._options.assets || {}, {
      baseUrl: process.cwd(),
      resolver: null
    });
  }
  _v() {
    if (!this[bd3("X29wdGlvbnM=")][bd3("bGljZW5zZQ==")]) {
      log_default.error(bd3("TGljZW5zaW5n"), bd3("Tm8gYGxpY2Vuc2VgIG9wdGlvbiBnaXZlbg=="));
      log_default.error(bd3("TGljZW5zaW5n"), bd3("SW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIGxpY2Vuc2UgeWV0LCBwbGVhc2UgY29udGFjdCBvdXIgc2FsZXMgc3RhZmYgYXQgc2FsZXNAcGhvdG9lZGl0b3JzZGsuY29tIHRvIG9idGFpbiBhIGxpY2Vuc2Ugb3IgbG9nIGluIHRvIHlvdXIgY3VzdG9tZXIgZGFzaGJvYXJkLg=="));
      return false;
    }
    return true;
  }
  _initEvents() {
    this._mediator.pipeEvents(this);
  }
  _disposeEvents() {
    this._mediator.unpipeEvents(this);
  }
  setImage(image5) {
    this._editor.setImage(image5);
  }
  getAssetPath(asset, uiAsset = false, disableRetina = false) {
    const {baseUrl, resolver} = this._options.assets;
    let path2 = `${baseUrl}/${asset}`;
    if (asset.match(/(ftp|http|https):\/\//)) {
      path2 = asset;
    }
    if (uiAsset) {
      if (!disableRetina) {
        const pixelRatio = typeof window !== "undefined" && window.devicePixelRatio || 1;
        if (pixelRatio > 1) {
          const regex = /\.[\w?=]+$/;
          asset = asset.replace(regex, (match) => `@2x${match}`);
        }
      }
      path2 = `${baseUrl}/ui/desktop/${asset}`;
    }
    if (typeof resolver !== "undefined" && resolver !== null) {
      path2 = resolver(path2);
    }
    return path2;
  }
  getFontLoader() {
    return this._fontLoader;
  }
  dispose() {
    if (this._disposed) {
      throw new Error("This instance of PhotoEditorSDK is already disposed.");
    }
    this._disposed = true;
    this._disposeEvents();
  }
  render(config) {
    return this.deserialize(config).then(() => this.export());
  }
}
Server.prototype.identifier = "node";
Server.Constants = constants_default3;
Server.Events = constants_default3.EVENTS;
Server.Utils = utils_default3;
Server.JSONLoader = JSONLoader;
Server.SDK = SDK;
var server_default = Server;
